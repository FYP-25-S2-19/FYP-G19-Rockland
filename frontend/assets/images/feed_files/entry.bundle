var __BUNDLE_START_TIME__=globalThis.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=true,process=globalThis.process||{},__METRO_GLOBAL_PREFIX__='',__requireCycleIgnorePatterns=[/(^|\/|\\)node_modules($|\/|\\)/];process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"development";
(function (global) {
  "use strict";

  global.__r = metroRequire;
  global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;
  global.__c = clear;
  global.__registerSegment = registerSegment;
  var modules = clear();
  const EMPTY = {};
  const CYCLE_DETECTED = {};
  const {
    hasOwnProperty
  } = {};
  if (__DEV__) {
    global.$RefreshReg$ = () => {};
    global.$RefreshSig$ = () => type => type;
  }
  function clear() {
    modules = new Map();
    return modules;
  }
  if (__DEV__) {
    var verboseNamesToModuleIds = new Map();
    var getModuleIdForVerboseName = verboseName => {
      const moduleId = verboseNamesToModuleIds.get(verboseName);
      if (moduleId == null) {
        throw new Error(`Unknown named module: "${verboseName}"`);
      }
      return moduleId;
    };
    var initializingModuleIds = [];
  }
  function define(factory, moduleId, dependencyMap) {
    if (modules.has(moduleId)) {
      if (__DEV__) {
        const inverseDependencies = arguments[4];
        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        }
      }
      return;
    }
    const mod = {
      dependencyMap,
      factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules.set(moduleId, mod);
    if (__DEV__) {
      mod.hot = createHotReloadingObject();
      const verboseName = arguments[3];
      if (verboseName) {
        mod.verboseName = verboseName;
        verboseNamesToModuleIds.set(verboseName, moduleId);
      }
    }
  }
  function metroRequire(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
      console.warn(`Requiring module "${verboseName}" by name is only supported for ` + "debugging purposes and will BREAK IN PRODUCTION!");
    }
    const moduleIdReallyIsNumber = moduleId;
    if (__DEV__) {
      const initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);
      if (initializingIndex !== -1) {
        const cycle = initializingModuleIds.slice(initializingIndex).map(id => modules.get(id)?.verboseName ?? "[unknown]");
        if (shouldPrintRequireCycle(cycle)) {
          cycle.push(cycle[0]);
          console.warn(`Require cycle: ${cycle.join(" -> ")}\n\n` + "Require cycles are allowed, but can result in uninitialized values. " + "Consider refactoring to remove the need for a cycle.");
        }
      }
    }
    const module = modules.get(moduleIdReallyIsNumber);
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }
  function shouldPrintRequireCycle(modules) {
    const regExps = global[__METRO_GLOBAL_PREFIX__ + "__requireCycleIgnorePatterns"];
    if (!Array.isArray(regExps)) {
      return true;
    }
    const isIgnored = module => module != null && regExps.some(regExp => regExp.test(module));
    return modules.every(module => !isIgnored(module));
  }
  function metroImportDefault(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
    }
    const moduleIdReallyIsNumber = moduleId;
    const maybeInitializedModule = modules.get(moduleIdReallyIsNumber);
    if (maybeInitializedModule && maybeInitializedModule.importedDefault !== EMPTY) {
      return maybeInitializedModule.importedDefault;
    }
    const exports = metroRequire(moduleIdReallyIsNumber);
    const importedDefault = exports && exports.__esModule ? exports.default : exports;
    const initializedModule = modules.get(moduleIdReallyIsNumber);
    return initializedModule.importedDefault = importedDefault;
  }
  metroRequire.importDefault = metroImportDefault;
  function metroImportAll(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
    }
    const moduleIdReallyIsNumber = moduleId;
    const maybeInitializedModule = modules.get(moduleIdReallyIsNumber);
    if (maybeInitializedModule && maybeInitializedModule.importedAll !== EMPTY) {
      return maybeInitializedModule.importedAll;
    }
    const exports = metroRequire(moduleIdReallyIsNumber);
    let importedAll;
    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};
      if (exports) {
        for (const key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }
      importedAll.default = exports;
    }
    const initializedModule = modules.get(moduleIdReallyIsNumber);
    return initializedModule.importedAll = importedAll;
  }
  metroRequire.importAll = metroImportAll;
  metroRequire.context = function fallbackRequireContext() {
    if (__DEV__) {
      throw new Error("The experimental Metro feature `require.context` is not enabled in your project.\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.");
    }
    throw new Error("The experimental Metro feature `require.context` is not enabled in your project.");
  };
  metroRequire.resolveWeak = function fallbackRequireResolveWeak() {
    if (__DEV__) {
      throw new Error("require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.");
    }
    throw new Error("require.resolveWeak cannot be called dynamically.");
  };
  let inGuard = false;
  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      let returnValue;
      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }
      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }
  const ID_MASK_SHIFT = 16;
  const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;
  function unpackModuleId(moduleId) {
    const segmentId = moduleId >>> ID_MASK_SHIFT;
    const localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId,
      localId
    };
  }
  metroRequire.unpackModuleId = unpackModuleId;
  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }
  metroRequire.packModuleId = packModuleId;
  const moduleDefinersBySegmentID = [];
  const definingSegmentByModuleID = new Map();
  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;
    if (__DEV__) {
      if (segmentId === 0 && moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be null for main segment");
      }
      if (segmentId !== 0 && !moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be passed for segment #" + segmentId);
      }
    }
    if (moduleIds) {
      moduleIds.forEach(moduleId => {
        if (!modules.has(moduleId) && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }
  function loadModuleImplementation(moduleId, module) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      const segmentId = definingSegmentByModuleID.get(moduleId) ?? 0;
      const definer = moduleDefinersBySegmentID[segmentId];
      if (definer != null) {
        definer(moduleId);
        module = modules.get(moduleId);
        definingSegmentByModuleID.delete(moduleId);
      }
    }
    const nativeRequire = global.nativeRequire;
    if (!module && nativeRequire) {
      const {
        segmentId,
        localId
      } = unpackModuleId(moduleId);
      nativeRequire(localId, segmentId);
      module = modules.get(moduleId);
    }
    if (!module) {
      throw unknownModuleError(moduleId);
    }
    if (module.hasError) {
      throw module.error;
    }
    if (__DEV__) {
      var Systrace = requireSystrace();
      var Refresh = requireRefresh();
    }
    module.isInitialized = true;
    const {
      factory,
      dependencyMap
    } = module;
    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }
    try {
      if (__DEV__) {
        Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
      }
      const moduleObject = module.publicModule;
      if (__DEV__) {
        moduleObject.hot = module.hot;
        var prevRefreshReg = global.$RefreshReg$;
        var prevRefreshSig = global.$RefreshSig$;
        if (Refresh != null) {
          const RefreshRuntime = Refresh;
          global.$RefreshReg$ = (type, id) => {
            RefreshRuntime.register(type, moduleId + " " + id);
          };
          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
        }
      }
      moduleObject.id = moduleId;
      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);
      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }
      if (__DEV__) {
        Systrace.endEvent();
        if (Refresh != null) {
          registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
        }
      }
      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error("initializingModuleIds is corrupt; something is terribly wrong");
        }
        global.$RefreshReg$ = prevRefreshReg;
        global.$RefreshSig$ = prevRefreshSig;
      }
    }
  }
  function unknownModuleError(id) {
    let message = 'Requiring unknown module "' + id + '".';
    if (__DEV__) {
      message += " If you are sure the module exists, try restarting Metro. " + "You may also want to run `yarn` or `npm install`.";
    }
    return Error(message);
  }
  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: () => {},
      endEvent: () => {}
    };
    metroRequire.getModules = () => {
      return modules;
    };
    var createHotReloadingObject = function () {
      const hot = {
        _acceptCallback: null,
        _disposeCallback: null,
        _didAccept: false,
        accept: callback => {
          hot._didAccept = true;
          hot._acceptCallback = callback;
        },
        dispose: callback => {
          hot._disposeCallback = callback;
        }
      };
      return hot;
    };
    let reactRefreshTimeout = null;
    const metroHotUpdateModule = function (id, factory, dependencyMap, inverseDependencies) {
      const mod = modules.get(id);
      if (!mod) {
        if (factory) {
          return;
        }
        throw unknownModuleError(id);
      }
      if (!mod.hasError && !mod.isInitialized) {
        mod.factory = factory;
        mod.dependencyMap = dependencyMap;
        return;
      }
      const Refresh = requireRefresh();
      const refreshBoundaryIDs = new Set();
      let didBailOut = false;
      let updatedModuleIDs;
      try {
        updatedModuleIDs = topologicalSort([id], pendingID => {
          const pendingModule = modules.get(pendingID);
          if (pendingModule == null) {
            return [];
          }
          const pendingHot = pendingModule.hot;
          if (pendingHot == null) {
            throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
          }
          let canAccept = pendingHot._didAccept;
          if (!canAccept && Refresh != null) {
            const isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);
            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }
          if (canAccept) {
            return [];
          }
          const parentIDs = inverseDependencies[pendingID];
          if (parentIDs.length === 0) {
            performFullRefresh("No root boundary", {
              source: mod,
              failed: pendingModule
            });
            didBailOut = true;
            return [];
          }
          return parentIDs;
        }, () => didBailOut).reverse();
      } catch (e) {
        if (e === CYCLE_DETECTED) {
          performFullRefresh("Dependency cycle", {
            source: mod
          });
          return;
        }
        throw e;
      }
      if (didBailOut) {
        return;
      }
      const seenModuleIDs = new Set();
      for (let i = 0; i < updatedModuleIDs.length; i++) {
        const updatedID = updatedModuleIDs[i];
        if (seenModuleIDs.has(updatedID)) {
          continue;
        }
        seenModuleIDs.add(updatedID);
        const updatedMod = modules.get(updatedID);
        if (updatedMod == null) {
          throw new Error("[Refresh] Expected to find the updated module.");
        }
        const prevExports = updatedMod.publicModule.exports;
        const didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);
        const nextExports = updatedMod.publicModule.exports;
        if (didError) {
          return;
        }
        if (refreshBoundaryIDs.has(updatedID)) {
          const isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);
          const didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);
          if (isNoLongerABoundary || didInvalidate) {
            const parentIDs = inverseDependencies[updatedID];
            if (parentIDs.length === 0) {
              performFullRefresh(isNoLongerABoundary ? "No longer a boundary" : "Invalidated boundary", {
                source: mod,
                failed: updatedMod
              });
              return;
            }
            for (let j = 0; j < parentIDs.length; j++) {
              const parentID = parentIDs[j];
              const parentMod = modules.get(parentID);
              if (parentMod == null) {
                throw new Error("[Refresh] Expected to find parent module.");
              }
              const canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);
              if (canAcceptParent) {
                refreshBoundaryIDs.add(parentID);
                updatedModuleIDs.push(parentID);
              } else {
                performFullRefresh("Invalidated boundary", {
                  source: mod,
                  failed: parentMod
                });
                return;
              }
            }
          }
        }
      }
      if (Refresh != null) {
        if (reactRefreshTimeout == null) {
          reactRefreshTimeout = setTimeout(() => {
            reactRefreshTimeout = null;
            Refresh.performReactRefresh();
          }, 30);
        }
      }
    };
    const topologicalSort = function (roots, getEdges, earlyStop) {
      const result = [];
      const visited = new Set();
      const stack = new Set();
      function traverseDependentNodes(node) {
        if (stack.has(node)) {
          throw CYCLE_DETECTED;
        }
        if (visited.has(node)) {
          return;
        }
        visited.add(node);
        stack.add(node);
        const dependentNodes = getEdges(node);
        if (earlyStop(node)) {
          stack.delete(node);
          return;
        }
        dependentNodes.forEach(dependent => {
          traverseDependentNodes(dependent);
        });
        stack.delete(node);
        result.push(node);
      }
      roots.forEach(root => {
        traverseDependentNodes(root);
      });
      return result;
    };
    const runUpdatedModule = function (id, factory, dependencyMap) {
      const mod = modules.get(id);
      if (mod == null) {
        throw new Error("[Refresh] Expected to find the module.");
      }
      const {
        hot
      } = mod;
      if (!hot) {
        throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
      }
      if (hot._disposeCallback) {
        try {
          hot._disposeCallback();
        } catch (error) {
          console.error(`Error while calling dispose handler for module ${id}: `, error);
        }
      }
      if (factory) {
        mod.factory = factory;
      }
      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }
      mod.hasError = false;
      mod.error = undefined;
      mod.importedAll = EMPTY;
      mod.importedDefault = EMPTY;
      mod.isInitialized = false;
      const prevExports = mod.publicModule.exports;
      mod.publicModule.exports = {};
      hot._didAccept = false;
      hot._acceptCallback = null;
      hot._disposeCallback = null;
      metroRequire(id);
      if (mod.hasError) {
        mod.hasError = false;
        mod.isInitialized = true;
        mod.error = null;
        mod.publicModule.exports = prevExports;
        return true;
      }
      if (hot._acceptCallback) {
        try {
          hot._acceptCallback();
        } catch (error) {
          console.error(`Error while calling accept handler for module ${id}: `, error);
        }
      }
      return false;
    };
    const performFullRefresh = (reason, modules) => {
      if (typeof window !== "undefined" && window.location != null && typeof window.location.reload === "function") {
        window.location.reload();
      } else {
        const Refresh = requireRefresh();
        if (Refresh != null) {
          const sourceName = modules.source?.verboseName ?? "unknown";
          const failedName = modules.failed?.verboseName ?? "unknown";
          Refresh.performFullRefresh(`Fast Refresh - ${reason} <${sourceName}> <${failedName}>`);
        } else {
          console.warn("Could not reload the application after an edit.");
        }
      }
    };
    var isReactRefreshBoundary = function (Refresh, moduleExports) {
      if (Refresh.isLikelyComponentType(moduleExports)) {
        return true;
      }
      if (moduleExports == null || typeof moduleExports !== "object") {
        return false;
      }
      let hasExports = false;
      let areAllExportsComponents = true;
      for (const key in moduleExports) {
        hasExports = true;
        if (key === "__esModule") {
          continue;
        }
        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          return false;
        }
        const exportValue = moduleExports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) {
          areAllExportsComponents = false;
        }
      }
      return hasExports && areAllExportsComponents;
    };
    var shouldInvalidateReactRefreshBoundary = (Refresh, prevExports, nextExports) => {
      const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
      const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
      if (prevSignature.length !== nextSignature.length) {
        return true;
      }
      for (let i = 0; i < nextSignature.length; i++) {
        if (prevSignature[i] !== nextSignature[i]) {
          return true;
        }
      }
      return false;
    };
    var getRefreshBoundarySignature = (Refresh, moduleExports) => {
      const signature = [];
      signature.push(Refresh.getFamilyByType(moduleExports));
      if (moduleExports == null || typeof moduleExports !== "object") {
        return signature;
      }
      for (const key in moduleExports) {
        if (key === "__esModule") {
          continue;
        }
        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          continue;
        }
        const exportValue = moduleExports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
      }
      return signature;
    };
    var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {
      Refresh.register(moduleExports, moduleID + " %exports%");
      if (moduleExports == null || typeof moduleExports !== "object") {
        return;
      }
      for (const key in moduleExports) {
        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          continue;
        }
        const exportValue = moduleExports[key];
        const typeID = moduleID + " %exports% " + key;
        Refresh.register(exportValue, typeID);
      }
    };
    global.__accept = metroHotUpdateModule;
  }
  if (__DEV__) {
    var requireSystrace = function requireSystrace() {
      return global[__METRO_GLOBAL_PREFIX__ + "__SYSTRACE"] || metroRequire.Systrace;
    };
    var requireRefresh = function requireRefresh() {
      return global[__METRO_GLOBAL_PREFIX__ + "__ReactRefresh"] || metroRequire.Refresh;
    };
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  global.$$require_external = typeof require !== "undefined" ? require : () => null;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
/* HMR env vars from Expo CLI (dev-only) */ process.env=Object.defineProperties(process.env, {"EXPO_PUBLIC_PROJECT_ROOT": { enumerable: true, value: "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend" }});
(function (global) {
  let _inGuard = 0;
  let _globalHandler = global.RN$useAlwaysAvailableJSErrorHandling === true ? global.RN$handleException : (e, isFatal) => {
    throw e;
  };
  const ErrorUtils = {
    setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler() {
      return _globalHandler;
    },
    reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard(fun, context, args, unused_onError, unused_name) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard() {
      return !!_inGuard;
    },
    guard(fun, name, context) {
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      const guardName = name ?? fun.name ?? '<generated guard>';
      function guarded(...args) {
        return ErrorUtils.applyWithGuard(fun, context ?? this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createElement = exports.createInteropElement = exports.jsxDEV = exports.jsx = exports.jsxs = exports.Fragment = void 0;
  const react_1 = require(_dependencyMap[0], "react");
  const jsx_runtime_1 = __importDefault(require(_dependencyMap[1], "react/jsx-runtime"));
  const wrap_jsx_1 = __importDefault(require(_dependencyMap[2], "./wrap-jsx"));
  var react_2 = require(_dependencyMap[0], "react");
  Object.defineProperty(exports, "Fragment", {
    enumerable: true,
    get: function () {
      return react_2.Fragment;
    }
  });
  exports.jsxs = (0, wrap_jsx_1.default)(jsx_runtime_1.default.jsxs);
  exports.jsx = (0, wrap_jsx_1.default)(jsx_runtime_1.default.jsx);
  exports.jsxDEV = (0, wrap_jsx_1.default)(jsx_runtime_1.default.jsxDEV);
  exports.createInteropElement = (0, wrap_jsx_1.default)(react_1.createElement);
  exports.createElement = react_1.createElement;
},2,[3,6,8],"node_modules\\react-native-css-interop\\dist\\runtime\\jsx-runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react.development.js");
  }
},3,[4,5],"node_modules\\react\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},4,[],"node_modules\\metro-runtime\\src\\modules\\empty-module.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function isValidElementType(type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? !0 : !1;
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: assign({}, props, {
            value: prevLog
          }),
          info: assign({}, props, {
            value: prevInfo
          }),
          warn: assign({}, props, {
            value: prevWarn
          }),
          error: assign({}, props, {
            value: prevError
          }),
          group: assign({}, props, {
            value: prevGroup
          }),
          groupCollapsed: assign({}, props, {
            value: prevGroupCollapsed
          }),
          groupEnd: assign({}, props, {
            value: prevGroupEnd
          })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix) try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
          for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
          for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
            if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
              do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                "function" === typeof fn && componentFrameCache.set(fn, _frame);
                return _frame;
              } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
            }
            break;
          }
        }
      } finally {
        reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
      if (null == type) return "";
      if ("function" === typeof type) {
        var prototype = type.prototype;
        return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
      }
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type) switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          return type = describeNativeComponentFrame(type.render, !1), type;
        case REACT_MEMO_TYPE:
          return describeUnknownElementTypeFrameInDEV(type.type);
        case REACT_LAZY_TYPE:
          prototype = type._payload;
          type = type._init;
          try {
            return describeUnknownElementTypeFrameInDEV(type(prototype));
          } catch (x) {}
      }
      return "";
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: !1,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", {
        enumerable: !1,
        value: null
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props);
      newKey._store.validated = oldElement._store.validated;
      return newKey;
    }
    function validateChildKeys(node, parentType) {
      if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) if (isArrayImpl(node)) for (var i = 0; i < node.length; i++) {
        var child = node[i];
        isValidElement(child) && validateExplicitKey(child, parentType);
      } else if (isValidElement(node)) node._store && (node._store.validated = 1);else if (i = getIteratorFn(node), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for (; !(node = i.next()).done;) isValidElement(node.value) && validateExplicitKey(node.value, parentType);
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
      if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
        ownerHasKeyUseWarning[parentType] = !0;
        var childOwner = "";
        element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
        ReactSharedInternals.getCurrentStack = function () {
          var stack = describeUnknownElementTypeFrameInDEV(element.type);
          prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
          return stack;
        };
        console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function getCurrentComponentErrorInfo(parentType) {
      var info = "",
        owner = getOwner();
      owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
      info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
      return info;
    }
    function escape(key) {
      var escaperLookup = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + key.replace(/[=:]/g, function (match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function (error) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;else switch (type) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = !0;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = !0;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
          }
      }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
        if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(function (moduleObject) {
          if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
        }, function (error) {
          if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
        });
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (null === enqueueTaskImpl) try {
        var requireString = ("require" + Math.random()).slice(0, 7);
        enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
      } catch (_err) {
        enqueueTaskImpl = function (callback) {
          !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
          var channel = new MessageChannel();
          channel.port1.onmessage = callback;
          channel.port2.postMessage(void 0);
        };
      }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue) if (0 !== queue.length) try {
        flushActQueue(queue);
        enqueueTask(function () {
          return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
        });
        return;
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      } else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
        replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
      },
      fnName;
    for (fnName in deprecatedAPIs) deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      specialPropKeyWarningShown,
      didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var ownerHasKeyUseWarning = {},
      didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function (callback) {
        queueMicrotask(function () {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
    exports.Children = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(children, function () {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return mapChildren(children, function (child) {
          return child;
        }) || [];
      },
      only: function (children) {
        if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [],
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (null !== result && "object" === typeof result && "function" === typeof result.then) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(function (returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (0 === prevActScopeDepth) {
                try {
                  flushActQueue(queue), enqueueTask(function () {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$2) {
                  ReactSharedInternals.thrownErrors.push(error$2);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else resolve(returnValue);
            }, function (error) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function () {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function () {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propName in config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++) JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, void 0, void 0, owner, props);
      for (key = 2; key < arguments.length; key++) validateChildKeys(arguments[key], props.type);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      if (isValidElementType(type)) for (var i = 2; i < arguments.length; i++) validateChildKeys(arguments[i], type);else {
        i = "";
        if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        if (null === type) var typeString = "null";else isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
        console.error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, i);
      }
      var propName;
      i = {};
      typeString = null;
      if (null != config) for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), typeString = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++) childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      typeString && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
    };
    exports.createRef = function () {
      var refObject = {
        current: null
      };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render
        },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", {
            value: name
          }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: {
          _status: -1,
          _result: ctor
        },
        _init: lazyInitializer
      };
    };
    exports.memo = function (type, compare) {
      isValidElementType(type) || console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", {
            value: name
          }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, deps) {
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},5,[],"node_modules\\react\\cjs\\react.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-jsx-runtime.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-jsx-runtime.development.js");
  }
},6,[4,7],"node_modules\\react\\jsx-runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: assign({}, props, {
            value: prevLog
          }),
          info: assign({}, props, {
            value: prevInfo
          }),
          warn: assign({}, props, {
            value: prevWarn
          }),
          error: assign({}, props, {
            value: prevError
          }),
          group: assign({}, props, {
            value: prevGroup
          }),
          groupCollapsed: assign({}, props, {
            value: prevGroupCollapsed
          }),
          groupEnd: assign({}, props, {
            value: prevGroupEnd
          })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix) try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
          for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
          for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
            if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
              do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                "function" === typeof fn && componentFrameCache.set(fn, _frame);
                return _frame;
              } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
            }
            break;
          }
        }
      } finally {
        reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
      if (null == type) return "";
      if ("function" === typeof type) {
        var prototype = type.prototype;
        return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
      }
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type) switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          return type = describeNativeComponentFrame(type.render, !1), type;
        case REACT_MEMO_TYPE:
          return describeUnknownElementTypeFrameInDEV(type.type);
        case REACT_LAZY_TYPE:
          prototype = type._payload;
          type = type._init;
          try {
            return describeUnknownElementTypeFrameInDEV(type(prototype));
          } catch (x) {}
      }
      return "";
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: !1,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", {
        enumerable: !1,
        value: null
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
      if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) {
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++) validateChildKeys(children[isStaticChildren], type);
            Object.freeze && Object.freeze(children);
          } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        } else validateChildKeys(children, type);
      } else {
        children = "";
        if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
        console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
      }
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
      if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) if (isArrayImpl(node)) for (var i = 0; i < node.length; i++) {
        var child = node[i];
        isValidElement(child) && validateExplicitKey(child, parentType);
      } else if (isValidElement(node)) node._store && (node._store.validated = 1);else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for (; !(node = i.next()).done;) isValidElement(node.value) && validateExplicitKey(node.value, parentType);
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
      if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
        ownerHasKeyUseWarning[parentType] = !0;
        var childOwner = "";
        element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
        ReactSharedInternals.getCurrentStack = function () {
          var stack = describeUnknownElementTypeFrameInDEV(element.type);
          prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
          return stack;
        };
        console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function getCurrentComponentErrorInfo(parentType) {
      var info = "",
        owner = getOwner();
      owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
      info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
      return info;
    }
    var React = require(_dependencyMap[0], "react"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      assign = Object.assign,
      REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
      isArrayImpl = Array.isArray,
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {},
      ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function (type, config, maybeKey, source, self) {
      return jsxDEVImpl(type, config, maybeKey, !1, source, self);
    };
    exports.jsxs = function (type, config, maybeKey, source, self) {
      return jsxDEVImpl(type, config, maybeKey, !0, source, self);
    };
  }();
},7,[3],"node_modules\\react\\cjs\\react-jsx-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = wrapJSX;
  const api_1 = require(_dependencyMap[0], "./api");
  const react_native_safe_area_context_1 = require(_dependencyMap[1], "./third-party-libs/react-native-safe-area-context");
  function wrapJSX(jsx) {
    return function (type, props, ...rest) {
      if (type === "react-native-css-interop-jsx-pragma-check") {
        return true;
      }
      if (process.env.NODE_ENV !== "test") require(_dependencyMap[2], "./components");
      type = (0, react_native_safe_area_context_1.maybeHijackSafeAreaProvider)(type);
      if (props && props.cssInterop === false) {
        delete props.cssInterop;
      } else {
        type = api_1.interopComponents.get(type) ?? type;
      }
      return jsx.call(jsx, type, props, ...rest);
    };
  }
},8,[9,274,275],"node_modules\\react-native-css-interop\\dist\\runtime\\wrap-jsx.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(require(_dependencyMap[0], "./web/api"), exports);
  __exportStar(require(_dependencyMap[1], "./web/interopComponentsMap"), exports);
},9,[10,14],"node_modules\\react-native-css-interop\\dist\\runtime\\api.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  "use client";

  var _objectDestructuringEmpty = require(_dependencyMap[0], "@babel/runtime/helpers/objectDestructuringEmpty");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useUnstableNativeVariable = exports.remapProps = exports.cssInterop = exports.useColorScheme = exports.rem = exports.colorScheme = exports.StyleSheet = void 0;
  exports.vars = vars;
  exports.useSafeAreaEnv = useSafeAreaEnv;
  const react_1 = require(_dependencyMap[1], "react");
  const shared_1 = require(_dependencyMap[2], "../../shared");
  const config_1 = require(_dependencyMap[3], "../config");
  const interopComponentsMap_1 = require(_dependencyMap[4], "./interopComponentsMap");
  var stylesheet_1 = require(_dependencyMap[5], "./stylesheet");
  Object.defineProperty(exports, "StyleSheet", {
    enumerable: true,
    get: function () {
      return stylesheet_1.StyleSheet;
    }
  });
  var color_scheme_1 = require(_dependencyMap[6], "./color-scheme");
  Object.defineProperty(exports, "colorScheme", {
    enumerable: true,
    get: function () {
      return color_scheme_1.colorScheme;
    }
  });
  var rem_1 = require(_dependencyMap[7], "./rem");
  Object.defineProperty(exports, "rem", {
    enumerable: true,
    get: function () {
      return rem_1.rem;
    }
  });
  const ForwardRefSymbol = Symbol.for("react.forward_ref");
  var useColorScheme_1 = require(_dependencyMap[8], "./useColorScheme");
  Object.defineProperty(exports, "useColorScheme", {
    enumerable: true,
    get: function () {
      return useColorScheme_1.useColorScheme;
    }
  });
  const cssInterop = (baseComponent, mapping) => {
    const configs = (0, config_1.getNormalizeConfig)(mapping);
    const interopComponent = (0, react_1.forwardRef)(function CssInteropComponent(_ref, ref) {
      let props = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));
      if (props.cssInterop === false) {
        return (0, react_1.createElement)(baseComponent, props);
      }
      props = Object.assign({}, props, {
        ref
      });
      for (const config of configs) {
        const source = props[config.source];
        if (typeof source === "string" && source) {
          (0, shared_1.assignToTarget)(props, {
            $$css: true,
            [source]: source
          }, config, {
            objectMergeStyle: "toArray"
          });
        }
        delete props[config.source];
      }
      if ("$$typeof" in baseComponent && typeof baseComponent === "function" && baseComponent.$$typeof === ForwardRefSymbol) {
        delete props.cssInterop;
        return baseComponent.render(props, props.ref);
      } else if (typeof baseComponent === "function" && !(baseComponent.prototype instanceof react_1.Component)) {
        delete props.cssInterop;
        return baseComponent(props);
      } else {
        return (0, react_1.createElement)(baseComponent, props);
      }
    });
    interopComponent.displayName = `CssInterop.${baseComponent.displayName ?? baseComponent.name ?? "unknown"}`;
    interopComponentsMap_1.interopComponents.set(baseComponent, interopComponent);
    return interopComponent;
  };
  exports.cssInterop = cssInterop;
  exports.remapProps = exports.cssInterop;
  const useUnstableNativeVariable = name => {
    if (process.env.NODE_ENV !== "production") {
      console.log("useUnstableNativeVariable is not supported on web.");
    }
    return undefined;
  };
  exports.useUnstableNativeVariable = useUnstableNativeVariable;
  function vars(variables) {
    const $variables = {};
    for (const [key, value] of Object.entries(variables)) {
      if (key.startsWith("--")) {
        $variables[key] = value.toString();
      } else {
        $variables[`--${key}`] = value.toString();
      }
    }
    return $variables;
  }
  function useSafeAreaEnv() {
    return undefined;
  }
},10,[954,3,11,13,14,15,270,272,273],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\api.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.transformKeys = exports.inlineSpecificity = exports.SpecificityIndex = exports.STYLE_SCOPES = exports.DEFAULT_CONTAINER_NAME = exports.PLACEHOLDER_SYMBOL = exports.StyleRuleSymbol = exports.StyleRuleSetSymbol = exports.INTERNAL_FLAGS = exports.INTERNAL_SET = exports.INTERNAL_RESET = void 0;
  exports.isDescriptorFunction = isDescriptorFunction;
  exports.isDescriptorArray = isDescriptorArray;
  exports.isRuntimeDescriptor = isRuntimeDescriptor;
  exports.assignToTarget = assignToTarget;
  exports.getTargetValue = getTargetValue;
  const shared_1 = require(_dependencyMap[0], "./runtime/native/resolvers/shared");
  exports.INTERNAL_RESET = Symbol();
  exports.INTERNAL_SET = Symbol();
  exports.INTERNAL_FLAGS = Symbol();
  exports.StyleRuleSetSymbol = Symbol();
  exports.StyleRuleSymbol = Symbol();
  exports.PLACEHOLDER_SYMBOL = Symbol();
  exports.DEFAULT_CONTAINER_NAME = "@__";
  exports.STYLE_SCOPES = {
    GLOBAL: 0,
    CONTEXT: 1,
    SELF: 2
  };
  function isDescriptorFunction(value) {
    return Array.isArray(value) && typeof value[0] === "object" && !Array.isArray(value[0]);
  }
  function isDescriptorArray(value) {
    if (Array.isArray(value)) {
      return typeof value[0] === "object" ? Array.isArray(value[0]) : true;
    }
    return false;
  }
  function isRuntimeDescriptor(value) {
    if (typeof value === "object" && Array.isArray(value)) {
      return true;
    } else {
      return typeof value !== "object";
    }
  }
  function assignToTarget(parent, value, config, options = {}) {
    if (typeof value === "object" && shared_1.ShorthandSymbol in value) {
      return value.map(shorthandConfig => {
        let pathTokens = Array.from(Array.isArray(config) ? config : config.target);
        const shortHandProp = shorthandConfig[0];
        if (typeof shortHandProp === "string") {
          pathTokens.splice(-1, 1, shortHandProp);
        } else {
          pathTokens.splice(-1, 1, ...shortHandProp);
        }
        assignToTarget(parent, shorthandConfig[1], pathTokens, options);
      });
    }
    const {
      arrayMergeStyle = "push",
      objectMergeStyle = "assign",
      allowTransformMerging = false,
      reverseTransformPush = false
    } = options;
    let prop;
    let props = Array.isArray(config) ? config : config.target;
    if (props.length === 0) {
      Object.assign(parent, value);
      return;
    }
    for (let index = 0; index < props.length - 1; index++) {
      prop = props[index];
      if (Array.isArray(parent) && isFinite(Number(prop))) {
        prop = Number(prop);
      }
      if (typeof parent[prop] !== "object") {
        parent[prop] = {};
      } else if (Object.isFrozen(parent[prop])) {
        parent[prop] = Object.assign({}, parent[prop]);
      }
      parent = parent[prop];
    }
    prop = props[props.length - 1];
    if (allowTransformMerging && exports.transformKeys.has(prop)) {
      let existing;
      if (!Array.isArray(parent.transform)) {
        parent.transform = [];
      } else {
        existing = parent.transform.find(t => prop in t);
      }
      if (existing) {
        existing[prop] = value;
      } else {
        if (reverseTransformPush) {
          parent.transform.shift({
            [prop]: value
          });
        } else {
          parent.transform.push({
            [prop]: value
          });
        }
      }
    } else {
      const target = parent[prop];
      if (Array.isArray(target)) {
        switch (arrayMergeStyle) {
          case "push":
            target.push(value);
        }
      } else if (typeof target === "object" && target && !(exports.PLACEHOLDER_SYMBOL in target)) {
        switch (objectMergeStyle) {
          case "assign":
            {
              if (typeof value === "object") {
                parent[prop] = Object.assign({}, parent[prop], value);
              } else {
                parent[prop] = value;
              }
              break;
            }
          case "toArray":
            {
              parent[prop] = [target, value];
            }
        }
      } else if (value && typeof value === "object" && !("_isReanimatedSharedValue" in value) && !(exports.PLACEHOLDER_SYMBOL in value) && !Array.isArray(value)) {
        parent[prop] = Object.assign({}, value);
      } else {
        parent[prop] = value;
      }
    }
  }
  function getTargetValue(parent, props) {
    let prop;
    props = typeof props === "string" ? [props] : props;
    for (let index = 0; index < props.length - 1; index++) {
      prop = props[index];
      if (Array.isArray(parent) && isFinite(Number(prop))) {
        prop = Number(prop);
      }
      if (typeof parent[prop] !== "object") {
        parent[prop] = {};
      }
      parent = parent[prop];
    }
    prop = props[props.length - 1];
    if (exports.transformKeys.has(prop)) {
      let existing;
      if (!Array.isArray(parent.transform)) {
        parent.transform = [];
      } else {
        existing = parent.transform.find(t => prop in t);
      }
      return existing?.[prop];
    } else {
      return parent[prop];
    }
  }
  exports.SpecificityIndex = {
    Order: 0,
    ClassName: 1,
    Important: 2,
    Inline: 3,
    PseudoElements: 4
  };
  exports.inlineSpecificity = [];
  exports.inlineSpecificity[exports.SpecificityIndex.Inline] = 1;
  exports.transformKeys = new Set(["translateX", "translateY", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "perspective", "matrix", "transformOrigin"]);
},11,[12],"node_modules\\react-native-css-interop\\dist\\shared.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ShorthandSymbol = void 0;
  exports.ShorthandSymbol = Symbol();
},12,[],"node_modules\\react-native-css-interop\\dist\\runtime\\native\\resolvers\\shared.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNormalizeConfig = getNormalizeConfig;
  function getNormalizeConfig(mapping) {
    const configs = [];
    for (const [source, options] of Object.entries(mapping)) {
      let target;
      let inlineProp;
      let propToRemove;
      let nativeStyleToProp;
      if (!options) continue;
      if (options === true) {
        target = [source];
      } else if (typeof options === "string") {
        target = [options];
      } else if (options.target === false) {
        target = [source];
        propToRemove = source;
        nativeStyleToProp = parseNativeStyleToProp(options.nativeStyleToProp);
      } else {
        target = options.target === true ? [source] : options.target.split(".");
        nativeStyleToProp = parseNativeStyleToProp(options.nativeStyleToProp);
      }
      if (target.length === 1 && target[0] !== source) {
        inlineProp = target[0];
      }
      configs.push({
        nativeStyleToProp,
        source,
        target,
        inlineProp,
        propToRemove
      });
    }
    return configs;
  }
  function parseNativeStyleToProp(nativeStyleToProp) {
    if (!nativeStyleToProp) return;
    return Object.entries(nativeStyleToProp).map(([key, value]) => {
      return [key, value === true ? [key] : value.split(".")];
    });
  }
},13,[],"node_modules\\react-native-css-interop\\dist\\runtime\\config.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.interopComponents = void 0;
  exports.interopComponents = new Map();
},14,[],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\interopComponentsMap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StyleSheet = void 0;
  const react_native_1 = require(_dependencyMap[0], "react-native-web/dist/index");
  const documentStyle = globalThis.window?.getComputedStyle(globalThis.window?.document.documentElement);
  const commonStyleSheet = {
    getFlag(name) {
      return documentStyle?.getPropertyValue(`--css-interop-${name}`);
    },
    unstable_hook_onClassName() {},
    register(_options) {
      throw new Error("Stylesheet.register is not available on web");
    },
    registerCompiled(_options) {
      throw new Error("Stylesheet.registerCompiled is not available on web");
    },
    getGlobalStyle() {
      throw new Error("Stylesheet.getGlobalStyle is not available on web");
    }
  };
  exports.StyleSheet = Object.assign({}, commonStyleSheet, react_native_1.StyleSheet);
},15,[16],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\stylesheet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "AccessibilityInfo", {
    enumerable: true,
    get: function () {
      return _AccessibilityInfo.default;
    }
  });
  Object.defineProperty(exports, "ActivityIndicator", {
    enumerable: true,
    get: function () {
      return _ActivityIndicator.default;
    }
  });
  Object.defineProperty(exports, "Alert", {
    enumerable: true,
    get: function () {
      return _Alert.default;
    }
  });
  Object.defineProperty(exports, "Animated", {
    enumerable: true,
    get: function () {
      return _Animated.default;
    }
  });
  Object.defineProperty(exports, "AppRegistry", {
    enumerable: true,
    get: function () {
      return _AppRegistry.default;
    }
  });
  Object.defineProperty(exports, "AppState", {
    enumerable: true,
    get: function () {
      return _AppState.default;
    }
  });
  Object.defineProperty(exports, "Appearance", {
    enumerable: true,
    get: function () {
      return _Appearance.default;
    }
  });
  Object.defineProperty(exports, "BackHandler", {
    enumerable: true,
    get: function () {
      return _BackHandler.default;
    }
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function () {
      return _Button.default;
    }
  });
  Object.defineProperty(exports, "CheckBox", {
    enumerable: true,
    get: function () {
      return _CheckBox.default;
    }
  });
  Object.defineProperty(exports, "Clipboard", {
    enumerable: true,
    get: function () {
      return _Clipboard.default;
    }
  });
  Object.defineProperty(exports, "DeviceEventEmitter", {
    enumerable: true,
    get: function () {
      return _DeviceEventEmitter.default;
    }
  });
  Object.defineProperty(exports, "Dimensions", {
    enumerable: true,
    get: function () {
      return _Dimensions.default;
    }
  });
  Object.defineProperty(exports, "Easing", {
    enumerable: true,
    get: function () {
      return _Easing.default;
    }
  });
  Object.defineProperty(exports, "FlatList", {
    enumerable: true,
    get: function () {
      return _FlatList.default;
    }
  });
  Object.defineProperty(exports, "I18nManager", {
    enumerable: true,
    get: function () {
      return _I18nManager.default;
    }
  });
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return _Image.default;
    }
  });
  Object.defineProperty(exports, "ImageBackground", {
    enumerable: true,
    get: function () {
      return _ImageBackground.default;
    }
  });
  Object.defineProperty(exports, "InteractionManager", {
    enumerable: true,
    get: function () {
      return _InteractionManager.default;
    }
  });
  Object.defineProperty(exports, "Keyboard", {
    enumerable: true,
    get: function () {
      return _Keyboard.default;
    }
  });
  Object.defineProperty(exports, "KeyboardAvoidingView", {
    enumerable: true,
    get: function () {
      return _KeyboardAvoidingView.default;
    }
  });
  Object.defineProperty(exports, "LayoutAnimation", {
    enumerable: true,
    get: function () {
      return _LayoutAnimation.default;
    }
  });
  Object.defineProperty(exports, "Linking", {
    enumerable: true,
    get: function () {
      return _Linking.default;
    }
  });
  Object.defineProperty(exports, "LogBox", {
    enumerable: true,
    get: function () {
      return _LogBox.default;
    }
  });
  Object.defineProperty(exports, "Modal", {
    enumerable: true,
    get: function () {
      return _Modal.default;
    }
  });
  Object.defineProperty(exports, "NativeEventEmitter", {
    enumerable: true,
    get: function () {
      return _NativeEventEmitter.default;
    }
  });
  Object.defineProperty(exports, "NativeModules", {
    enumerable: true,
    get: function () {
      return _NativeModules.default;
    }
  });
  Object.defineProperty(exports, "PanResponder", {
    enumerable: true,
    get: function () {
      return _PanResponder.default;
    }
  });
  Object.defineProperty(exports, "Picker", {
    enumerable: true,
    get: function () {
      return _Picker.default;
    }
  });
  Object.defineProperty(exports, "PixelRatio", {
    enumerable: true,
    get: function () {
      return _PixelRatio.default;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _Platform.default;
    }
  });
  Object.defineProperty(exports, "Pressable", {
    enumerable: true,
    get: function () {
      return _Pressable.default;
    }
  });
  Object.defineProperty(exports, "ProgressBar", {
    enumerable: true,
    get: function () {
      return _ProgressBar.default;
    }
  });
  Object.defineProperty(exports, "RefreshControl", {
    enumerable: true,
    get: function () {
      return _RefreshControl.default;
    }
  });
  Object.defineProperty(exports, "SafeAreaView", {
    enumerable: true,
    get: function () {
      return _SafeAreaView.default;
    }
  });
  Object.defineProperty(exports, "ScrollView", {
    enumerable: true,
    get: function () {
      return _ScrollView.default;
    }
  });
  Object.defineProperty(exports, "SectionList", {
    enumerable: true,
    get: function () {
      return _SectionList.default;
    }
  });
  Object.defineProperty(exports, "Share", {
    enumerable: true,
    get: function () {
      return _Share.default;
    }
  });
  Object.defineProperty(exports, "StatusBar", {
    enumerable: true,
    get: function () {
      return _StatusBar.default;
    }
  });
  Object.defineProperty(exports, "StyleSheet", {
    enumerable: true,
    get: function () {
      return _StyleSheet.default;
    }
  });
  Object.defineProperty(exports, "Switch", {
    enumerable: true,
    get: function () {
      return _Switch.default;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function () {
      return _Text.default;
    }
  });
  Object.defineProperty(exports, "TextInput", {
    enumerable: true,
    get: function () {
      return _TextInput.default;
    }
  });
  Object.defineProperty(exports, "Touchable", {
    enumerable: true,
    get: function () {
      return _Touchable.default;
    }
  });
  Object.defineProperty(exports, "TouchableHighlight", {
    enumerable: true,
    get: function () {
      return _TouchableHighlight.default;
    }
  });
  Object.defineProperty(exports, "TouchableNativeFeedback", {
    enumerable: true,
    get: function () {
      return _TouchableNativeFeedback.default;
    }
  });
  Object.defineProperty(exports, "TouchableOpacity", {
    enumerable: true,
    get: function () {
      return _TouchableOpacity.default;
    }
  });
  Object.defineProperty(exports, "TouchableWithoutFeedback", {
    enumerable: true,
    get: function () {
      return _TouchableWithoutFeedback.default;
    }
  });
  Object.defineProperty(exports, "UIManager", {
    enumerable: true,
    get: function () {
      return _UIManager.default;
    }
  });
  Object.defineProperty(exports, "Vibration", {
    enumerable: true,
    get: function () {
      return _Vibration.default;
    }
  });
  Object.defineProperty(exports, "View", {
    enumerable: true,
    get: function () {
      return _View.default;
    }
  });
  Object.defineProperty(exports, "VirtualizedList", {
    enumerable: true,
    get: function () {
      return _VirtualizedList.default;
    }
  });
  Object.defineProperty(exports, "YellowBox", {
    enumerable: true,
    get: function () {
      return _YellowBox.default;
    }
  });
  Object.defineProperty(exports, "findNodeHandle", {
    enumerable: true,
    get: function () {
      return _findNodeHandle.default;
    }
  });
  Object.defineProperty(exports, "processColor", {
    enumerable: true,
    get: function () {
      return _processColor.default;
    }
  });
  Object.defineProperty(exports, "render", {
    enumerable: true,
    get: function () {
      return _render.default;
    }
  });
  Object.defineProperty(exports, "unmountComponentAtNode", {
    enumerable: true,
    get: function () {
      return _unmountComponentAtNode.default;
    }
  });
  Object.defineProperty(exports, "unstable_createElement", {
    enumerable: true,
    get: function () {
      return _createElement.default;
    }
  });
  Object.defineProperty(exports, "useColorScheme", {
    enumerable: true,
    get: function () {
      return _useColorScheme.default;
    }
  });
  Object.defineProperty(exports, "useLocaleContext", {
    enumerable: true,
    get: function () {
      return _useLocaleContext.default;
    }
  });
  Object.defineProperty(exports, "useWindowDimensions", {
    enumerable: true,
    get: function () {
      return _useWindowDimensions.default;
    }
  });
  var _createElement = _interopRequireDefault(require(_dependencyMap[1], "./exports/createElement"));
  var _findNodeHandle = _interopRequireDefault(require(_dependencyMap[2], "./exports/findNodeHandle"));
  var _processColor = _interopRequireDefault(require(_dependencyMap[3], "./exports/processColor"));
  var _render = _interopRequireDefault(require(_dependencyMap[4], "./exports/render"));
  var _unmountComponentAtNode = _interopRequireDefault(require(_dependencyMap[5], "./exports/unmountComponentAtNode"));
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[6], "./exports/NativeModules"));
  var _AccessibilityInfo = _interopRequireDefault(require(_dependencyMap[7], "./exports/AccessibilityInfo"));
  var _Alert = _interopRequireDefault(require(_dependencyMap[8], "./exports/Alert"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[9], "./exports/Animated"));
  var _Appearance = _interopRequireDefault(require(_dependencyMap[10], "./exports/Appearance"));
  var _AppRegistry = _interopRequireDefault(require(_dependencyMap[11], "./exports/AppRegistry"));
  var _AppState = _interopRequireDefault(require(_dependencyMap[12], "./exports/AppState"));
  var _BackHandler = _interopRequireDefault(require(_dependencyMap[13], "./exports/BackHandler"));
  var _Clipboard = _interopRequireDefault(require(_dependencyMap[14], "./exports/Clipboard"));
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[15], "./exports/Dimensions"));
  var _Easing = _interopRequireDefault(require(_dependencyMap[16], "./exports/Easing"));
  var _I18nManager = _interopRequireDefault(require(_dependencyMap[17], "./exports/I18nManager"));
  var _Keyboard = _interopRequireDefault(require(_dependencyMap[18], "./exports/Keyboard"));
  var _InteractionManager = _interopRequireDefault(require(_dependencyMap[19], "./exports/InteractionManager"));
  var _LayoutAnimation = _interopRequireDefault(require(_dependencyMap[20], "./exports/LayoutAnimation"));
  var _Linking = _interopRequireDefault(require(_dependencyMap[21], "./exports/Linking"));
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[22], "./exports/NativeEventEmitter"));
  var _PanResponder = _interopRequireDefault(require(_dependencyMap[23], "./exports/PanResponder"));
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[24], "./exports/PixelRatio"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[25], "./exports/Platform"));
  var _Share = _interopRequireDefault(require(_dependencyMap[26], "./exports/Share"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[27], "./exports/StyleSheet"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[28], "./exports/UIManager"));
  var _Vibration = _interopRequireDefault(require(_dependencyMap[29], "./exports/Vibration"));
  var _ActivityIndicator = _interopRequireDefault(require(_dependencyMap[30], "./exports/ActivityIndicator"));
  var _Button = _interopRequireDefault(require(_dependencyMap[31], "./exports/Button"));
  var _CheckBox = _interopRequireDefault(require(_dependencyMap[32], "./exports/CheckBox"));
  var _FlatList = _interopRequireDefault(require(_dependencyMap[33], "./exports/FlatList"));
  var _Image = _interopRequireDefault(require(_dependencyMap[34], "./exports/Image"));
  var _ImageBackground = _interopRequireDefault(require(_dependencyMap[35], "./exports/ImageBackground"));
  var _KeyboardAvoidingView = _interopRequireDefault(require(_dependencyMap[36], "./exports/KeyboardAvoidingView"));
  var _Modal = _interopRequireDefault(require(_dependencyMap[37], "./exports/Modal"));
  var _Picker = _interopRequireDefault(require(_dependencyMap[38], "./exports/Picker"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[39], "./exports/Pressable"));
  var _ProgressBar = _interopRequireDefault(require(_dependencyMap[40], "./exports/ProgressBar"));
  var _RefreshControl = _interopRequireDefault(require(_dependencyMap[41], "./exports/RefreshControl"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[42], "./exports/SafeAreaView"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[43], "./exports/ScrollView"));
  var _SectionList = _interopRequireDefault(require(_dependencyMap[44], "./exports/SectionList"));
  var _StatusBar = _interopRequireDefault(require(_dependencyMap[45], "./exports/StatusBar"));
  var _Switch = _interopRequireDefault(require(_dependencyMap[46], "./exports/Switch"));
  var _Text = _interopRequireDefault(require(_dependencyMap[47], "./exports/Text"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[48], "./exports/TextInput"));
  var _Touchable = _interopRequireDefault(require(_dependencyMap[49], "./exports/Touchable"));
  var _TouchableHighlight = _interopRequireDefault(require(_dependencyMap[50], "./exports/TouchableHighlight"));
  var _TouchableNativeFeedback = _interopRequireDefault(require(_dependencyMap[51], "./exports/TouchableNativeFeedback"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[52], "./exports/TouchableOpacity"));
  var _TouchableWithoutFeedback = _interopRequireDefault(require(_dependencyMap[53], "./exports/TouchableWithoutFeedback"));
  var _View = _interopRequireDefault(require(_dependencyMap[54], "./exports/View"));
  var _VirtualizedList = _interopRequireDefault(require(_dependencyMap[55], "./exports/VirtualizedList"));
  var _YellowBox = _interopRequireDefault(require(_dependencyMap[56], "./exports/YellowBox"));
  var _LogBox = _interopRequireDefault(require(_dependencyMap[57], "./exports/LogBox"));
  var _DeviceEventEmitter = _interopRequireDefault(require(_dependencyMap[58], "./exports/DeviceEventEmitter"));
  var _useColorScheme = _interopRequireDefault(require(_dependencyMap[59], "./exports/useColorScheme"));
  var _useLocaleContext = _interopRequireDefault(require(_dependencyMap[60], "./exports/useLocaleContext"));
  var _useWindowDimensions = _interopRequireDefault(require(_dependencyMap[61], "./exports/useWindowDimensions"));
},16,[17,18,87,37,88,95,96,102,103,104,211,212,215,216,217,136,208,218,219,143,220,222,223,224,183,106,227,30,97,228,229,230,234,109,180,235,236,237,242,244,249,134,250,135,186,251,252,190,254,255,259,260,231,262,111,263,264,265,266,267,268,269],"node_modules\\react-native-web\\dist\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
      "default": e
    };
  }
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},17,[],"node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AccessibilityUtil = _interopRequireDefault(require(_dependencyMap[1], "../../modules/AccessibilityUtil"));
  var _createDOMProps = _interopRequireDefault(require(_dependencyMap[2], "../../modules/createDOMProps"));
  var _react = _interopRequireDefault(require(_dependencyMap[3], "react"));
  var _useLocale = require(_dependencyMap[4], "../../modules/useLocale");
  var createElement = (component, props, options) => {
    // Use equivalent platform elements where possible.
    var accessibilityComponent;
    if (component && component.constructor === String) {
      accessibilityComponent = _AccessibilityUtil.default.propsToAccessibilityComponent(props);
    }
    var Component = accessibilityComponent || component;
    var domProps = (0, _createDOMProps.default)(Component, props, options);
    var element = /*#__PURE__*/_react.default.createElement(Component, domProps);

    // Update locale context if element's writing direction prop changes
    var elementWithLocaleProvider = domProps.dir ? /*#__PURE__*/_react.default.createElement(_useLocale.LocaleProvider, {
      children: element,
      direction: domProps.dir,
      locale: domProps.lang
    }) : element;
    return elementWithLocaleProvider;
  };
  var _default = exports.default = createElement;
},18,[17,19,23,3,85],"node_modules\\react-native-web\\dist\\exports\\createElement\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _isDisabled = _interopRequireDefault(require(_dependencyMap[1], "./isDisabled"));
  var _propsToAccessibilityComponent = _interopRequireDefault(require(_dependencyMap[2], "./propsToAccessibilityComponent"));
  var _propsToAriaRole = _interopRequireDefault(require(_dependencyMap[3], "./propsToAriaRole"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var AccessibilityUtil = {
    isDisabled: _isDisabled.default,
    propsToAccessibilityComponent: _propsToAccessibilityComponent.default,
    propsToAriaRole: _propsToAriaRole.default
  };
  var _default = exports.default = AccessibilityUtil;
},19,[17,20,21,22],"node_modules\\react-native-web\\dist\\modules\\AccessibilityUtil\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isDisabled = props => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf('disabled') > -1;
  var _default = exports.default = isDisabled;
},20,[],"node_modules\\react-native-web\\dist\\modules\\AccessibilityUtil\\isDisabled.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _propsToAriaRole = _interopRequireDefault(require(_dependencyMap[1], "./propsToAriaRole"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var roleComponents = {
    article: 'article',
    banner: 'header',
    blockquote: 'blockquote',
    button: 'button',
    code: 'code',
    complementary: 'aside',
    contentinfo: 'footer',
    deletion: 'del',
    emphasis: 'em',
    figure: 'figure',
    insertion: 'ins',
    form: 'form',
    list: 'ul',
    listitem: 'li',
    main: 'main',
    navigation: 'nav',
    paragraph: 'p',
    region: 'section',
    strong: 'strong'
  };
  var emptyObject = {};
  var propsToAccessibilityComponent = function propsToAccessibilityComponent(props) {
    if (props === void 0) {
      props = emptyObject;
    }
    var roleProp = props.role || props.accessibilityRole;
    // special-case for "label" role which doesn't map to an ARIA role
    if (roleProp === 'label') {
      return 'label';
    }
    var role = (0, _propsToAriaRole.default)(props);
    if (role) {
      if (role === 'heading') {
        var level = props.accessibilityLevel || props['aria-level'];
        if (level != null) {
          return "h" + level;
        }
        return 'h1';
      }
      return roleComponents[role];
    }
  };
  var _default = exports.default = propsToAccessibilityComponent;
},21,[17,22],"node_modules\\react-native-web\\dist\\modules\\AccessibilityUtil\\propsToAccessibilityComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var accessibilityRoleToWebRole = {
    adjustable: 'slider',
    button: 'button',
    header: 'heading',
    image: 'img',
    imagebutton: null,
    keyboardkey: null,
    label: null,
    link: 'link',
    none: 'presentation',
    search: 'search',
    summary: 'region',
    text: null
  };
  var propsToAriaRole = _ref => {
    var accessibilityRole = _ref.accessibilityRole,
      role = _ref.role;
    var _role = role || accessibilityRole;
    if (_role) {
      var inferredRole = accessibilityRoleToWebRole[_role];
      if (inferredRole !== null) {
        // ignore roles that don't map to web
        return inferredRole || _role;
      }
    }
  };
  var _default = exports.default = propsToAriaRole;
},22,[],"node_modules\\react-native-web\\dist\\modules\\AccessibilityUtil\\propsToAriaRole.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _AccessibilityUtil = _interopRequireDefault(require(_dependencyMap[3], "../AccessibilityUtil"));
  var _StyleSheet2 = _interopRequireDefault(require(_dependencyMap[4], "../../exports/StyleSheet"));
  var _warnOnce = require(_dependencyMap[5], "../warnOnce");
  var _excluded = ["aria-activedescendant", "accessibilityActiveDescendant", "aria-atomic", "accessibilityAtomic", "aria-autocomplete", "accessibilityAutoComplete", "aria-busy", "accessibilityBusy", "aria-checked", "accessibilityChecked", "aria-colcount", "accessibilityColumnCount", "aria-colindex", "accessibilityColumnIndex", "aria-colspan", "accessibilityColumnSpan", "aria-controls", "accessibilityControls", "aria-current", "accessibilityCurrent", "aria-describedby", "accessibilityDescribedBy", "aria-details", "accessibilityDetails", "aria-disabled", "accessibilityDisabled", "aria-errormessage", "accessibilityErrorMessage", "aria-expanded", "accessibilityExpanded", "aria-flowto", "accessibilityFlowTo", "aria-haspopup", "accessibilityHasPopup", "aria-hidden", "accessibilityHidden", "aria-invalid", "accessibilityInvalid", "aria-keyshortcuts", "accessibilityKeyShortcuts", "aria-label", "accessibilityLabel", "aria-labelledby", "accessibilityLabelledBy", "aria-level", "accessibilityLevel", "aria-live", "accessibilityLiveRegion", "aria-modal", "accessibilityModal", "aria-multiline", "accessibilityMultiline", "aria-multiselectable", "accessibilityMultiSelectable", "aria-orientation", "accessibilityOrientation", "aria-owns", "accessibilityOwns", "aria-placeholder", "accessibilityPlaceholder", "aria-posinset", "accessibilityPosInSet", "aria-pressed", "accessibilityPressed", "aria-readonly", "accessibilityReadOnly", "aria-required", "accessibilityRequired", "role", "accessibilityRole", "aria-roledescription", "accessibilityRoleDescription", "aria-rowcount", "accessibilityRowCount", "aria-rowindex", "accessibilityRowIndex", "aria-rowspan", "accessibilityRowSpan", "aria-selected", "accessibilitySelected", "aria-setsize", "accessibilitySetSize", "aria-sort", "accessibilitySort", "aria-valuemax", "accessibilityValueMax", "aria-valuemin", "accessibilityValueMin", "aria-valuenow", "accessibilityValueNow", "aria-valuetext", "accessibilityValueText", "dataSet", "focusable", "id", "nativeID", "pointerEvents", "style", "tabIndex", "testID"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var uppercasePattern = /[A-Z]/g;
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateString(str) {
    return str.replace(uppercasePattern, toHyphenLower);
  }
  function processIDRefList(idRefList) {
    return isArray(idRefList) ? idRefList.join(' ') : idRefList;
  }
  var pointerEventsStyles = _StyleSheet2.default.create({
    auto: {
      pointerEvents: 'auto'
    },
    'box-none': {
      pointerEvents: 'box-none'
    },
    'box-only': {
      pointerEvents: 'box-only'
    },
    none: {
      pointerEvents: 'none'
    }
  });
  var createDOMProps = (elementType, props, options) => {
    if (!props) {
      props = emptyObject;
    }
    var _props = props,
      ariaActiveDescendant = _props['aria-activedescendant'],
      accessibilityActiveDescendant = _props.accessibilityActiveDescendant,
      ariaAtomic = _props['aria-atomic'],
      accessibilityAtomic = _props.accessibilityAtomic,
      ariaAutoComplete = _props['aria-autocomplete'],
      accessibilityAutoComplete = _props.accessibilityAutoComplete,
      ariaBusy = _props['aria-busy'],
      accessibilityBusy = _props.accessibilityBusy,
      ariaChecked = _props['aria-checked'],
      accessibilityChecked = _props.accessibilityChecked,
      ariaColumnCount = _props['aria-colcount'],
      accessibilityColumnCount = _props.accessibilityColumnCount,
      ariaColumnIndex = _props['aria-colindex'],
      accessibilityColumnIndex = _props.accessibilityColumnIndex,
      ariaColumnSpan = _props['aria-colspan'],
      accessibilityColumnSpan = _props.accessibilityColumnSpan,
      ariaControls = _props['aria-controls'],
      accessibilityControls = _props.accessibilityControls,
      ariaCurrent = _props['aria-current'],
      accessibilityCurrent = _props.accessibilityCurrent,
      ariaDescribedBy = _props['aria-describedby'],
      accessibilityDescribedBy = _props.accessibilityDescribedBy,
      ariaDetails = _props['aria-details'],
      accessibilityDetails = _props.accessibilityDetails,
      ariaDisabled = _props['aria-disabled'],
      accessibilityDisabled = _props.accessibilityDisabled,
      ariaErrorMessage = _props['aria-errormessage'],
      accessibilityErrorMessage = _props.accessibilityErrorMessage,
      ariaExpanded = _props['aria-expanded'],
      accessibilityExpanded = _props.accessibilityExpanded,
      ariaFlowTo = _props['aria-flowto'],
      accessibilityFlowTo = _props.accessibilityFlowTo,
      ariaHasPopup = _props['aria-haspopup'],
      accessibilityHasPopup = _props.accessibilityHasPopup,
      ariaHidden = _props['aria-hidden'],
      accessibilityHidden = _props.accessibilityHidden,
      ariaInvalid = _props['aria-invalid'],
      accessibilityInvalid = _props.accessibilityInvalid,
      ariaKeyShortcuts = _props['aria-keyshortcuts'],
      accessibilityKeyShortcuts = _props.accessibilityKeyShortcuts,
      ariaLabel = _props['aria-label'],
      accessibilityLabel = _props.accessibilityLabel,
      ariaLabelledBy = _props['aria-labelledby'],
      accessibilityLabelledBy = _props.accessibilityLabelledBy,
      ariaLevel = _props['aria-level'],
      accessibilityLevel = _props.accessibilityLevel,
      ariaLive = _props['aria-live'],
      accessibilityLiveRegion = _props.accessibilityLiveRegion,
      ariaModal = _props['aria-modal'],
      accessibilityModal = _props.accessibilityModal,
      ariaMultiline = _props['aria-multiline'],
      accessibilityMultiline = _props.accessibilityMultiline,
      ariaMultiSelectable = _props['aria-multiselectable'],
      accessibilityMultiSelectable = _props.accessibilityMultiSelectable,
      ariaOrientation = _props['aria-orientation'],
      accessibilityOrientation = _props.accessibilityOrientation,
      ariaOwns = _props['aria-owns'],
      accessibilityOwns = _props.accessibilityOwns,
      ariaPlaceholder = _props['aria-placeholder'],
      accessibilityPlaceholder = _props.accessibilityPlaceholder,
      ariaPosInSet = _props['aria-posinset'],
      accessibilityPosInSet = _props.accessibilityPosInSet,
      ariaPressed = _props['aria-pressed'],
      accessibilityPressed = _props.accessibilityPressed,
      ariaReadOnly = _props['aria-readonly'],
      accessibilityReadOnly = _props.accessibilityReadOnly,
      ariaRequired = _props['aria-required'],
      accessibilityRequired = _props.accessibilityRequired,
      ariaRole = _props.role,
      accessibilityRole = _props.accessibilityRole,
      ariaRoleDescription = _props['aria-roledescription'],
      accessibilityRoleDescription = _props.accessibilityRoleDescription,
      ariaRowCount = _props['aria-rowcount'],
      accessibilityRowCount = _props.accessibilityRowCount,
      ariaRowIndex = _props['aria-rowindex'],
      accessibilityRowIndex = _props.accessibilityRowIndex,
      ariaRowSpan = _props['aria-rowspan'],
      accessibilityRowSpan = _props.accessibilityRowSpan,
      ariaSelected = _props['aria-selected'],
      accessibilitySelected = _props.accessibilitySelected,
      ariaSetSize = _props['aria-setsize'],
      accessibilitySetSize = _props.accessibilitySetSize,
      ariaSort = _props['aria-sort'],
      accessibilitySort = _props.accessibilitySort,
      ariaValueMax = _props['aria-valuemax'],
      accessibilityValueMax = _props.accessibilityValueMax,
      ariaValueMin = _props['aria-valuemin'],
      accessibilityValueMin = _props.accessibilityValueMin,
      ariaValueNow = _props['aria-valuenow'],
      accessibilityValueNow = _props.accessibilityValueNow,
      ariaValueText = _props['aria-valuetext'],
      accessibilityValueText = _props.accessibilityValueText,
      dataSet = _props.dataSet,
      focusable = _props.focusable,
      id = _props.id,
      nativeID = _props.nativeID,
      pointerEvents = _props.pointerEvents,
      style = _props.style,
      tabIndex = _props.tabIndex,
      testID = _props.testID,
      domProps = (0, _objectWithoutPropertiesLoose2.default)(_props, _excluded);

    /*
    if (accessibilityDisabled != null) {
      warnOnce('accessibilityDisabled', `accessibilityDisabled is deprecated.`);
    }
    */
    var disabled = ariaDisabled || accessibilityDisabled;
    var role = _AccessibilityUtil.default.propsToAriaRole(props);

    // ACCESSIBILITY
    /*
    if (accessibilityActiveDescendant != null) {
      warnOnce(
        'accessibilityActiveDescendant',
        `accessibilityActiveDescendant is deprecated. Use aria-activedescendant.`
      );
    }
    */
    var _ariaActiveDescendant = ariaActiveDescendant != null ? ariaActiveDescendant : accessibilityActiveDescendant;
    if (_ariaActiveDescendant != null) {
      domProps['aria-activedescendant'] = _ariaActiveDescendant;
    }

    /*
    if (accessibilityAtomic != null) {
      warnOnce(
        'accessibilityAtomic',
        `accessibilityAtomic is deprecated. Use aria-atomic.`
      );
    }
    */
    var _ariaAtomic = ariaAtomic != null ? ariaActiveDescendant : accessibilityAtomic;
    if (_ariaAtomic != null) {
      domProps['aria-atomic'] = _ariaAtomic;
    }

    /*
    if (accessibilityAutoComplete != null) {
      warnOnce(
        'accessibilityAutoComplete',
        `accessibilityAutoComplete is deprecated. Use aria-autocomplete.`
      );
    }
    */
    var _ariaAutoComplete = ariaAutoComplete != null ? ariaAutoComplete : accessibilityAutoComplete;
    if (_ariaAutoComplete != null) {
      domProps['aria-autocomplete'] = _ariaAutoComplete;
    }

    /*
    if (accessibilityBusy != null) {
      warnOnce(
        'accessibilityBusy',
        `accessibilityBusy is deprecated. Use aria-busy.`
      );
    }
    */
    var _ariaBusy = ariaBusy != null ? ariaBusy : accessibilityBusy;
    if (_ariaBusy != null) {
      domProps['aria-busy'] = _ariaBusy;
    }

    /*
    if (accessibilityChecked != null) {
      warnOnce(
        'accessibilityChecked',
        `accessibilityChecked is deprecated. Use aria-checked.`
      );
    }
    */
    var _ariaChecked = ariaChecked != null ? ariaChecked : accessibilityChecked;
    if (_ariaChecked != null) {
      domProps['aria-checked'] = _ariaChecked;
    }

    /*
    if (accessibilityColumnCount != null) {
      warnOnce(
        'accessibilityColumnCount',
        `accessibilityColumnCount is deprecated. Use aria-colcount.`
      );
    }
    */
    var _ariaColumnCount = ariaColumnCount != null ? ariaColumnCount : accessibilityColumnCount;
    if (_ariaColumnCount != null) {
      domProps['aria-colcount'] = _ariaColumnCount;
    }

    /*
    if (accessibilityColumnIndex != null) {
      warnOnce(
        'accessibilityColumnIndex',
        `accessibilityColumnIndex is deprecated. Use aria-colindex.`
      );
    }
    */
    var _ariaColumnIndex = ariaColumnIndex != null ? ariaColumnIndex : accessibilityColumnIndex;
    if (_ariaColumnIndex != null) {
      domProps['aria-colindex'] = _ariaColumnIndex;
    }

    /*
    if (accessibilityColumnSpan != null) {
      warnOnce(
        'accessibilityColumnSpan',
        `accessibilityColumnSpan is deprecated. Use aria-colspan.`
      );
    }
    */
    var _ariaColumnSpan = ariaColumnSpan != null ? ariaColumnSpan : accessibilityColumnSpan;
    if (_ariaColumnSpan != null) {
      domProps['aria-colspan'] = _ariaColumnSpan;
    }

    /*
    if (accessibilityControls != null) {
      warnOnce(
        'accessibilityControls',
        `accessibilityControls is deprecated. Use aria-controls.`
      );
    }
    */
    var _ariaControls = ariaControls != null ? ariaControls : accessibilityControls;
    if (_ariaControls != null) {
      domProps['aria-controls'] = processIDRefList(_ariaControls);
    }

    /*
    if (accessibilityCurrent != null) {
      warnOnce(
        'accessibilityCurrent',
        `accessibilityCurrent is deprecated. Use aria-current.`
      );
    }
    */
    var _ariaCurrent = ariaCurrent != null ? ariaCurrent : accessibilityCurrent;
    if (_ariaCurrent != null) {
      domProps['aria-current'] = _ariaCurrent;
    }

    /*
    if (accessibilityDescribedBy != null) {
      warnOnce(
        'accessibilityDescribedBy',
        `accessibilityDescribedBy is deprecated. Use aria-describedby.`
      );
    }
    */
    var _ariaDescribedBy = ariaDescribedBy != null ? ariaDescribedBy : accessibilityDescribedBy;
    if (_ariaDescribedBy != null) {
      domProps['aria-describedby'] = processIDRefList(_ariaDescribedBy);
    }

    /*
    if (accessibilityDetails != null) {
      warnOnce(
        'accessibilityDetails',
        `accessibilityDetails is deprecated. Use aria-details.`
      );
    }
    */
    var _ariaDetails = ariaDetails != null ? ariaDetails : accessibilityDetails;
    if (_ariaDetails != null) {
      domProps['aria-details'] = _ariaDetails;
    }
    if (disabled === true) {
      domProps['aria-disabled'] = true;
      // Enhance with native semantics
      if (elementType === 'button' || elementType === 'form' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.disabled = true;
      }
    }

    /*
    if (accessibilityErrorMessage != null) {
      warnOnce(
        'accessibilityErrorMessage',
        `accessibilityErrorMessage is deprecated. Use aria-errormessage.`
      );
    }
    */
    var _ariaErrorMessage = ariaErrorMessage != null ? ariaErrorMessage : accessibilityErrorMessage;
    if (_ariaErrorMessage != null) {
      domProps['aria-errormessage'] = _ariaErrorMessage;
    }

    /*
    if (accessibilityExpanded != null) {
      warnOnce(
        'accessibilityExpanded',
        `accessibilityExpanded is deprecated. Use aria-expanded.`
      );
    }
    */
    var _ariaExpanded = ariaExpanded != null ? ariaExpanded : accessibilityExpanded;
    if (_ariaExpanded != null) {
      domProps['aria-expanded'] = _ariaExpanded;
    }

    /*
    if (accessibilityFlowTo != null) {
      warnOnce(
        'accessibilityFlowTo',
        `accessibilityFlowTo is deprecated. Use aria-flowto.`
      );
    }
    */
    var _ariaFlowTo = ariaFlowTo != null ? ariaFlowTo : accessibilityFlowTo;
    if (_ariaFlowTo != null) {
      domProps['aria-flowto'] = processIDRefList(_ariaFlowTo);
    }

    /*
    if (accessibilityHasPopup != null) {
      warnOnce(
        'accessibilityHasPopup',
        `accessibilityHasPopup is deprecated. Use aria-haspopup.`
      );
    }
    */
    var _ariaHasPopup = ariaHasPopup != null ? ariaHasPopup : accessibilityHasPopup;
    if (_ariaHasPopup != null) {
      domProps['aria-haspopup'] = _ariaHasPopup;
    }

    /*
    if (accessibilityHidden != null) {
      warnOnce(
        'accessibilityHidden',
        `accessibilityHidden is deprecated. Use aria-hidden.`
      );
    }
    */
    var _ariaHidden = ariaHidden != null ? ariaHidden : accessibilityHidden;
    if (_ariaHidden === true) {
      domProps['aria-hidden'] = _ariaHidden;
    }

    /*
    if (accessibilityInvalid != null) {
      warnOnce(
        'accessibilityInvalid',
        `accessibilityInvalid is deprecated. Use aria-invalid.`
      );
    }
    */
    var _ariaInvalid = ariaInvalid != null ? ariaInvalid : accessibilityInvalid;
    if (_ariaInvalid != null) {
      domProps['aria-invalid'] = _ariaInvalid;
    }

    /*
    if (accessibilityKeyShortcuts != null) {
      warnOnce(
        'accessibilityKeyShortcuts',
        `accessibilityKeyShortcuts is deprecated. Use aria-keyshortcuts.`
      );
    }
    */
    var _ariaKeyShortcuts = ariaKeyShortcuts != null ? ariaKeyShortcuts : accessibilityKeyShortcuts;
    if (_ariaKeyShortcuts != null) {
      domProps['aria-keyshortcuts'] = processIDRefList(_ariaKeyShortcuts);
    }

    /*
    if (accessibilityLabel != null) {
      warnOnce(
        'accessibilityLabel',
        `accessibilityLabel is deprecated. Use aria-label.`
      );
    }
    */
    var _ariaLabel = ariaLabel != null ? ariaLabel : accessibilityLabel;
    if (_ariaLabel != null) {
      domProps['aria-label'] = _ariaLabel;
    }

    /*
    if (accessibilityLabelledBy != null) {
      warnOnce(
        'accessibilityLabelledBy',
        `accessibilityLabelledBy is deprecated. Use aria-labelledby.`
      );
    }
    */
    var _ariaLabelledBy = ariaLabelledBy != null ? ariaLabelledBy : accessibilityLabelledBy;
    if (_ariaLabelledBy != null) {
      domProps['aria-labelledby'] = processIDRefList(_ariaLabelledBy);
    }

    /*
    if (accessibilityLevel != null) {
      warnOnce(
        'accessibilityLevel',
        `accessibilityLevel is deprecated. Use aria-level.`
      );
    }
    */
    var _ariaLevel = ariaLevel != null ? ariaLevel : accessibilityLevel;
    if (_ariaLevel != null) {
      domProps['aria-level'] = _ariaLevel;
    }

    /*
    if (accessibilityLiveRegion != null) {
      warnOnce(
        'accessibilityLiveRegion',
        `accessibilityLiveRegion is deprecated. Use aria-live.`
      );
    }
    */
    var _ariaLive = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    if (_ariaLive != null) {
      domProps['aria-live'] = _ariaLive === 'none' ? 'off' : _ariaLive;
    }

    /*
    if (accessibilityModal != null) {
      warnOnce(
        'accessibilityModal',
        `accessibilityModal is deprecated. Use aria-modal.`
      );
    }
    */
    var _ariaModal = ariaModal != null ? ariaModal : accessibilityModal;
    if (_ariaModal != null) {
      domProps['aria-modal'] = _ariaModal;
    }

    /*
    if (accessibilityMultiline != null) {
      warnOnce(
        'accessibilityMultiline',
        `accessibilityMultiline is deprecated. Use aria-multiline.`
      );
    }
    */
    var _ariaMultiline = ariaMultiline != null ? ariaMultiline : accessibilityMultiline;
    if (_ariaMultiline != null) {
      domProps['aria-multiline'] = _ariaMultiline;
    }

    /*
    if (accessibilityMultiSelectable != null) {
      warnOnce(
        'accessibilityMultiSelectable',
        `accessibilityMultiSelectable is deprecated. Use aria-multiselectable.`
      );
    }
    */
    var _ariaMultiSelectable = ariaMultiSelectable != null ? ariaMultiSelectable : accessibilityMultiSelectable;
    if (_ariaMultiSelectable != null) {
      domProps['aria-multiselectable'] = _ariaMultiSelectable;
    }

    /*
    if (accessibilityOrientation != null) {
      warnOnce(
        'accessibilityOrientation',
        `accessibilityOrientation is deprecated. Use aria-orientation.`
      );
    }
    */
    var _ariaOrientation = ariaOrientation != null ? ariaOrientation : accessibilityOrientation;
    if (_ariaOrientation != null) {
      domProps['aria-orientation'] = _ariaOrientation;
    }

    /*
    if (accessibilityOwns != null) {
      warnOnce(
        'accessibilityOwns',
        `accessibilityOwns is deprecated. Use aria-owns.`
      );
    }
    */
    var _ariaOwns = ariaOwns != null ? ariaOwns : accessibilityOwns;
    if (_ariaOwns != null) {
      domProps['aria-owns'] = processIDRefList(_ariaOwns);
    }

    /*
    if (accessibilityPlaceholder != null) {
      warnOnce(
        'accessibilityPlaceholder',
        `accessibilityPlaceholder is deprecated. Use aria-placeholder.`
      );
    }
    */
    var _ariaPlaceholder = ariaPlaceholder != null ? ariaPlaceholder : accessibilityPlaceholder;
    if (_ariaPlaceholder != null) {
      domProps['aria-placeholder'] = _ariaPlaceholder;
    }

    /*
    if (accessibilityPosInSet != null) {
      warnOnce(
        'accessibilityPosInSet',
        `accessibilityPosInSet is deprecated. Use aria-posinset.`
      );
    }
    */
    var _ariaPosInSet = ariaPosInSet != null ? ariaPosInSet : accessibilityPosInSet;
    if (_ariaPosInSet != null) {
      domProps['aria-posinset'] = _ariaPosInSet;
    }

    /*
    if (accessibilityPressed != null) {
      warnOnce(
        'accessibilityPressed',
        `accessibilityPressed is deprecated. Use aria-pressed.`
      );
    }
    */
    var _ariaPressed = ariaPressed != null ? ariaPressed : accessibilityPressed;
    if (_ariaPressed != null) {
      domProps['aria-pressed'] = _ariaPressed;
    }

    /*
    if (accessibilityReadOnly != null) {
      warnOnce(
        'accessibilityReadOnly',
        `accessibilityReadOnly is deprecated. Use aria-readonly.`
      );
    }
    */
    var _ariaReadOnly = ariaReadOnly != null ? ariaReadOnly : accessibilityReadOnly;
    if (_ariaReadOnly != null) {
      domProps['aria-readonly'] = _ariaReadOnly;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.readOnly = true;
      }
    }

    /*
    if (accessibilityRequired != null) {
      warnOnce(
        'accessibilityRequired',
        `accessibilityRequired is deprecated. Use aria-required.`
      );
    }
    */
    var _ariaRequired = ariaRequired != null ? ariaRequired : accessibilityRequired;
    if (_ariaRequired != null) {
      domProps['aria-required'] = _ariaRequired;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.required = accessibilityRequired;
      }
    }

    /*
    if (accessibilityRole != null) {
      warnOnce('accessibilityRole', `accessibilityRole is deprecated. Use role.`);
    }
    */
    if (role != null) {
      // 'presentation' synonym has wider browser support
      domProps['role'] = role === 'none' ? 'presentation' : role;
    }

    /*
    if (accessibilityRoleDescription != null) {
      warnOnce(
        'accessibilityRoleDescription',
        `accessibilityRoleDescription is deprecated. Use aria-roledescription.`
      );
    }
    */
    var _ariaRoleDescription = ariaRoleDescription != null ? ariaRoleDescription : accessibilityRoleDescription;
    if (_ariaRoleDescription != null) {
      domProps['aria-roledescription'] = _ariaRoleDescription;
    }

    /*
    if (accessibilityRowCount != null) {
      warnOnce(
        'accessibilityRowCount',
        `accessibilityRowCount is deprecated. Use aria-rowcount.`
      );
    }
    */
    var _ariaRowCount = ariaRowCount != null ? ariaRowCount : accessibilityRowCount;
    if (_ariaRowCount != null) {
      domProps['aria-rowcount'] = _ariaRowCount;
    }

    /*
    if (accessibilityRowIndex != null) {
      warnOnce(
        'accessibilityRowIndex',
        `accessibilityRowIndex is deprecated. Use aria-rowindex.`
      );
    }
    */
    var _ariaRowIndex = ariaRowIndex != null ? ariaRowIndex : accessibilityRowIndex;
    if (_ariaRowIndex != null) {
      domProps['aria-rowindex'] = _ariaRowIndex;
    }

    /*
    if (accessibilityRowSpan != null) {
      warnOnce(
        'accessibilityRowSpan',
        `accessibilityRowSpan is deprecated. Use aria-rowspan.`
      );
    }
    */
    var _ariaRowSpan = ariaRowSpan != null ? ariaRowSpan : accessibilityRowSpan;
    if (_ariaRowSpan != null) {
      domProps['aria-rowspan'] = _ariaRowSpan;
    }

    /*
    if (accessibilitySelected != null) {
      warnOnce(
        'accessibilitySelected',
        `accessibilitySelected is deprecated. Use aria-selected.`
      );
    }
    */
    var _ariaSelected = ariaSelected != null ? ariaSelected : accessibilitySelected;
    if (_ariaSelected != null) {
      domProps['aria-selected'] = _ariaSelected;
    }

    /*
    if (accessibilitySetSize != null) {
      warnOnce(
        'accessibilitySetSize',
        `accessibilitySetSize is deprecated. Use aria-setsize.`
      );
    }
    */
    var _ariaSetSize = ariaSetSize != null ? ariaSetSize : accessibilitySetSize;
    if (_ariaSetSize != null) {
      domProps['aria-setsize'] = _ariaSetSize;
    }

    /*
    if (accessibilitySort != null) {
      warnOnce(
        'accessibilitySort',
        `accessibilitySort is deprecated. Use aria-sort.`
      );
    }
    */
    var _ariaSort = ariaSort != null ? ariaSort : accessibilitySort;
    if (_ariaSort != null) {
      domProps['aria-sort'] = _ariaSort;
    }

    /*
    if (accessibilityValueMax != null) {
      warnOnce(
        'accessibilityValueMax',
        `accessibilityValueMax is deprecated. Use aria-valuemax.`
      );
    }
    */
    var _ariaValueMax = ariaValueMax != null ? ariaValueMax : accessibilityValueMax;
    if (_ariaValueMax != null) {
      domProps['aria-valuemax'] = _ariaValueMax;
    }

    /*
    if (accessibilityValueMin != null) {
      warnOnce(
        'accessibilityValueMin',
        `accessibilityValueMin is deprecated. Use aria-valuemin.`
      );
    }
    */
    var _ariaValueMin = ariaValueMin != null ? ariaValueMin : accessibilityValueMin;
    if (_ariaValueMin != null) {
      domProps['aria-valuemin'] = _ariaValueMin;
    }

    /*
    if (accessibilityValueNow != null) {
      warnOnce(
        'accessibilityValueNow',
        `accessibilityValueNow is deprecated. Use aria-valuenow.`
      );
    }
    */
    var _ariaValueNow = ariaValueNow != null ? ariaValueNow : accessibilityValueNow;
    if (_ariaValueNow != null) {
      domProps['aria-valuenow'] = _ariaValueNow;
    }

    /*
    if (accessibilityValueText != null) {
      warnOnce(
        'accessibilityValueText',
        `accessibilityValueText is deprecated. Use aria-valuetext.`
      );
    }
    */
    var _ariaValueText = ariaValueText != null ? ariaValueText : accessibilityValueText;
    if (_ariaValueText != null) {
      domProps['aria-valuetext'] = _ariaValueText;
    }

    // "dataSet" replaced with "data-*"
    if (dataSet != null) {
      for (var dataProp in dataSet) {
        if (hasOwnProperty.call(dataSet, dataProp)) {
          var dataName = hyphenateString(dataProp);
          var dataValue = dataSet[dataProp];
          if (dataValue != null) {
            domProps["data-" + dataName] = dataValue;
          }
        }
      }
    }

    // FOCUS
    if (tabIndex === 0 || tabIndex === '0' || tabIndex === -1 || tabIndex === '-1') {
      domProps.tabIndex = tabIndex;
    } else {
      /*
      if (focusable != null) {
        warnOnce('focusable', `focusable is deprecated.`);
      }
      */

      // "focusable" indicates that an element may be a keyboard tab-stop.
      if (focusable === false) {
        domProps.tabIndex = '-1';
      }
      if (
      // These native elements are keyboard focusable by default
      elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        if (focusable === false || accessibilityDisabled === true) {
          domProps.tabIndex = '-1';
        }
      } else if (
      // These roles are made keyboard focusable by default
      role === 'button' || role === 'checkbox' || role === 'link' || role === 'radio' || role === 'textbox' || role === 'switch') {
        if (focusable !== false) {
          domProps.tabIndex = '0';
        }
      } else {
        // Everything else must explicitly set the prop
        if (focusable === true) {
          domProps.tabIndex = '0';
        }
      }
    }

    // Resolve styles
    if (pointerEvents != null) {
      (0, _warnOnce.warnOnce)('pointerEvents', "props.pointerEvents is deprecated. Use style.pointerEvents");
    }
    var _StyleSheet = (0, _StyleSheet2.default)([style, pointerEvents && pointerEventsStyles[pointerEvents]], (0, _objectSpread2.default)({
        writingDirection: 'ltr'
      }, options)),
      className = _StyleSheet[0],
      inlineStyle = _StyleSheet[1];
    if (className) {
      domProps.className = className;
    }
    if (inlineStyle) {
      domProps.style = inlineStyle;
    }

    // OTHER
    // Native element ID
    /*
    if (nativeID != null) {
      warnOnce('nativeID', `nativeID is deprecated. Use id.`);
    }
    */
    var _id = id != null ? id : nativeID;
    if (_id != null) {
      domProps.id = _id;
    }
    // Automated test IDs
    if (testID != null) {
      domProps['data-testid'] = testID;
    }
    if (domProps.type == null && elementType === 'button') {
      domProps.type = 'button';
    }
    return domProps;
  };
  var _default = exports.default = createDOMProps;
},23,[17,868,873,19,30,76],"node_modules\\react-native-web\\dist\\modules\\createDOMProps\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
},29,[],"node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _compiler = require(_dependencyMap[3], "./compiler");
  var _dom = require(_dependencyMap[4], "./dom");
  var _transformLocalizeStyle = require(_dependencyMap[5], "styleq/transform-localize-style");
  var _preprocess = require(_dependencyMap[6], "./preprocess");
  var _styleq = require(_dependencyMap[7], "styleq");
  var _validate = require(_dependencyMap[8], "./validate");
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[9], "../../modules/canUseDom"));
  var _excluded = ["writingDirection"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var staticStyleMap = new WeakMap();
  var sheet = (0, _dom.createSheet)();
  var defaultPreprocessOptions = {
    shadow: true,
    textShadow: true
  };
  function customStyleq(styles, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
      writingDirection = _options.writingDirection,
      preprocessOptions = (0, _objectWithoutPropertiesLoose2.default)(_options, _excluded);
    var isRTL = writingDirection === 'rtl';
    return _styleq.styleq.factory({
      transform(style) {
        var compiledStyle = staticStyleMap.get(style);
        if (compiledStyle != null) {
          return (0, _transformLocalizeStyle.localizeStyle)(compiledStyle, isRTL);
        }
        return (0, _preprocess.preprocess)(style, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, defaultPreprocessOptions), preprocessOptions));
      }
    })(styles);
  }
  function insertRules(compiledOrderedRules) {
    compiledOrderedRules.forEach(_ref => {
      var rules = _ref[0],
        order = _ref[1];
      if (sheet != null) {
        rules.forEach(rule => {
          sheet.insert(rule, order);
        });
      }
    });
  }
  function compileAndInsertAtomic(style) {
    var _atomic = (0, _compiler.atomic)((0, _preprocess.preprocess)(style, defaultPreprocessOptions)),
      compiledStyle = _atomic[0],
      compiledOrderedRules = _atomic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }
  function compileAndInsertReset(style, key) {
    var _classic = (0, _compiler.classic)(style, key),
      compiledStyle = _classic[0],
      compiledOrderedRules = _classic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }

  /* ----- API ----- */

  var absoluteFillObject = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var absoluteFill = create({
    x: (0, _objectSpread2.default)({}, absoluteFillObject)
  }).x;

  /**
   * create
   */
  function create(styles) {
    Object.keys(styles).forEach(key => {
      var styleObj = styles[key];
      // Only compile at runtime if the style is not already compiled
      if (styleObj != null && styleObj.$$css !== true) {
        var compiledStyles;
        if (key.indexOf('$raw') > -1) {
          compiledStyles = compileAndInsertReset(styleObj, key.split('$raw')[0]);
        } else {
          if (process.env.NODE_ENV !== 'production') {
            (0, _validate.validate)(styleObj);
            styles[key] = Object.freeze(styleObj);
          }
          compiledStyles = compileAndInsertAtomic(styleObj);
        }
        staticStyleMap.set(styleObj, compiledStyles);
      }
    });
    return styles;
  }

  /**
   * compose
   */
  function compose(style1, style2) {
    if (process.env.NODE_ENV !== 'production') {
      /* eslint-disable prefer-rest-params */
      var len = arguments.length;
      if (len > 2) {
        var readableStyles = [...arguments].map(a => flatten(a));
        throw new Error("StyleSheet.compose() only accepts 2 arguments, received " + len + ": " + JSON.stringify(readableStyles));
      }
      /* eslint-enable prefer-rest-params */
      /*
      console.warn(
        'StyleSheet.compose(a, b) is deprecated; use array syntax, i.e., [a,b].'
      );
      */
    }
    return [style1, style2];
  }

  /**
   * flatten
   */
  function flatten() {
    for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
      styles[_key] = arguments[_key];
    }
    var flatArray = styles.flat(Infinity);
    var result = {};
    for (var i = 0; i < flatArray.length; i++) {
      var style = flatArray[i];
      if (style != null && typeof style === 'object') {
        // $FlowFixMe
        Object.assign(result, style);
      }
    }
    return result;
  }

  /**
   * getSheet
   */
  function getSheet() {
    return {
      id: sheet.id,
      textContent: sheet.getTextContent()
    };
  }

  /**
   * resolve
   */

  function StyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }
    var isRTL = options.writingDirection === 'rtl';
    var styleProps = customStyleq(styles, options);
    if (Array.isArray(styleProps) && styleProps[1] != null) {
      styleProps[1] = (0, _compiler.inline)(styleProps[1], isRTL);
    }
    return styleProps;
  }
  StyleSheet.absoluteFill = absoluteFill;
  StyleSheet.absoluteFillObject = absoluteFillObject;
  StyleSheet.create = create;
  StyleSheet.compose = compose;
  StyleSheet.flatten = flatten;
  StyleSheet.getSheet = getSheet;
  // `hairlineWidth` is not implemented using screen density as browsers may
  // round sub-pixel values down to `0`, causing the line not to be rendered.
  StyleSheet.hairlineWidth = 1;
  if (_canUseDom.default && window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.resolveRNStyle = StyleSheet.flatten;
  }
  var stylesheet = StyleSheet;
  var _default = exports.default = stylesheet;
},30,[17,868,873,31,70,73,75,78,79,39],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.atomic = atomic;
  exports.classic = classic;
  exports.inline = inline;
  exports.stringifyValueWithProperty = stringifyValueWithProperty;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _createReactDOMStyle = _interopRequireDefault(require(_dependencyMap[3], "./createReactDOMStyle"));
  var _hash = _interopRequireDefault(require(_dependencyMap[4], "./hash"));
  var _hyphenateStyleName = _interopRequireDefault(require(_dependencyMap[5], "./hyphenateStyleName"));
  var _normalizeValueWithProperty = _interopRequireDefault(require(_dependencyMap[6], "./normalizeValueWithProperty"));
  var _prefixStyles = _interopRequireDefault(require(_dependencyMap[7], "../../../modules/prefixStyles"));
  var _excluded = ["animationKeyframes"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cache = new Map();
  var emptyObject = {};
  var classicGroup = 1;
  var atomicGroup = 3;
  var customGroup = {
    borderColor: 2,
    borderRadius: 2,
    borderStyle: 2,
    borderWidth: 2,
    display: 2,
    flex: 2,
    inset: 2,
    margin: 2,
    overflow: 2,
    overscrollBehavior: 2,
    padding: 2,
    insetBlock: 2.1,
    insetInline: 2.1,
    marginInline: 2.1,
    marginBlock: 2.1,
    paddingInline: 2.1,
    paddingBlock: 2.1,
    borderBlockStartColor: 2.2,
    borderBlockStartStyle: 2.2,
    borderBlockStartWidth: 2.2,
    borderBlockEndColor: 2.2,
    borderBlockEndStyle: 2.2,
    borderBlockEndWidth: 2.2,
    borderInlineStartColor: 2.2,
    borderInlineStartStyle: 2.2,
    borderInlineStartWidth: 2.2,
    borderInlineEndColor: 2.2,
    borderInlineEndStyle: 2.2,
    borderInlineEndWidth: 2.2,
    borderEndStartRadius: 2.2,
    borderEndEndRadius: 2.2,
    borderStartStartRadius: 2.2,
    borderStartEndRadius: 2.2,
    insetBlockEnd: 2.2,
    insetBlockStart: 2.2,
    insetInlineEnd: 2.2,
    insetInlineStart: 2.2,
    marginBlockStart: 2.2,
    marginBlockEnd: 2.2,
    marginInlineStart: 2.2,
    marginInlineEnd: 2.2,
    paddingBlockStart: 2.2,
    paddingBlockEnd: 2.2,
    paddingInlineStart: 2.2,
    paddingInlineEnd: 2.2
  };
  var borderTopLeftRadius = 'borderTopLeftRadius';
  var borderTopRightRadius = 'borderTopRightRadius';
  var borderBottomLeftRadius = 'borderBottomLeftRadius';
  var borderBottomRightRadius = 'borderBottomRightRadius';
  var borderLeftColor = 'borderLeftColor';
  var borderLeftStyle = 'borderLeftStyle';
  var borderLeftWidth = 'borderLeftWidth';
  var borderRightColor = 'borderRightColor';
  var borderRightStyle = 'borderRightStyle';
  var borderRightWidth = 'borderRightWidth';
  var right = 'right';
  var marginLeft = 'marginLeft';
  var marginRight = 'marginRight';
  var paddingLeft = 'paddingLeft';
  var paddingRight = 'paddingRight';
  var left = 'left';

  // Map of LTR property names to their BiDi equivalent.
  var PROPERTIES_FLIP = {
    [borderTopLeftRadius]: borderTopRightRadius,
    [borderTopRightRadius]: borderTopLeftRadius,
    [borderBottomLeftRadius]: borderBottomRightRadius,
    [borderBottomRightRadius]: borderBottomLeftRadius,
    [borderLeftColor]: borderRightColor,
    [borderLeftStyle]: borderRightStyle,
    [borderLeftWidth]: borderRightWidth,
    [borderRightColor]: borderLeftColor,
    [borderRightStyle]: borderLeftStyle,
    [borderRightWidth]: borderLeftWidth,
    [left]: right,
    [marginLeft]: marginRight,
    [marginRight]: marginLeft,
    [paddingLeft]: paddingRight,
    [paddingRight]: paddingLeft,
    [right]: left
  };

  // Map of I18N property names to their LTR equivalent.
  var PROPERTIES_I18N = {
    borderStartStartRadius: borderTopLeftRadius,
    borderStartEndRadius: borderTopRightRadius,
    borderEndStartRadius: borderBottomLeftRadius,
    borderEndEndRadius: borderBottomRightRadius,
    borderInlineStartColor: borderLeftColor,
    borderInlineStartStyle: borderLeftStyle,
    borderInlineStartWidth: borderLeftWidth,
    borderInlineEndColor: borderRightColor,
    borderInlineEndStyle: borderRightStyle,
    borderInlineEndWidth: borderRightWidth,
    insetInlineEnd: right,
    insetInlineStart: left,
    marginInlineStart: marginLeft,
    marginInlineEnd: marginRight,
    paddingInlineStart: paddingLeft,
    paddingInlineEnd: paddingRight
  };
  var PROPERTIES_VALUE = ['clear', 'float', 'textAlign'];
  function atomic(style) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    function atomicCompile(srcProp, prop, value) {
      var valueString = stringifyValueWithProperty(value, prop);
      var cacheKey = prop + valueString;
      var cachedResult = cache.get(cacheKey);
      var identifier;
      if (cachedResult != null) {
        identifier = cachedResult[0];
        compiledRules.push(cachedResult[1]);
      } else {
        var v = srcProp !== prop ? cacheKey : valueString;
        identifier = createIdentifier('r', srcProp, v);
        var order = customGroup[srcProp] || atomicGroup;
        var rules = createAtomicRules(identifier, prop, value);
        var orderedRules = [rules, order];
        compiledRules.push(orderedRules);
        cache.set(cacheKey, [identifier, orderedRules]);
      }
      return identifier;
    }
    Object.keys(style).sort().forEach(srcProp => {
      var value = style[srcProp];
      if (value != null) {
        var localizeableValue;
        // BiDi flip values
        if (PROPERTIES_VALUE.indexOf(srcProp) > -1) {
          var _left = atomicCompile(srcProp, srcProp, 'left');
          var _right = atomicCompile(srcProp, srcProp, 'right');
          if (value === 'start') {
            localizeableValue = [_left, _right];
          } else if (value === 'end') {
            localizeableValue = [_right, _left];
          }
        }
        // BiDi flip properties
        var propPolyfill = PROPERTIES_I18N[srcProp];
        if (propPolyfill != null) {
          var ltr = atomicCompile(srcProp, propPolyfill, value);
          var rtl = atomicCompile(srcProp, PROPERTIES_FLIP[propPolyfill], value);
          localizeableValue = [ltr, rtl];
        }
        // BiDi flip transitionProperty value
        if (srcProp === 'transitionProperty') {
          var values = Array.isArray(value) ? value : [value];
          var polyfillIndices = [];
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (typeof val === 'string' && PROPERTIES_I18N[val] != null) {
              polyfillIndices.push(i);
            }
          }
          if (polyfillIndices.length > 0) {
            var ltrPolyfillValues = [...values];
            var rtlPolyfillValues = [...values];
            polyfillIndices.forEach(i => {
              var ltrVal = ltrPolyfillValues[i];
              if (typeof ltrVal === 'string') {
                var ltrPolyfill = PROPERTIES_I18N[ltrVal];
                var rtlPolyfill = PROPERTIES_FLIP[ltrPolyfill];
                ltrPolyfillValues[i] = ltrPolyfill;
                rtlPolyfillValues[i] = rtlPolyfill;
                var _ltr = atomicCompile(srcProp, srcProp, ltrPolyfillValues);
                var _rtl = atomicCompile(srcProp, srcProp, rtlPolyfillValues);
                localizeableValue = [_ltr, _rtl];
              }
            });
          }
        }
        if (localizeableValue == null) {
          localizeableValue = atomicCompile(srcProp, srcProp, value);
        } else {
          compiledStyle['$$css$localize'] = true;
        }
        compiledStyle[srcProp] = localizeableValue;
      }
    });
    return [compiledStyle, compiledRules];
  }

  /**
   * Compile simple style object to classic CSS rules.
   * No support for 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function classic(style, name) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    var animationKeyframes = style.animationKeyframes,
      rest = (0, _objectWithoutPropertiesLoose2.default)(style, _excluded);
    var identifier = createIdentifier('css', name, JSON.stringify(style));
    var selector = "." + identifier;
    var animationName;
    if (animationKeyframes != null) {
      var _processKeyframesValu = processKeyframesValue(animationKeyframes),
        animationNames = _processKeyframesValu[0],
        keyframesRules = _processKeyframesValu[1];
      animationName = animationNames.join(',');
      compiledRules.push(...keyframesRules);
    }
    var block = createDeclarationBlock((0, _objectSpread2.default)((0, _objectSpread2.default)({}, rest), {}, {
      animationName
    }));
    compiledRules.push("" + selector + block);
    compiledStyle[identifier] = identifier;
    return [compiledStyle, [[compiledRules, classicGroup]]];
  }

  /**
   * Compile simple style object to inline DOM styles.
   * No support for 'animationKeyframes', 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function inline(originalStyle, isRTL) {
    var style = originalStyle || emptyObject;
    var frozenProps = {};
    var nextStyle = {};
    var _loop = function _loop() {
      var originalValue = style[originalProp];
      var prop = originalProp;
      var value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || originalValue == null) {
        return "continue";
      }

      // BiDi flip values
      if (PROPERTIES_VALUE.indexOf(originalProp) > -1) {
        if (originalValue === 'start') {
          value = isRTL ? 'right' : 'left';
        } else if (originalValue === 'end') {
          value = isRTL ? 'left' : 'right';
        }
      }
      // BiDi flip properties
      var propPolyfill = PROPERTIES_I18N[originalProp];
      if (propPolyfill != null) {
        prop = isRTL ? PROPERTIES_FLIP[propPolyfill] : propPolyfill;
      }
      // BiDi flip transitionProperty value
      if (originalProp === 'transitionProperty') {
        // $FlowFixMe
        var originalValues = Array.isArray(originalValue) ? originalValue : [originalValue];
        originalValues.forEach((val, i) => {
          if (typeof val === 'string') {
            var valuePolyfill = PROPERTIES_I18N[val];
            if (valuePolyfill != null) {
              originalValues[i] = isRTL ? PROPERTIES_FLIP[valuePolyfill] : valuePolyfill;
              value = originalValues.join(' ');
            }
          }
        });
      }

      // Create finalized style
      if (!frozenProps[prop]) {
        nextStyle[prop] = value;
      }
      if (prop === originalProp) {
        frozenProps[prop] = true;
      }

      //    if (PROPERTIES_I18N.hasOwnProperty(originalProp)) {
      //    frozenProps[prop] = true;
      //}
    };
    for (var originalProp in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return (0, _createReactDOMStyle.default)(nextStyle, true);
  }

  /**
   * Create a value string that normalizes different input values with a common
   * output.
   */
  function stringifyValueWithProperty(value, property) {
    // e.g., 0 => '0px', 'black' => 'rgba(0,0,0,1)'
    var normalizedValue = (0, _normalizeValueWithProperty.default)(value, property);
    return typeof normalizedValue !== 'string' ? JSON.stringify(normalizedValue || '') : normalizedValue;
  }

  /**
   * Create the Atomic CSS rules needed for a given StyleSheet rule.
   * Translates StyleSheet declarations to CSS.
   */
  function createAtomicRules(identifier, property, value) {
    var rules = [];
    var selector = "." + identifier;

    // Handle non-standard properties and object values that require multiple
    // CSS rules to be created.
    switch (property) {
      case 'animationKeyframes':
        {
          var _processKeyframesValu2 = processKeyframesValue(value),
            animationNames = _processKeyframesValu2[0],
            keyframesRules = _processKeyframesValu2[1];
          var block = createDeclarationBlock({
            animationName: animationNames.join(',')
          });
          rules.push("" + selector + block, ...keyframesRules);
          break;
        }

      // Equivalent to using '::placeholder'
      case 'placeholderTextColor':
        {
          var _block = createDeclarationBlock({
            color: value,
            opacity: 1
          });
          rules.push(selector + "::-webkit-input-placeholder" + _block, selector + "::-moz-placeholder" + _block, selector + ":-ms-input-placeholder" + _block, selector + "::placeholder" + _block);
          break;
        }

      // Polyfill for additional 'pointer-events' values
      // See d13f78622b233a0afc0c7a200c0a0792c8ca9e58
      case 'pointerEvents':
        {
          var finalValue = value;
          if (value === 'auto' || value === 'box-only') {
            finalValue = 'auto!important';
            if (value === 'box-only') {
              var _block2 = createDeclarationBlock({
                pointerEvents: 'none'
              });
              rules.push(selector + ">*" + _block2);
            }
          } else if (value === 'none' || value === 'box-none') {
            finalValue = 'none!important';
            if (value === 'box-none') {
              var _block3 = createDeclarationBlock({
                pointerEvents: 'auto'
              });
              rules.push(selector + ">*" + _block3);
            }
          }
          var _block4 = createDeclarationBlock({
            pointerEvents: finalValue
          });
          rules.push("" + selector + _block4);
          break;
        }

      // Polyfill for draft spec
      // https://drafts.csswg.org/css-scrollbars-1/
      case 'scrollbarWidth':
        {
          if (value === 'none') {
            rules.push(selector + "::-webkit-scrollbar{display:none}");
          }
          var _block5 = createDeclarationBlock({
            scrollbarWidth: value
          });
          rules.push("" + selector + _block5);
          break;
        }
      default:
        {
          var _block6 = createDeclarationBlock({
            [property]: value
          });
          rules.push("" + selector + _block6);
          break;
        }
    }
    return rules;
  }

  /**
   * Creates a CSS declaration block from a StyleSheet object.
   */
  function createDeclarationBlock(style) {
    var domStyle = (0, _prefixStyles.default)((0, _createReactDOMStyle.default)(style));
    var declarationsString = Object.keys(domStyle).map(property => {
      var value = domStyle[property];
      var prop = (0, _hyphenateStyleName.default)(property);
      // The prefixer may return an array of values:
      // { display: [ '-webkit-flex', 'flex' ] }
      // to represent "fallback" declarations
      // { display: -webkit-flex; display: flex; }
      if (Array.isArray(value)) {
        return value.map(v => prop + ":" + v).join(';');
      } else {
        return prop + ":" + value;
      }
    })
    // Once properties are hyphenated, this will put the vendor
    // prefixed and short-form properties first in the list.
    .sort().join(';');
    return "{" + declarationsString + ";}";
  }

  /**
   * An identifier is associated with a unique set of styles.
   */
  function createIdentifier(prefix, name, key) {
    var hashedString = (0, _hash.default)(name + key);
    return process.env.NODE_ENV !== 'production' ? prefix + "-" + name + "-" + hashedString : prefix + "-" + hashedString;
  }

  /**
   * Create individual CSS keyframes rules.
   */
  function createKeyframes(keyframes) {
    var prefixes = ['-webkit-', ''];
    var identifier = createIdentifier('r', 'animation', JSON.stringify(keyframes));
    var steps = '{' + Object.keys(keyframes).map(stepName => {
      var rule = keyframes[stepName];
      var block = createDeclarationBlock(rule);
      return "" + stepName + block;
    }).join('') + '}';
    var rules = prefixes.map(prefix => {
      return "@" + prefix + "keyframes " + identifier + steps;
    });
    return [identifier, rules];
  }

  /**
   * Create CSS keyframes rules and names from a StyleSheet keyframes object.
   */
  function processKeyframesValue(keyframesValue) {
    if (typeof keyframesValue === 'number') {
      throw new Error("Invalid CSS keyframes type: " + typeof keyframesValue);
    }
    var animationNames = [];
    var rules = [];
    var value = Array.isArray(keyframesValue) ? keyframesValue : [keyframesValue];
    value.forEach(keyframes => {
      if (typeof keyframes === 'string') {
        // Support external animation libraries (identifiers only)
        animationNames.push(keyframes);
      } else {
        // Create rules for each of the keyframes
        var _createKeyframes = createKeyframes(keyframes),
          identifier = _createKeyframes[0],
          keyframesRules = _createKeyframes[1];
        animationNames.push(identifier);
        rules.push(...keyframesRules);
      }
    });
    return [animationNames, rules];
  }
},31,[17,868,873,32,40,41,33,42],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _normalizeValueWithProperty = _interopRequireDefault(require(_dependencyMap[1], "./normalizeValueWithProperty"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[2], "../../../modules/canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * The browser implements the CSS cascade, where the order of properties is a
   * factor in determining which styles to paint. React Native is different. It
   * gives giving precedence to the more specific style property. For example,
   * the value of `paddingTop` takes precedence over that of `padding`.
   *
   * This module creates mutally exclusive style declarations by expanding all of
   * React Native's supported shortform properties (e.g. `padding`) to their
   * longfrom equivalents.
   */

  var emptyObject = {};
  var supportsCSS3TextDecoration = !_canUseDom.default || window.CSS != null && window.CSS.supports != null && (window.CSS.supports('text-decoration-line', 'none') || window.CSS.supports('-webkit-text-decoration-line', 'none'));
  var MONOSPACE_FONT_STACK = 'monospace,monospace';
  var SYSTEM_FONT_STACK = '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif';
  var STYLE_SHORT_FORM_EXPANSIONS = {
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderBlockColor: ['borderTopColor', 'borderBottomColor'],
    borderInlineColor: ['borderRightColor', 'borderLeftColor'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderBlockStyle: ['borderTopStyle', 'borderBottomStyle'],
    borderInlineStyle: ['borderRightStyle', 'borderLeftStyle'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderBlockWidth: ['borderTopWidth', 'borderBottomWidth'],
    borderInlineWidth: ['borderRightWidth', 'borderLeftWidth'],
    insetBlock: ['top', 'bottom'],
    insetInline: ['left', 'right'],
    marginBlock: ['marginTop', 'marginBottom'],
    marginInline: ['marginRight', 'marginLeft'],
    paddingBlock: ['paddingTop', 'paddingBottom'],
    paddingInline: ['paddingRight', 'paddingLeft'],
    overflow: ['overflowX', 'overflowY'],
    overscrollBehavior: ['overscrollBehaviorX', 'overscrollBehaviorY'],
    borderBlockStartColor: ['borderTopColor'],
    borderBlockStartStyle: ['borderTopStyle'],
    borderBlockStartWidth: ['borderTopWidth'],
    borderBlockEndColor: ['borderBottomColor'],
    borderBlockEndStyle: ['borderBottomStyle'],
    borderBlockEndWidth: ['borderBottomWidth'],
    //borderInlineStartColor: ['borderLeftColor'],
    //borderInlineStartStyle: ['borderLeftStyle'],
    //borderInlineStartWidth: ['borderLeftWidth'],
    //borderInlineEndColor: ['borderRightColor'],
    //borderInlineEndStyle: ['borderRightStyle'],
    //borderInlineEndWidth: ['borderRightWidth'],
    borderEndStartRadius: ['borderBottomLeftRadius'],
    borderEndEndRadius: ['borderBottomRightRadius'],
    borderStartStartRadius: ['borderTopLeftRadius'],
    borderStartEndRadius: ['borderTopRightRadius'],
    insetBlockEnd: ['bottom'],
    insetBlockStart: ['top'],
    //insetInlineEnd: ['right'],
    //insetInlineStart: ['left'],
    marginBlockStart: ['marginTop'],
    marginBlockEnd: ['marginBottom'],
    //marginInlineStart: ['marginLeft'],
    //marginInlineEnd: ['marginRight'],
    paddingBlockStart: ['paddingTop'],
    paddingBlockEnd: ['paddingBottom']
    //paddingInlineStart: ['marginLeft'],
    //paddingInlineEnd: ['marginRight'],
  };

  /**
   * Reducer
   */

  var createReactDOMStyle = (style, isInline) => {
    if (!style) {
      return emptyObject;
    }
    var resolvedStyle = {};
    var _loop = function _loop() {
      var value = style[prop];
      if (
      // Ignore everything with a null value
      value == null) {
        return "continue";
      }
      if (prop === 'backgroundClip') {
        // TODO: remove once this issue is fixed
        // https://github.com/rofrischmann/inline-style-prefixer/issues/159
        if (value === 'text') {
          resolvedStyle.backgroundClip = value;
          resolvedStyle.WebkitBackgroundClip = value;
        }
      } else if (prop === 'flex') {
        if (value === -1) {
          resolvedStyle.flexGrow = 0;
          resolvedStyle.flexShrink = 1;
          resolvedStyle.flexBasis = 'auto';
        } else {
          resolvedStyle.flex = value;
        }
      } else if (prop === 'font') {
        resolvedStyle[prop] = value.replace('System', SYSTEM_FONT_STACK);
      } else if (prop === 'fontFamily') {
        if (value.indexOf('System') > -1) {
          var stack = value.split(/,\s*/);
          stack[stack.indexOf('System')] = SYSTEM_FONT_STACK;
          resolvedStyle[prop] = stack.join(',');
        } else if (value === 'monospace') {
          resolvedStyle[prop] = MONOSPACE_FONT_STACK;
        } else {
          resolvedStyle[prop] = value;
        }
      } else if (prop === 'textDecorationLine') {
        // use 'text-decoration' for browsers that only support CSS2
        // text-decoration (e.g., IE, Edge)
        if (!supportsCSS3TextDecoration) {
          resolvedStyle.textDecoration = value;
        } else {
          resolvedStyle.textDecorationLine = value;
        }
      } else if (prop === 'writingDirection') {
        resolvedStyle.direction = value;
      } else {
        var _value = (0, _normalizeValueWithProperty.default)(style[prop], prop);
        var longFormProperties = STYLE_SHORT_FORM_EXPANSIONS[prop];
        if (isInline && prop === 'inset') {
          if (style.insetInline == null) {
            resolvedStyle.left = _value;
            resolvedStyle.right = _value;
          }
          if (style.insetBlock == null) {
            resolvedStyle.top = _value;
            resolvedStyle.bottom = _value;
          }
        } else if (isInline && prop === 'margin') {
          if (style.marginInline == null) {
            resolvedStyle.marginLeft = _value;
            resolvedStyle.marginRight = _value;
          }
          if (style.marginBlock == null) {
            resolvedStyle.marginTop = _value;
            resolvedStyle.marginBottom = _value;
          }
        } else if (isInline && prop === 'padding') {
          if (style.paddingInline == null) {
            resolvedStyle.paddingLeft = _value;
            resolvedStyle.paddingRight = _value;
          }
          if (style.paddingBlock == null) {
            resolvedStyle.paddingTop = _value;
            resolvedStyle.paddingBottom = _value;
          }
        } else if (longFormProperties) {
          longFormProperties.forEach((longForm, i) => {
            // The value of any longform property in the original styles takes
            // precedence over the shortform's value.
            if (style[longForm] == null) {
              resolvedStyle[longForm] = _value;
            }
          });
        } else {
          resolvedStyle[prop] = _value;
        }
      }
    };
    for (var prop in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return resolvedStyle;
  };
  var _default = exports.default = createReactDOMStyle;
},32,[17,33,39],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\createReactDOMStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeValueWithProperty;
  var _unitlessNumbers = _interopRequireDefault(require(_dependencyMap[1], "./unitlessNumbers"));
  var _normalizeColor = _interopRequireDefault(require(_dependencyMap[2], "./normalizeColor"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var colorProps = {
    backgroundColor: true,
    borderColor: true,
    borderTopColor: true,
    borderRightColor: true,
    borderBottomColor: true,
    borderLeftColor: true,
    color: true,
    shadowColor: true,
    textDecorationColor: true,
    textShadowColor: true
  };
  function normalizeValueWithProperty(value, property) {
    var returnValue = value;
    if ((property == null || !_unitlessNumbers.default[property]) && typeof value === 'number') {
      returnValue = value + "px";
    } else if (property != null && colorProps[property]) {
      returnValue = (0, _normalizeColor.default)(value);
    }
    return returnValue;
  }
},33,[17,34,35],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\normalizeValueWithProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = exports.default = unitlessNumbers;
},34,[],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\unitlessNumbers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _isWebColor = _interopRequireDefault(require(_dependencyMap[1], "../../../modules/isWebColor"));
  var _processColor = _interopRequireDefault(require(_dependencyMap[2], "../../../exports/processColor"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var normalizeColor = function normalizeColor(color, opacity) {
    if (opacity === void 0) {
      opacity = 1;
    }
    if (color == null) return;
    if (typeof color === 'string' && (0, _isWebColor.default)(color)) {
      return color;
    }
    var colorInt = (0, _processColor.default)(color);
    if (colorInt != null) {
      var r = colorInt >> 16 & 255;
      var g = colorInt >> 8 & 255;
      var b = colorInt & 255;
      var a = (colorInt >> 24 & 255) / 255;
      var alpha = (a * opacity).toFixed(2);
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }
  };
  var _default = exports.default = normalizeColor;
},35,[17,36,37],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\normalizeColor.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isWebColor = color => color === 'currentcolor' || color === 'currentColor' || color === 'inherit' || color.indexOf('var(') === 0;
  var _default = exports.default = isWebColor;
},36,[],"node_modules\\react-native-web\\dist\\modules\\isWebColor\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _normalizeColors = _interopRequireDefault(require(_dependencyMap[1], "@react-native/normalize-colors"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var processColor = color => {
    if (color === undefined || color === null) {
      return color;
    }

    // convert number and hex
    var int32Color = (0, _normalizeColors.default)(color);
    if (int32Color === undefined || int32Color === null) {
      return undefined;
    }
    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;
    return int32Color;
  };
  var _default = exports.default = processColor;
},37,[17,38],"node_modules\\react-native-web\\dist\\exports\\processColor\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  function normalizeColor(color) {
    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }
      return null;
    }
    if (typeof color !== 'string') {
      return null;
    }
    const matchers = getMatchers();
    let match;

    // Ordered based on occurrences on Facebook codebase
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 |
      // r
      parse255(match[2]) << 16 |
      // g
      parse255(match[3]) << 8 |
      // b
      0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      // rgba(R G B / A) notation
      if (match[6] !== undefined) {
        return (parse255(match[6]) << 24 |
        // r
        parse255(match[7]) << 16 |
        // g
        parse255(match[8]) << 8 |
        // b
        parse1(match[9])) >>>
        // a
        0;
      }

      // rgba(R, G, B, A) notation
      return (parse255(match[2]) << 24 |
      // r
      parse255(match[3]) << 16 |
      // g
      parse255(match[4]) << 8 |
      // b
      parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      'ff',
      // a
      16) >>> 0;
    }

    // https://drafts.csswg.org/css-color-4/#hex-notation
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      match[4] + match[4],
      // a
      16) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3]) // l
      ) | 0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      // hsla(H S L / A) notation
      if (match[6] !== undefined) {
        return (hslToRgb(parse360(match[6]),
        // h
        parsePercentage(match[7]),
        // s
        parsePercentage(match[8]) // l
        ) | parse1(match[9])) >>>
        // a
        0;
      }

      // hsla(H, S, L, A) notation
      return (hslToRgb(parse360(match[2]),
      // h
      parsePercentage(match[3]),
      // s
      parsePercentage(match[4]) // l
      ) | parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // w
      parsePercentage(match[3]) // b
      ) | 0x000000ff) >>>
      // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l) {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function hwbToRgb(h, w, b) {
    if (w + b >= 1) {
      const gray = Math.round(w * 255 / (w + b));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h + 1 / 3) * (1 - w - b) + w;
    const green = hue2rgb(0, 1, h) * (1 - w - b) + w;
    const blue = hue2rgb(0, 1, h - 1 / 3) * (1 - w - b) + w;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = '[-+]?\\d*\\.?\\d+';
  const PERCENTAGE = NUMBER + '%';
  function call(...args) {
    return '\\(\\s*(' + args.join(')\\s*,?\\s*(') + ')\\s*\\)';
  }
  function callWithSlashSeparator(...args) {
    return '\\(\\s*(' + args.slice(0, args.length - 1).join(')\\s*,?\\s*(') + ')\\s*/\\s*(' + args[args.length - 1] + ')\\s*\\)';
  }
  function commaSeparatedCall(...args) {
    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba(' + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + '|' + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ')'),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla(' + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + '|' + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ')'),
        hwb: new RegExp('hwb' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    // parseFloat conveniently ignores the final %
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    // prettier-ignore
    switch (name) {
      case 'transparent':
        return 0x00000000;
      // http://www.w3.org/TR/css3-color/#svg-color
      case 'aliceblue':
        return 0xf0f8ffff;
      case 'antiquewhite':
        return 0xfaebd7ff;
      case 'aqua':
        return 0x00ffffff;
      case 'aquamarine':
        return 0x7fffd4ff;
      case 'azure':
        return 0xf0ffffff;
      case 'beige':
        return 0xf5f5dcff;
      case 'bisque':
        return 0xffe4c4ff;
      case 'black':
        return 0x000000ff;
      case 'blanchedalmond':
        return 0xffebcdff;
      case 'blue':
        return 0x0000ffff;
      case 'blueviolet':
        return 0x8a2be2ff;
      case 'brown':
        return 0xa52a2aff;
      case 'burlywood':
        return 0xdeb887ff;
      case 'burntsienna':
        return 0xea7e5dff;
      case 'cadetblue':
        return 0x5f9ea0ff;
      case 'chartreuse':
        return 0x7fff00ff;
      case 'chocolate':
        return 0xd2691eff;
      case 'coral':
        return 0xff7f50ff;
      case 'cornflowerblue':
        return 0x6495edff;
      case 'cornsilk':
        return 0xfff8dcff;
      case 'crimson':
        return 0xdc143cff;
      case 'cyan':
        return 0x00ffffff;
      case 'darkblue':
        return 0x00008bff;
      case 'darkcyan':
        return 0x008b8bff;
      case 'darkgoldenrod':
        return 0xb8860bff;
      case 'darkgray':
        return 0xa9a9a9ff;
      case 'darkgreen':
        return 0x006400ff;
      case 'darkgrey':
        return 0xa9a9a9ff;
      case 'darkkhaki':
        return 0xbdb76bff;
      case 'darkmagenta':
        return 0x8b008bff;
      case 'darkolivegreen':
        return 0x556b2fff;
      case 'darkorange':
        return 0xff8c00ff;
      case 'darkorchid':
        return 0x9932ccff;
      case 'darkred':
        return 0x8b0000ff;
      case 'darksalmon':
        return 0xe9967aff;
      case 'darkseagreen':
        return 0x8fbc8fff;
      case 'darkslateblue':
        return 0x483d8bff;
      case 'darkslategray':
        return 0x2f4f4fff;
      case 'darkslategrey':
        return 0x2f4f4fff;
      case 'darkturquoise':
        return 0x00ced1ff;
      case 'darkviolet':
        return 0x9400d3ff;
      case 'deeppink':
        return 0xff1493ff;
      case 'deepskyblue':
        return 0x00bfffff;
      case 'dimgray':
        return 0x696969ff;
      case 'dimgrey':
        return 0x696969ff;
      case 'dodgerblue':
        return 0x1e90ffff;
      case 'firebrick':
        return 0xb22222ff;
      case 'floralwhite':
        return 0xfffaf0ff;
      case 'forestgreen':
        return 0x228b22ff;
      case 'fuchsia':
        return 0xff00ffff;
      case 'gainsboro':
        return 0xdcdcdcff;
      case 'ghostwhite':
        return 0xf8f8ffff;
      case 'gold':
        return 0xffd700ff;
      case 'goldenrod':
        return 0xdaa520ff;
      case 'gray':
        return 0x808080ff;
      case 'green':
        return 0x008000ff;
      case 'greenyellow':
        return 0xadff2fff;
      case 'grey':
        return 0x808080ff;
      case 'honeydew':
        return 0xf0fff0ff;
      case 'hotpink':
        return 0xff69b4ff;
      case 'indianred':
        return 0xcd5c5cff;
      case 'indigo':
        return 0x4b0082ff;
      case 'ivory':
        return 0xfffff0ff;
      case 'khaki':
        return 0xf0e68cff;
      case 'lavender':
        return 0xe6e6faff;
      case 'lavenderblush':
        return 0xfff0f5ff;
      case 'lawngreen':
        return 0x7cfc00ff;
      case 'lemonchiffon':
        return 0xfffacdff;
      case 'lightblue':
        return 0xadd8e6ff;
      case 'lightcoral':
        return 0xf08080ff;
      case 'lightcyan':
        return 0xe0ffffff;
      case 'lightgoldenrodyellow':
        return 0xfafad2ff;
      case 'lightgray':
        return 0xd3d3d3ff;
      case 'lightgreen':
        return 0x90ee90ff;
      case 'lightgrey':
        return 0xd3d3d3ff;
      case 'lightpink':
        return 0xffb6c1ff;
      case 'lightsalmon':
        return 0xffa07aff;
      case 'lightseagreen':
        return 0x20b2aaff;
      case 'lightskyblue':
        return 0x87cefaff;
      case 'lightslategray':
        return 0x778899ff;
      case 'lightslategrey':
        return 0x778899ff;
      case 'lightsteelblue':
        return 0xb0c4deff;
      case 'lightyellow':
        return 0xffffe0ff;
      case 'lime':
        return 0x00ff00ff;
      case 'limegreen':
        return 0x32cd32ff;
      case 'linen':
        return 0xfaf0e6ff;
      case 'magenta':
        return 0xff00ffff;
      case 'maroon':
        return 0x800000ff;
      case 'mediumaquamarine':
        return 0x66cdaaff;
      case 'mediumblue':
        return 0x0000cdff;
      case 'mediumorchid':
        return 0xba55d3ff;
      case 'mediumpurple':
        return 0x9370dbff;
      case 'mediumseagreen':
        return 0x3cb371ff;
      case 'mediumslateblue':
        return 0x7b68eeff;
      case 'mediumspringgreen':
        return 0x00fa9aff;
      case 'mediumturquoise':
        return 0x48d1ccff;
      case 'mediumvioletred':
        return 0xc71585ff;
      case 'midnightblue':
        return 0x191970ff;
      case 'mintcream':
        return 0xf5fffaff;
      case 'mistyrose':
        return 0xffe4e1ff;
      case 'moccasin':
        return 0xffe4b5ff;
      case 'navajowhite':
        return 0xffdeadff;
      case 'navy':
        return 0x000080ff;
      case 'oldlace':
        return 0xfdf5e6ff;
      case 'olive':
        return 0x808000ff;
      case 'olivedrab':
        return 0x6b8e23ff;
      case 'orange':
        return 0xffa500ff;
      case 'orangered':
        return 0xff4500ff;
      case 'orchid':
        return 0xda70d6ff;
      case 'palegoldenrod':
        return 0xeee8aaff;
      case 'palegreen':
        return 0x98fb98ff;
      case 'paleturquoise':
        return 0xafeeeeff;
      case 'palevioletred':
        return 0xdb7093ff;
      case 'papayawhip':
        return 0xffefd5ff;
      case 'peachpuff':
        return 0xffdab9ff;
      case 'peru':
        return 0xcd853fff;
      case 'pink':
        return 0xffc0cbff;
      case 'plum':
        return 0xdda0ddff;
      case 'powderblue':
        return 0xb0e0e6ff;
      case 'purple':
        return 0x800080ff;
      case 'rebeccapurple':
        return 0x663399ff;
      case 'red':
        return 0xff0000ff;
      case 'rosybrown':
        return 0xbc8f8fff;
      case 'royalblue':
        return 0x4169e1ff;
      case 'saddlebrown':
        return 0x8b4513ff;
      case 'salmon':
        return 0xfa8072ff;
      case 'sandybrown':
        return 0xf4a460ff;
      case 'seagreen':
        return 0x2e8b57ff;
      case 'seashell':
        return 0xfff5eeff;
      case 'sienna':
        return 0xa0522dff;
      case 'silver':
        return 0xc0c0c0ff;
      case 'skyblue':
        return 0x87ceebff;
      case 'slateblue':
        return 0x6a5acdff;
      case 'slategray':
        return 0x708090ff;
      case 'slategrey':
        return 0x708090ff;
      case 'snow':
        return 0xfffafaff;
      case 'springgreen':
        return 0x00ff7fff;
      case 'steelblue':
        return 0x4682b4ff;
      case 'tan':
        return 0xd2b48cff;
      case 'teal':
        return 0x008080ff;
      case 'thistle':
        return 0xd8bfd8ff;
      case 'tomato':
        return 0xff6347ff;
      case 'turquoise':
        return 0x40e0d0ff;
      case 'violet':
        return 0xee82eeff;
      case 'wheat':
        return 0xf5deb3ff;
      case 'white':
        return 0xffffffff;
      case 'whitesmoke':
        return 0xf5f5f5ff;
      case 'yellow':
        return 0xffff00ff;
      case 'yellowgreen':
        return 0x9acd32ff;
    }
    return null;
  }
  module.exports = normalizeColor;
},38,[],"node_modules\\react-native-web\\node_modules\\@react-native\\normalize-colors\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var _default = exports.default = canUseDOM;
},39,[],"node_modules\\react-native-web\\dist\\modules\\canUseDom\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /* eslint-disable */

  /**
   * JS Implementation of MurmurHash2
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} str ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   *
   * 
   */

  function murmurhash2_32_gc(str, seed) {
    var l = str.length,
      h = seed ^ l,
      i = 0,
      k;
    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }
    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }
    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return h >>> 0;
  }
  var hash = str => murmurhash2_32_gc(str, 1).toString(36);
  var _default = exports.default = hash;
},40,[],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\hash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (name in cache) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = exports.default = hyphenateStyleName;
},41,[],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\compiler\\hyphenateStyleName.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createPrefixer = _interopRequireDefault(require(_dependencyMap[1], "inline-style-prefixer/lib/createPrefixer"));
  var _static = _interopRequireDefault(require(_dependencyMap[2], "./static"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var prefixAll = (0, _createPrefixer.default)(_static.default);
  var _default = exports.default = prefixAll;
},42,[17,43,49],"node_modules\\react-native-web\\dist\\modules\\prefixStyles\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPrefixer;
  var _prefixProperty = require(_dependencyMap[0], "./utils/prefixProperty");
  var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
  var _prefixValue = require(_dependencyMap[1], "./utils/prefixValue");
  var _prefixValue2 = _interopRequireDefault(_prefixValue);
  var _addNewValuesOnly = require(_dependencyMap[2], "./utils/addNewValuesOnly");
  var _addNewValuesOnly2 = _interopRequireDefault(_addNewValuesOnly);
  var _isObject = require(_dependencyMap[3], "./utils/isObject");
  var _isObject2 = _interopRequireDefault(_isObject);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function createPrefixer(_ref) {
    var prefixMap = _ref.prefixMap,
      plugins = _ref.plugins;
    return function prefix(style) {
      for (var property in style) {
        var value = style[property];

        // handle nested objects
        if ((0, _isObject2.default)(value)) {
          style[property] = prefix(value);
          // handle array values
        } else if (Array.isArray(value)) {
          var combinedValue = [];
          for (var i = 0, len = value.length; i < len; ++i) {
            var processedValue = (0, _prefixValue2.default)(plugins, property, value[i], style, prefixMap);
            (0, _addNewValuesOnly2.default)(combinedValue, processedValue || value[i]);
          }

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (combinedValue.length > 0) {
            style[property] = combinedValue;
          }
        } else {
          var _processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (_processedValue) {
            style[property] = _processedValue;
          }
          style = (0, _prefixProperty2.default)(prefixMap, property, style);
        }
      }
      return style;
    };
  }
},43,[44,46,47,48],"node_modules\\inline-style-prefixer\\lib\\createPrefixer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString = require(_dependencyMap[0], "./capitalizeString");
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function prefixProperty(prefixProperties, property, style) {
    var requiredPrefixes = prefixProperties[property];
    if (requiredPrefixes && style.hasOwnProperty(property)) {
      var capitalizedProperty = (0, _capitalizeString2.default)(property);
      for (var i = 0; i < requiredPrefixes.length; ++i) {
        var prefixedProperty = requiredPrefixes[i] + capitalizedProperty;
        if (!style[prefixedProperty]) {
          style[prefixedProperty] = style[property];
        }
      }
    }
    return style;
  }
},44,[45],"node_modules\\inline-style-prefixer\\lib\\utils\\prefixProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
},45,[],"node_modules\\inline-style-prefixer\\lib\\utils\\capitalizeString.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);

      // we can stop processing if a value is returned
      // as all plugin criteria are unique
      if (processedValue) {
        return processedValue;
      }
    }
  }
},46,[],"node_modules\\inline-style-prefixer\\lib\\utils\\prefixValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addNewValuesOnly;
  function addIfNew(list, value) {
    if (list.indexOf(value) === -1) {
      list.push(value);
    }
  }
  function addNewValuesOnly(list, values) {
    if (Array.isArray(values)) {
      for (var i = 0, len = values.length; i < len; ++i) {
        addIfNew(list, values[i]);
      }
    } else {
      addIfNew(list, values);
    }
  }
},47,[],"node_modules\\inline-style-prefixer\\lib\\utils\\addNewValuesOnly.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isObject;
  function isObject(value) {
    return value instanceof Object && !Array.isArray(value);
  }
},48,[],"node_modules\\inline-style-prefixer\\lib\\utils\\isObject.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _crossFade = _interopRequireDefault(require(_dependencyMap[1], "inline-style-prefixer/lib/plugins/crossFade"));
  var _imageSet = _interopRequireDefault(require(_dependencyMap[2], "inline-style-prefixer/lib/plugins/imageSet"));
  var _logical = _interopRequireDefault(require(_dependencyMap[3], "inline-style-prefixer/lib/plugins/logical"));
  var _position = _interopRequireDefault(require(_dependencyMap[4], "inline-style-prefixer/lib/plugins/position"));
  var _sizing = _interopRequireDefault(require(_dependencyMap[5], "inline-style-prefixer/lib/plugins/sizing"));
  var _transition = _interopRequireDefault(require(_dependencyMap[6], "inline-style-prefixer/lib/plugins/transition"));
  var w = ['Webkit'];
  var m = ['Moz'];
  var wm = ['Webkit', 'Moz'];
  var wms = ['Webkit', 'ms'];
  var wmms = ['Webkit', 'Moz', 'ms'];
  var _default = exports.default = {
    plugins: [_crossFade.default, _imageSet.default, _logical.default, _position.default, _sizing.default, _transition.default],
    prefixMap: {
      appearance: wmms,
      userSelect: wm,
      textEmphasisPosition: wms,
      textEmphasis: wms,
      textEmphasisStyle: wms,
      textEmphasisColor: wms,
      boxDecorationBreak: wms,
      clipPath: w,
      maskImage: wms,
      maskMode: wms,
      maskRepeat: wms,
      maskPosition: wms,
      maskClip: wms,
      maskOrigin: wms,
      maskSize: wms,
      maskComposite: wms,
      mask: wms,
      maskBorderSource: wms,
      maskBorderMode: wms,
      maskBorderSlice: wms,
      maskBorderWidth: wms,
      maskBorderOutset: wms,
      maskBorderRepeat: wms,
      maskBorder: wms,
      maskType: wms,
      textDecorationStyle: w,
      textDecorationSkip: w,
      textDecorationLine: w,
      textDecorationColor: w,
      filter: w,
      breakAfter: w,
      breakBefore: w,
      breakInside: w,
      columnCount: w,
      columnFill: w,
      columnGap: w,
      columnRule: w,
      columnRuleColor: w,
      columnRuleStyle: w,
      columnRuleWidth: w,
      columns: w,
      columnSpan: w,
      columnWidth: w,
      backdropFilter: w,
      hyphens: w,
      flowInto: w,
      flowFrom: w,
      regionFragment: w,
      textOrientation: w,
      tabSize: m,
      fontKerning: w,
      textSizeAdjust: w
    }
  };
},49,[17,50,65,66,67,68,69],"node_modules\\react-native-web\\dist\\modules\\prefixStyles\\static.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade;
  var _cssInJsUtils = require(_dependencyMap[0], "css-in-js-utils");
  var CROSS_FADE_REGEX = /cross-fade\(/g;
  // http://caniuse.com/#search=cross-fade
  var prefixes = ['-webkit-', ''];
  function crossFade(property, value) {
    if (typeof value === 'string' && !(0, _cssInJsUtils.isPrefixedValue)(value) && value.indexOf('cross-fade(') !== -1) {
      return prefixes.map(function (prefix) {
        return value.replace(CROSS_FADE_REGEX, prefix + 'cross-fade(');
      });
    }
  }
},50,[874],"node_modules\\inline-style-prefixer\\lib\\plugins\\crossFade.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = hyphenateProperty;
  var _hyphenateStyleName = require(_dependencyMap[0], "hyphenate-style-name");
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2["default"])(property);
  }
},55,[879],"node_modules\\css-in-js-utils\\lib\\hyphenateProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isPrefixedValue;
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},59,[],"node_modules\\css-in-js-utils\\lib\\isPrefixedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet;
  var _isPrefixedValue = require(_dependencyMap[0], "css-in-js-utils/lib/isPrefixedValue");
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  // http://caniuse.com/#feat=css-image-set
  var prefixes = ['-webkit-', ''];
  function imageSet(property, value) {
    if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('image-set(') > -1) {
      return prefixes.map(function (prefix) {
        return value.replace(/image-set\(/g, prefix + 'image-set(');
      });
    }
  }
},65,[59],"node_modules\\inline-style-prefixer\\lib\\plugins\\imageSet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = logical;
  var alternativeProps = {
    marginBlockStart: ['WebkitMarginBefore'],
    marginBlockEnd: ['WebkitMarginAfter'],
    marginInlineStart: ['WebkitMarginStart', 'MozMarginStart'],
    marginInlineEnd: ['WebkitMarginEnd', 'MozMarginEnd'],
    paddingBlockStart: ['WebkitPaddingBefore'],
    paddingBlockEnd: ['WebkitPaddingAfter'],
    paddingInlineStart: ['WebkitPaddingStart', 'MozPaddingStart'],
    paddingInlineEnd: ['WebkitPaddingEnd', 'MozPaddingEnd'],
    borderBlockStart: ['WebkitBorderBefore'],
    borderBlockStartColor: ['WebkitBorderBeforeColor'],
    borderBlockStartStyle: ['WebkitBorderBeforeStyle'],
    borderBlockStartWidth: ['WebkitBorderBeforeWidth'],
    borderBlockEnd: ['WebkitBorderAfter'],
    borderBlockEndColor: ['WebkitBorderAfterColor'],
    borderBlockEndStyle: ['WebkitBorderAfterStyle'],
    borderBlockEndWidth: ['WebkitBorderAfterWidth'],
    borderInlineStart: ['WebkitBorderStart', 'MozBorderStart'],
    borderInlineStartColor: ['WebkitBorderStartColor', 'MozBorderStartColor'],
    borderInlineStartStyle: ['WebkitBorderStartStyle', 'MozBorderStartStyle'],
    borderInlineStartWidth: ['WebkitBorderStartWidth', 'MozBorderStartWidth'],
    borderInlineEnd: ['WebkitBorderEnd', 'MozBorderEnd'],
    borderInlineEndColor: ['WebkitBorderEndColor', 'MozBorderEndColor'],
    borderInlineEndStyle: ['WebkitBorderEndStyle', 'MozBorderEndStyle'],
    borderInlineEndWidth: ['WebkitBorderEndWidth', 'MozBorderEndWidth']
  };
  function logical(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps, property)) {
      var alternativePropList = alternativeProps[property];
      for (var i = 0, len = alternativePropList.length; i < len; ++i) {
        style[alternativePropList[i]] = value;
      }
    }
  }
},66,[],"node_modules\\inline-style-prefixer\\lib\\plugins\\logical.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position;
  function position(property, value) {
    if (property === 'position' && value === 'sticky') {
      return ['-webkit-sticky', 'sticky'];
    }
  }
},67,[],"node_modules\\inline-style-prefixer\\lib\\plugins\\position.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing;
  var prefixes = ['-webkit-', '-moz-', ''];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values = {
    'min-content': true,
    'max-content': true,
    'fill-available': true,
    'fit-content': true,
    'contain-floats': true
  };
  function sizing(property, value) {
    if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
      return prefixes.map(function (prefix) {
        return prefix + value;
      });
    }
  }
},68,[],"node_modules\\inline-style-prefixer\\lib\\plugins\\sizing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition;
  var _hyphenateProperty = require(_dependencyMap[0], "css-in-js-utils/lib/hyphenateProperty");
  var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
  var _isPrefixedValue = require(_dependencyMap[1], "css-in-js-utils/lib/isPrefixedValue");
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  var _capitalizeString = require(_dependencyMap[2], "../utils/capitalizeString");
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: '-webkit-',
    Moz: '-moz-',
    ms: '-ms-'
  };
  function prefixValue(value, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value)) {
      return value;
    }

    // only split multi values, not cubic beziers
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
          var prefixes = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
            // join all prefixes and create a new value
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values.join(',');
    }
    return multipleValues.join(',');
  }
  function transition(property, value, style, propertyPrefixMap) {
    // also check for already prefixed transitions
    if (typeof value === 'string' && properties.hasOwnProperty(property)) {
      var outputValue = prefixValue(value, propertyPrefixMap);
      // if the property is already prefixed
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-moz-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Webkit') > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Moz') > -1) {
        return mozOutput;
      }
      style['Webkit' + (0, _capitalizeString2.default)(property)] = webkitOutput;
      style['Moz' + (0, _capitalizeString2.default)(property)] = mozOutput;
      return outputValue;
    }
  }
},69,[55,59,45],"node_modules\\inline-style-prefixer\\lib\\plugins\\transition.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSheet = createSheet;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../../../modules/canUseDom"));
  var _createCSSStyleSheet = _interopRequireDefault(require(_dependencyMap[2], "./createCSSStyleSheet"));
  var _createOrderedCSSStyleSheet = _interopRequireDefault(require(_dependencyMap[3], "./createOrderedCSSStyleSheet"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultId = 'react-native-stylesheet';
  var roots = new WeakMap();
  var sheets = [];
  var initialRules = [
  // minimal top-level reset
  'html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0);}', 'body{margin:0;}',
  // minimal form pseudo-element reset
  'button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}', 'input::-webkit-search-cancel-button,input::-webkit-search-decoration,input::-webkit-search-results-button,input::-webkit-search-results-decoration{display:none;}'];
  function createSheet(root, id) {
    if (id === void 0) {
      id = defaultId;
    }
    var sheet;
    if (_canUseDom.default) {
      var rootNode = root != null ? root.getRootNode() : document;
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        roots.set(rootNode, sheets.length);
        sheets.push(sheet);
      } else {
        var index = roots.get(rootNode);
        if (index == null) {
          var initialSheet = sheets[0];
          // If we're creating a new sheet, populate it with existing styles
          var textContent = initialSheet != null ? initialSheet.getTextContent() : '';
          // Cast rootNode to 'any' because Flow types for getRootNode are wrong
          sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id, rootNode, textContent));
          roots.set(rootNode, sheets.length);
          sheets.push(sheet);
        } else {
          sheet = sheets[index];
        }
      }
    } else {
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        sheets.push(sheet);
      } else {
        sheet = sheets[0];
      }
    }
    return {
      getTextContent() {
        return sheet.getTextContent();
      },
      id,
      insert(cssText, groupValue) {
        sheets.forEach(s => {
          s.insert(cssText, groupValue);
        });
      }
    };
  }
},70,[17,39,71,72],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\dom\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createCSSStyleSheet;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../../../modules/canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // $FlowFixMe: HTMLStyleElement is incorrectly typed - https://github.com/facebook/flow/issues/2696
  function createCSSStyleSheet(id, rootNode, textContent) {
    if (_canUseDom.default) {
      var root = rootNode != null ? rootNode : document;
      var element = root.getElementById(id);
      if (element == null) {
        element = document.createElement('style');
        element.setAttribute('id', id);
        if (typeof textContent === 'string') {
          element.appendChild(document.createTextNode(textContent));
        }
        if (root instanceof ShadowRoot) {
          root.insertBefore(element, root.firstChild);
        } else {
          var head = root.head;
          if (head) {
            head.insertBefore(element, head.firstChild);
          }
        }
      }
      // $FlowFixMe: HTMLElement is incorrectly typed
      return element.sheet;
    } else {
      return null;
    }
  }
},71,[17,39],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\dom\\createCSSStyleSheet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createOrderedCSSStyleSheet;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var slice = Array.prototype.slice;

  /**
   * Order-based insertion of CSS.
   *
   * Each rule is associated with a numerically defined group.
   * Groups are ordered within the style sheet according to their number, with the
   * lowest first.
   *
   * Groups are implemented using marker rules. The selector of the first rule of
   * each group is used only to encode the group number for hydration. An
   * alternative implementation could rely on CSSMediaRule, allowing groups to be
   * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
   * broken.
   * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
   * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
   */
  function createOrderedCSSStyleSheet(sheet) {
    var groups = {};
    var selectors = {};

    /**
     * Hydrate approximate record from any existing rules in the sheet.
     */
    if (sheet != null) {
      var group;
      slice.call(sheet.cssRules).forEach((cssRule, i) => {
        var cssText = cssRule.cssText;
        // Create record of existing selectors and rules
        if (cssText.indexOf('stylesheet-group') > -1) {
          group = decodeGroupRule(cssRule);
          groups[group] = {
            start: i,
            rules: [cssText]
          };
        } else {
          var selectorText = getSelectorText(cssText);
          if (selectorText != null) {
            selectors[selectorText] = true;
            groups[group].rules.push(cssText);
          }
        }
      });
    }
    function sheetInsert(sheet, group, text) {
      var orderedGroups = getOrderedGroups(groups);
      var groupIndex = orderedGroups.indexOf(group);
      var nextGroupIndex = groupIndex + 1;
      var nextGroup = orderedGroups[nextGroupIndex];
      // Insert rule before the next group, or at the end of the stylesheet
      var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;
      var isInserted = insertRuleAt(sheet, text, position);
      if (isInserted) {
        // Set the starting index of the new group
        if (groups[group].start == null) {
          groups[group].start = position;
        }
        // Increment the starting index of all subsequent groups
        for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
          var groupNumber = orderedGroups[i];
          var previousStart = groups[groupNumber].start || 0;
          groups[groupNumber].start = previousStart + 1;
        }
      }
      return isInserted;
    }
    var OrderedCSSStyleSheet = {
      /**
       * The textContent of the style sheet.
       */
      getTextContent() {
        return getOrderedGroups(groups).map(group => {
          var rules = groups[group].rules;
          // Sorting provides deterministic order of styles in group for
          // build-time extraction of the style sheet.
          var marker = rules.shift();
          rules.sort();
          rules.unshift(marker);
          return rules.join('\n');
        }).join('\n');
      },
      /**
       * Insert a rule into the style sheet
       */
      insert(cssText, groupValue) {
        var group = Number(groupValue);

        // Create a new group.
        if (groups[group] == null) {
          var markerRule = encodeGroupRule(group);
          // Create the internal record.
          groups[group] = {
            start: null,
            rules: [markerRule]
          };
          // Update CSSOM.
          if (sheet != null) {
            sheetInsert(sheet, group, markerRule);
          }
        }

        // selectorText is more reliable than cssText for insertion checks. The
        // browser excludes vendor-prefixed properties and rewrites certain values
        // making cssText more likely to be different from what was inserted.
        var selectorText = getSelectorText(cssText);
        if (selectorText != null && selectors[selectorText] == null) {
          // Update the internal records.
          selectors[selectorText] = true;
          groups[group].rules.push(cssText);
          // Update CSSOM.
          if (sheet != null) {
            var isInserted = sheetInsert(sheet, group, cssText);
            if (!isInserted) {
              // Revert internal record change if a rule was rejected (e.g.,
              // unrecognized pseudo-selector)
              groups[group].rules.pop();
            }
          }
        }
      }
    };
    return OrderedCSSStyleSheet;
  }

  /**
   * Helper functions
   */

  function encodeGroupRule(group) {
    return "[stylesheet-group=\"" + group + "\"]{}";
  }
  var groupPattern = /["']/g;
  function decodeGroupRule(cssRule) {
    return Number(cssRule.selectorText.split(groupPattern)[1]);
  }
  function getOrderedGroups(obj) {
    return Object.keys(obj).map(Number).sort((a, b) => a > b ? 1 : -1);
  }
  var selectorPattern = /\s*([,])\s*/g;
  function getSelectorText(cssText) {
    var selector = cssText.split('{')[0].trim();
    return selector !== '' ? selector.replace(selectorPattern, '$1') : null;
  }
  function insertRuleAt(root, cssText, position) {
    try {
      // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.
      root.insertRule(cssText, position);
      return true;
    } catch (e) {
      // JSDOM doesn't support `CSSSMediaRule#insertRule`.
      // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
      return false;
    }
  }
},72,[],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\dom\\createOrderedCSSStyleSheet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  module.exports = require(_dependencyMap[0], "./dist/transform-localize-style");
},73,[74],"node_modules\\styleq\\transform-localize-style.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.localizeStyle = localizeStyle;
  var cache = new WeakMap();
  var markerProp = '$$css$localize';
  /**
   * The compiler polyfills logical properties and values, generating a class
   * name for both writing directions. The style objects are annotated by
   * the compiler as needing this runtime transform. The results are memoized.
   *
   * { '$$css$localize': true, float: [ 'float-left', 'float-right' ] }
   * => { float: 'float-left' }
   */

  function compileStyle(style, isRTL) {
    // Create a new compiled style for styleq
    var compiledStyle = {};
    for (var prop in style) {
      if (prop !== markerProp) {
        var value = style[prop];
        if (Array.isArray(value)) {
          compiledStyle[prop] = isRTL ? value[1] : value[0];
        } else {
          compiledStyle[prop] = value;
        }
      }
    }
    return compiledStyle;
  }
  function localizeStyle(style, isRTL) {
    if (style[markerProp] != null) {
      var compiledStyleIndex = isRTL ? 1 : 0; // Check the cache in case we've already seen this object

      if (cache.has(style)) {
        var _cachedStyles = cache.get(style);
        var _compiledStyle = _cachedStyles[compiledStyleIndex];
        if (_compiledStyle == null) {
          // Update the missing cache entry
          _compiledStyle = compileStyle(style, isRTL);
          _cachedStyles[compiledStyleIndex] = _compiledStyle;
          cache.set(style, _cachedStyles);
        }
        return _compiledStyle;
      } // Create a new compiled style for styleq

      var compiledStyle = compileStyle(style, isRTL);
      var cachedStyles = new Array(2);
      cachedStyles[compiledStyleIndex] = compiledStyle;
      cache.set(style, cachedStyles);
      return compiledStyle;
    }
    return style;
  }
},74,[],"node_modules\\styleq\\dist\\transform-localize-style.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.preprocess = exports.default = exports.createTransformValue = exports.createTransformOriginValue = exports.createTextShadowValue = exports.createBoxShadowValue = exports.createBoxShadowArrayValue = void 0;
  var _normalizeColor = _interopRequireDefault(require(_dependencyMap[1], "./compiler/normalizeColor"));
  var _normalizeValueWithProperty = _interopRequireDefault(require(_dependencyMap[2], "./compiler/normalizeValueWithProperty"));
  var _warnOnce = require(_dependencyMap[3], "../../modules/warnOnce");
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Shadows
   */

  var defaultOffset = {
    height: 0,
    width: 0
  };
  var createBoxShadowValue = style => {
    var shadowColor = style.shadowColor,
      shadowOffset = style.shadowOffset,
      shadowOpacity = style.shadowOpacity,
      shadowRadius = style.shadowRadius;
    var _ref = shadowOffset || defaultOffset,
      height = _ref.height,
      width = _ref.width;
    var offsetX = (0, _normalizeValueWithProperty.default)(width);
    var offsetY = (0, _normalizeValueWithProperty.default)(height);
    var blurRadius = (0, _normalizeValueWithProperty.default)(shadowRadius || 0);
    var color = (0, _normalizeColor.default)(shadowColor || 'black', shadowOpacity);
    if (color != null && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };
  exports.createBoxShadowValue = createBoxShadowValue;
  var createTextShadowValue = style => {
    var textShadowColor = style.textShadowColor,
      textShadowOffset = style.textShadowOffset,
      textShadowRadius = style.textShadowRadius;
    var _ref2 = textShadowOffset || defaultOffset,
      height = _ref2.height,
      width = _ref2.width;
    var radius = textShadowRadius || 0;
    var offsetX = (0, _normalizeValueWithProperty.default)(width);
    var offsetY = (0, _normalizeValueWithProperty.default)(height);
    var blurRadius = (0, _normalizeValueWithProperty.default)(radius);
    var color = (0, _normalizeValueWithProperty.default)(textShadowColor, 'textShadowColor');
    if (color && (height !== 0 || width !== 0 || radius !== 0) && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };

  // { offsetX: 1, offsetY: 2, blurRadius: 3, spreadDistance: 4, color: 'rgba(255, 0, 0)', inset: true }
  // => 'rgba(255, 0, 0) 1px 2px 3px 4px inset'
  exports.createTextShadowValue = createTextShadowValue;
  var mapBoxShadow = boxShadow => {
    if (typeof boxShadow === 'string') {
      return boxShadow;
    }
    var offsetX = (0, _normalizeValueWithProperty.default)(boxShadow.offsetX) || 0;
    var offsetY = (0, _normalizeValueWithProperty.default)(boxShadow.offsetY) || 0;
    var blurRadius = (0, _normalizeValueWithProperty.default)(boxShadow.blurRadius) || 0;
    var spreadDistance = (0, _normalizeValueWithProperty.default)(boxShadow.spreadDistance) || 0;
    var color = (0, _normalizeColor.default)(boxShadow.color) || 'black';
    var position = boxShadow.inset ? 'inset ' : '';
    return "" + position + offsetX + " " + offsetY + " " + blurRadius + " " + spreadDistance + " " + color;
  };
  var createBoxShadowArrayValue = value => {
    return value.map(mapBoxShadow).join(', ');
  };

  // { scale: 2 } => 'scale(2)'
  // { translateX: 20 } => 'translateX(20px)'
  // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
  exports.createBoxShadowArrayValue = createBoxShadowArrayValue;
  var mapTransform = transform => {
    var type = Object.keys(transform)[0];
    var value = transform[type];
    if (type === 'matrix' || type === 'matrix3d') {
      return type + "(" + value.join(',') + ")";
    } else {
      var normalizedValue = (0, _normalizeValueWithProperty.default)(value, type);
      return type + "(" + normalizedValue + ")";
    }
  };
  var createTransformValue = value => {
    return value.map(mapTransform).join(' ');
  };

  // [2, '30%', 10] => '2px 30% 10px'
  exports.createTransformValue = createTransformValue;
  var createTransformOriginValue = value => {
    return value.map(v => (0, _normalizeValueWithProperty.default)(v)).join(' ');
  };
  exports.createTransformOriginValue = createTransformOriginValue;
  var PROPERTIES_STANDARD = {
    borderBottomEndRadius: 'borderEndEndRadius',
    borderBottomStartRadius: 'borderEndStartRadius',
    borderTopEndRadius: 'borderStartEndRadius',
    borderTopStartRadius: 'borderStartStartRadius',
    borderEndColor: 'borderInlineEndColor',
    borderEndStyle: 'borderInlineEndStyle',
    borderEndWidth: 'borderInlineEndWidth',
    borderStartColor: 'borderInlineStartColor',
    borderStartStyle: 'borderInlineStartStyle',
    borderStartWidth: 'borderInlineStartWidth',
    end: 'insetInlineEnd',
    marginEnd: 'marginInlineEnd',
    marginHorizontal: 'marginInline',
    marginStart: 'marginInlineStart',
    marginVertical: 'marginBlock',
    paddingEnd: 'paddingInlineEnd',
    paddingHorizontal: 'paddingInline',
    paddingStart: 'paddingInlineStart',
    paddingVertical: 'paddingBlock',
    start: 'insetInlineStart'
  };
  var ignoredProps = {
    elevation: true,
    overlayColor: true,
    resizeMode: true,
    tintColor: true
  };

  /**
   * Preprocess styles
   */
  var preprocess = exports.preprocess = function preprocess(originalStyle, options) {
    if (options === void 0) {
      options = {};
    }
    var style = originalStyle || emptyObject;
    var nextStyle = {};

    // Convert shadow styles
    if (options.shadow === true, style.shadowColor != null || style.shadowOffset != null || style.shadowOpacity != null || style.shadowRadius != null) {
      (0, _warnOnce.warnOnce)('shadowStyles', "\"shadow*\" style props are deprecated. Use \"boxShadow\".");
      var boxShadowValue = createBoxShadowValue(style);
      if (boxShadowValue != null) {
        nextStyle.boxShadow = boxShadowValue;
      }
    }

    // Convert text shadow styles
    if (options.textShadow === true, style.textShadowColor != null || style.textShadowOffset != null || style.textShadowRadius != null) {
      (0, _warnOnce.warnOnce)('textShadowStyles', "\"textShadow*\" style props are deprecated. Use \"textShadow\".");
      var textShadowValue = createTextShadowValue(style);
      if (textShadowValue != null && nextStyle.textShadow == null) {
        var textShadow = style.textShadow;
        var value = textShadow ? textShadow + ", " + textShadowValue : textShadowValue;
        nextStyle.textShadow = value;
      }
    }
    for (var originalProp in style) {
      if (
      // Ignore some React Native styles
      ignoredProps[originalProp] != null || originalProp === 'shadowColor' || originalProp === 'shadowOffset' || originalProp === 'shadowOpacity' || originalProp === 'shadowRadius' || originalProp === 'textShadowColor' || originalProp === 'textShadowOffset' || originalProp === 'textShadowRadius') {
        continue;
      }
      var originalValue = style[originalProp];
      var prop = PROPERTIES_STANDARD[originalProp] || originalProp;
      var _value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || prop !== originalProp && style[prop] != null) {
        continue;
      }
      if (prop === 'aspectRatio' && typeof _value === 'number') {
        nextStyle[prop] = _value.toString();
      } else if (prop === 'boxShadow') {
        if (Array.isArray(_value)) {
          _value = createBoxShadowArrayValue(_value);
        }
        var boxShadow = nextStyle.boxShadow;
        nextStyle.boxShadow = boxShadow ? _value + ", " + boxShadow : _value;
      } else if (prop === 'fontVariant') {
        if (Array.isArray(_value) && _value.length > 0) {
          /*
          warnOnce(
            'fontVariant',
            '"fontVariant" style array value is deprecated. Use space-separated values.'
          );
          */
          _value = _value.join(' ');
        }
        nextStyle[prop] = _value;
      } else if (prop === 'textAlignVertical') {
        /*
        warnOnce(
          'textAlignVertical',
          '"textAlignVertical" style is deprecated. Use "verticalAlign".'
        );
        */
        if (style.verticalAlign == null) {
          nextStyle.verticalAlign = _value === 'center' ? 'middle' : _value;
        }
      } else if (prop === 'transform') {
        if (Array.isArray(_value)) {
          _value = createTransformValue(_value);
        }
        nextStyle.transform = _value;
      } else if (prop === 'transformOrigin') {
        if (Array.isArray(_value)) {
          _value = createTransformOriginValue(_value);
        }
        nextStyle.transformOrigin = _value;
      } else {
        nextStyle[prop] = _value;
      }
    }

    // $FlowIgnore
    return nextStyle;
  };
  var _default = exports.default = preprocess;
},75,[17,35,33,76],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\preprocess.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.warnOnce = warnOnce;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var warnedKeys = {};

  /**
   * A simple function that prints a warning message once per session.
   *
   * @param {string} key - The key used to ensure the message is printed once.
   *                       This should be unique to the callsite.
   * @param {string} message - The message to print
   */
  function warnOnce(key, message) {
    if (process.env.NODE_ENV !== 'production') {
      if (warnedKeys[key]) {
        return;
      }
      console.warn(message);
      warnedKeys[key] = true;
    }
  }
},76,[],"node_modules\\react-native-web\\dist\\modules\\warnOnce\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.styleq = void 0;
  var cache = new WeakMap();
  var compiledKey = '$$css';
  function createStyleq(options) {
    var disableCache;
    var disableMix;
    var transform;
    if (options != null) {
      disableCache = options.disableCache === true;
      disableMix = options.disableMix === true;
      transform = options.transform;
    }
    return function styleq() {
      // Keep track of property commits to the className
      var definedProperties = []; // The className and inline style to build up

      var className = '';
      var inlineStyle = null; // The current position in the cache graph

      var nextCache = disableCache ? null : cache; // This way of creating an array from arguments is fastest

      var styles = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) {
        styles[i] = arguments[i];
      } // Iterate over styles from last to first

      while (styles.length > 0) {
        var possibleStyle = styles.pop(); // Skip empty items

        if (possibleStyle == null || possibleStyle === false) {
          continue;
        } // Push nested styles back onto the stack to be processed

        if (Array.isArray(possibleStyle)) {
          for (var _i = 0; _i < possibleStyle.length; _i++) {
            styles.push(possibleStyle[_i]);
          }
          continue;
        } // Process an individual style object

        var style = transform != null ? transform(possibleStyle) : possibleStyle;
        if (style.$$css) {
          // Build up the class names defined by this object
          var classNameChunk = ''; // Check the cache to see if we've already done this work

          if (nextCache != null && nextCache.has(style)) {
            // Cache: read
            var cacheEntry = nextCache.get(style);
            if (cacheEntry != null) {
              classNameChunk = cacheEntry[0]; // $FlowIgnore

              definedProperties.push.apply(definedProperties, cacheEntry[1]);
              nextCache = cacheEntry[2];
            }
          } // Update the chunks with data from this object
          else {
            // The properties defined by this object
            var definedPropertiesChunk = [];
            for (var prop in style) {
              var value = style[prop];
              if (prop === compiledKey) continue; // Each property value is used as an HTML class name
              // { 'debug.string': 'debug.string', opacity: 's-jskmnoqp' }

              if (typeof value === 'string' || value === null) {
                // Only add to chunks if this property hasn't already been seen
                if (!definedProperties.includes(prop)) {
                  definedProperties.push(prop);
                  if (nextCache != null) {
                    definedPropertiesChunk.push(prop);
                  }
                  if (typeof value === 'string') {
                    classNameChunk += classNameChunk ? ' ' + value : value;
                  }
                }
              } // If we encounter a value that isn't a string or `null`
              else {
                console.error("styleq: ".concat(prop, " typeof ").concat(String(value), " is not \"string\" or \"null\"."));
              }
            } // Cache: write

            if (nextCache != null) {
              // Create the next WeakMap for this sequence of styles
              var weakMap = new WeakMap();
              nextCache.set(style, [classNameChunk, definedPropertiesChunk, weakMap]);
              nextCache = weakMap;
            }
          } // Order of classes in chunks matches property-iteration order of style
          // object. Order of chunks matches passed order of styles from first to
          // last (which we iterate over in reverse).

          if (classNameChunk) {
            className = className ? classNameChunk + ' ' + className : classNameChunk;
          }
        } // ----- DYNAMIC: Process inline style object -----
        else {
          if (disableMix) {
            if (inlineStyle == null) {
              inlineStyle = {};
            }
            inlineStyle = Object.assign({}, style, inlineStyle);
          } else {
            var subStyle = null;
            for (var _prop in style) {
              var _value = style[_prop];
              if (_value !== undefined) {
                if (!definedProperties.includes(_prop)) {
                  if (_value != null) {
                    if (inlineStyle == null) {
                      inlineStyle = {};
                    }
                    if (subStyle == null) {
                      subStyle = {};
                    }
                    subStyle[_prop] = _value;
                  }
                  definedProperties.push(_prop); // Cache is unnecessary overhead if results can't be reused.

                  nextCache = null;
                }
              }
            }
            if (subStyle != null) {
              inlineStyle = Object.assign(subStyle, inlineStyle);
            }
          }
        }
      }
      var styleProps = [className, inlineStyle];
      return styleProps;
    };
  }
  var styleq = createStyleq();
  exports.styleq = styleq;
  styleq.factory = createStyleq;
},78,[],"node_modules\\styleq\\dist\\styleq.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validate = validate;
  var _postcssValueParser = _interopRequireDefault(require(_dependencyMap[1], "postcss-value-parser"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var invalidShortforms = {
    background: true,
    borderBottom: true,
    borderLeft: true,
    borderRight: true,
    borderTop: true,
    font: true,
    grid: true,
    outline: true,
    textDecoration: true
  };
  var invalidMultiValueShortforms = {
    flex: true,
    margin: true,
    padding: true,
    borderColor: true,
    borderRadius: true,
    borderStyle: true,
    borderWidth: true,
    inset: true,
    insetBlock: true,
    insetInline: true,
    marginBlock: true,
    marginInline: true,
    marginHorizontal: true,
    marginVertical: true,
    paddingBlock: true,
    paddingInline: true,
    paddingHorizontal: true,
    paddingVertical: true,
    overflow: true,
    overscrollBehavior: true,
    backgroundPosition: true
  };
  function error(message) {
    console.error(message);
  }
  function validate(obj) {
    for (var k in obj) {
      var prop = k.trim();
      var value = obj[prop];
      var isInvalid = false;
      if (value === null) {
        continue;
      }
      if (typeof value === 'string' && value.indexOf('!important') > -1) {
        error("Invalid style declaration \"" + prop + ":" + value + "\". Values cannot include \"!important\"");
        isInvalid = true;
      } else {
        var suggestion = '';
        if (prop === 'animation' || prop === 'animationName') {
          suggestion = 'Did you mean "animationKeyframes"?';
          isInvalid = true;
        } else if (prop === 'direction') {
          suggestion = 'Did you mean "writingDirection"?';
          isInvalid = true;
        } else if (invalidShortforms[prop]) {
          suggestion = 'Please use long-form properties.';
          isInvalid = true;
        } else if (invalidMultiValueShortforms[prop]) {
          if (typeof value === 'string' && (0, _postcssValueParser.default)(value).nodes.length > 1) {
            suggestion = "Value is \"" + value + "\" but only single values are supported.";
            isInvalid = true;
          }
        }
        if (suggestion !== '') {
          error("Invalid style property of \"" + prop + "\". " + suggestion);
        }
      }
      if (isInvalid) {
        delete obj[k];
      }
    }
  }
},79,[17,80],"node_modules\\react-native-web\\dist\\exports\\StyleSheet\\validate.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var parse = require(_dependencyMap[0], "./parse");
  var walk = require(_dependencyMap[1], "./walk");
  var stringify = require(_dependencyMap[2], "./stringify");
  function ValueParser(value) {
    if (this instanceof ValueParser) {
      this.nodes = parse(value);
      return this;
    }
    return new ValueParser(value);
  }
  ValueParser.prototype.toString = function () {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
  };
  ValueParser.prototype.walk = function (cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
  };
  ValueParser.unit = require(_dependencyMap[3], "./unit");
  ValueParser.walk = walk;
  ValueParser.stringify = stringify;
  module.exports = ValueParser;
},80,[81,82,83,84],"node_modules\\postcss-value-parser\\lib\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote = "'".charCodeAt(0);
  var doubleQuote = '"'.charCodeAt(0);
  var backslash = "\\".charCodeAt(0);
  var slash = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;
  module.exports = function (input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [{
      nodes: tokens
    }];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while (pos < max) {
      // Whitespaces
      if (code <= 32) {
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        token = value.slice(pos, next);
        prev = tokens[tokens.length - 1];
        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
          prev.sourceEndIndex += token.length;
        } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;

        // Quotes
      } else if (code === singleQuote || code === doubleQuote) {
        next = pos;
        quote = code === singleQuote ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote: quote
        };
        do {
          escape = false;
          next = value.indexOf(quote, next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += quote;
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        token.value = value.slice(pos + 1, next);
        token.sourceEndIndex = token.unclosed ? next : next + 1;
        tokens.push(token);
        pos = next + 1;
        code = value.charCodeAt(pos);

        // Comments
      } else if (code === slash && value.charCodeAt(pos + 1) === star) {
        next = value.indexOf("*/", pos);
        token = {
          type: "comment",
          sourceIndex: pos,
          sourceEndIndex: next + 2
        };
        if (next === -1) {
          token.unclosed = true;
          next = value.length;
          token.sourceEndIndex = next;
        }
        token.value = value.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value.charCodeAt(pos);

        // Operation within calc
      } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
        token = value[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token
        });
        pos += 1;
        code = value.charCodeAt(pos);

        // Dividers
      } else if (code === slash || code === comma || code === colon) {
        token = value[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token,
          before: before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value.charCodeAt(pos);

        // Open parentheses
      } else if (openParentheses === code) {
        // Whitespaces after open parentheses
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;
        if (name === "url" && code !== singleQuote && code !== doubleQuote) {
          next -= 1;
          do {
            escape = false;
            next = value.indexOf(")", next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += ")";
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          // Whitespaces before closed
          whitespacePos = next;
          do {
            whitespacePos -= 1;
            code = value.charCodeAt(whitespacePos);
          } while (code <= 32);
          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [{
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }];
            } else {
              token.nodes = [];
            }
            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                sourceEndIndex: next,
                value: value.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value.slice(whitespacePos + 1, next);
              token.sourceEndIndex = next;
            }
          } else {
            token.after = "";
            token.nodes = [];
          }
          pos = next + 1;
          token.sourceEndIndex = token.unclosed ? next : pos;
          code = value.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          token.sourceEndIndex = pos + 1;
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }
        name = "";

        // Close parentheses
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value.charCodeAt(pos);
        parent.after = after;
        parent.sourceEndIndex += after.length;
        after = "";
        balanced -= 1;
        stack[stack.length - 1].sourceEndIndex = pos;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes;

        // Words
      } else {
        next = pos;
        do {
          if (code === backslash) {
            next += 1;
          }
          next += 1;
          code = value.charCodeAt(next);
        } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
        token = value.slice(pos, next);
        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;
      }
    }
    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
      stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
  };
},81,[],"node_modules\\postcss-value-parser\\lib\\parse.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for (i = 0, max = nodes.length; i < max; i += 1) {
      node = nodes[i];
      if (!bubble) {
        result = cb(node, i, nodes);
      }
      if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
        walk(node.nodes, cb, bubble);
      }
      if (bubble) {
        cb(node, i, nodes);
      }
    }
  };
},82,[],"node_modules\\postcss-value-parser\\lib\\walk.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
      return customResult;
    } else if (type === "word" || type === "space") {
      return value;
    } else if (type === "string") {
      buf = node.quote || "";
      return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
      return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
      return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
      buf = stringify(node.nodes, custom);
      if (type !== "function") {
        return buf;
      }
      return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
  }
  function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
      result = "";
      for (i = nodes.length - 1; ~i; i -= 1) {
        result = stringifyNode(nodes[i], custom) + result;
      }
      return result;
    }
    return stringifyNode(nodes, custom);
  }
  module.exports = stringify;
},83,[],"node_modules\\postcss-value-parser\\lib\\stringify.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);

  // Check if three code points would start a number
  // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
  function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }

  // Consume a number
  // https://www.w3.org/TR/css-syntax-3/#consume-number
  module.exports = function (value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
      return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    };
  };
},84,[],"node_modules\\postcss-value-parser\\lib\\unit.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocaleProvider = LocaleProvider;
  exports.getLocaleDirection = getLocaleDirection;
  exports.useLocaleContext = useLocaleContext;
  var _react = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _isLocaleRTL = require(_dependencyMap[1], "./isLocaleRTL");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultLocale = {
    direction: 'ltr',
    locale: 'en-US'
  };
  var LocaleContext = /*#__PURE__*/(0, _react.createContext)(defaultLocale);
  function getLocaleDirection(locale) {
    return (0, _isLocaleRTL.isLocaleRTL)(locale) ? 'rtl' : 'ltr';
  }
  function LocaleProvider(props) {
    var direction = props.direction,
      locale = props.locale,
      children = props.children;
    var needsContext = direction || locale;
    return needsContext ? /*#__PURE__*/_react.default.createElement(LocaleContext.Provider, {
      children: children,
      value: {
        direction: locale ? getLocaleDirection(locale) : direction,
        locale
      }
    }) : children;
  }
  function useLocaleContext() {
    return (0, _react.useContext)(LocaleContext);
  }
},85,[3,86],"node_modules\\react-native-web\\dist\\modules\\useLocale\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isLocaleRTL = isLocaleRTL;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var rtlScripts = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
  var rtlLangs = new Set(['ae',
  // Avestan
  'ar',
  // Arabic
  'arc',
  // Aramaic
  'bcc',
  // Southern Balochi
  'bqi',
  // Bakthiari
  'ckb',
  // Sorani
  'dv',
  // Dhivehi
  'fa', 'far',
  // Persian
  'glk',
  // Gilaki
  'he', 'iw',
  // Hebrew
  'khw',
  // Khowar
  'ks',
  // Kashmiri
  'ku',
  // Kurdish
  'mzn',
  // Mazanderani
  'nqo',
  // N'Ko
  'pnb',
  // Western Punjabi
  'ps',
  // Pashto
  'sd',
  // Sindhi
  'ug',
  // Uyghur
  'ur',
  // Urdu
  'yi' // Yiddish
  ]);
  var cache = new Map();

  /**
   * Determine the writing direction of a locale
   */
  function isLocaleRTL(locale) {
    var cachedRTL = cache.get(locale);
    if (cachedRTL) {
      return cachedRTL;
    }
    var isRTL = false;
    // $FlowFixMe
    if (Intl.Locale) {
      try {
        // $FlowFixMe
        var script = new Intl.Locale(locale).maximize().script;
        isRTL = rtlScripts.has(script);
      } catch (_unused) {
        // RangeError: Incorrect locale information provided
        // Fallback to inferring from language
        var lang = locale.split('-')[0];
        isRTL = rtlLangs.has(lang);
      }
    } else {
      // Fallback to inferring from language
      var _lang = locale.split('-')[0];
      isRTL = rtlLangs.has(_lang);
    }
    cache.set(locale, isRTL);
    return isRTL;
  }
},86,[],"node_modules\\react-native-web\\dist\\modules\\useLocale\\isLocaleRTL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var findNodeHandle = component => {
    throw new Error('findNodeHandle is not supported on web. ' + 'Use the ref property on the component instead.');
  };
  var _default = exports.default = findNodeHandle;
},87,[],"node_modules\\react-native-web\\dist\\exports\\findNodeHandle\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = render;
  exports.hydrate = hydrate;
  var _client = require(_dependencyMap[0], "react-dom/client");
  var _dom = require(_dependencyMap[1], "../StyleSheet/dom");
  function hydrate(element, root) {
    (0, _dom.createSheet)(root);
    return (0, _client.hydrateRoot)(root, element);
  }
  function render(element, root) {
    (0, _dom.createSheet)(root);
    var reactRoot = (0, _client.createRoot)(root);
    reactRoot.render(element);
    return reactRoot;
  }
},88,[89,70],"node_modules\\react-native-web\\dist\\exports\\render\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      // This branch is unreachable because this function is only called
      // in production, but the condition is true only in development.
      // Therefore if the branch is still here, dead code elimination wasn't
      // properly applied.
      // Don't change the message. React DevTools relies on it. Also make sure
      // this message doesn't occur elsewhere in this function, or it will cause
      // a false positive.
      throw new Error('^_^');
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  if (process.env.NODE_ENV === 'production') {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0], "./cjs/react-dom-client.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-dom-client.development.js");
  }
},89,[4,90],"node_modules\\react-dom\\client.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /*
   Modernizr 3.0.0pre (Custom Build) | MIT
  */
  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState; null !== fiber && 0 < id;) fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length) return value;
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length) console.warn("copyWithRename() expects paths of the same length");else {
        for (var i = 0; i < newPath.length - 1; i++) if (oldPath[i] !== newPath[i]) {
          console.warn("copyWithRename() expects paths to be the same except for the deepest key");
          return;
        }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return !1;
    }
    function shouldErrorImpl() {
      return null;
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop$2() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function (value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
      if (null !== resolveFamily) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPassiveEffects();
        scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return (type.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" === typeof type) return type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (null != type) for (var i = type.length - 1; 0 <= i; i--) if ("string" === typeof type[i].name) return type[i].name;
          if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: assign({}, props, {
            value: prevLog
          }),
          info: assign({}, props, {
            value: prevInfo
          }),
          warn: assign({}, props, {
            value: prevWarn
          }),
          error: assign({}, props, {
            value: prevError
          }),
          group: assign({}, props, {
            value: prevGroup
          }),
          groupCollapsed: assign({}, props, {
            value: prevGroupCollapsed
          }),
          groupEnd: assign({}, props, {
            value: prevGroupEnd
          })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix) try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
          for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
          for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
            if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
              do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                "function" === typeof fn && componentFrameCache.set(fn, _frame);
                return _frame;
              } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
            }
            break;
          }
        }
      } finally {
        reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;
        case 11:
          return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;
        case 1:
          return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "";
        do {
          info += describeFiber(workInProgress);
          var debugInfo = workInProgress._debugInfo;
          if (debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) {
            var entry = debugInfo[i];
            if ("string" === typeof entry.name) {
              var JSCompiler_temp_const = info,
                env = entry.env;
              var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? " [" + env + "]" : ""));
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          }
          workInProgress = workInProgress.return;
        } while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (null === current) return null;
      var owner = current._debugOwner;
      return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      return null === current ? "" : getStackByFiberInDevAndProd(current);
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = fiber;
      try {
        return callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        current = previousFiber;
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return;) node = node.return;else {
        fiber = node;
        do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return; while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate;;) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB;) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return) a = parentA, b = parentB;else {
          for (var didFindChild = !1, _child = parentA.child; _child;) {
            if (_child === a) {
              didFindChild = !0;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child;) {
              if (_child === a) {
                didFindChild = !0;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node;) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    function createCursor(defaultValue) {
      return {
        current: defaultValue
      };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      null === c && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
          break;
        default:
          if (nextRootInstance = 8 === nextRootContext ? nextRootInstance.parentNode : nextRootInstance, nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);else switch (nextRootContext) {
            case "svg":
              nextRootInstance = HostContextNamespaceSvg;
              break;
            case "math":
              nextRootInstance = HostContextNamespaceMath;
              break;
            default:
              nextRootInstance = HostContextNamespaceNone;
          }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = {
        context: nextContext,
        ancestorInfo: type
      };
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
    }
    function typeName(value) {
      return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch (e) {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value)) return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
    }
    function injectInternals(internals) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) return !0;
      if (!hook.supportsFiber) return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), !0;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        console.error("React instrumentation encountered an error: %s.", err);
      }
      return hook.checkDCE ? !0 : !1;
    }
    function onCommitRoot$1(root, eventPriority) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
        var didError = 128 === (root.current.flags & 128);
        switch (eventPriority) {
          case DiscreteEventPriority:
            var schedulerPriority = ImmediatePriority;
            break;
          case ContinuousEventPriority:
            schedulerPriority = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            schedulerPriority = NormalPriority$1;
            break;
          case IdleEventPriority:
            schedulerPriority = IdlePriority;
            break;
          default:
            schedulerPriority = NormalPriority$1;
        }
        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
        injectedHook.setStrictMode(rendererID, newIsStrictMode);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    function getLabelForLane(lane) {
      if (lane & 1) return "SyncHydrationLane";
      if (lane & 2) return "Sync";
      if (lane & 4) return "InputContinuousHydration";
      if (lane & 8) return "InputContinuous";
      if (lane & 16) return "DefaultHydration";
      if (lane & 32) return "Default";
      if (lane & 64) return "TransitionHydration";
      if (lane & 4194176) return "Transition";
      if (lane & 62914560) return "Retry";
      if (lane & 67108864) return "SelectiveHydration";
      if (lane & 134217728) return "IdleHydration";
      if (lane & 268435456) return "Idle";
      if (lane & 536870912) return "Offscreen";
      if (lane & 1073741824) return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194176;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root, wipLanes) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes,
        warmLanes = root.warmLanes;
      root = 0 !== root.finishedLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
          return currentTime + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
    }
    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
        var index = 31 - clz32(remainingLanes),
          lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
          var update = hiddenUpdatesForLane[index];
          null !== update && (update.lane &= -536870913);
        }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = root.entangledLanes |= entangledLanes;
      for (root = root.entanglements; rootEntangledLanes;) {
        var index = 31 - clz32(rootEntangledLanes),
          lane = 1 << index;
        lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent) for (root = root.pendingUpdatersLaneMap; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        root[index].add(fiber);
        lanes &= ~lane;
      }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent) for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;) {
        var index = 31 - clz32(lanes);
        root = 1 << index;
        index = pendingUpdatersLaneMap[index];
        0 < index.size && (index.forEach(function (fiber) {
          var alternate = fiber.alternate;
          null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
        }), index.clear());
        lanes &= ~root;
      }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode;) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;) {
            if (parentNode = targetNode[internalInstanceKey]) return parentNode;
            targetNode = getParentSuspenseInstance(targetNode);
          }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources || (resources = root[internalRootNodeResourcesKey] = {
        hoistableStyles: new Map(),
        hoistableScripts: new Map()
      });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
      for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
      illegalAttributeNameCache[attributeName] = !0;
      console.error("Invalid attribute name: `%s`", attributeName);
      return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (!1 === expected) return expected;
          }
          return void 0 === expected ? void 0 : null;
        }
        node = node.getAttribute(name);
        if ("" === node && !0 === expected) return !0;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            node.removeAttribute(name);
            return;
          case "boolean":
            var prefix = name.toLowerCase().slice(0, 5);
            if ("data-" !== prefix && "aria-" !== prefix) {
              node.removeAttribute(name);
              return;
            }
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node) {
      var valueField = isCheckable(node) ? "checked" : "value",
        descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      checkFormFieldValueStringCoercion(node[valueField]);
      var currentValue = "" + node[valueField];
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: !0,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node) return !1;
      var tracker = node._valueTracker;
      if (!tracker) return !0;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      });
    }
    function validateInputProps(element, props) {
      void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0);
      void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue$1 = !0);
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
      if (null != value) {
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
        } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) return;
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
    }
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function (child) {
        null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
      }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
      null == props.selected || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = !0;
        for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = !0;
            setDefaultSelected && (node[i].defaultSelected = !0);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = !0);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0; element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (null != props[propName]) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
      }
      void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = !0);
    }
    function validateTextareaProps(element, props) {
      void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
      null != props.children && null == props.value && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
    }
    function findNotableNode(node, indent) {
      return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        case 11:
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        case 1:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + "\n";
      if ("string" === typeof serverProps) {
        for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function (m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
        case "object":
          if (null === value) return "null";
          if (isArrayImpl(value)) return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          var name = objectName(value);
          if ("Object" === name) {
            name = "";
            maxLength -= 2;
            for (var propName in value) if (value.hasOwnProperty(propName)) {
              var jsonPropName = JSON.stringify(propName);
              jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
              maxLength -= propName.length - 2;
              jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
              maxLength -= jsonPropName.length;
              if (0 > maxLength) {
                name += "" === name ? "..." : ", ...";
                break;
              }
              name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
            }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length,
        properties = [],
        propName;
      for (propName in props) if (props.hasOwnProperty(propName) && "children" !== propName) {
        var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
        remainingRowLength -= propName.length + propValue.length + 2;
        properties.push(propName + "=" + propValue);
      }
      return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "",
        remainingServerProperties = assign({}, serverObject),
        propName;
      for (propName in clientObject) if (clientObject.hasOwnProperty(propName)) {
        delete remainingServerProperties[propName];
        var maxLength = 120 - 2 * indent - propName.length - 2,
          clientPropValue = describeValue(clientObject[propName], maxLength);
        serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
      }
      for (var _propName in remainingServerProperties) remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + "\n");
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "",
        serverPropNames = new Map();
      for (propName$jscomp$0 in serverProps) serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (1 === serverPropNames.size && serverPropNames.has("children")) content += describeExpandedElement(type, clientProps, indentation(indent));else {
        for (var _propName2 in clientProps) if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
          var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1,
            serverPropName = serverPropNames.get(_propName2.toLowerCase());
          if (void 0 !== serverPropName) {
            serverPropNames.delete(_propName2.toLowerCase());
            var propName$jscomp$0 = clientProps[_propName2];
            serverPropName = serverProps[serverPropName];
            var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
            maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
            "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
          } else content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
        }
        serverPropNames.forEach(function (propName) {
          if ("children" !== propName) {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
          }
        });
        content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
        serverPropNames = "";
        if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (null === type) {
        type = "";
        for (fiber = fiber.child; fiber;) type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo) for (var i = 0; i < debugInfo.length; i++) {
        var serverComponentName = debugInfo[i].name;
        "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
      }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {
        debugInfo = indent;
        var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
          content = "";
        for (propName in i) if (i.hasOwnProperty(propName) && "children" !== propName) {
          var propValue = describePropValue(i[propName], 15);
          maxLength -= propName.length + propValue.length + 2;
          if (0 > maxLength) {
            content += " ...";
            break;
          }
          content += " " + propName + "=" + propValue;
        }
        debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
        indent++;
      } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : "string" === typeof node.serverProps ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0; i && serverComponentName < node.children.length;) maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
      i = node.serverTail;
      null === node.serverProps && indent--;
      for (node = 0; node < i.length; node++) serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return "\n\n" + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber;) fiber === ancestor && (distanceFromLeaf = 0), node = {
        fiber: fiber,
        children: null !== node ? [node] : [],
        serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      }, distanceFromLeaf++, fiber = fiber.return;
      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      oldInfo = assign({}, oldInfo || emptyAncestorInfoDev);
      var info = {
        tag: tag
      };
      -1 !== inScopeTags.indexOf(tag) && (oldInfo.aTagInScope = null, oldInfo.buttonTagInScope = null, oldInfo.nobrTagInScope = null);
      -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
      -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (oldInfo.listItemTagAutoclosing = null, oldInfo.dlItemTagAutoclosing = null);
      oldInfo.current = info;
      "form" === tag && (oldInfo.formTag = info);
      "a" === tag && (oldInfo.aTagInScope = info);
      "button" === tag && (oldInfo.buttonTagInScope = info);
      "nobr" === tag && (oldInfo.nobrTagInScope = info);
      "p" === tag && (oldInfo.pTagInButtonScope = info);
      "li" === tag && (oldInfo.listItemTagAutoclosing = info);
      if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
      "#document" === tag || "html" === tag ? oldInfo.containerTagInScope = null : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
      return oldInfo;
    }
    function isTagValidWithParent(tag, parentTag) {
      switch (parentTag) {
        case "select":
          return "hr" === tag || "option" === tag || "optgroup" === tag || "#text" === tag;
        case "optgroup":
          return "option" === tag || "#text" === tag;
        case "option":
          return "#text" === tag;
        case "tr":
          return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "tbody":
        case "thead":
        case "tfoot":
          return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "colgroup":
          return "col" === tag || "template" === tag;
        case "table":
          return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "head":
          return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "html":
          return "head" === tag || "body" === tag || "frameset" === tag;
        case "frameset":
          return "frame" === tag;
        case "#document":
          return "html" === tag;
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
        case "rp":
        case "rt":
          return -1 === impliedEndTags.indexOf(parentTag);
        case "body":
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "head":
        case "html":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return null == parentTag;
      }
      return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (; parent;) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName) return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo) return !0;
      ancestorInfo = ancestorInfo.tag;
      var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
      if (didWarn[warnKey]) return !1;
      didWarn[warnKey] = !0;
      var ancestor = (warnKey = current) ? findAncestor(warnKey.return, ancestorInfo) : null;
      warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, null) : "";
      ancestor = "<" + childTag + ">";
      parentInfo ? (parentInfo = "", "table" === ancestorInfo && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error("In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s", ancestor, ancestorInfo, parentInfo, warnKey)) : console.error("In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s", ancestor, ancestorInfo, warnKey);
      return !1;
    }
    function validateTextNesting(childText, parentTag) {
      if (isTagValidWithParent("#text", parentTag)) return !0;
      var warnKey = "#text|" + parentTag;
      if (didWarn[warnKey]) return !1;
      didWarn[warnKey] = !0;
      var ancestor = (warnKey = current) ? findAncestor(warnKey, parentTag) : null;
      warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, 6 !== warnKey.tag ? {
        children: null
      } : null) : "";
      /\S/.test(childText) ? console.error("In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s", parentTag, warnKey) : console.error("In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s", parentTag, warnKey);
      return !1;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function (_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, console.error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', styleName, value.replace(badStyleValueWithSemicolonPattern, ""))), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style[styleName] = ("" + value).trim()) : style[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      styles && Object.freeze(styles);
      node = node.style;
      if (null != prevStyles) {
        if (styles) {
          var expandedUpdates = {};
          if (prevStyles) for (var key in prevStyles) if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key)) for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++) expandedUpdates[longhands[i]] = key;
          for (var _key in styles) if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key])) for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++) expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles) for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++) _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates) if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
            key$jscomp$0[i] = !0;
            i = console;
            var value = styles[key];
            i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating", key, longhands);
          }
        }
        for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var _styleName in styles) _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
      } else for (expandedUpdates in styles) styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return !1;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
        if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return warnedProperties$1[name] = !0, !1;
        name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
      }
      return !0;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [],
        key;
      for (key in props) validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps.map(function (prop) {
        return "`" + prop + "`";
      }).join(", ");
      1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return !0;
      var lowerCasedName = name.toLowerCase();
      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
      if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
      if (null != eventRegistry) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
        if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
      } else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
      if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
      if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
      if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
      if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
      } else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              return warnedProperties[name] = !0;
          }
        case "function":
        case "symbol":
          return warnedProperties[name] = !0, !1;
        case "string":
          if ("false" === value || "true" === value) {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties[name] = !0;
          }
      }
      return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [],
        key;
      for (key in props) validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
      props = unknownProps.map(function (prop) {
        return "`" + prop + "`";
      }).join(", ");
      1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode;) props = props.parentNode;
              checkAttributeStringCoercion(internalInstance, "name");
              props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                  updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
        }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = !0;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = !1;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
      return stateNode;
    }
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE) return null;
          hasSpaceKeypress = !0;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM) return !1;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
      return isSupported;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
        event: nativeEvent,
        listeners: inst
      }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return !0;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return !1;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
      }
      return !0;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild;) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node;) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset) return {
            node: node,
            offset: offset - root
          };
          root = nodeEnd;
        }
        a: {
          for (; node;) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = !1;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    function restoreSelection(priorSelectionInformation, containerInfo) {
      var curFocusedElem = getActiveElementDeep(containerInfo);
      containerInfo = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
        if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo) containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(curFocusedElem, containerInfo.value.length);else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
          curFocusedElem = curFocusedElem.getSelection();
          var length = containerInfo.textContent.length,
            start = Math.min(priorSelectionRange.start, length);
          priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length);
          !curFocusedElem.extend && start > priorSelectionRange && (length = priorSelectionRange, priorSelectionRange = start, start = length);
          length = getNodeForCharacterOffset(containerInfo, start);
          var endMarker = getNodeForCharacterOffset(containerInfo, priorSelectionRange);
          length && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length.node || curFocusedElem.anchorOffset !== length.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length.node, length.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(endMarker.node, endMarker.offset), curFocusedElem.addRange(priorSelectionInformation)));
        }
        priorSelectionInformation = [];
        for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode;) 1 === curFocusedElem.nodeType && priorSelectionInformation.push({
          element: curFocusedElem,
          left: curFocusedElem.scrollLeft,
          top: curFocusedElem.scrollTop
        });
        "function" === typeof containerInfo.focus && containerInfo.focus();
        for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++) curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
      }
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
        start: doc.selectionStart,
        end: doc.selectionEnd
      } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
        event: nativeEvent,
        listeners: doc
      }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
      isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return; null !== parent;) null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: family
      }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (null === resolveFamily) return !1;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = !1,
        $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1:
          "function" === typeof element && (needsCompareFamilies = !0);
          break;
        case 0:
          "function" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        default:
          return !1;
      }
      return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type,
        candidateType = null;
      switch (tag) {
        case 0:
        case 15:
        case 1:
          candidateType = type;
          break;
        case 11:
          candidateType = type.render;
      }
      if (null === resolveFamily) throw Error("Expected resolveFamily to be set during hot reload.");
      var needsRender = !1;
      type = !1;
      null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));
      null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);
      type && (fiber._debugNeedsRemount = !0);
      if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
      null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
      null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
      }
    }
    function startEffectTimer() {
      profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child;) fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
    }
    function pushMaterializedTreeId(workInProgress) {
      warnIfNotHydrating();
      null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (null === fiber.return) {
        if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {
          fiber: fiber,
          children: [],
          serverProps: void 0,
          serverTail: [],
          distanceFromLeaf: distanceFromLeaf
        };else {
          if (hydrationDiffRootDEV.fiber !== fiber) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var diff = "",
        diffRoot = hydrationDiffRootDEV;
      null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var type = fiber.type,
        props = fiber.memoizedProps;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
          track(didHydrate);
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = !0) : didHydrate = !1;
      didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
        case 3:
        case 27:
          rootOrSingletonContext = !0;
          return;
        case 5:
        case 13:
          rootOrSingletonContext = !1;
          return;
        default:
          hydrationParentFiber = hydrationParentFiber.return;
      }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
      var shouldClear = !1,
        JSCompiler_temp;
      if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
        if (JSCompiler_temp = 5 === fiber.tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && (shouldClear = !0);
      if (shouldClear && nextHydratableInstance) {
        for (shouldClear = nextHydratableInstance; shouldClear;) {
          JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
          var description = describeHydratableInstanceForDevWarnings(shouldClear);
          JSCompiler_temp.serverTail.push(description);
          shouldClear = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratable(shouldClear.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (13 === fiber.tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return !0;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = !1;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", diffRoot));
    }
    function createThenableState() {
      return {
        didWarnAboutUncachedPromise: !1,
        thenables: []
      };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {}
    function trackUsedThenable(thenableState, thenable, index) {
      null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);
      var trackedThenables = thenableState.thenables;
      index = trackedThenables[index];
      void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$3, noop$3), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);else {
            thenableState = workInProgressRoot;
            if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(function (fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function (error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = !0;
          throw SuspenseException;
      }
    }
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = !1;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function (erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", invalidChild, invalidChild, invalidChild) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", invalidChild) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", parentName, invalidChild, parentName));
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
        newFiber.flags |= 33554434;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;
        if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;
        current = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current, element);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if ("function" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (null !== key) return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if ("function" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if ("function" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
        if ("object" !== typeof child || null === child) return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress, child);
            var key = child.key;
            if ("string" !== typeof key) break;
            if (null === knownKeys) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress, function () {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
            });
            break;
          case REACT_LAZY_TYPE:
            child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next()) oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key; null !== currentFirstChild;) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key; null !== currentFirstChild;) {
                  if (currentFirstChild.key === newChild) {
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          }
          if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
            } else newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if ("function" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException) throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          if (null != debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) if ("string" === typeof debugInfo[i].stack) {
            fiber._debugOwner = debugInfo[i];
            break;
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
          var current = fiber.alternate;
          null !== current && null !== current.memoizedState && (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row; null !== node;) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || state.data === SUSPENSE_FALLBACK_START_DATA)) return node;
        } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling;) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function () {
        cache.controller.abort();
      });
    }
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          }
        };
      thenable.then(function () {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
      }, function (error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : {
        parent: CacheContext._currentValue,
        pool: cacheFromPool
      };
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {
          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i],
              newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length;) oldHookName += " ";
            oldHookName += newHookName + "\n";
            table += oldHookName;
          }
          console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      void 0 === deps || null === deps || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
      didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName));
    }
    function throwInvalidHookError() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies) return !1;
      if (null === prevDeps) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
      nextDeps.length !== prevDeps.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
      return !0;
    }
    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber$1 = workInProgress;
      hookTypesDev = null !== current ? current._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
      if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."));
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = !1;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(!0);
        try {
          children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      finishRenderingHooks(current, workInProgress);
      return children;
    }
    function finishRenderingHooks(current, workInProgress) {
      workInProgress._debugHookTypes = hookTypesDev;
      null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState
      }) : workInProgress.dependencies._debugThenableState = thenableState;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
      hookTypesUpdateIndexDev = -1;
      null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = !1;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;
      current && (workInProgress = getComponentNameFromFiber(workInProgress) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber$1 = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = !1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags = (workInProgress.mode & StrictEffectsMode) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber$1.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber$1.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber$1;
      null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber$1.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber$1.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function (array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = {
        data: [],
        index: 0
      });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue || ignorePreviousDependencies) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;else updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null,
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction = !1;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
              lane: 0,
              revertLane: 0,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
              continue;
            } else updateLane = {
              lane: 0,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else revertLane = {
            lane: updateLane,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do newState = reducer(newState, update.action), update = update.next; while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber$1,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0));
        if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = {
        value: nextSnapshot,
        getSnapshot: getSnapshot
      };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {
        destroy: void 0
      }, null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber$1,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {
          destroy: void 0
        }, null);
        if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = {
        getSnapshot: getSnapshot,
        value: renderedSnapshot
      };
      getSnapshot = currentlyRenderingFiber$1.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        ReactSharedInternals.T._updatedFibers = new Set();
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else try {
        currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
      } catch (error$3) {
        onActionError(actionQueue, node, error$3);
      }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(function (nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function (error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next; while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var isMatching = currentlyRenderingFiber$1;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType;) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(markerInstance.nextSibling);
                    if (null === markerInstance) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = !1;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(!1);
      inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, inRootOrSingleton, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, !1];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
      var actionQueueHook = updateWorkInProgressHook(),
        actionQueue = actionQueueHook.queue,
        dispatch = actionQueue.dispatch;
      action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {
        destroy: void 0
      }, null));
      return [currentStateHook, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, !1];
    }
    function pushEffect(tag, create, inst, deps) {
      tag = {
        tag: tag,
        create: create,
        inst: inst,
        deps: deps,
        next: null
      };
      create = currentlyRenderingFiber$1.updateQueue;
      null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
      inst = create.lastEffect;
      null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = {
        current: initialValue
      };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber$1.flags |= fiberFlags;
      hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {
        destroy: void 0
      }, void 0 === deps ? null : deps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref) return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function () {
        ref.current = null;
      };
    }
    function mountImperativeHandle(ref, create, deps) {
      "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
      if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, {
          then: function () {},
          status: "rejected",
          reason: error
        }, requestUpdateLane(fiber));
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function () {
        requestFormReset$1(formFiber);
        return action(formData);
      });
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      null === ReactSharedInternals.T && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));
    }
    function mountTransition() {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += ":";
      } else treeId = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + treeId.toString(32) + ":";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return; null !== provider;) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider);
            fiber = createUpdate(lane);
            var root = enqueueUpdate(provider, fiber, lane);
            null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
            provider = createCache();
            null !== seedKey && void 0 !== seedKey && null !== root && console.error("The seed argument is not enabled outside experimental channels.");
            fiber.payload = {
              cache: provider
            };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
      action = {
        lane: JSCompiler_OptimizeArgumentsArray_p0,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));
      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
    }
    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);
      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
          } catch (error) {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
      }
      return !1;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194176)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (null !== callback && "function" !== typeof callback) {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress.memoizedState,
        partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
      workInProgress.memoizedState = prevState;
      0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress.stateNode;
      if ("function" === typeof instance.shouldComponentUpdate) {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        void 0 === oldProps && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
    }
    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
      var oldState = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component) void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error, errorInfo) {
      reportGlobalError(error);
      error = componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.";
      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
        componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
      ReactSharedInternals.getCurrentStack = function () {
        return componentStack;
      };
      try {
        console.warn("%s\n\n%s\n", error, "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.");
      } finally {
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function defaultOnCaughtError(error, errorInfo) {
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.",
        recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + "."),
        prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
        componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
      ReactSharedInternals.getCurrentStack = function () {
        return componentStack;
      };
      try {
        "object" === typeof error && null !== error && "string" === typeof error.environmentName ? bindToConsole("error", ["%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage], error.environmentName)() : console.error("%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage);
      } finally {
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, {
            componentStack: errorInfo.stack
          });
        }
      } catch (e$4) {
        setTimeout(function () {
          throw e$4;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$5) {
        setTimeout(function () {
          throw e$5;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = {
        element: null
      };
      lane.callback = function () {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function () {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
        isHydrating && (didSuspendOrErrorDEV = !0);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
          }
          throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return !1;
      }
      if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", {
        cause: value
      }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", {
        cause: value
      }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;
      var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", {
        cause: value
      }), sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (null === returnFiber) return !0;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
          case 1:
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return !1;
    }
    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
      workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
    }
    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
      key = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);
        current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return workInProgress.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
      return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & OffscreenDetached),
        prevState = null !== current ? current.memoizedState : null;
      markRef(current, workInProgress);
      if ("hidden" === nextProps.mode || nextIsDetached) {
        if (0 !== (workInProgress.flags & 128)) {
          nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
          if (null !== current) {
            nextChildren = workInProgress.child = current.child;
            for (nextIsDetached = 0; null !== nextChildren;) nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
            workInProgress.childLanes = nextIsDetached & ~nextProps;
          } else workInProgress.childLanes = 0, workInProgress.child = null;
          return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
        }
        if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
          baseLanes: 0,
          cachePool: null
        }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
      } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
        parent: CacheContext._currentValue,
        pool: JSCompiler_inline_result
      };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack(workInProgress);
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
      return null;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);else {
        if ("function" !== typeof ref && "object" !== typeof ref) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;
      }
    }
    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (Component.prototype && "function" === typeof Component.prototype.render) {
        var componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
      }
      workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
      null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName))));
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
      nextProps = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
      finishRenderingHooks(current, workInProgress);
      Component = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {
      switch (shouldErrorImpl(workInProgress)) {
        case !1:
          var _instance = workInProgress.stateNode,
            state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case !0:
          workInProgress.flags |= 128;
          workInProgress.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes & -renderLanes;
          workInProgress.lanes |= lane;
          state = workInProgressRoot;
          if (null === state) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));
          enqueueCapturedUpdate(workInProgress, lane);
      }
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress.stateNode = _instance;
        _instance._reactInternals = workInProgress;
        _instance._reactInternalInstance = fakeInternalInstance;
        "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, null === _instance.state ? "null" : "undefined", state)));
        if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
          var foundWillUpdateName = lane = state = null;
          "function" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
          "function" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
          "function" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (null !== state || null !== lane || null !== foundWillUpdateName) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _instance, newApiName, null !== state ? "\n  " + state : "", null !== lane ? "\n  " + lane : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
          }
        }
        _instance = workInProgress.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        "function" === typeof _instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        "function" === typeof _instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        "function" === typeof _instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        "function" === typeof _instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        void 0 !== _instance.props && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        "function" === typeof _instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        "function" === typeof _instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        "function" === typeof Component.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress);
        state = Component.contextType;
        _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);
        _instance.state = workInProgress.memoizedState;
        state = Component.getDerivedStateFromProps;
        "function" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);
        "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);
        (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864);
        _instance = !0;
      } else if (null === current$jscomp$0) {
        _instance = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);
        hasForceUpdate = !1;
        var oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864)) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);
      } else {
        _instance = workInProgress.stateNode;
        cloneUpdateQueue(current$jscomp$0, workInProgress);
        state = workInProgress.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);
        hasForceUpdate = !1;
        oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), "function" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);
      }
      lane = _instance;
      markRef(current$jscomp$0, workInProgress);
      state = 0 !== (workInProgress.flags & 128);
      if (lane || state) {
        lane = workInProgress.stateNode;
        ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;
        isRendering = !1;
        current = workInProgress;
        if (state && "function" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;else {
          markComponentRenderStarted(workInProgress);
          Component = callRenderInDEV(lane);
          if (workInProgress.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          markComponentRenderStopped();
        }
        workInProgress.flags |= 1;
        null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);
        workInProgress.memoizedState = lane.state;
        current$jscomp$0 = workInProgress.child;
      } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);
      renderLanes = workInProgress.stateNode;
      _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress) || "a component"), didWarnAboutReassigningProps = !0);
      return current$jscomp$0;
    }
    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
      Component && Component.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", Component.displayName || Component.name || "Component");
      "function" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));
      "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));
    }
    function mountSuspenseOffscreenState(renderLanes) {
      return {
        baseLanes: renderLanes,
        cachePool: getSuspendedCache()
      };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var JSCompiler_object_inline_digest_2317;
      var JSCompiler_object_inline_stack_2318 = workInProgress.pendingProps;
      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
      var JSCompiler_object_inline_componentStack_2319 = !1;
      var didSuspend = 0 !== (workInProgress.flags & 128);
      (JSCompiler_object_inline_digest_2317 = didSuspend) || (JSCompiler_object_inline_digest_2317 = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
      JSCompiler_object_inline_digest_2317 && (JSCompiler_object_inline_componentStack_2319 = !0, workInProgress.flags &= -129);
      JSCompiler_object_inline_digest_2317 = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          JSCompiler_object_inline_componentStack_2319 ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
          if (isHydrating) {
            var JSCompiler_object_inline_message_2316 = nextHydratableInstance;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2316)) {
              c: {
                var instance = JSCompiler_object_inline_message_2316;
                for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType;) {
                  if (!JSCompiler_temp) {
                    JSCompiler_temp = null;
                    break c;
                  }
                  instance = getNextHydratable(instance.nextSibling);
                  if (null === instance) {
                    JSCompiler_temp = null;
                    break c;
                  }
                }
                JSCompiler_temp = instance;
              }
              null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress.memoizedState = {
                dehydrated: JSCompiler_temp,
                treeContext: null !== treeContextProvider ? {
                  id: treeContextId,
                  overflow: treeContextOverflow
                } : null,
                retryLane: 536870912
              }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress, workInProgress.child = instance, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp = !0) : JSCompiler_temp = !1;
              JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp && (warnNonHydratedInstance(workInProgress, JSCompiler_object_inline_message_2316), throwOnHydrationMismatch(workInProgress));
          }
          JSCompiler_object_inline_message_2316 = workInProgress.memoizedState;
          if (null !== JSCompiler_object_inline_message_2316 && (JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_message_2316.dehydrated, null !== JSCompiler_object_inline_message_2316)) return JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;
          popSuspenseHandler(workInProgress);
        }
        JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_stack_2318.children;
        JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_stack_2318.fallback;
        if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = workInProgress.mode, JSCompiler_object_inline_message_2316 = mountWorkInProgressOffscreenFiber({
          mode: "hidden",
          children: JSCompiler_object_inline_message_2316
        }, JSCompiler_object_inline_componentStack_2319), JSCompiler_object_inline_stack_2318 = createFiberFromFragment(JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_componentStack_2319, renderLanes, null), JSCompiler_object_inline_message_2316.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_message_2316.sibling = JSCompiler_object_inline_stack_2318, workInProgress.child = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_componentStack_2319.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_message_2316);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (JSCompiler_object_inline_message_2316 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2316)) {
        if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_object_inline_stack_2318 = mountWorkInProgressOffscreenFiber({
          mode: "visible",
          children: JSCompiler_object_inline_stack_2318.children
        }, JSCompiler_object_inline_message_2316), JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, reconcileChildFibers(workInProgress, current.child, null, renderLanes), JSCompiler_object_inline_stack_2318 = workInProgress.child, JSCompiler_object_inline_stack_2318.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_stack_2318.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = JSCompiler_object_inline_componentStack_2319);else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug."), JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA) {
          JSCompiler_object_inline_digest_2317 = JSCompiler_object_inline_message_2316.nextSibling && JSCompiler_object_inline_message_2316.nextSibling.dataset;
          if (JSCompiler_object_inline_digest_2317) {
            JSCompiler_temp = JSCompiler_object_inline_digest_2317.dgst;
            var message = JSCompiler_object_inline_digest_2317.msg;
            instance = JSCompiler_object_inline_digest_2317.stck;
            var componentStack = JSCompiler_object_inline_digest_2317.cstck;
          }
          JSCompiler_object_inline_message_2316 = message;
          JSCompiler_object_inline_digest_2317 = JSCompiler_temp;
          JSCompiler_object_inline_stack_2318 = instance;
          JSCompiler_temp = JSCompiler_object_inline_componentStack_2319 = componentStack;
          JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_message_2316 ? Error(JSCompiler_object_inline_message_2316) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          JSCompiler_object_inline_componentStack_2319.stack = JSCompiler_object_inline_stack_2318 || "";
          JSCompiler_object_inline_componentStack_2319.digest = JSCompiler_object_inline_digest_2317;
          JSCompiler_object_inline_digest_2317 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
          JSCompiler_object_inline_stack_2318 = {
            value: JSCompiler_object_inline_componentStack_2319,
            source: null,
            stack: JSCompiler_object_inline_digest_2317
          };
          "string" === typeof JSCompiler_object_inline_digest_2317 && CapturedStacks.set(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_stack_2318);
          queueHydrationError(JSCompiler_object_inline_stack_2318);
          workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_object_inline_digest_2317 = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2317) {
          JSCompiler_object_inline_digest_2317 = workInProgressRoot;
          if (null !== JSCompiler_object_inline_digest_2317) {
            JSCompiler_object_inline_stack_2318 = renderLanes & -renderLanes;
            if (0 !== (JSCompiler_object_inline_stack_2318 & 42)) JSCompiler_object_inline_stack_2318 = 1;else switch (JSCompiler_object_inline_stack_2318) {
              case 2:
                JSCompiler_object_inline_stack_2318 = 1;
                break;
              case 8:
                JSCompiler_object_inline_stack_2318 = 4;
                break;
              case 32:
                JSCompiler_object_inline_stack_2318 = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                JSCompiler_object_inline_stack_2318 = 64;
                break;
              case 268435456:
                JSCompiler_object_inline_stack_2318 = 134217728;
                break;
              default:
                JSCompiler_object_inline_stack_2318 = 0;
            }
            JSCompiler_object_inline_stack_2318 = 0 !== (JSCompiler_object_inline_stack_2318 & (JSCompiler_object_inline_digest_2317.suspendedLanes | renderLanes)) ? 0 : JSCompiler_object_inline_stack_2318;
            if (0 !== JSCompiler_object_inline_stack_2318 && JSCompiler_object_inline_stack_2318 !== prevState.retryLane) throw prevState.retryLane = JSCompiler_object_inline_stack_2318, enqueueConcurrentRenderForLane(current, JSCompiler_object_inline_stack_2318), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2317, current, JSCompiler_object_inline_stack_2318), SelectiveHydrationException;
          }
          JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
          workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
        } else JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), JSCompiler_object_inline_message_2316._reactRetry = workInProgress, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2316.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_stack_2318.children), workInProgress.flags |= 4096);
        return workInProgress;
      }
      if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_temp = current.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2318 = createWorkInProgress(JSCompiler_temp, {
        mode: "hidden",
        children: JSCompiler_object_inline_stack_2318.children
      }), JSCompiler_object_inline_stack_2318.subtreeFlags = JSCompiler_temp.subtreeFlags & 31457280, null !== instance ? JSCompiler_object_inline_componentStack_2319 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2319) : (JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2), JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_message_2316 = current.child.memoizedState, null === JSCompiler_object_inline_message_2316 ? JSCompiler_object_inline_message_2316 = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp = JSCompiler_object_inline_message_2316.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? {
        parent: instance,
        pool: instance
      } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2316 = {
        baseLanes: JSCompiler_object_inline_message_2316.baseLanes | renderLanes,
        cachePool: JSCompiler_temp
      }), JSCompiler_object_inline_componentStack_2319.memoizedState = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2318.children
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current && (JSCompiler_object_inline_digest_2317 = workInProgress.deletions, null === JSCompiler_object_inline_digest_2317 ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_object_inline_digest_2317.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({
        mode: "visible",
        children: primaryChildren
      }, workInProgress.mode);
      primaryChildren.return = workInProgress;
      return workInProgress.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      return createFiberFromOffscreen(offscreenProps, mode, 0, null);
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), !1) : !0;
    }
    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress.memoizedState;
      null === renderState ? workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
      nextProps = nextProps.children;
      if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, "string" === typeof revealOrder) switch (revealOrder.toLowerCase()) {
        case "together":
        case "forwards":
        case "backwards":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
          break;
        case "forward":
        case "backward":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
          break;
        default:
          console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      } else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
      a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for (var i = 0; i < nextProps.length; i++) {
        if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
      } else if (i = getIteratorFn(nextProps), "function" === typeof i) {
        if (i = i.call(nextProps)) for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
          if (!validateSuspenseListNestedChild(step.value, _i)) break a;
          _i++;
        }
      } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;else {
        if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
          if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress) break a;
          for (; null === current.sibling;) {
            if (null === current.return || current.return === workInProgress) break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
        nextProps &= SubtreeSuspenseContextMask;
      }
      push(suspenseStackCursor, nextProps, workInProgress);
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
          renderLanes = revealOrder;
          null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
          initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
          break;
        case "backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder;) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
          break;
        case "together":
          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
        if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;
      } else return null;
      if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return !0;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
          break;
        case 12:
          0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);
          workInProgress.flags |= 2048;
          var stateNode = workInProgress.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 13:
          stateNode = workInProgress.memoizedState;
          if (null !== stateNode) {
            if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
            if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
          stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));
          if (didSuspendBefore) {
            if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);
          if (stateNode) break;else return null;
        case 22:
        case 23:
          return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (workInProgress._debugNeedsRemount && null !== current) {
        renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);
        var returnFiber = workInProgress.return;
        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
        current.alternate = null;
        workInProgress.alternate = null;
        renderLanes.index = workInProgress.index;
        renderLanes.sibling = workInProgress.sibling;
        renderLanes.return = workInProgress.return;
        renderLanes.ref = workInProgress.ref;
        renderLanes._debugInfo = workInProgress._debugInfo;
        if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;else {
          var prevSibling = returnFiber.child;
          if (null === prevSibling) throw Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== workInProgress;) if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes;
        }
        workInProgress = returnFiber.deletions;
        null === workInProgress ? (returnFiber.deletions = [current], returnFiber.flags |= 16) : workInProgress.push(current);
        renderLanes.flags |= 2;
        return renderLanes;
      }
      if (null !== current) {
        if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;else {
          if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
        }
      } else {
        didReceiveUpdate = !1;
        if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);
        returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));
      }
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, "function" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));else {
            if (void 0 !== current && null !== current) if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress.type = current = resolveForwardRefForHotReloading(current);
              workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);
              break a;
            } else if (prevSibling === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);
              break a;
            }
            workInProgress = "";
            null !== current && "object" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = " Did you wrap a component in React.lazy() more than once?");
            current = getComponentNameFromType(current) || current;
            throw Error("Element type is invalid. Received a promise that resolves to: " + current + ". Lazy element type must resolve to a class or function." + workInProgress);
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 1:
          return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);
        case 3:
          a: {
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            if (null === current) throw Error("Should have a current fiber. This is a bug in React.");
            var nextProps = workInProgress.pendingProps;
            prevSibling = workInProgress.memoizedState;
            returnFiber = prevSibling.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, nextProps, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            nextProps = nextState.cache;
            pushProvider(workInProgress, CacheContext, nextProps);
            nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0);
            suspendIfUpdateReadFromEntangledAsyncAction();
            nextProps = nextState.element;
            if (prevSibling.isDehydrated) {
              if (prevSibling = {
                element: nextProps,
                isDehydrated: !1,
                cache: nextState.cache
              }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {
                workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
                break a;
              } else if (nextProps !== returnFiber) {
                returnFiber = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress);
                queueHydrationError(returnFiber);
                workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
                break a;
              } else for (nextHydratableInstance = getNextHydratable(workInProgress.stateNode.containerInfo.firstChild), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0, current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;) current.flags = current.flags & -3 | 4096, current = current.sibling;
            } else {
              resetHydrationState();
              if (nextProps === returnFiber) {
                workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                break a;
              }
              reconcileChildren(current, workInProgress, nextProps, renderLanes);
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (current = workInProgress.type, renderLanes = workInProgress.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current), returnFiber[internalInstanceKey] = workInProgress, returnFiber[internalPropsKey] = renderLanes, setInitialProperties(returnFiber, current, renderLanes), markNodeAsHoistable(returnFiber), workInProgress.stateNode = returnFiber) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
        case 27:
          return pushHostContext(workInProgress), null === current && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedProperties(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getNextHydratable(prevSibling.firstChild)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;
        case 5:
          return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateDOMNesting(workInProgress.type, nextProps.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedProperties(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 6:
          return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext().ancestorInfo.current, current = null != renderLanes ? validateTextNesting(current, renderLanes.tag) : !0, renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 11:
          return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 7:
          return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
        case 8:
          return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 12:
          return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 10:
          return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;
        case 9:
          return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, "function" !== typeof returnFiber && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 14:
          return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 15:
          return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 19:
          return updateSuspenseListComponent(current, workInProgress, renderLanes);
        case 22:
          return updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {
            parent: returnFiber,
            cache: prevSibling
          }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber = null;
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
      for (; null !== parent;) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber;) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list;) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
              list.lanes |= renderLanes;
              dependency = list.alternate;
              null !== dependency && (dependency.lanes |= renderLanes);
              scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;else for (nextFiber = fiber; null !== nextFiber;) {
          if (nextFiber === workInProgress) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;) {
        if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
        if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
        currentDependencies = currentDependencies.next;
      }
      return !1;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = {
        context: context,
        memoizedValue: value,
        next: null
      };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          lanes: 0,
          hiddenCallbacks: null
        },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current && (workInProgress.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane: lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName = getComponentNameFromFiber(fiber);
        console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", componentName);
        didWarnUpdateInsideUpdate = !0;
      }
      if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {
      didReadFromEntangledAsyncAction = !1;
      var queue = workInProgress.updateQueue;
      hasForceUpdate = !1;
      currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress;
              var partialState = pendingQueue;
              var nextProps = props,
                instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if ("function" === typeof partialState) {
                    isDisallowedContextReadInDEV = !0;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = updateLane.flags & -65537 | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if ("function" === typeof nextState) {
                    isDisallowedContextReadInDEV = !0;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                  } else partialState = nextState;
                  if (null === partialState || void 0 === partialState) break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = !0;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else isHiddenUpdate = {
            lane: updateLane,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress.lanes = lastBaseUpdate;
        workInProgress.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (null !== hiddenCallbacks) for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++) callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
    }
    function shouldProfile(current) {
      return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
              var hookName = void 0;
              hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
              var addendum = void 0;
              addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
              runWithFiberInDEV(finishedWork, function (n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
      var prevProps = current.memoizedProps,
        prevState = current.memoizedState;
      current = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);
        var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function () {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
      instance.state = current.memoizedState;
      shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (null !== ref) {
        var instance = finishedWork.stateNode;
        if ("function" === typeof ref) {
          if (shouldProfile(finishedWork)) try {
            startEffectTimer(), finishedWork.refCleanup = ref(instance);
          } finally {
            recordEffectDuration();
          } else finishedWork.refCleanup = ref(instance);
        } else "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instance;
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current, commitAttachRef, current);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref) if ("function" === typeof refCleanup) try {
        if (shouldProfile(current)) try {
          startEffectTimer(), runWithFiberInDEV(current, refCleanup);
        } finally {
          recordEffectDuration(current);
        } else runWithFiberInDEV(current, refCleanup);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
      } else if ("function" === typeof ref) try {
        if (shouldProfile(current)) try {
          startEffectTimer(), runWithFiberInDEV(current, ref, null);
        } finally {
          recordEffectDuration(current);
        } else runWithFiberInDEV(current, ref, null);
      } catch (error$6) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$6);
      } else ref.current = null;
    }
    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {
      var _finishedWork$memoize = finishedWork.memoizedProps,
        id = _finishedWork$memoize.id,
        onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);
      "function" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);
    }
    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling;) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag;) {
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag) node = node.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node, before) : parent.insertBefore(node, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node, parent)) : (before = parent, before.appendChild(node)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      if (27 !== finishedWork.tag) {
        a: {
          for (var parent = finishedWork.return; null !== parent;) {
            if (isHostParent(parent)) {
              var parentFiber = parent;
              break a;
            }
            parent = parent.return;
          }
          throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        switch (parentFiber.tag) {
          case 27:
            parent = parentFiber.stateNode;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
            break;
          case 5:
            parent = parentFiber.stateNode;
            parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
            break;
          case 3:
          case 4:
            parent = parentFiber.stateNode.containerInfo;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);
            break;
          default:
            throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root) var JSCompiler_temp = {
          start: root.selectionStart,
          end: root.selectionEnd
        };else a: {
          JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset,
              focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e$2) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0,
              start = -1,
              end = -1,
              indexWithinAnchor = 0,
              indexWithinFocus = 0,
              node = root,
              parentNode = null;
            b: for (;;) {
              for (var next;;) {
                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (;;) {
                if (node === root) break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp = -1 === start || -1 === end ? null : {
              start: start,
              end: end
            };
          } else JSCompiler_temp = null;
        }
        JSCompiler_temp = JSCompiler_temp || {
          start: 0,
          end: 0
        };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp
      };
      _enabled = !1;
      for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root) root.return = firstChild, nextEffect = root;else for (; null !== nextEffect;) {
        root = firstChild = nextEffect;
        JSCompiler_temp = root.alternate;
        anchorOffset = root.flags;
        switch (root.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root, JSCompiler_temp);
            break;
          case 3:
            if (0 !== (anchorOffset & 1024)) if (root = root.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);else if (1 === JSCompiler_temp) switch (root.nodeName) {
              case "HEAD":
              case "HTML":
              case "BODY":
                clearContainerSparingly(root);
                break;
              default:
                root.textContent = "";
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (anchorOffset & 1024)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
      firstChild = shouldFireAfterActiveInstanceBlur;
      shouldFireAfterActiveInstanceBlur = !1;
      return firstChild;
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);else {
            var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
            current = current.memoizedState;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
            shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
          }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
            prevProps = null;
            if (null !== finishedWork.child) switch (finishedWork.child.tag) {
              case 27:
              case 5:
                prevProps = finishedWork.child.stateNode;
                break;
              case 1:
                prevProps = finishedWork.child.stateNode;
            }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current);
          break;
        case 26:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!prevProps) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
              prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevProps;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          deletedFiber = deletedFiber.stateNode;
          for (finishedRoot = deletedFiber.attributes; finishedRoot.length;) deletedFiber.removeAttributeNode(finishedRoot[0]);
          detachDeletedInstance(deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent) if (hostParentIsContainer) try {
            runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          } else try {
            runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, deletedFiber = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber) : 1 === finishedRoot.nodeType && clearSuspenseBoundary(finishedRoot, deletedFiber), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = !0;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 22:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
        runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
          wakeable.then(retry, retry);
        }
      });
    }
    function commitMutationEffects(root, finishedWork, committedLanes) {
      inProgressLanes = committedLanes;
      inProgressRoot = root;
      commitMutationEffectsOnFiber(finishedWork, root);
      inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var root = root$jscomp$0,
          returnFiber = parentFiber,
          deletedFiber = deletions[i],
          parent = returnFiber;
        a: for (; null !== parent;) {
          switch (parent.tag) {
            case 27:
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = !1;
              break a;
            case 3:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = !0;
              break a;
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = !0;
              break a;
          }
          parent = parent.return;
        }
        if (null === hostParent) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
        hostParent = null;
        hostParentIsContainer = !1;
        root = deletedFiber;
        returnFiber = root.alternate;
        null !== returnFiber && (returnFiber.return = null);
        root.return = null;
      }
      if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) if (root = null !== current ? current.memoizedState : null, flags = finishedWork.memoizedState, null === current) {
            if (null === flags) {
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  root = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      hoistableRoot = root.getElementsByTagName("title")[0];
                      if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop")) hoistableRoot = root.createElement(flags), root.head.insertBefore(hoistableRoot, root.querySelector("head > title"));
                      setInitialProperties(hoistableRoot, flags, current);
                      hoistableRoot[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(hoistableRoot);
                      flags = hoistableRoot;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache("link", "href", root).get(flags + (current.href || ""));
                      if (maybeNodes) for (var i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current.href ? null : current.href) && hoistableRoot.getAttribute("rel") === (null == current.rel ? null : current.rel) && hoistableRoot.getAttribute("title") === (null == current.title ? null : current.title) && hoistableRoot.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      hoistableRoot = root.createElement(flags);
                      setInitialProperties(hoistableRoot, flags, current);
                      root.head.appendChild(hoistableRoot);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache("meta", "content", root).get(flags + (current.content || ""))) for (i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current.content, "content"), hoistableRoot.getAttribute("content") === (null == current.content ? null : "" + current.content) && hoistableRoot.getAttribute("name") === (null == current.name ? null : current.name) && hoistableRoot.getAttribute("property") === (null == current.property ? null : current.property) && hoistableRoot.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      hoistableRoot = root.createElement(flags);
                      setInitialProperties(hoistableRoot, flags, current);
                      root.head.appendChild(hoistableRoot);
                      break;
                    default:
                      throw Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                  }
                  hoistableRoot[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(hoistableRoot);
                  flags = hoistableRoot;
                }
                finishedWork.stateNode = flags;
              } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
            } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
          } else root !== flags ? (null === root ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : root.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
          break;
        case 27:
          if (flags & 4 && null === finishedWork.alternate) {
            hoistableRoot = finishedWork.stateNode;
            maybeNodes = finishedWork.memoizedProps;
            try {
              for (i = hoistableRoot.firstChild; i;) {
                var nextNode = i.nextSibling,
                  nodeName = i.nodeName;
                i[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === i.rel.toLowerCase() || hoistableRoot.removeChild(i);
                i = nextNode;
              }
              runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, maybeNodes, hoistableRoot, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, root);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));
          flags & 1024 && (needsFormReset = !0, "form" !== finishedWork.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current = null !== current ? current.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          tagCaches = null;
          maybeNodes = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = maybeNodes;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
            runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          i = null !== finishedWork.memoizedState;
          nextNode = null !== current && null !== current.memoizedState;
          nodeName = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = nodeName || i;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = nodeName;
          commitReconciliationEffects(finishedWork);
          root = finishedWork.stateNode;
          root._current = finishedWork;
          root._visibility &= ~OffscreenDetached;
          root._visibility |= root._pendingVisibility & OffscreenDetached;
          if (flags & 8192 && (root._visibility = i ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, i && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode)) a: for (current = null, root = finishedWork;;) {
            if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
              if (null === current) {
                nextNode = current = root;
                try {
                  hoistableRoot = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideInstance, hoistableRoot) : runWithFiberInDEV(nextNode, unhideInstance, nextNode.stateNode, nextNode.memoizedProps);
                } catch (error) {
                  captureCommitPhaseError(nextNode, nextNode.return, error);
                }
              }
            } else if (6 === root.tag) {
              if (null === current) {
                nextNode = root;
                try {
                  maybeNodes = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideTextInstance, maybeNodes) : runWithFiberInDEV(nextNode, unhideTextInstance, maybeNodes, nextNode.memoizedProps);
                } catch (error) {
                  captureCommitPhaseError(nextNode, nextNode.return, error);
                }
              }
            } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
              root.child.return = root;
              root = root.child;
              continue;
            }
            if (root === finishedWork) break a;
            for (; null === root.sibling;) {
              if (null === root.return || root.return === finishedWork) break a;
              current === root && (current = null);
              root = root.return;
            }
            current === root && (current = null);
            root.sibling.return = root.return;
            root = root.sibling;
          }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var fiber = parentFiber;
        recursivelyResetForms(fiber);
        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
        parentFiber = parentFiber.sibling;
      }
    }
    function commitLayoutEffects(finishedWork, root, committedLanes) {
      inProgressLanes = committedLanes;
      inProgressRoot = root;
      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
      inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 26:
        case 27:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          safelyDetachRef(finishedWork, finishedWork.return);
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber;) disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current = finishedWork.stateNode;
          "function" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);
          current = finishedWork.updateQueue;
          if (null !== current) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 26:
        case 27:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber;) reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            prevEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        case 23:
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
          flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber;) reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 22:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
            break;
          case 24:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber; while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
        }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
        }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber;) disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect;) {
        var fiber = nextEffect,
          current = fiber;
        switch (current.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);
            break;
          case 23:
          case 22:
            null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));
            break;
          case 24:
            releaseCache(current.memoizedState.cache);
        }
        current = fiber.child;
        if (null !== current) current.return = fiber, nextEffect = current;else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
          current = nextEffect;
          var sibling = current.sibling,
            returnFiber = current.return;
          detachFiberAfterEffects(current);
          if (current === fiber) {
            nextEffect = null;
            break a;
          }
          if (null !== sibling) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
      }
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = !1;
      this._debugHookTypes = null;
      hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);
      workInProgress.flags = current.flags & 31457280;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies = null === pendingProps ? null : {
        lanes: pendingProps.lanes,
        firstContext: pendingProps.firstContext,
        _debugThenableState: pendingProps._debugThenableState
      };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
      workInProgress._debugInfo = current._debugInfo;
      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
      switch (workInProgress.tag) {
        case 0:
        case 15:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 1:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 11:
          workInProgress.type = resolveForwardRefForHotReloading(current.type);
      }
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 31457282;
      var current = workInProgress.alternate;
      null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
        lanes: renderLanes.lanes,
        firstContext: renderLanes.firstContext,
        _debugThenableState: renderLanes._debugThenableState
      }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);
      return workInProgress;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0,
        resolvedType = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);else if ("string" === typeof type) fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;else a: switch (type) {
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= StrictLegacyMode;
          mode |= StrictEffectsMode;
          break;
        case REACT_PROFILER_TYPE:
          return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          }, key;
        case REACT_SUSPENSE_TYPE:
          return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
        case REACT_SUSPENSE_LIST_TYPE:
          return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
        case REACT_OFFSCREEN_TYPE:
          return createFiberFromOffscreen(pendingProps, mode, lanes, key);
        default:
          if ("object" === typeof type && null !== type) switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              resolvedType = resolveForwardRefForHotReloading(resolvedType);
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              resolvedType = null;
              break a;
          }
          resolvedType = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
          (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
          fiberTag = 29;
          pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
          resolvedType = null;
      }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
      pendingProps = createFiber(22, pendingProps, key, mode);
      pendingProps.elementType = REACT_OFFSCREEN_TYPE;
      pendingProps.lanes = lanes;
      var primaryChildInstance = {
        _visibility: OffscreenVisible,
        _pendingVisibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
        _current: null,
        detach: function () {
          var instance = primaryChildInstance,
            fiber = instance._current;
          if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
          if (0 === (instance._pendingVisibility & OffscreenDetached)) {
            var root = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root && (instance._pendingVisibility |= OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
          }
        },
        attach: function () {
          var instance = primaryChildInstance,
            fiber = instance._current;
          if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
          if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
            var root = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root && (instance._pendingVisibility &= ~OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
          }
        }
      };
      pendingProps.stateNode = primaryChildInstance;
      return pendingProps;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded) workInProgress.flags &= -16777217;else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
        resource = suspenseHandlerStackCursor.current;
        if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        workInProgress.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating) switch (renderState.tailMode) {
        case "hidden":
          hasRenderedATailFallback = renderState.tail;
          for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
          break;
        case "collapsed":
          lastTailNode = renderState.tail;
          for (var _lastTailNode = null; null !== lastTailNode;) null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
          null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
      }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout) {
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;) newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      } else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child; null !== child;) newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress), null;
        case 1:
          return bubbleProperties(workInProgress), null;
        case 3:
          newProps = workInProgress.stateNode;
          renderLanes = null;
          null !== current && (renderLanes = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048);
          popProvider(CacheContext, workInProgress);
          popHostContainer(workInProgress);
          newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
          if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
          bubbleProperties(workInProgress);
          return null;
        case 26:
          return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
        case 27:
          popHostContext(workInProgress);
          renderLanes = requiredContext(rootInstanceStackCursor.current);
          var _type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if (!newProps) {
              if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress);
              return null;
            }
            current = getHostContext();
            popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(_type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          renderLanes = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if (!newProps) {
              if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress);
              return null;
            }
            _type = getHostContext();
            if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, _type);else {
              current = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(renderLanes, _type.ancestorInfo);
              _type = _type.context;
              current = getOwnerDocumentFromRootContainer(current);
              switch (_type) {
                case HostContextNamespaceSvg:
                  current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                  break;
                case HostContextNamespaceMath:
                  current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                  break;
                default:
                  switch (renderLanes) {
                    case "svg":
                      current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                      break;
                    case "math":
                      current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                      break;
                    case "script":
                      current = current.createElement("div");
                      current.innerHTML = "<script>\x3c/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current = "string" === typeof newProps.is ? current.createElement("select", {
                        is: newProps.is
                      }) : current.createElement("select");
                      newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      current = "string" === typeof newProps.is ? current.createElement(renderLanes, {
                        is: newProps.is
                      }) : current.createElement(renderLanes), -1 === renderLanes.indexOf("-") && (renderLanes !== renderLanes.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", renderLanes), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current) || hasOwnProperty.call(warnedUnknownTags, renderLanes) || (warnedUnknownTags[renderLanes] = !0, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", renderLanes)));
                  }
              }
              current[internalInstanceKey] = workInProgress;
              current[internalPropsKey] = newProps;
              a: for (_type = workInProgress.child; null !== _type;) {
                if (5 === _type.tag || 6 === _type.tag) current.appendChild(_type.stateNode);else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                  _type.child.return = _type;
                  _type = _type.child;
                  continue;
                }
                if (_type === workInProgress) break a;
                for (; null === _type.sibling;) {
                  if (null === _type.return || _type.return === workInProgress) break a;
                  _type = _type.return;
                }
                _type.sibling.return = _type.return;
                _type = _type.sibling;
              }
              workInProgress.stateNode = current;
              a: switch (setInitialProperties(current, renderLanes, newProps), renderLanes) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = !0;
                  break a;
                default:
                  current = !1;
              }
              current && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          workInProgress.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current = requiredContext(rootInstanceStackCursor.current);
            renderLanes = getHostContext();
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              newProps = workInProgress.memoizedProps;
              _type = !didSuspendOrErrorDEV;
              renderLanes = null;
              var returnFiber = hydrationParentFiber;
              if (null !== returnFiber) switch (returnFiber.tag) {
                case 3:
                  _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
                  break;
                case 27:
                case 5:
                  renderLanes = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
              }
              current[internalInstanceKey] = workInProgress;
              current = current.nodeValue === newProps || null !== renderLanes && !0 === renderLanes.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, newProps) ? !0 : !1;
              current || throwOnHydrationMismatch(workInProgress);
            } else renderLanes = renderLanes.ancestorInfo.current, null != renderLanes && validateTextNesting(newProps, renderLanes.tag), current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            _type = popHydrationState(workInProgress);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!_type) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                _type = workInProgress.memoizedState;
                _type = null !== _type ? _type.dehydrated : null;
                if (!_type) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                _type[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
              } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
              _type = !1;
            } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), _type = !0;
            if (!_type) {
              if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress;
          newProps = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          newProps && (renderLanes = workInProgress.child, _type = null, null !== renderLanes.alternate && null !== renderLanes.alternate.memoizedState && null !== renderLanes.alternate.memoizedState.cachePool && (_type = renderLanes.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== renderLanes.memoizedState && null !== renderLanes.memoizedState.cachePool && (returnFiber = renderLanes.memoizedState.cachePool.pool), returnFiber !== _type && (renderLanes.flags |= 2048));
          newProps !== current && newProps && (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          (workInProgress.mode & ProfileMode) !== NoMode && newProps && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));
          return null;
        case 4:
          return popHostContainer(workInProgress), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;
        case 19:
          pop(suspenseStackCursor, workInProgress);
          _type = workInProgress.memoizedState;
          if (null === _type) return bubbleProperties(workInProgress), null;
          newProps = 0 !== (workInProgress.flags & 128);
          returnFiber = _type.rendering;
          if (null === returnFiber) {
            if (newProps) cutOffTailIfNeeded(_type, !1);else {
              if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
                returnFiber = findFirstSuspended(current);
                if (null !== returnFiber) {
                  workInProgress.flags |= 128;
                  cutOffTailIfNeeded(_type, !1);
                  current = returnFiber.updateQueue;
                  workInProgress.updateQueue = current;
                  scheduleRetryEffect(workInProgress, current);
                  workInProgress.subtreeFlags = 0;
                  current = renderLanes;
                  for (newProps = workInProgress.child; null !== newProps;) resetWorkInProgress(newProps, current), newProps = newProps.sibling;
                  push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);
                  return workInProgress.child;
                }
                current = current.sibling;
              }
              null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
            }
          } else {
            if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {
              if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(_type, !0), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
            } else 2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
            _type.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = _type.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, _type.last = returnFiber);
          }
          if (null !== _type.tail) return current = _type.tail, _type.rendering = current, _type.tail = current.sibling, _type.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), newProps = workInProgress.updateQueue, null !== newProps && scheduleRetryEffect(workInProgress, newProps.retryQueue), newProps = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (newProps = current.memoizedState.cachePool.pool), renderLanes = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (renderLanes = workInProgress.memoizedState.cachePool.pool), renderLanes !== newProps && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;
        case 24:
          return newProps = null, null !== current && (newProps = current.memoizedState.cache), workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;
        case 25:
          return null;
      }
      throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 3:
          return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress), null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress), null;
        case 4:
          return popHostContainer(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 24:
          return popProvider(CacheContext, workInProgress), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          null !== current && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function (commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
      isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
      if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
      markRootUpdated$1(root, lane);
      if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {
        if (isRendering) switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
            didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
            break;
          case 1:
            didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
        }
      } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
      var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes),
        exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0),
        renderWasConcurrent = shouldTimeSlice;
      do {
        if (exitStatus === RootInProgress) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);
          break;
        } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);else {
          forceSync = root.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root, lanes, !1);
            renderWasConcurrent = !1;
            continue;
          }
          if (exitStatus === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
            if (0 !== errorRetryLanes) {
              lanes = errorRetryLanes;
              a: {
                exitStatus = root;
                var errorRetryLanes$jscomp$0 = errorRetryLanes;
                errorRetryLanes = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);
                errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);
                if (errorRetryLanes$jscomp$0 !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = RootSuspendedWithDelay;
                    break a;
                  }
                  exitStatus = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = errorRetryLanes;
                  null !== exitStatus && queueRecoverableErrors(exitStatus);
                }
                exitStatus = errorRetryLanes$jscomp$0;
              }
              renderWasConcurrent = !1;
              if (exitStatus !== RootErrored) continue;
            }
          }
          if (exitStatus === RootFatalErrored) {
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, !0);
            break;
          }
          a: {
            shouldTimeSlice = root;
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194176) === lanes) {
                  markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                  break a;
                }
                break;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            shouldTimeSlice.finishedWork = forceSync;
            shouldTimeSlice.finishedLanes = lanes;
            if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, renderStartTime, 0);else {
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, renderStartTime, 0), exitStatus);
                break a;
              }
              commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, renderStartTime, 0);
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function queueRecoverableErrors(errors) {
      null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
    }
    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      var subtreeFlags = finishedWork.subtreeFlags;
      if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) if (suspendedState = {
        stylesheets: null,
        count: 0,
        unsuspend: noop
      }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
        root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));
        markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
        return;
      }
      commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork;;) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
          var check = tag[i],
            getSnapshot = check.getSnapshot;
          check = check.value;
          try {
            if (!objectIs(getSnapshot(), check)) return !1;
          } catch (error) {
            return !1;
          }
        }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;else {
          if (node === finishedWork) break;
          for (; null === node.sibling;) {
            if (null === node.return || node.return === finishedWork) return !0;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return !0;
    }
    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root, lanes) {
      root.finishedWork = null;
      root.finishedLanes = 0;
      var timeoutHandle = root.timeoutHandle;
      timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
      timeoutHandle = root.cancelPendingCommit;
      null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = !1;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = !1;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root.entangledLanes;
      if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
        var index = 31 - clz32(allEntangledLanes),
          lane = 1 << index;
        lanes |= root[index];
        allEntangledLanes &= ~lane;
      }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      ReactStrictModeWarnings.discardPendingWarnings();
      return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = !1;
      current = null;
      thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));else switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
        case SuspendedOnError:
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
          break;
        case SuspendedOnData:
        case SuspendedOnImmediate:
        case SuspendedOnDeprecatedThrowPromise:
        case SuspendedAndReadyToContinue:
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);
      }
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      markRenderStarted(lanes);
      lanes = !1;
      memoizedUpdaters = workInProgressRootExitStatus;
      a: do try {
        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
          var unitOfWork = workInProgress,
            thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case SuspendedOnHydration:
              resetWorkInProgressStack();
              memoizedUpdaters = RootDidNotComplete;
              break a;
            case SuspendedOnImmediate:
            case SuspendedOnData:
            case SuspendedOnDeprecatedThrowPromise:
              null === suspenseHandlerStackCursor.current && (lanes = !0);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                memoizedUpdaters = RootInProgress;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        memoizedUpdaters = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$8) {
        handleThrow(root, thrownValue$8);
      } while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      markRenderStopped();
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (; null !== workInProgress;) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      markRenderStarted(lanes);
      a: do try {
        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
          case SuspendedOnError:
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
            break;
          case SuspendedOnData:
            if (isThenableResolved(memoizedUpdaters)) {
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
              ensureRootIsScheduled(root);
            };
            memoizedUpdaters.then(lanes, lanes);
            break a;
          case SuspendedOnImmediate:
            workInProgressSuspendedReason = SuspendedAndReadyToContinue;
            break a;
          case SuspendedOnInstance:
            workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
            break a;
          case SuspendedAndReadyToContinue:
            isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
            break;
          case SuspendedOnInstanceAndReadyToContinue:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                  }
                  break b;
                }
                break;
              default:
                console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
            }
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
            break;
          case SuspendedOnDeprecatedThrowPromise:
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
            break;
          case SuspendedOnHydration:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = RootDidNotComplete;
            break a;
          default:
            throw Error("Unexpected SuspendedReason. This is a bug in React.");
        }
        null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();
        break;
      } catch (thrownValue$9) {
        handleThrow(root, thrownValue$9);
      } while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
      markRenderStopped();
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrent() {
      for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      var current = unitOfWork.alternate,
        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);
          break;
        case 11:
          current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current;
    }
    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        var current = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);
        (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (null !== current) {
          workInProgress = current;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child; null !== child;) next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = RootDidNotComplete;
      workInProgress = null;
    }
    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      var prevTransition = ReactSharedInternals.T,
        previousUpdateLanePriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = DiscreteEventPriority, ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
      } finally {
        ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
      }
    }
    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
      do flushPassiveEffects(); while (null !== rootWithPendingPassiveEffects);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
      var finishedWork = root.finishedWork;
      didIncludeRenderPhaseUpdate = root.finishedLanes;
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
      if (null === finishedWork) return markCommitStopped(), null;
      0 === didIncludeRenderPhaseUpdate && console.error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
      root.finishedWork = null;
      root.finishedLanes = 0;
      if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      root.callbackNode = null;
      root.callbackPriority = 0;
      root.cancelPendingCommit = null;
      var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
      remainingLanes |= concurrentlyUpdatedLanes;
      markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);
      root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function () {
        flushPassiveEffects(!0);
        return null;
      }));
      commitStartTime = now();
      transitions = 0 !== (finishedWork.flags & 15990);
      0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = DiscreteEventPriority, updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), restoreSelection(selectionInformation, root.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root.current = finishedWork, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root.current = finishedWork;
      (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
      remainingLanes = root.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      transitions || commitDoubleInvokeEffectsInDEV(root);
      onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
      isDevToolsPresent && root.memoizedUpdaters.clear();
      onCommitRoot();
      ensureRootIsScheduled(root);
      if (null !== recoverableErrors) for (renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);
      0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
      remainingLanes = root.pendingLanes;
      0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0, !1);
      markCommitStopped();
      return null;
    }
    function makeErrorInfo(componentStack) {
      componentStack = {
        componentStack: componentStack
      };
      Object.defineProperty(componentStack, "digest", {
        get: function () {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPassiveEffects() {
      if (null !== rootWithPendingPassiveEffects) {
        var root = rootWithPendingPassiveEffects,
          remainingLanes = pendingPassiveEffectsRemainingLanes;
        pendingPassiveEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
          priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
        renderPriority = ReactSharedInternals.T;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = priority;
          ReactSharedInternals.T = null;
          if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;else {
            priority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = rootWithPendingPassiveEffects,
              lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Cannot flush passive effects while already rendering.");
            isFlushingPassiveEffects = !0;
            didScheduleUpdateDuringPassiveEffects = !1;
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, !1);
            didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
              hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
            }
            var stateNode = root$jscomp$0.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            JSCompiler_inline_result = !0;
          }
          return JSCompiler_inline_result;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
        }
      }
      return !1;
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = !1;
      if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else {
        for (; null !== nearestMountedAncestor;) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error);
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act");
      workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if (0 !== (parentFiber.subtreeFlags & 33562624)) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var root = root$jscomp$0,
          fiber = parentFiber,
          isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
        isStrictModeFiber = isInStrictMode || isStrictModeFiber;
        22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
        parentFiber = parentFiber.sibling;
      }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
      setIsStrictModeForDevtools(!0);
      try {
        disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = !0;
      root.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = !1);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function () {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent && root.memoizedUpdaters.forEach(function (schedulingFiber) {
        addFiberToLanesMap(root, schedulingFiber, lanes);
      });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function () {
        console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
      });
    }
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
      mightHavePendingSyncWork = !0;
      null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do {
          var didPerformSomeWork = !1;
          for (var root = firstScheduledRoot; null !== root;) {
            if (!onlyLegacy) if (0 !== syncTransitionLanes) {
              var pendingLanes = root.pendingLanes;
              if (0 === pendingLanes) var nextLanes = 0;else {
                var suspendedLanes = root.suspendedLanes,
                  pingedLanes = root.pingedLanes;
                nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;
              }
              0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
            } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = !1;
      }
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
      for (var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
        root = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index,
          expirationTime = expirationTimes[index];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);
      pingedLanes = root.callbackNode;
      if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode) cancelCallback(pingedLanes);else return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = !1;
      var originalCallbackNode = root.callbackNode;
      if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPassiveEffects()) return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = !1;
      performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateTask(cb) {
      null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function () {
        cb();
        return null;
      });
      scheduleMicrotask(function () {
        (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp) return null;
      if ("function" === typeof actionProp) return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
          submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
        dispatchQueue.push({
          event: event,
          listeners: [{
            instance: null,
            listener: function () {
              if (nativeEvent.defaultPrevented) {
                if (0 !== currentEventTransitionLane) {
                  var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget),
                    pendingState = {
                      pending: !0,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action
                    };
                  Object.freeze(pendingState);
                  startHostTransition(maybeTargetInst, pendingState, null, formData);
                }
              } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                pending: !0,
                data: formData,
                method: nativeEventTarget.method,
                action: action
              }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
            },
            currentTarget: nativeEventTarget
          }]
        });
      }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = void 0,
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
              instance = _dispatchListeners$i.instance,
              currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) break a;
            previousInstance = event;
            previousInstance.currentTarget = currentTarget;
            try {
              _dispatchListeners$i(previousInstance);
            } catch (error) {
              reportGlobalError(error);
            }
            previousInstance.currentTarget = null;
            previousInstance = instance;
          } else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
            instance = _dispatchListeners$i.instance;
            currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) break a;
            previousInstance = event;
            previousInstance.currentTarget = currentTarget;
            try {
              _dispatchListeners$i(previousInstance);
            } catch (error) {
              reportGlobalError(error);
            }
            previousInstance.currentTarget = null;
            previousInstance = instance;
          }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
      var listenerSet = targetElement[internalEventHandlersKey];
      void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: !0,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
        if (null === targetInst$jscomp$0) return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (3 === nodeTag || 4 === nodeTag) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer) break;
          if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
            var grandTag = nodeTag.tag;
            if (3 === grandTag || 4 === grandTag) if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer) return;
            nodeTag = nodeTag.return;
          }
          for (; null !== container;) {
            nodeTag = getClosestInstanceFromNode(container);
            if (null === nodeTag) return;
            grandTag = nodeTag.tag;
            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance;) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: reactName,
              listeners: inCapturePhase
            }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType) b: {
                  inCapturePhase = SyntheticEventCtor;
                  reactEventName = reactEventType;
                  instance = 0;
                  for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent)) instance++;
                  lastHostComponent = 0;
                  for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2)) lastHostComponent++;
                  for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--;
                  for (; 0 < lastHostComponent - instance;) reactEventName = getParent(reactEventName), lastHostComponent--;
                  for (; instance--;) {
                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                    inCapturePhase = getParent(inCapturePhase);
                    reactEventName = getParent(reactEventName);
                  }
                  inCapturePhase = null;
                } else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;else if (isTextInputElement(reactName)) {
              if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent) b: {
            switch (domEventName) {
              case "compositionstart":
                var eventType = "onCompositionStart";
                break b;
              case "compositionend":
                eventType = "onCompositionEnd";
                break b;
              case "compositionupdate":
                eventType = "onCompositionUpdate";
                break b;
            }
            eventType = void 0;
          } else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: eventType,
            listeners: handleEventFunc
          }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: handleEventFunc,
            listeners: eventType
          }), handleEventFunc.data = fallbackData);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
        var _instance3 = targetFiber,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
        targetFiber = targetFiber.return;
      }
      return listeners;
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return; while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
        var _instance4 = target,
          alternate = _instance4.alternate,
          stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({
        event: event,
        listeners: listeners
      });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      var eventRegistry = {
        registrationNameDependencies: registrationNameDependencies,
        possibleRegistrationNames: possibleRegistrationNames
      };
      isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
    }
    function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
      serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
      attributeNames.forEach(function (attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      !1 === listener ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }
    function normalizeHTML(parent, html) {
      parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if ("string" === typeof value) validateTextNesting(value, tag), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);else if ("number" === typeof value || "bigint" === typeof value) validateTextNesting("" + value, tag), "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            "src" === key ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          null != value && ("form" === tag ? "formAction" === key ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : "input" === tag || "button" === tag ? "action" === key ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = !0, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = !0, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = !0, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : "action" === key ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
          if ("function" === typeof value) {
            domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
          break;
        case "inert":
          "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          !0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
          break;
        case "is":
          null != prevValue && console.error('Cannot update the "is" prop after it has been initialized.');
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = !0, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
        default:
          !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key)) null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);else a: {
            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
              domElement.addEventListener(tag, value, props);
              break a;
            }
            key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
          }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = !1,
            hasSrcSet = !1,
            propKey;
          for (propKey in props) if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue) switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
          }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null,
            checked = null,
            defaultChecked = null;
          for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
            var _propValue = props[hasSrc];
            if (null != _propValue) switch (hasSrc) {
              case "name":
                hasSrcSet = _propValue;
                break;
              case "type":
                propValue = _propValue;
                break;
              case "checked":
                checked = _propValue;
                break;
              case "defaultChecked":
                defaultChecked = _propValue;
                break;
              case "value":
                propKey = _propValue;
                break;
              case "defaultValue":
                defaultValue = _propValue;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != _propValue) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                break;
              default:
                setProp(domElement, tag, hasSrc, _propValue, props, null);
            }
          }
          validateInputProps(domElement, props);
          initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
          track(domElement);
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
            case "selected":
              domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
          return;
        case "dialog":
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props) props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, void 0));
            return;
          }
      }
      for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                lastDefaultValue = lastProp;
              default:
                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
            }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp)) switch (_propKey8) {
              case "type":
                type = propKey;
                break;
              case "name":
                name = propKey;
                break;
              case "checked":
                checked = propKey;
                break;
              case "defaultChecked":
                defaultChecked = propKey;
                break;
              case "value":
                value = propKey;
                break;
              case "defaultValue":
                defaultValue = propKey;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                break;
              default:
                propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);
            }
          }
          tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
          nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
          tag || !nextProps || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = !0);
          !tag || nextProps || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = !0);
          updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
          }
          for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
            case "value":
              _propKey8 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
          }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, !1) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, !0) : updateOptions(domElement, !!tag, tag ? [] : "", !1));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
          for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
            case "value":
              _propKey8 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              break;
            default:
              name !== type && setProp(domElement, tag, value, name, nextProps, type);
          }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps) if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13)) switch (_propKey13) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);
          }
          for (lastDefaultValue in nextProps) if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (lastDefaultValue) {
            case "selected":
              domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
              break;
            default:
              setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);
          }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps) _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);
          for (checked in nextProps) if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != _propKey8) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              break;
            default:
              setProp(domElement, tag, checked, _propKey8, nextProps, propKey);
          }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps) _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, void 0, nextProps, _propKey8);
            for (defaultChecked in nextProps) _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);
            return;
          }
      }
      for (var _propKey19 in lastProps) _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps) _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0; i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0) console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");else if (canDiffStyleForHydrationWarning) {
        var clientValue;
        var delimiter = clientValue = "",
          styleName;
        for (styleName in value$jscomp$0) if (value$jscomp$0.hasOwnProperty(styleName)) {
          var value = value$jscomp$0[styleName];
          null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
        }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (checkAttributeStringCoercion(value, propKey), domElement === "" + value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value) return;
      } else switch (typeof value) {
        case "function":
        case "symbol":
          break;
        default:
          if (value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
          break;
        default:
          if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
        default:
          if (isNaN(value)) return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value)) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (var serverDifferences = {}, extraAttributes = new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++) switch (attributes[i].name.toLowerCase()) {
        case "value":
          break;
        case "checked":
          break;
        case "selected":
          break;
        default:
          extraAttributes.add(attributes[i].name);
      }
      if (isCustomElement(tag)) for (var propKey in props) {
        if (props.hasOwnProperty(propKey)) {
          var value = props[propKey];
          if (null != value) if (registrationNameDependencies.hasOwnProperty(propKey)) "function" !== typeof value && warnForInvalidEventListener(propKey, value);else if (!0 !== props.suppressHydrationWarning) switch (propKey) {
            case "children":
              "string" !== typeof value && "number" !== typeof value || warnForPropDifference("children", domElement.textContent, value, serverDifferences);
              continue;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              continue;
            case "dangerouslySetInnerHTML":
              attributes = domElement.innerHTML;
              value = value ? value.__html : void 0;
              null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));
              continue;
            case "style":
              extraAttributes.delete(propKey);
              diffHydratedStyles(domElement, value, serverDifferences);
              continue;
            case "offsetParent":
            case "offsetTop":
            case "offsetLeft":
            case "offsetWidth":
            case "offsetHeight":
            case "isContentEditable":
            case "outerText":
            case "outerHTML":
              extraAttributes.delete(propKey.toLowerCase());
              console.error("Assignment to read-only property will result in a no-op: `%s`", propKey);
              continue;
            case "className":
              extraAttributes.delete("class");
              attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
              warnForPropDifference("className", attributes, value, serverDifferences);
              continue;
            default:
              hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);
          }
        }
      } else for (value in props) if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) if (registrationNameDependencies.hasOwnProperty(value)) "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);else if (!0 !== props.suppressHydrationWarning) switch (value) {
        case "children":
          "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference("children", domElement.textContent, propKey, serverDifferences);
          continue;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "value":
        case "checked":
        case "selected":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          continue;
        case "dangerouslySetInnerHTML":
          attributes = domElement.innerHTML;
          propKey = propKey ? propKey.__html : void 0;
          null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = {
            __html: attributes
          }));
          continue;
        case "className":
          hydrateAttribute(domElement, value, "class", propKey, extraAttributes, serverDifferences);
          continue;
        case "tabIndex":
          hydrateAttribute(domElement, value, "tabindex", propKey, extraAttributes, serverDifferences);
          continue;
        case "style":
          extraAttributes.delete(value);
          diffHydratedStyles(domElement, propKey, serverDifferences);
          continue;
        case "multiple":
          extraAttributes.delete(value);
          warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);
          continue;
        case "muted":
          extraAttributes.delete(value);
          warnForPropDifference(value, domElement.muted, propKey, serverDifferences);
          continue;
        case "autoFocus":
          extraAttributes.delete("autofocus");
          warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);
          continue;
        case "data":
          if ("object" !== tag) {
            extraAttributes.delete(value);
            attributes = domElement.getAttribute("data");
            warnForPropDifference(value, attributes, propKey, serverDifferences);
            continue;
          }
        case "src":
        case "href":
          if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
            "src" === value ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
            hydrateSanitizedAttribute(domElement, value, value, null, extraAttributes, serverDifferences);
            continue;
          }
          hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "action":
        case "formAction":
          attributes = domElement.getAttribute(value);
          if ("function" === typeof propKey) {
            extraAttributes.delete(value.toLowerCase());
            "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
            continue;
          } else if (attributes === EXPECTED_FORM_ACTION_URL) {
            extraAttributes.delete(value.toLowerCase());
            warnForPropDifference(value, "function", propKey, serverDifferences);
            continue;
          }
          hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkHref":
          hydrateSanitizedAttribute(domElement, value, "xlink:href", propKey, extraAttributes, serverDifferences);
          continue;
        case "contentEditable":
          hydrateBooleanishAttribute(domElement, value, "contenteditable", propKey, extraAttributes, serverDifferences);
          continue;
        case "spellCheck":
          hydrateBooleanishAttribute(domElement, value, "spellcheck", propKey, extraAttributes, serverDifferences);
          continue;
        case "draggable":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
          continue;
        case "capture":
        case "download":
          a: {
            i = domElement;
            var attributeName = attributes = value,
              serverDifferences$jscomp$0 = serverDifferences;
            extraAttributes.delete(attributeName);
            i = i.getAttribute(attributeName);
            if (null === i) switch (typeof propKey) {
              case "undefined":
              case "function":
              case "symbol":
                break a;
              default:
                if (!1 === propKey) break a;
            } else if (null != propKey) switch (typeof propKey) {
              case "function":
              case "symbol":
                break;
              case "boolean":
                if (!0 === propKey && "" === i) break a;
                break;
              default:
                if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey) break a;
            }
            warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
          }
          continue;
        case "cols":
        case "rows":
        case "size":
        case "span":
          a: {
            i = domElement;
            attributeName = attributes = value;
            serverDifferences$jscomp$0 = serverDifferences;
            extraAttributes.delete(attributeName);
            i = i.getAttribute(attributeName);
            if (null === i) switch (typeof propKey) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                break a;
              default:
                if (isNaN(propKey) || 1 > propKey) break a;
            } else if (null != propKey) switch (typeof propKey) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)) break a;
            }
            warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
          }
          continue;
        case "rowSpan":
          hydrateNumericAttribute(domElement, value, "rowspan", propKey, extraAttributes, serverDifferences);
          continue;
        case "start":
          hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "xHeight":
          hydrateAttribute(domElement, value, "x-height", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkActuate":
          hydrateAttribute(domElement, value, "xlink:actuate", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkArcrole":
          hydrateAttribute(domElement, value, "xlink:arcrole", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkRole":
          hydrateAttribute(domElement, value, "xlink:role", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkShow":
          hydrateAttribute(domElement, value, "xlink:show", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkTitle":
          hydrateAttribute(domElement, value, "xlink:title", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkType":
          hydrateAttribute(domElement, value, "xlink:type", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlBase":
          hydrateAttribute(domElement, value, "xml:base", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlLang":
          hydrateAttribute(domElement, value, "xml:lang", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlSpace":
          hydrateAttribute(domElement, value, "xml:space", propKey, extraAttributes, serverDifferences);
          continue;
        case "inert":
          "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
          hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        default:
          if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
            i = getAttributeAlias(value);
            attributes = !1;
            hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = !0, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
            a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0)) {
              if (attributeName.hasAttribute(serverDifferences$jscomp$0)) attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === "" + i ? i : attributeName;else {
                switch (typeof i) {
                  case "function":
                  case "symbol":
                    break a;
                  case "boolean":
                    if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName) break a;
                }
                i = void 0 === i ? void 0 : null;
              }
            } else i = void 0;
            attributes || warnForPropDifference(value, i, propKey, serverDifferences);
          }
      }
      0 < extraAttributes.size && !0 !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
      }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone) switch (type) {
        case "svg":
          return HostContextNamespaceSvg;
        case "math":
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
      return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return !1;
        currentPopstateTransitionEvent = event;
        return !0;
      }
      currentPopstateTransitionEvent = null;
      return !1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      8 === container.nodeType ? container.parentNode.removeChild(child) : container.removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node = suspenseInstance,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, node === SUSPENSE_END_DATA) {
          if (0 === depth) {
            parentInstance.removeChild(nextNode);
            retryIfBlockedOn(suspenseInstance);
            return;
          }
          depth--;
        } else node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || depth++;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
      instance = instance.style;
      "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
      instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode;) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType;) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
        } else if (!inRootOrSingleton) {
          if ("input" === type && "hidden" === instance.type) {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
          } else return instance;
        } else if (!instance[internalHoistableMarker]) switch (type) {
          case "meta":
            if (!instance.hasAttribute("itemprop")) break;
            return instance;
          case "link":
            name = instance.getAttribute("rel");
            if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
            return instance;
          case "style":
            if (instance.hasAttribute("data-precedence")) break;
            return instance;
          case "script":
            name = instance.getAttribute("src");
            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
            return instance;
          default:
            return instance;
        }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType;) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING) break;
          if (nodeType === SUSPENSE_END_DATA) return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (1 === instance.nodeType) {
        for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
        }
        return {
          type: JSCompiler_temp_const,
          props: serverDifferences
        };
      }
      return 8 === instance.nodeType ? {
        type: "Suspense",
        props: {}
      } : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return null === parentProps || !0 !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      suspenseInstance = suspenseInstance.nextSibling;
      for (var depth = 0; suspenseInstance;) {
        if (8 === suspenseInstance.nodeType) {
          var data = suspenseInstance.data;
          if (data === SUSPENSE_END_DATA) {
            if (0 === depth) return getNextHydratable(suspenseInstance.nextSibling);
            depth--;
          } else data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
        }
        suspenseInstance = suspenseInstance.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance;) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
            if (0 === depth) return targetInstance;
            depth--;
          } else data === SUSPENSE_END_DATA && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
      validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        default:
          throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
    }
    function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
      if (getInstanceFromNode(instance)) {
        var tagName = instance.tagName.toLowerCase();
        console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
      for (tagName = instance.attributes; tagName.length;) instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
          rel: rel,
          crossOrigin: crossOrigin,
          href: href
        }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
      if (!resourceRoot) throw Error('"resourceRoot" was expected to exist. This is a bug in React.');
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
              _resource = _styles.get(type);
            if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: {
                loading: NotLoaded,
                preload: null
              }
            }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);
            }
            if (currentProps && null === currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
            return _resource;
          }
          if (currentProps && null !== currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        default:
          throw Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0,
        description = "<link";
      "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
      "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
      "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
      Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function () {
        return state.loading |= Loaded;
      }), key.addEventListener("error", function () {
        return state.loading |= Errored;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance) switch (resource.type) {
        case "style":
          var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
          if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
          var styleProps = assign({}, props, {
            "data-href": props.href,
            "data-precedence": props.precedence,
            href: null,
            precedence: null
          });
          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
          markNodeAsHoistable(instance);
          setInitialProperties(instance, "style", styleProps);
          insertStylesheet(instance, props.precedence, hoistableRoot);
          return resource.instance = instance;
        case "stylesheet":
          styleProps = getStyleKey(props.href);
          var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
          if (_instance) return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
          instance = stylesheetPropsFromRawProps(props);
          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
          _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
          markNodeAsHoistable(_instance);
          var linkInstance = _instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(_instance, "link", instance);
          resource.state.loading |= Inserted;
          insertStylesheet(_instance, props.precedence, hoistableRoot);
          return resource.instance = _instance;
        case "script":
          _instance = getScriptKey(props.src);
          if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
          instance = props;
          if (styleProps = preloadPropsMap.get(_instance)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          styleProps = hoistableRoot.createElement("script");
          markNodeAsHoistable(styleProps);
          setInitialProperties(styleProps, "link", instance);
          hoistableRoot.head.appendChild(styleProps);
          return resource.instance = styleProps;
        case "void":
          return null;
        default:
          throw Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
      } else "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = tagCaches = new Map();
        caches.set(ownerDocument, cache);
      } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
      if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp) return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), !1;
      switch (type) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
            outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.');
            break;
          }
          return !0;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
            if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
              type = props.href;
              var onError = props.onError,
                disabled = props.disabled;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              null != disabled && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += 1 === hostContext.length ? " prop" : " props";
              disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
              hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
            }
            outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (props.onError || props.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), "string" === typeof type && null == props;
            default:
              return !0;
          }
        case "script":
          type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
          if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
            outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
      }
      return !1;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? !1 : !0;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      var state = suspendedState;
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      var state = suspendedState;
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);else if (this.unsuspend) {
        var unsuspend = this.unsuspend;
        this.unsuspend = null;
        unsuspend();
      }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(LAST_PRECEDENCE);else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function bindToConsole(methodName, args, badgeName) {
      var offset = 0;
      switch (methodName) {
        case "dir":
        case "dirxml":
        case "groupEnd":
        case "table":
          return bind.apply(console[methodName], [console].concat(args));
        case "assert":
          offset = 1;
      }
      args = args.slice(0);
      "string" === typeof args[offset] ? args.splice(offset, 1, badgeFormat + args[offset], badgeStyle, pad + badgeName + pad, resetStyle) : args.splice(offset, 0, badgeFormat, badgeStyle, pad + badgeName + pad, resetStyle);
      args.unshift(console);
      return bind.apply(console[methodName], args);
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set();
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
      tag = ConcurrentMode;
      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
      isDevToolsPresent && (tag |= ProfileMode);
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerSync(element, container, parentComponent, callback) {
      0 === container.tag && flushPassiveEffects();
      updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
      return 2;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot) try {
        injectedHook.onScheduleFiberRoot(rendererID, container, element);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = {
        element: element
      };
      callback = void 0 === callback ? null : callback;
      null !== callback && ("function" !== typeof callback && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function getLaneLabelMap() {
      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
        var label = getLabelForLane(lane);
        map.set(lane, label);
        lane *= 2;
      }
      return map;
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn;) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber) switch (fiber.tag) {
              case 3:
                fiber = fiber.stateNode;
                if (fiber.current.memoizedState.isDehydrated) {
                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                  if (0 !== lanes) {
                    var root = fiber;
                    root.pendingLanes |= 2;
                    for (root.entangledLanes |= 2; lanes;) {
                      var lane = 1 << 31 - clz32(lanes);
                      root.entanglements[1] |= lane;
                      lanes &= ~lane;
                    }
                    ensureRootIsScheduled(fiber);
                    (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));
                  }
                }
                break;
              case 13:
                root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
            }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
          return !0;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) if (targetInst = nearestMounted.tag, 13 === targetInst) {
          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function () {
              if (13 === nearestMounted.tag) {
                var lane = requestUpdateLane(nearestMounted),
                  root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
                markRetryLaneIfNotHydrated(nearestMounted, lane);
              }
            });
            return;
          }
        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          return;
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return !1;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn),
            event = nativeEventClone;
          null !== currentReplayingEvent && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          null === currentReplayingEvent && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = null;
        } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
            pending: !0,
            data: formData,
            method: form.method,
            action: submitterOrAction
          }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
        }
      }));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
        var form = i[queuedTarget],
          submitterOrAction = i[queuedTarget + 1],
          formProps = form[internalPropsKey] || null;
        if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);else if (formProps) {
          var action = null;
          if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;else {
              if (null !== findInstanceBlockingTarget(form)) continue;
            }
          } else action = formProps.action;
          "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
          scheduleReplayQueueIfNeeded(i);
        }
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = require(_dependencyMap[0], "scheduler"),
      React = require(_dependencyMap[1], "react"),
      ReactDOM = require(_dependencyMap[2], "react-dom"),
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      assign = Object.assign,
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var current = null,
      isRendering = !1,
      isArrayImpl = Array.isArray,
      ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
      }),
      valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1,
      contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null),
      hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now$1 = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null,
      injectedProfilingHooks = null,
      hasLoggedError = !1,
      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2,
      nextTransitionLane = 128,
      nextRetryLane = 4194304,
      DiscreteEventPriority = 2,
      ContinuousEventPriority = 8,
      DefaultEventPriority = 32,
      IdleEventPriority = 268435456,
      randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey,
      allNativeEvents = new Set(),
      registrationNameDependencies = {},
      possibleRegistrationNames = {},
      canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
      hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      },
      VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {},
      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
      didWarnValueDefaultValue$1 = !1,
      didWarnCheckedDefaultChecked = !1,
      didWarnSelectedSetOnOption = !1,
      didWarnInvalidChild = !1,
      didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = ["value", "defaultValue"],
      didWarnValDefaultVal = !1,
      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
      specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "),
      inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "),
      buttonScopeTags = inScopeTags.concat(["button"]),
      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
      emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null
      },
      didWarn = {},
      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
      shorthandToLonghand = {
        animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
        background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
        fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      },
      uppercasePattern = /([A-Z])/g,
      msPattern$1 = /^ms-/,
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
      msPattern = /^-ms-/,
      hyphenPattern = /-(.)/g,
      badStyleValueWithSemicolonPattern = /;\s*$/,
      warnedStyleNames = {},
      warnedStyleValues = {},
      warnedForNaNValue = !1,
      warnedForInfinityValue = !1,
      unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")),
      aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]),
      possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      },
      ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      },
      warnedProperties$1 = {},
      rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      didWarnValueNull = !1,
      warnedProperties = {},
      EVENT_NAME_REGEX = /^on./,
      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
      rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
      currentReplayingEvent = null,
      restoreTarget = null,
      restoreQueue = null,
      isInsideEventHandler = !1,
      passiveBrowserEventsSupported = !1;
    if (canUseDOM) try {
      var options$jscomp$0 = {};
      Object.defineProperty(options$jscomp$0, "passive", {
        get: function () {
          passiveBrowserEventsSupported = !0;
        }
      });
      window.addEventListener("test", options$jscomp$0, options$jscomp$0);
      window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
    } catch (e) {
      passiveBrowserEventsSupported = !1;
    }
    var root = null,
      startText = null,
      fallbackText = null,
      EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
      }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
      }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
      }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, {
        data: 0
      }),
      SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
      SyntheticInputEvent = SyntheticCompositionEvent,
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      },
      KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      START_KEYCODE = 229,
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
      SPACEBAR_CODE = 32,
      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
      hasSpaceKeypress = !1,
      isComposing = !1,
      supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      },
      activeElement$1 = null,
      activeElementInst$1 = null,
      isInputEventSupported = !1;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is,
      skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1,
      vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" "),
      OffscreenVisible = 1,
      OffscreenDetached = 2,
      OffscreenPassiveEffectsConnected = 4,
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0,
      emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null,
      failedBoundaries = null,
      NoMode = 0,
      ConcurrentMode = 1,
      ProfileMode = 2,
      StrictLegacyMode = 8,
      StrictEffectsMode = 16,
      NoStrictPassiveEffectsMode = 64,
      now = Scheduler.unstable_now,
      renderStartTime = -0,
      commitStartTime = -0,
      profilerStartTime = -1.1,
      profilerEffectDuration = -0,
      currentUpdateIsNested = !1,
      nestedUpdateScheduled = !1,
      ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function () {},
        flushPendingUnsafeLifecycleWarnings: function () {},
        recordLegacyContextWarning: function () {},
        flushLegacyContextWarning: function () {},
        discardPendingWarnings: function () {}
      },
      pendingComponentWillMountWarnings = [],
      pendingUNSAFE_ComponentWillMountWarnings = [],
      pendingComponentWillReceivePropsWarnings = [],
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
      pendingComponentWillUpdateWarnings = [],
      pendingUNSAFE_ComponentWillUpdateWarnings = [],
      didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
      var componentWillMountUniqueNames = new Set();
      0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      var UNSAFE_componentWillMountUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      var componentWillReceivePropsUniqueNames = new Set();
      0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropsWarnings = []);
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
      var componentWillUpdateUniqueNames = new Set();
      0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      var UNSAFE_componentWillUpdateUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", sortedNames));
      0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
    };
    var pendingLegacyContextWarning = new Map(),
      didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
      var strictRoot = null;
      for (var node = fiber; null !== node;) node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
      null === strictRoot ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
      pendingLegacyContextWarning.forEach(function (fiberArray) {
        if (0 !== fiberArray.length) {
          var firstFiber = fiberArray[0],
            uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function () {
            console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", sortedNames);
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function () {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map();
    };
    var CapturedStacks = new WeakMap(),
      forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "",
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      didSuspendOrErrorDEV = !1,
      hydrationDiffRootDEV = null,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
      SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"),
      SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
      noopSuspenseyCommitThenable = {
        then: function () {
          console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
        }
      },
      suspendedThenable = null,
      needsToResetSuspendedThenableDEV = !1,
      callComponent = {
        "react-stack-bottom-frame": function (Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent),
      callRender = {
        "react-stack-bottom-frame": function (instance) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
      callComponentDidMount = {
        "react-stack-bottom-frame": function (finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount),
      callComponentDidUpdate = {
        "react-stack-bottom-frame": function (finishedWork, instance, prevProps, prevState, snapshot) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate),
      callComponentDidCatch = {
        "react-stack-bottom-frame": function (instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      },
      callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch),
      callComponentWillUnmount = {
        "react-stack-bottom-frame": function (current, nearestMountedAncestor, instance) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount),
      callCreate = {
        "react-stack-bottom-frame": function (effect) {
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return effect.destroy = create;
        }
      },
      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
      callDestroy = {
        "react-stack-bottom-frame": function (current, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy),
      callLazyInit = {
        "react-stack-bottom-frame": function (lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      },
      callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
      thenableState$1 = null,
      thenableIndexCounter$1 = 0,
      currentDebugInfo = null,
      didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = !1;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function (returnFiber, workInProgress, child) {
      if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
        if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var componentName = getComponentNameFromFiber(returnFiber),
          componentKey = componentName || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = !0;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
          currentComponentErrorInfo || componentName && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName + ">.");
          var childOwnerAppendix = "";
          null != child && returnFiber !== child && (componentName = null, "number" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = " It was passed a child from " + componentName + "."));
          runWithFiberInDEV(workInProgress, function () {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null,
      SubtreeSuspenseContextMask = 1,
      ForceSuspenseFallback = 2,
      suspenseStackCursor = createCursor(0),
      NoFlags = 0,
      HasEffect = 1,
      Insertion = 2,
      Layout = 4,
      Passive = 8,
      AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function () {
        var listeners = [],
          signal = this.signal = {
            aborted: !1,
            addEventListener: function (type, listener) {
              listeners.push(listener);
            }
          };
        this.abort = function () {
          signal.aborted = !0;
          listeners.forEach(function (listener) {
            return listener();
          });
        };
      },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      },
      currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null,
      prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null),
      didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0,
      currentlyRenderingFiber$1 = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter = 0,
      thenableState = null,
      globalClientIdCounter = 0,
      RE_RENDER_LIMIT = 25,
      currentHookNameInDev = null,
      hookTypesDev = null,
      hookTypesUpdateIndexDev = -1,
      ignorePreviousDependencies = !1;
    var createFunctionComponentUpdateQueue = function () {
      return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
      };
    };
    var ContextOnlyDispatcher = {
      readContext: readContext,
      use: use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError
    };
    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
    ContextOnlyDispatcher.useFormState = throwInvalidHookError;
    ContextOnlyDispatcher.useActionState = throwInvalidHookError;
    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null,
      HooksDispatcherOnMountWithHookTypesInDEV = null,
      HooksDispatcherOnUpdateInDEV = null,
      HooksDispatcherOnRerenderInDEV = null,
      InvalidNestedHooksDispatcherOnMountInDEV = null,
      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
      currentHookNameInDev = "useFormState";
      mountHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useActionState = function (action, initialState) {
      currentHookNameInDev = "useActionState";
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
      currentHookNameInDev = "useOptimistic";
      mountHookTypesDev();
      return mountOptimistic(passthrough);
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function (action, initialState) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function (action, initialState) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function (passthrough) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return mountOptimistic(passthrough);
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnUpdateInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useOptimistic = function (passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnRerenderInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useOptimistic = function (passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function (action, initialState) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOptimistic(passthrough);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function (passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function (passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        isMounted: function (component) {
          var owner = current;
          if (null !== owner && isRendering && 1 === owner.tag) {
            var instance = owner.stateNode;
            instance._warnedAboutRefsInRender || console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(owner) || "A component");
            instance._warnedAboutRefsInRender = !0;
          }
          return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;
        },
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
      },
      reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      },
      componentName = null,
      errorBoundaryName = null,
      SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."),
      didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      },
      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
      valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber = null,
      lastContextDependency = null,
      isDisallowedContextReadInDEV = !1,
      UpdateState = 0,
      ReplaceState = 1,
      ForceUpdate = 2,
      CaptureUpdate = 3,
      hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1,
      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null,
      inProgressLanes = null,
      inProgressRoot = null,
      shouldFireAfterActiveInstanceBlur = !1,
      hostParent = null,
      hostParentIsContainer = !1,
      currentHoistableRoot = null,
      suspenseyCommitFlag = 8192;
    var hasBadMapPolyfill = !1;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$7) {
      hasBadMapPolyfill = !0;
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function (resourceType) {
        var cache = readContext(CacheContext),
          cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      getOwner: function () {
        return current;
      }
    };
    if ("function" === typeof Symbol && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [],
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      NoContext = 0,
      RenderContext = 2,
      CommitContext = 4,
      RootInProgress = 0,
      RootFatalErrored = 1,
      RootErrored = 2,
      RootSuspended = 3,
      RootSuspendedWithDelay = 4,
      RootCompleted = 5,
      RootDidNotComplete = 6,
      executionContext = NoContext,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      NotSuspended = 0,
      SuspendedOnError = 1,
      SuspendedOnData = 2,
      SuspendedOnImmediate = 3,
      SuspendedOnInstance = 4,
      SuspendedOnInstanceAndReadyToContinue = 5,
      SuspendedOnDeprecatedThrowPromise = 6,
      SuspendedAndReadyToContinue = 7,
      SuspendedOnHydration = 8,
      workInProgressSuspendedReason = NotSuspended,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = RootInProgress,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      FALLBACK_THROTTLE_MS = 300,
      workInProgressRootRenderTargetTime = Infinity,
      RENDER_TIMEOUT_MS = 500,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      rootDoesHavePassiveEffects = !1,
      rootWithPendingPassiveEffects = null,
      pendingPassiveEffectsLanes = 0,
      pendingPassiveEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      isFlushingPassiveEffects = !1,
      didScheduleUpdateDuringPassiveEffects = !1,
      NESTED_PASSIVE_UPDATE_LIMIT = 50,
      nestedPassiveUpdateCount = 0,
      rootWithPassiveNestedUpdates = null,
      isRunningInsertionEffect = !1,
      IMMEDIATE_COMMIT = 0,
      SUSPENDED_COMMIT = 1,
      THROTTLED_COMMIT = 2,
      didWarnStateUpdateForNotYetMountedComponent = null,
      didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {},
      firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      didScheduleMicrotask_act = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0,
      fakeActCallbackNode = {};
    (function () {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i],
          domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
      nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)),
      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
      didWarnControlledToUncontrolled = !1,
      didWarnUncontrolledToControlled = !1,
      didWarnFormActionType = !1,
      didWarnFormActionName = !1,
      didWarnFormActionTarget = !1,
      didWarnFormActionMethod = !1,
      didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var canDiffStyleForHydrationWarning = !0;
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
      xlinkNamespace = "http://www.w3.org/1999/xlink",
      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
      EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')",
      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
      SUSPENSE_START_DATA = "$",
      SUSPENSE_END_DATA = "/$",
      SUSPENSE_PENDING_START_DATA = "$?",
      SUSPENSE_FALLBACK_START_DATA = "$!",
      FORM_STATE_IS_MATCHING = "F!",
      FORM_STATE_IS_NOT_MATCHING = "F",
      STYLE = "style",
      HostContextNamespaceNone = 0,
      HostContextNamespaceSvg = 1,
      HostContextNamespaceMath = 2,
      eventsEnabled = null,
      selectionInformation = null,
      warnedUnknownTags = {
        dialog: !0,
        webview: !0
      },
      currentPopstateTransitionEvent = null,
      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
      noTimeout = -1,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function (callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout,
      NotLoaded = 0,
      Loaded = 1,
      Errored = 2,
      Settled = 3,
      Inserted = 4,
      preloadPropsMap = new Map(),
      preconnectsSet = new Set(),
      previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function () {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function (form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      },
      D: function (href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function (href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function (href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign({
            rel: "preload",
            href: "image" === as && options && options.imageSrcSet ? void 0 : href,
            as: as
          }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      },
      m: function (href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options && "string" === typeof options.as ? options.as : "script",
            preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]',
            key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({
            rel: "modulepreload",
            href: href
          }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function (src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
            src: src,
            async: !0
          }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      },
      S: function (href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = {
              loading: NotLoaded,
              preload: null
            };
            if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = Loaded | Inserted;else {
              href = assign({
                rel: "stylesheet",
                href: href,
                "data-precedence": precedence
              }, options);
              (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function () {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function () {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state: state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function (src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
            src: src,
            async: !0,
            type: "module"
          }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
    };
    var globalDocument = "undefined" === typeof document ? null : document,
      tagCaches = null,
      suspendedState = null,
      LAST_PRECEDENCE = null,
      precedencesByRoot = null,
      NotPendingTransition = NotPending,
      HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      },
      badgeFormat = "%c%s%c ",
      badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
      resetStyle = "",
      pad = " ",
      bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null,
      overrideHookStateDeletePath = null,
      overrideHookStateRenamePath = null,
      overrideProps = null,
      overridePropsDeletePath = null,
      overridePropsRenamePath = null,
      scheduleUpdate = null,
      setErrorHandler = null,
      setSuspenseHandler = null;
    overrideHookState = function (fiber, id, path, value) {
      id = findHook(fiber, id);
      null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function (fiber, id, path) {
      id = findHook(fiber, id);
      null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function (fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function (fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function (fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function (fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    setErrorHandler = function (newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function (newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0,
      return_targetInst = null,
      hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "),
      lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children, JSCompiler_OptimizeArgumentsArray_p2) {
      var root = this._internalRoot;
      if (null === root) throw Error("Cannot update an unmounted root.");
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p2 ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(JSCompiler_OptimizeArgumentsArray_p2) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : "undefined" !== typeof JSCompiler_OptimizeArgumentsArray_p2 && console.error("You passed a second argument to root.render(...) but it only accepts one argument.");
      JSCompiler_OptimizeArgumentsArray_p2 = root.current;
      var lane = requestUpdateLane(JSCompiler_OptimizeArgumentsArray_p2);
      updateContainerImpl(JSCompiler_OptimizeArgumentsArray_p2, lane, children, root, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function (JSCompiler_OptimizeArgumentsArray_p3) {
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p3 && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      JSCompiler_OptimizeArgumentsArray_p3 = this._internalRoot;
      if (null !== JSCompiler_OptimizeArgumentsArray_p3) {
        this._internalRoot = null;
        var container = JSCompiler_OptimizeArgumentsArray_p3.containerInfo;
        (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
        updateContainerSync(null, JSCompiler_OptimizeArgumentsArray_p3, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = {
          blockedOn: null,
          target: target,
          priority: updatePriority
        };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    (function () {
      var isomorphicReactPackageVersion = React.version;
      if ("19.0.0" !== isomorphicReactPackageVersion) throw Error('Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.0.0\nLearn more: https://react.dev/warnings/version-mismatch"));
    })();
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render) throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (!function () {
      var internals = {
        bundleType: 1,
        version: "19.0.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        findFiberByHostInstance: getClosestInstanceFromNode,
        reconcilerVersion: "19.0.0"
      };
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProps;
      internals.overridePropsDeletePath = overridePropsDeletePath;
      internals.overridePropsRenamePath = overridePropsRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevTools;
      internals.getLaneLabelMap = getLaneLabelMap;
      internals.injectProfilingHooks = injectProfilingHooks;
      return injectInternals(internals);
    }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""), "font-weight:bold");
    }
    exports.createRoot = function (container, options) {
      if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null;
      null !== options && void 0 !== options && (options.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"), !0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
      options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(8 === container.nodeType ? container.parentNode : container);
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function (container, initialChildren, options) {
      if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      void 0 === initialChildren && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null,
        formState = null;
      null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      initialChildren.current.lanes = isStrictMode;
      markRootUpdated$1(initialChildren, isStrictMode);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},90,[91,3,93],"node_modules\\react-dom\\cjs\\react-dom-client.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/scheduler.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/scheduler.development.js");
  }
},91,[4,92],"node_modules\\scheduler\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function performWorkUntilDeadline() {
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          a: {
            isHostCallbackScheduled = !1;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = !0;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = !0;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = !0;else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = !1;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index;) {
        var parentIndex = index - 1 >>> 1,
          parent = heap[parentIndex];
        if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0],
        last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer;) {
        if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();else {
        var firstTimer = peek(timerQueue);
        null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
    function shouldYieldToHost() {
      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback() {
      isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date,
        initialTime = localDate.now();
      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
      localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
      localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null,
      isMessageLoopRunning = !1,
      taskTimeoutID = -1,
      frameInterval = 5,
      startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function () {
      localSetImmediate(performWorkUntilDeadline);
    };else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(),
        port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function () {
        port.postMessage(null);
      };
    } else schedulePerformWorkUntilDeadline = function () {
      localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function () {
      isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function (fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function () {
      return peek(taskQueue);
    };
    exports.unstable_next = function (eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function () {};
    exports.unstable_requestPaint = function () {};
    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function (callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},92,[],"node_modules\\scheduler\\cjs\\scheduler.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      // This branch is unreachable because this function is only called
      // in production, but the condition is true only in development.
      // Therefore if the branch is still here, dead code elimination wasn't
      // properly applied.
      // Don't change the message. React DevTools relies on it. Also make sure
      // this message doesn't occur elsewhere in this function, or it will cause
      // a false positive.
      throw new Error('^_^');
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  if (process.env.NODE_ENV === 'production') {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0], "./cjs/react-dom.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-dom.development.js");
  }
},93,[4,94],"node_modules\\react-dom\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input) return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require(_dependencyMap[0], "react"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function (children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : null != options && "string" !== typeof options.crossOrigin && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href) console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : "style" !== options.as && "script" !== options.as && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity = "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority
        }) : "script" === as && Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered) console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);else switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
        case "script":
          break;
        default:
          encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
      }
      if ("string" === typeof href) if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
        crossOrigin: encountered,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},94,[3],"node_modules\\react-dom\\cjs\\react-dom.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unmountComponentAtNode;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function unmountComponentAtNode(rootTag) {
    rootTag.unmount();
    return true;
  }
},95,[],"node_modules\\react-native-web\\dist\\exports\\unmountComponentAtNode\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _UIManager = _interopRequireDefault(require(_dependencyMap[1], "../UIManager"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // NativeModules shim
  var NativeModules = {
    UIManager: _UIManager.default
  };
  var _default = exports.default = NativeModules;
},96,[17,97],"node_modules\\react-native-web\\dist\\exports\\NativeModules\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _getBoundingClientRect = _interopRequireDefault(require(_dependencyMap[1], "../../modules/getBoundingClientRect"));
  var _setValueForStyles = _interopRequireDefault(require(_dependencyMap[2], "../../modules/setValueForStyles"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getRect = node => {
    var height = node.offsetHeight;
    var width = node.offsetWidth;
    var left = node.offsetLeft;
    var top = node.offsetTop;
    node = node.offsetParent;
    while (node && node.nodeType === 1 /* Node.ELEMENT_NODE */) {
      left += node.offsetLeft + node.clientLeft - node.scrollLeft;
      top += node.offsetTop + node.clientTop - node.scrollTop;
      node = node.offsetParent;
    }
    top -= window.scrollY;
    left -= window.scrollX;
    return {
      width,
      height,
      top,
      left
    };
  };
  var measureLayout = (node, relativeToNativeNode, callback) => {
    var relativeNode = relativeToNativeNode || node && node.parentNode;
    if (node && relativeNode) {
      setTimeout(() => {
        if (node.isConnected && relativeNode.isConnected) {
          var relativeRect = getRect(relativeNode);
          var _getRect = getRect(node),
            height = _getRect.height,
            left = _getRect.left,
            top = _getRect.top,
            width = _getRect.width;
          var x = left - relativeRect.left;
          var y = top - relativeRect.top;
          callback(x, y, width, height, left, top);
        }
      }, 0);
    }
  };
  var elementsToIgnore = {
    A: true,
    BODY: true,
    INPUT: true,
    SELECT: true,
    TEXTAREA: true
  };
  var UIManager = {
    blur(node) {
      try {
        node.blur();
      } catch (err) {}
    },
    focus(node) {
      try {
        var name = node.nodeName;
        // A tabIndex of -1 allows element to be programmatically focused but
        // prevents keyboard focus. We don't want to set the tabindex value on
        // elements that should not prevent keyboard focus.
        if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {
          node.setAttribute('tabIndex', '-1');
        }
        node.focus();
      } catch (err) {}
    },
    measure(node, callback) {
      measureLayout(node, null, callback);
    },
    measureInWindow(node, callback) {
      if (node) {
        setTimeout(() => {
          var _getBoundingClientRec = (0, _getBoundingClientRect.default)(node),
            height = _getBoundingClientRec.height,
            left = _getBoundingClientRec.left,
            top = _getBoundingClientRec.top,
            width = _getBoundingClientRec.width;
          callback(left, top, width, height);
        }, 0);
      }
    },
    measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
      measureLayout(node, relativeToNativeNode, onSuccess);
    },
    updateView(node, props) {
      for (var prop in props) {
        if (!Object.prototype.hasOwnProperty.call(props, prop)) {
          continue;
        }
        var value = props[prop];
        switch (prop) {
          case 'style':
            {
              (0, _setValueForStyles.default)(node, value);
              break;
            }
          case 'class':
          case 'className':
            {
              node.setAttribute('class', value);
              break;
            }
          case 'text':
          case 'value':
            // native platforms use `text` prop to replace text input value
            node.value = value;
            break;
          default:
            node.setAttribute(prop, value);
        }
      }
    },
    configureNextLayoutAnimation(config, onAnimationDidEnd) {
      onAnimationDidEnd();
    },
    // mocks
    setLayoutAnimationEnabledExperimental() {}
  };
  var _default = exports.default = UIManager;
},97,[17,98,99],"node_modules\\react-native-web\\dist\\exports\\UIManager\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getBoundingClientRect = node => {
    if (node != null) {
      var isElement = node.nodeType === 1; /* Node.ELEMENT_NODE */
      if (isElement && typeof node.getBoundingClientRect === 'function') {
        return node.getBoundingClientRect();
      }
    }
  };
  var _default = exports.default = getBoundingClientRect;
},98,[],"node_modules\\react-native-web\\dist\\modules\\getBoundingClientRect\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _dangerousStyleValue = _interopRequireDefault(require(_dependencyMap[1], "./dangerousStyleValue"));
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.3.0
   * 
   */

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  function setValueForStyles(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = (0, _dangerousStyleValue.default)(styleName, styles[styleName], isCustomProperty);
      if (styleName === 'float') {
        styleName = 'cssFloat';
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else {
        style[styleName] = styleValue;
      }
    }
  }
  var _default = exports.default = setValueForStyles;
},99,[17,100],"node_modules\\react-native-web\\dist\\modules\\setValueForStyles\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _unitlessNumbers = _interopRequireDefault(require(_dependencyMap[1], "../unitlessNumbers"));
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   * 
   */

  /**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @return {string} Normalized style value with dimensions applied.
   */
  function dangerousStyleValue(name, value, isCustomProperty) {
    // Note that we've removed escapeTextForBrowser() calls here since the
    // whole string will be escaped when the attribute is injected into
    // the markup. If you provide unsafe user data here they can inject
    // arbitrary CSS which may be problematic (I couldn't repro this):
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
    // This is not an XSS hole but instead a potential CSS injection issue
    // which has lead to a greater discussion about how we're going to
    // trust URLs moving forward. See #2115901

    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(_unitlessNumbers.default.hasOwnProperty(name) && _unitlessNumbers.default[name])) {
      return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
    }
    return ('' + value).trim();
  }
  var _default = exports.default = dangerousStyleValue;
},100,[17,101],"node_modules\\react-native-web\\dist\\modules\\setValueForStyles\\dangerousStyleValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = exports.default = unitlessNumbers;
},101,[],"node_modules\\react-native-web\\dist\\modules\\unitlessNumbers\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../../modules/canUseDom"));
  function isScreenReaderEnabled() {
    return new Promise((resolve, reject) => {
      resolve(true);
    });
  }
  var prefersReducedMotionMedia = _canUseDom.default && typeof window.matchMedia === 'function' ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
  function isReduceMotionEnabled() {
    return new Promise((resolve, reject) => {
      resolve(prefersReducedMotionMedia ? prefersReducedMotionMedia.matches : true);
    });
  }
  function addChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.addEventListener != null ? prefersReducedMotionMedia.addEventListener('change', fn) : prefersReducedMotionMedia.addListener(fn);
    }
  }
  function removeChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.removeEventListener != null ? prefersReducedMotionMedia.removeEventListener('change', fn) : prefersReducedMotionMedia.removeListener(fn);
    }
  }
  var handlers = {};
  var AccessibilityInfo = {
    /**
     * Query whether a screen reader is currently enabled.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isScreenReaderEnabled,
    /**
     * Query whether the user prefers reduced motion.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isReduceMotionEnabled,
    /**
     * Deprecated
     */
    fetch: isScreenReaderEnabled,
    /**
     * Add an event handler. Supported events: reduceMotionChanged
     */
    addEventListener: function addEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        if (!prefersReducedMotionMedia) {
          return;
        }
        var listener = event => {
          handler(event.matches);
        };
        addChangeListener(listener);
        handlers[handler] = listener;
      }
      return {
        remove: () => AccessibilityInfo.removeEventListener(eventName, handler)
      };
    },
    /**
     * Set accessibility focus to a react component.
     */
    setAccessibilityFocus: function setAccessibilityFocus(reactTag) {},
    /**
     * Post a string to be announced by the screen reader.
     */
    announceForAccessibility: function announceForAccessibility(announcement) {},
    /**
     * Remove an event handler.
     */
    removeEventListener: function removeEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        var listener = handlers[handler];
        if (!listener || !prefersReducedMotionMedia) {
          return;
        }
        removeChangeListener(listener);
      }
      return;
    }
  };
  var _default = exports.default = AccessibilityInfo;
},102,[17,39],"node_modules\\react-native-web\\dist\\exports\\AccessibilityInfo\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Alert {
    static alert() {}
  }
  var _default = exports.default = Alert;
},103,[],"node_modules\\react-native-web\\dist\\exports\\Alert\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Animated = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/Animated/Animated"));
  var _default = exports.default = _Animated.default;
},104,[17,105],"node_modules\\react-native-web\\dist\\exports\\Animated\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "../../../exports/Platform"));
  var _AnimatedFlatList = _interopRequireDefault(require(_dependencyMap[3], "./components/AnimatedFlatList"));
  var _AnimatedImage = _interopRequireDefault(require(_dependencyMap[4], "./components/AnimatedImage"));
  var _AnimatedScrollView = _interopRequireDefault(require(_dependencyMap[5], "./components/AnimatedScrollView"));
  var _AnimatedSectionList = _interopRequireDefault(require(_dependencyMap[6], "./components/AnimatedSectionList"));
  var _AnimatedText = _interopRequireDefault(require(_dependencyMap[7], "./components/AnimatedText"));
  var _AnimatedView = _interopRequireDefault(require(_dependencyMap[8], "./components/AnimatedView"));
  var _AnimatedMock = _interopRequireDefault(require(_dependencyMap[9], "./AnimatedMock"));
  var _AnimatedImplementation = _interopRequireDefault(require(_dependencyMap[10], "./AnimatedImplementation"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var Animated = _Platform.default.isTesting ? _AnimatedMock.default : _AnimatedImplementation.default;
  var _default = exports.default = (0, _objectSpread2.default)({
    FlatList: _AnimatedFlatList.default,
    Image: _AnimatedImage.default,
    ScrollView: _AnimatedScrollView.default,
    SectionList: _AnimatedSectionList.default,
    Text: _AnimatedText.default,
    View: _AnimatedView.default
  }, Animated);
},105,[17,868,106,107,179,184,185,189,191,192,193],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\Animated.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var Platform = {
    OS: 'web',
    select: obj => 'web' in obj ? obj.web : obj.default,
    get isTesting() {
      if (process.env.NODE_ENV === 'test') {
        return true;
      }
      return false;
    }
  };
  var _default = exports.default = Platform;
},106,[],"node_modules\\react-native-web\\dist\\exports\\Platform\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _FlatList = _interopRequireDefault(require(_dependencyMap[3], "../../../../exports/FlatList"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[4], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var FlatListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_FlatList.default, (0, _extends2.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = exports.default = (0, _createAnimatedComponent.default)(FlatListWithEventThrottle);
},107,[17,888,3,109,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedFlatList.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _FlatList = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/FlatList"));
  var _default = exports.default = _FlatList.default;
},109,[17,110],"node_modules\\react-native-web\\dist\\exports\\FlatList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectSpread2"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "../../../exports/View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../../../exports/StyleSheet"));
  var _deepDiffer = _interopRequireDefault(require(_dependencyMap[6], "../deepDiffer"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[7], "../../../exports/Platform"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[8], "fbjs/lib/invariant"));
  var React = _interopRequireWildcard(require(_dependencyMap[9], "react"));
  var _VirtualizedList = _interopRequireDefault(require(_dependencyMap[10], "../VirtualizedList"));
  var _VirtualizeUtils = require(_dependencyMap[11], "../VirtualizeUtils");
  var _memoizeOne = _interopRequireDefault(require(_dependencyMap[12], "memoize-one"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["numColumns", "columnWrapperStyle", "removeClippedSubviews", "strictMode"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // removeClippedSubviewsOrDefault(this.props.removeClippedSubviews)
  function removeClippedSubviewsOrDefault(removeClippedSubviews) {
    return removeClippedSubviews !== null && removeClippedSubviews !== void 0 ? removeClippedSubviews : _Platform.default.OS === 'android';
  }

  // numColumnsOrDefault(this.props.numColumns)
  function numColumnsOrDefault(numColumns) {
    return numColumns !== null && numColumns !== void 0 ? numColumns : 1;
  }
  function isArrayLike(data) {
    // $FlowExpectedError[incompatible-use]
    return typeof Object(data).length === 'number';
  }
  /**
   * A performant interface for rendering simple, flat lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Optional horizontal mode.
   *  - Configurable viewability callbacks.
   *  - Header support.
   *  - Footer support.
   *  - Separator support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *  - ScrollToIndex support.
   *
   * If you need section support, use [`<SectionList>`](docs/sectionlist.html).
   *
   * Minimal Example:
   *
   *     <FlatList
   *       data={[{key: 'a'}, {key: 'b'}]}
   *       renderItem={({item}) => <Text>{item.key}</Text>}
   *     />
   *
   * More complex, multi-select example demonstrating `PureComponent` usage for perf optimization and avoiding bugs.
   *
   * - By binding the `onPressItem` handler, the props will remain `===` and `PureComponent` will
   *   prevent wasteful re-renders unless the actual `id`, `selected`, or `title` props change, even
   *   if the components rendered in `MyListItem` did not have such optimizations.
   * - By passing `extraData={this.state}` to `FlatList` we make sure `FlatList` itself will re-render
   *   when the `state.selected` changes. Without setting this prop, `FlatList` would not know it
   *   needs to re-render any items because it is also a `PureComponent` and the prop comparison will
   *   not show any changes.
   * - `keyExtractor` tells the list to use the `id`s for the react keys instead of the default `key` property.
   *
   *
   *     class MyListItem extends React.PureComponent {
   *       _onPress = () => {
   *         this.props.onPressItem(this.props.id);
   *       };
   *
   *       render() {
   *         const textColor = this.props.selected ? "red" : "black";
   *         return (
   *           <TouchableOpacity onPress={this._onPress}>
   *             <View>
   *               <Text style={{ color: textColor }}>
   *                 {this.props.title}
   *               </Text>
   *             </View>
   *           </TouchableOpacity>
   *         );
   *       }
   *     }
   *
   *     class MultiSelectList extends React.PureComponent {
   *       state = {selected: (new Map(): Map<string, boolean>)};
   *
   *       _keyExtractor = (item, index) => item.id;
   *
   *       _onPressItem = (id: string) => {
   *         // updater functions are preferred for transactional updates
   *         this.setState((state) => {
   *           // copy the map rather than modifying state.
   *           const selected = new Map(state.selected);
   *           selected.set(id, !selected.get(id)); // toggle
   *           return {selected};
   *         });
   *       };
   *
   *       _renderItem = ({item}) => (
   *         <MyListItem
   *           id={item.id}
   *           onPressItem={this._onPressItem}
   *           selected={!!this.state.selected.get(item.id)}
   *           title={item.title}
   *         />
   *       );
   *
   *       render() {
   *         return (
   *           <FlatList
   *             data={this.props.data}
   *             extraData={this.state}
   *             keyExtractor={this._keyExtractor}
   *             renderItem={this._renderItem}
   *           />
   *         );
   *       }
   *     }
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist.html),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   * Also inherits [ScrollView Props](docs/scrollview.html#props), unless it is nested in another FlatList of same orientation.
   */
  class FlatList extends React.PureComponent {
    /**
     * Scrolls to the end of the content. May be janky without `getItemLayout` prop.
     */
    scrollToEnd(params) {
      if (this._listRef) {
        this._listRef.scrollToEnd(params);
      }
    }

    /**
     * Scrolls to the item at the specified index such that it is positioned in the viewable area
     * such that `viewPosition` 0 places it at the top, 1 at the bottom, and 0.5 centered in the
     * middle. `viewOffset` is a fixed number of pixels to offset the final target position.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToIndex(params) {
      if (this._listRef) {
        this._listRef.scrollToIndex(params);
      }
    }

    /**
     * Requires linear scan through data - use `scrollToIndex` instead if possible.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToItem(params) {
      if (this._listRef) {
        this._listRef.scrollToItem(params);
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Check out [scrollToOffset](docs/virtualizedlist.html#scrolltooffset) of VirtualizedList
     */
    scrollToOffset(params) {
      if (this._listRef) {
        this._listRef.scrollToOffset(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      if (this._listRef) {
        this._listRef.recordInteraction();
      }
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      if (this._listRef) {
        this._listRef.flashScrollIndicators();
      }
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      if (this._listRef) {
        return this._listRef.getScrollResponder();
      }
    }

    /**
     * Provides a reference to the underlying host component
     */
    getNativeScrollRef() {
      if (this._listRef) {
        /* $FlowFixMe[incompatible-return] Suppresses errors found when fixing
         * TextInput typing */
        return this._listRef.getScrollRef();
      }
    }
    getScrollableNode() {
      if (this._listRef) {
        return this._listRef.getScrollableNode();
      }
    }
    constructor(_props) {
      super(_props);
      this._virtualizedListPairs = [];
      this._captureRef = ref => {
        this._listRef = ref;
      };
      this._getItem = (data, index) => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (numColumns > 1) {
          var ret = [];
          for (var kk = 0; kk < numColumns; kk++) {
            var itemIndex = index * numColumns + kk;
            if (itemIndex < data.length) {
              var _item = data[itemIndex];
              ret.push(_item);
            }
          }
          return ret;
        } else {
          return data[index];
        }
      };
      this._getItemCount = data => {
        // Legacy behavior of FlatList was to forward "undefined" length if invalid
        // data like a non-arraylike object is passed. VirtualizedList would then
        // coerce this, and the math would work out to no-op. For compatibility, if
        // invalid data is passed, we tell VirtualizedList there are zero items
        // available to prevent it from trying to read from the invalid data
        // (without propagating invalidly typed data).
        if (data != null && isArrayLike(data)) {
          var numColumns = numColumnsOrDefault(this.props.numColumns);
          return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
        } else {
          return 0;
        }
      };
      this._keyExtractor = (items, index) => {
        var _this$props$keyExtrac;
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        var keyExtractor = (_this$props$keyExtrac = this.props.keyExtractor) !== null && _this$props$keyExtrac !== void 0 ? _this$props$keyExtrac : _VirtualizeUtils.keyExtractor;
        if (numColumns > 1) {
          (0, _invariant.default)(Array.isArray(items), 'FlatList: Encountered internal consistency error, expected each item to consist of an ' + 'array with 1-%s columns; instead, received a single item.', numColumns);
          return items.map((item, kk) => keyExtractor(item, index * numColumns + kk)).join(':');
        }

        // $FlowFixMe[incompatible-call] Can't call keyExtractor with an array
        return keyExtractor(items, index);
      };
      this._renderer = (ListItemComponent, renderItem, columnWrapperStyle, numColumns, extraData
      // $FlowFixMe[missing-local-annot]
      ) => {
        var cols = numColumnsOrDefault(numColumns);
        var render = props => {
          if (ListItemComponent) {
            // $FlowFixMe[not-a-component] Component isn't valid
            // $FlowFixMe[incompatible-type-arg] Component isn't valid
            // $FlowFixMe[incompatible-return] Component isn't valid
            return /*#__PURE__*/React.createElement(ListItemComponent, props);
          } else if (renderItem) {
            // $FlowFixMe[incompatible-call]
            return renderItem(props);
          } else {
            return null;
          }
        };
        var renderProp = info => {
          if (cols > 1) {
            var _item2 = info.item,
              _index = info.index;
            (0, _invariant.default)(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
            return /*#__PURE__*/React.createElement(_View.default, {
              style: [styles.row, columnWrapperStyle]
            }, _item2.map((it, kk) => {
              var element = render({
                // $FlowFixMe[incompatible-call]
                item: it,
                index: _index * cols + kk,
                separators: info.separators
              });
              return element != null ? /*#__PURE__*/React.createElement(React.Fragment, {
                key: kk
              }, element) : null;
            }));
          } else {
            return render(info);
          }
        };
        return ListItemComponent ? {
          ListItemComponent: renderProp
        } : {
          renderItem: renderProp
        };
      };
      this._memoizedRenderer = (0, _memoizeOne.default)(this._renderer);
      this._checkProps(this.props);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityConfig: pair.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
        }));
      } else if (this.props.onViewableItemsChanged) {
        this._virtualizedListPairs.push({
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          viewabilityConfig: this.props.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
        });
      }
    }

    // $FlowFixMe[missing-local-annot]
    componentDidUpdate(prevProps) {
      (0, _invariant.default)(prevProps.numColumns === this.props.numColumns, 'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' + 'changing the number of columns to force a fresh render of the component.');
      (0, _invariant.default)(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
      (0, _invariant.default)(!(0, _deepDiffer.default)(prevProps.viewabilityConfig, this.props.viewabilityConfig), 'Changing viewabilityConfig on the fly is not supported');
      (0, _invariant.default)(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');
      this._checkProps(this.props);
    }
    // $FlowFixMe[missing-local-annot]
    _checkProps(props) {
      var getItem = props.getItem,
        getItemCount = props.getItemCount,
        horizontal = props.horizontal,
        columnWrapperStyle = props.columnWrapperStyle,
        onViewableItemsChanged = props.onViewableItemsChanged,
        viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      (0, _invariant.default)(!getItem && !getItemCount, 'FlatList does not support custom data formats.');
      if (numColumns > 1) {
        (0, _invariant.default)(!horizontal, 'numColumns does not support horizontal.');
      } else {
        (0, _invariant.default)(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
      }
      (0, _invariant.default)(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), 'FlatList does not support setting both onViewableItemsChanged and ' + 'viewabilityConfigCallbackPairs.');
    }
    _pushMultiColumnViewable(arr, v) {
      var _this$props$keyExtrac2;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      var keyExtractor = (_this$props$keyExtrac2 = this.props.keyExtractor) !== null && _this$props$keyExtrac2 !== void 0 ? _this$props$keyExtrac2 : _VirtualizeUtils.keyExtractor;
      v.item.forEach((item, ii) => {
        (0, _invariant.default)(v.index != null, 'Missing index!');
        var index = v.index * numColumns + ii;
        arr.push((0, _objectSpread2.default)((0, _objectSpread2.default)({}, v), {}, {
          item,
          key: keyExtractor(item, index),
          index
        }));
      });
    }
    _createOnViewableItemsChanged(onViewableItemsChanged
    // $FlowFixMe[missing-local-annot]
    ) {
      return info => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (onViewableItemsChanged) {
          if (numColumns > 1) {
            var changed = [];
            var viewableItems = [];
            info.viewableItems.forEach(v => this._pushMultiColumnViewable(viewableItems, v));
            info.changed.forEach(v => this._pushMultiColumnViewable(changed, v));
            onViewableItemsChanged({
              viewableItems,
              changed
            });
          } else {
            onViewableItemsChanged(info);
          }
        }
      };
    }

    // $FlowFixMe[missing-local-annot]

    render() {
      var _this$props = this.props,
        numColumns = _this$props.numColumns,
        columnWrapperStyle = _this$props.columnWrapperStyle,
        _removeClippedSubviews = _this$props.removeClippedSubviews,
        _this$props$strictMod = _this$props.strictMode,
        strictMode = _this$props$strictMod === void 0 ? false : _this$props$strictMod,
        restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      var renderer = strictMode ? this._memoizedRenderer : this._renderer;
      return (/*#__PURE__*/
        // $FlowFixMe[incompatible-exact] - `restProps` (`Props`) is inexact.
        React.createElement(_VirtualizedList.default, (0, _extends2.default)({}, restProps, {
          getItem: this._getItem,
          getItemCount: this._getItemCount,
          keyExtractor: this._keyExtractor,
          ref: this._captureRef,
          viewabilityConfigCallbackPairs: this._virtualizedListPairs,
          removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
        }, renderer(this.props.ListItemComponent, this.props.renderItem, columnWrapperStyle, numColumns, this.props.extraData)))
      );
    }
  }
  var styles = _StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    }
  });
  var _default = exports.default = FlatList;
},110,[17,888,873,868,111,30,128,106,129,3,130,156,892],"node_modules\\react-native-web\\dist\\vendor\\react-native\\FlatList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[3], "../createElement"));
  var forwardedProps = _interopRequireWildcard(require(_dependencyMap[4], "../../modules/forwardedProps"));
  var _pick = _interopRequireDefault(require(_dependencyMap[5], "../../modules/pick"));
  var _useElementLayout = _interopRequireDefault(require(_dependencyMap[6], "../../modules/useElementLayout"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[7], "../../modules/useMergeRefs"));
  var _usePlatformMethods = _interopRequireDefault(require(_dependencyMap[8], "../../modules/usePlatformMethods"));
  var _useResponderEvents = _interopRequireDefault(require(_dependencyMap[9], "../../modules/useResponderEvents"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[10], "../StyleSheet"));
  var _TextAncestorContext = _interopRequireDefault(require(_dependencyMap[11], "../Text/TextAncestorContext"));
  var _useLocale = require(_dependencyMap[12], "../../modules/useLocale");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["hrefAttrs", "onLayout", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture"];
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    onScroll: true,
    onWheel: true,
    pointerEvents: true
  });
  var pickProps = props => (0, _pick.default)(props, forwardPropsList);
  var View = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    if (process.env.NODE_ENV !== 'production') {
      React.Children.toArray(props.children).forEach(item => {
        if (typeof item === 'string') {
          console.error("Unexpected text node: " + item + ". A text node cannot be a child of a <View>.");
        }
      });
    }
    var hasTextAncestor = React.useContext(_TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, _useElementLayout.default)(hostRef, onLayout);
    (0, _useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var component = 'div';
    var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    supportedProps.style = [styles.view$raw, hasTextAncestor && styles.inline, props.style];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
    var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, _createElement.default)(component, supportedProps, {
      writingDirection
    });
  });
  View.displayName = 'View';
  var styles = _StyleSheet.default.create({
    view$raw: {
      alignContent: 'flex-start',
      alignItems: 'stretch',
      backgroundColor: 'transparent',
      border: '0 solid black',
      boxSizing: 'border-box',
      display: 'flex',
      flexBasis: 'auto',
      flexDirection: 'column',
      flexShrink: 0,
      listStyle: 'none',
      margin: 0,
      minHeight: 0,
      minWidth: 0,
      padding: 0,
      position: 'relative',
      textDecoration: 'none',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    }
  });
  var _default = exports.default = View;
},111,[17,873,3,18,112,113,114,116,118,120,30,127,85],"node_modules\\react-native-web\\dist\\exports\\View\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.touchProps = exports.styleProps = exports.mouseProps = exports.keyboardProps = exports.focusProps = exports.defaultProps = exports.clickProps = exports.accessibilityProps = void 0;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultProps = exports.defaultProps = {
    children: true,
    dataSet: true,
    dir: true,
    id: true,
    ref: true,
    suppressHydrationWarning: true,
    tabIndex: true,
    testID: true,
    // @deprecated
    focusable: true,
    nativeID: true
  };
  var accessibilityProps = exports.accessibilityProps = {
    'aria-activedescendant': true,
    'aria-atomic': true,
    'aria-autocomplete': true,
    'aria-busy': true,
    'aria-checked': true,
    'aria-colcount': true,
    'aria-colindex': true,
    'aria-colspan': true,
    'aria-controls': true,
    'aria-current': true,
    'aria-describedby': true,
    'aria-details': true,
    'aria-disabled': true,
    'aria-errormessage': true,
    'aria-expanded': true,
    'aria-flowto': true,
    'aria-haspopup': true,
    'aria-hidden': true,
    'aria-invalid': true,
    'aria-keyshortcuts': true,
    'aria-label': true,
    'aria-labelledby': true,
    'aria-level': true,
    'aria-live': true,
    'aria-modal': true,
    'aria-multiline': true,
    'aria-multiselectable': true,
    'aria-orientation': true,
    'aria-owns': true,
    'aria-placeholder': true,
    'aria-posinset': true,
    'aria-pressed': true,
    'aria-readonly': true,
    'aria-required': true,
    role: true,
    'aria-roledescription': true,
    'aria-rowcount': true,
    'aria-rowindex': true,
    'aria-rowspan': true,
    'aria-selected': true,
    'aria-setsize': true,
    'aria-sort': true,
    'aria-valuemax': true,
    'aria-valuemin': true,
    'aria-valuenow': true,
    'aria-valuetext': true,
    // @deprecated
    accessibilityActiveDescendant: true,
    accessibilityAtomic: true,
    accessibilityAutoComplete: true,
    accessibilityBusy: true,
    accessibilityChecked: true,
    accessibilityColumnCount: true,
    accessibilityColumnIndex: true,
    accessibilityColumnSpan: true,
    accessibilityControls: true,
    accessibilityCurrent: true,
    accessibilityDescribedBy: true,
    accessibilityDetails: true,
    accessibilityDisabled: true,
    accessibilityErrorMessage: true,
    accessibilityExpanded: true,
    accessibilityFlowTo: true,
    accessibilityHasPopup: true,
    accessibilityHidden: true,
    accessibilityInvalid: true,
    accessibilityKeyShortcuts: true,
    accessibilityLabel: true,
    accessibilityLabelledBy: true,
    accessibilityLevel: true,
    accessibilityLiveRegion: true,
    accessibilityModal: true,
    accessibilityMultiline: true,
    accessibilityMultiSelectable: true,
    accessibilityOrientation: true,
    accessibilityOwns: true,
    accessibilityPlaceholder: true,
    accessibilityPosInSet: true,
    accessibilityPressed: true,
    accessibilityReadOnly: true,
    accessibilityRequired: true,
    accessibilityRole: true,
    accessibilityRoleDescription: true,
    accessibilityRowCount: true,
    accessibilityRowIndex: true,
    accessibilityRowSpan: true,
    accessibilitySelected: true,
    accessibilitySetSize: true,
    accessibilitySort: true,
    accessibilityValueMax: true,
    accessibilityValueMin: true,
    accessibilityValueNow: true,
    accessibilityValueText: true
  };
  var clickProps = exports.clickProps = {
    onClick: true,
    onAuxClick: true,
    onContextMenu: true,
    onGotPointerCapture: true,
    onLostPointerCapture: true,
    onPointerCancel: true,
    onPointerDown: true,
    onPointerEnter: true,
    onPointerMove: true,
    onPointerLeave: true,
    onPointerOut: true,
    onPointerOver: true,
    onPointerUp: true
  };
  var focusProps = exports.focusProps = {
    onBlur: true,
    onFocus: true
  };
  var keyboardProps = exports.keyboardProps = {
    onKeyDown: true,
    onKeyDownCapture: true,
    onKeyUp: true,
    onKeyUpCapture: true
  };
  var mouseProps = exports.mouseProps = {
    onMouseDown: true,
    onMouseEnter: true,
    onMouseLeave: true,
    onMouseMove: true,
    onMouseOver: true,
    onMouseOut: true,
    onMouseUp: true
  };
  var touchProps = exports.touchProps = {
    onTouchCancel: true,
    onTouchCancelCapture: true,
    onTouchEnd: true,
    onTouchEndCapture: true,
    onTouchMove: true,
    onTouchMoveCapture: true,
    onTouchStart: true,
    onTouchStartCapture: true
  };
  var styleProps = exports.styleProps = {
    style: true
  };
},112,[],"node_modules\\react-native-web\\dist\\modules\\forwardedProps\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = pick;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function pick(obj, list) {
    var nextObj = {};
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (list[key] === true) {
          nextObj[key] = obj[key];
        }
      }
    }
    return nextObj;
  }
},113,[],"node_modules\\react-native-web\\dist\\modules\\pick\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useElementLayout;
  var _useLayoutEffect = _interopRequireDefault(require(_dependencyMap[1], "../useLayoutEffect"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[2], "../../exports/UIManager"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[3], "../canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var DOM_LAYOUT_HANDLER_NAME = '__reactLayoutHandler';
  var didWarn = !_canUseDom.default;
  var resizeObserver = null;
  function getResizeObserver() {
    if (_canUseDom.default && typeof window.ResizeObserver !== 'undefined') {
      if (resizeObserver == null) {
        resizeObserver = new window.ResizeObserver(function (entries) {
          entries.forEach(entry => {
            var node = entry.target;
            var onLayout = node[DOM_LAYOUT_HANDLER_NAME];
            if (typeof onLayout === 'function') {
              // We still need to measure the view because browsers don't yet provide
              // border-box dimensions in the entry
              _UIManager.default.measure(node, (x, y, width, height, left, top) => {
                var event = {
                  // $FlowFixMe
                  nativeEvent: {
                    layout: {
                      x,
                      y,
                      width,
                      height,
                      left,
                      top
                    }
                  },
                  timeStamp: Date.now()
                };
                Object.defineProperty(event.nativeEvent, 'target', {
                  enumerable: true,
                  get: () => entry.target
                });
                onLayout(event);
              });
            }
          });
        });
      }
    } else if (!didWarn) {
      if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
        console.warn('onLayout relies on ResizeObserver which is not supported by your browser. ' + 'Please include a polyfill, e.g., https://github.com/que-etc/resize-observer-polyfill.');
        didWarn = true;
      }
    }
    return resizeObserver;
  }
  function useElementLayout(ref, onLayout) {
    var observer = getResizeObserver();
    (0, _useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null) {
        node[DOM_LAYOUT_HANDLER_NAME] = onLayout;
      }
    }, [ref, onLayout]);

    // Observing is done in a separate effect to avoid this effect running
    // when 'onLayout' changes.
    (0, _useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null && observer != null) {
        if (typeof node[DOM_LAYOUT_HANDLER_NAME] === 'function') {
          observer.observe(node);
        } else {
          observer.unobserve(node);
        }
      }
      return () => {
        if (node != null && observer != null) {
          observer.unobserve(node);
        }
      };
    }, [ref, observer]);
  }
},114,[17,115,97,39],"node_modules\\react-native-web\\dist\\modules\\useElementLayout\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _react = require(_dependencyMap[1], "react");
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[2], "../canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * useLayoutEffect throws an error on the server. On the few occasions where is
   * problematic, use this hook.
   *
   * 
   */

  var useLayoutEffectImpl = _canUseDom.default ? _react.useLayoutEffect : _react.useEffect;
  var _default = exports.default = useLayoutEffectImpl;
},115,[17,3,39],"node_modules\\react-native-web\\dist\\modules\\useLayoutEffect\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useMergeRefs;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _mergeRefs = _interopRequireDefault(require(_dependencyMap[2], "../mergeRefs"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function useMergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return React.useMemo(() => (0, _mergeRefs.default)(...args),
    // eslint-disable-next-line
    [...args]);
  }
},116,[17,3,117],"node_modules\\react-native-web\\dist\\modules\\useMergeRefs\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = mergeRefs;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function mergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return function forwardRef(node) {
      args.forEach(ref => {
        if (ref == null) {
          return;
        }
        if (typeof ref === 'function') {
          ref(node);
          return;
        }
        if (typeof ref === 'object') {
          ref.current = node;
          return;
        }
        console.error("mergeRefs cannot handle Refs of type boolean, number or string, received ref " + String(ref));
      });
    };
  }
},117,[3],"node_modules\\react-native-web\\dist\\modules\\mergeRefs\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = usePlatformMethods;
  var _UIManager = _interopRequireDefault(require(_dependencyMap[1], "../../exports/UIManager"));
  var _useStable = _interopRequireDefault(require(_dependencyMap[2], "../useStable"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Adds non-standard methods to the hode element. This is temporarily until an
   * API like `ReactNative.measure(hostRef, callback)` is added to React Native.
   */
  function usePlatformMethods(_ref) {
    var pointerEvents = _ref.pointerEvents,
      style = _ref.style;
    // Avoid creating a new ref on every render.
    var ref = (0, _useStable.default)(() => hostNode => {
      if (hostNode != null) {
        hostNode.measure = callback => _UIManager.default.measure(hostNode, callback);
        hostNode.measureLayout = (relativeToNode, success, failure) => _UIManager.default.measureLayout(hostNode, relativeToNode, failure, success);
        hostNode.measureInWindow = callback => _UIManager.default.measureInWindow(hostNode, callback);
      }
    });
    return ref;
  }
},118,[17,97,119],"node_modules\\react-native-web\\dist\\modules\\usePlatformMethods\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useStable;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var UNINITIALIZED = typeof Symbol === 'function' && typeof Symbol() === 'symbol' ? Symbol() : Object.freeze({});
  function useStable(getInitialValue) {
    var ref = React.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = getInitialValue();
    }
    // $FlowFixMe (#64650789) Trouble refining types where `Symbol` is concerned.
    return ref.current;
  }
},119,[3],"node_modules\\react-native-web\\dist\\modules\\useStable\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useResponderEvents;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var ResponderSystem = _interopRequireWildcard(require(_dependencyMap[1], "./ResponderSystem"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Hook for integrating the Responder System into React
   *
   *   function SomeComponent({ onStartShouldSetResponder }) {
   *     const ref = useRef(null);
   *     useResponderEvents(ref, { onStartShouldSetResponder });
   *     return <div ref={ref} />
   *   }
   */

  var emptyObject = {};
  var idCounter = 0;
  function useStable(getInitialValue) {
    var ref = React.useRef(null);
    if (ref.current == null) {
      ref.current = getInitialValue();
    }
    return ref.current;
  }
  function useResponderEvents(hostRef, config) {
    if (config === void 0) {
      config = emptyObject;
    }
    var id = useStable(() => idCounter++);
    var isAttachedRef = React.useRef(false);

    // This is a separate effects so it doesn't run when the config changes.
    // On initial mount, attach global listeners if needed.
    // On unmount, remove node potentially attached to the Responder System.
    React.useEffect(() => {
      ResponderSystem.attachListeners();
      return () => {
        ResponderSystem.removeNode(id);
      };
    }, [id]);

    // Register and unregister with the Responder System as necessary
    React.useEffect(() => {
      var _config = config,
        onMoveShouldSetResponder = _config.onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture = _config.onMoveShouldSetResponderCapture,
        onScrollShouldSetResponder = _config.onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture = _config.onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder = _config.onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture = _config.onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder = _config.onStartShouldSetResponder,
        onStartShouldSetResponderCapture = _config.onStartShouldSetResponderCapture;
      var requiresResponderSystem = onMoveShouldSetResponder != null || onMoveShouldSetResponderCapture != null || onScrollShouldSetResponder != null || onScrollShouldSetResponderCapture != null || onSelectionChangeShouldSetResponder != null || onSelectionChangeShouldSetResponderCapture != null || onStartShouldSetResponder != null || onStartShouldSetResponderCapture != null;
      var node = hostRef.current;
      if (requiresResponderSystem) {
        ResponderSystem.addNode(id, node, config);
        isAttachedRef.current = true;
      } else if (isAttachedRef.current) {
        ResponderSystem.removeNode(id);
        isAttachedRef.current = false;
      }
    }, [config, hostRef, id]);
    React.useDebugValue({
      isResponder: hostRef.current === ResponderSystem.getResponderNode()
    });
    React.useDebugValue(config);
  }
},120,[3,121],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addNode = addNode;
  exports.attachListeners = attachListeners;
  exports.getResponderNode = getResponderNode;
  exports.removeNode = removeNode;
  exports.terminateResponder = terminateResponder;
  var _createResponderEvent = _interopRequireDefault(require(_dependencyMap[1], "./createResponderEvent"));
  var _ResponderEventTypes = require(_dependencyMap[2], "./ResponderEventTypes");
  var _utils = require(_dependencyMap[3], "./utils");
  var _ResponderTouchHistoryStore = require(_dependencyMap[4], "./ResponderTouchHistoryStore");
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[5], "../canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * RESPONDER EVENT SYSTEM
   *
   * A single, global "interaction lock" on views. For a view to be the "responder" means
   * that pointer interactions are exclusive to that view and none other. The "interaction
   * lock" can be transferred (only) to ancestors of the current "responder" as long as
   * pointers continue to be active.
   *
   * Responder being granted:
   *
   * A view can become the "responder" after the following events:
   *  * "pointerdown" (implemented using "touchstart", "mousedown")
   *  * "pointermove" (implemented using "touchmove", "mousemove")
   *  * "scroll" (while a pointer is down)
   *  * "selectionchange" (while a pointer is down)
   *
   * If nothing is already the "responder", the event propagates to (capture) and from
   * (bubble) the event target until a view returns `true` for
   * `on*ShouldSetResponder(Capture)`.
   *
   * If something is already the responder, the event propagates to (capture) and from
   * (bubble) the lowest common ancestor of the event target and the current "responder".
   * Then negotiation happens between the current "responder" and a view that wants to
   * become the "responder": see the timing diagram below.
   *
   * (NOTE: Scrolled views either automatically become the "responder" or release the
   * "interaction lock". A native scroll view that isn't built on top of the responder
   * system must result in the current "responder" being notified that it no longer has
   * the "interaction lock" - the native system has taken over.
   *
   * Responder being released:
   *
   * As soon as there are no more active pointers that *started* inside descendants
   * of the *current* "responder", an `onResponderRelease` event is dispatched to the
   * current "responder", and the responder lock is released.
   *
   * Typical sequence of events:
   *  * startShouldSetResponder
   *  * responderGrant/Reject
   *  * responderStart
   *  * responderMove
   *  * responderEnd
   *  * responderRelease
   */

  /*                                             Negotiation Performed
                                               +-----------------------+
                                              /                         \
  Process low level events to    +     Current Responder      +   wantsResponderID
  determine who to perform negot-|   (if any exists at all)   |
  iation/transition              | Otherwise just pass through|
  -------------------------------+----------------------------+------------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +--------------+          |                            |
       | onTouchStart |          |                            |
       +------+-------+    none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | | onResponder            | |
              +------------------->|    TerminationRequest  | |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | | onResponderTerminate   |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderStart|
                                 |                            | +----------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +-------------+           |                            |
       | onTouchMove |           |                            |
       +------+------+     none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | |   onResponder          | |
              +------------------->|      TerminationRequest| |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | |   onResponderTerminate |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderMove |
                                 |                            | +----------------+
                                 |                            |
                                 |                            |
        Some active touch started|                            |
        inside current responder | +------------------------+ |
        +------------------------->|      onResponderEnd    | |
        |                        | +------------------------+ |
    +---+---------+              |                            |
    | onTouchEnd  |              |                            |
    +---+---------+              |                            |
        |                        | +------------------------+ |
        +------------------------->|     onResponderEnd     | |
        No active touches started| +-----------+------------+ |
        inside current responder |             |              |
                                 |             v              |
                                 | +------------------------+ |
                                 | |    onResponderRelease  | |
                                 | +------------------------+ |
                                 |                            |
                                 +                            + */

  /* ------------ TYPES ------------ */

  var emptyObject = {};

  /* ------------ IMPLEMENTATION ------------ */

  var startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {
    bubbles: true
  }];
  var moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {
    bubbles: true
  }];
  var scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {
    bubbles: false
  }];
  var shouldSetResponderEvents = {
    touchstart: startRegistration,
    mousedown: startRegistration,
    touchmove: moveRegistration,
    mousemove: moveRegistration,
    scroll: scrollRegistration
  };
  var emptyResponder = {
    id: null,
    idPath: null,
    node: null
  };
  var responderListenersMap = new Map();
  var isEmulatingMouseEvents = false;
  var trackedTouchCount = 0;
  var currentResponder = {
    id: null,
    node: null,
    idPath: null
  };
  var responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();
  function changeCurrentResponder(responder) {
    currentResponder = responder;
  }
  function getResponderConfig(id) {
    var config = responderListenersMap.get(id);
    return config != null ? config : emptyObject;
  }

  /**
   * Process native events
   *
   * A single event listener is used to manage the responder system.
   * All pointers are tracked in the ResponderTouchHistoryStore. Native events
   * are interpreted in terms of the Responder System and checked to see if
   * the responder should be transferred. Each host node that is attached to
   * the Responder System has an ID, which is used to look up its associated
   * callbacks.
   */
  function eventListener(domEvent) {
    var eventType = domEvent.type;
    var eventTarget = domEvent.target;

    /**
     * Manage emulated events and early bailout.
     * Since PointerEvent is not used yet (lack of support in older Safari), it's
     * necessary to manually manage the mess of browser touch/mouse events.
     * And bailout early for termination events when there is no active responder.
     */

    // Flag when browser may produce emulated events
    if (eventType === 'touchstart') {
      isEmulatingMouseEvents = true;
    }
    // Remove flag when browser will not produce emulated events
    if (eventType === 'touchmove' || trackedTouchCount > 1) {
      isEmulatingMouseEvents = false;
    }
    // Ignore various events in particular circumstances
    if (
    // Ignore browser emulated mouse events
    eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||
    // Ignore mousemove if a mousedown didn't occur first
    eventType === 'mousemove' && trackedTouchCount < 1) {
      return;
    }
    // Remove flag after emulated events are finished
    if (isEmulatingMouseEvents && eventType === 'mouseup') {
      if (trackedTouchCount === 0) {
        isEmulatingMouseEvents = false;
      }
      return;
    }
    var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);
    var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);
    var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);
    var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);
    var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);
    var responderEvent = (0, _createResponderEvent.default)(domEvent, responderTouchHistoryStore);

    /**
     * Record the state of active pointers
     */

    if (isStartEvent || isMoveEvent || isEndEvent) {
      if (domEvent.touches) {
        trackedTouchCount = domEvent.touches.length;
      } else {
        if (isStartEvent) {
          trackedTouchCount = 1;
        } else if (isEndEvent) {
          trackedTouchCount = 0;
        }
      }
      responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);
    }

    /**
     * Responder System logic
     */

    var eventPaths = (0, _utils.getResponderPaths)(domEvent);
    var wasNegotiated = false;
    var wantsResponder;

    // If an event occured that might change the current responder...
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      // If there is already a responder, prune the event paths to the lowest common ancestor
      // of the existing responder and deepest target of the event.
      var currentResponderIdPath = currentResponder.idPath;
      var eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);
          // Skip the current responder so it doesn't receive unexpected "shouldSet" events.
          var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index),
            nodePath: eventPaths.nodePath.slice(index)
          };
        } else {
          eventPaths = null;
        }
      }
      if (eventPaths != null) {
        // If a node wants to become the responder, attempt to transfer.
        wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);
        if (wantsResponder != null) {
          // Sets responder if none exists, or negotates with existing responder.
          attemptTransfer(responderEvent, wantsResponder);
          wasNegotiated = true;
        }
      }
    }

    // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.
    if (currentResponder.id != null && currentResponder.node != null) {
      var _currentResponder = currentResponder,
        id = _currentResponder.id,
        node = _currentResponder.node;
      var _getResponderConfig = getResponderConfig(id),
        onResponderStart = _getResponderConfig.onResponderStart,
        onResponderMove = _getResponderConfig.onResponderMove,
        onResponderEnd = _getResponderConfig.onResponderEnd,
        onResponderRelease = _getResponderConfig.onResponderRelease,
        onResponderTerminate = _getResponderConfig.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;
      responderEvent.bubbles = false;
      responderEvent.cancelable = false;
      responderEvent.currentTarget = node;

      // Start
      if (isStartEvent) {
        if (onResponderStart != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderStart';
          onResponderStart(responderEvent);
        }
      }
      // Move
      else if (isMoveEvent) {
        if (onResponderMove != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderMove';
          onResponderMove(responderEvent);
        }
      } else {
        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) ||
        // native context menu
        eventType === 'contextmenu' ||
        // window blur
        eventType === 'blur' && eventTarget === window ||
        // responder (or ancestors) blur
        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||
        // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 ||
        // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||
        // native select/selectionchange on node
        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);
        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);

        // End
        if (isEndEvent) {
          if (onResponderEnd != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderEnd';
            onResponderEnd(responderEvent);
          }
        }
        // Release
        if (isReleaseEvent) {
          if (onResponderRelease != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderRelease';
            onResponderRelease(responderEvent);
          }
          changeCurrentResponder(emptyResponder);
        }
        // Terminate
        if (isTerminateEvent) {
          var shouldTerminate = true;

          // Responders can still avoid termination but only for these events.
          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {
            // Only call this function is it wasn't already called during negotiation.
            if (wasNegotiated) {
              shouldTerminate = false;
            } else if (onResponderTerminationRequest != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
              if (onResponderTerminationRequest(responderEvent) === false) {
                shouldTerminate = false;
              }
            }
          }
          if (shouldTerminate) {
            if (onResponderTerminate != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
              onResponderTerminate(responderEvent);
            }
            changeCurrentResponder(emptyResponder);
            isEmulatingMouseEvents = false;
            trackedTouchCount = 0;
          }
        }
      }
    }
  }

  /**
   * Walk the event path to/from the target node. At each node, stop and call the
   * relevant "shouldSet" functions for the given event type. If any of those functions
   * call "stopPropagation" on the event, stop searching for a responder.
   */
  function findWantsResponder(eventPaths, domEvent, responderEvent) {
    var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow

    if (shouldSetCallbacks != null) {
      var idPath = eventPaths.idPath,
        nodePath = eventPaths.nodePath;
      var shouldSetCallbackCaptureName = shouldSetCallbacks[0];
      var shouldSetCallbackBubbleName = shouldSetCallbacks[1];
      var bubbles = shouldSetCallbacks[2].bubbles;
      var check = function check(id, node, callbackName) {
        var config = getResponderConfig(id);
        var shouldSetCallback = config[callbackName];
        if (shouldSetCallback != null) {
          responderEvent.currentTarget = node;
          if (shouldSetCallback(responderEvent) === true) {
            // Start the path from the potential responder
            var prunedIdPath = idPath.slice(idPath.indexOf(id));
            return {
              id,
              node,
              idPath: prunedIdPath
            };
          }
        }
      };

      // capture
      for (var i = idPath.length - 1; i >= 0; i--) {
        var id = idPath[i];
        var node = nodePath[i];
        var result = check(id, node, shouldSetCallbackCaptureName);
        if (result != null) {
          return result;
        }
        if (responderEvent.isPropagationStopped() === true) {
          return;
        }
      }

      // bubble
      if (bubbles) {
        for (var _i = 0; _i < idPath.length; _i++) {
          var _id = idPath[_i];
          var _node = nodePath[_i];
          var _result = check(_id, _node, shouldSetCallbackBubbleName);
          if (_result != null) {
            return _result;
          }
          if (responderEvent.isPropagationStopped() === true) {
            return;
          }
        }
      } else {
        var _id2 = idPath[0];
        var _node2 = nodePath[0];
        var target = domEvent.target;
        if (target === _node2) {
          return check(_id2, _node2, shouldSetCallbackBubbleName);
        }
      }
    }
  }

  /**
   * Attempt to transfer the responder.
   */
  function attemptTransfer(responderEvent, wantsResponder) {
    var _currentResponder2 = currentResponder,
      currentId = _currentResponder2.id,
      currentNode = _currentResponder2.node;
    var id = wantsResponder.id,
      node = wantsResponder.node;
    var _getResponderConfig2 = getResponderConfig(id),
      onResponderGrant = _getResponderConfig2.onResponderGrant,
      onResponderReject = _getResponderConfig2.onResponderReject;
    responderEvent.bubbles = false;
    responderEvent.cancelable = false;
    responderEvent.currentTarget = node;

    // Set responder
    if (currentId == null) {
      if (onResponderGrant != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
        onResponderGrant(responderEvent);
      }
      changeCurrentResponder(wantsResponder);
    }
    // Negotiate with current responder
    else {
      var _getResponderConfig3 = getResponderConfig(currentId),
        onResponderTerminate = _getResponderConfig3.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;
      var allowTransfer = true;
      if (onResponderTerminationRequest != null) {
        responderEvent.currentTarget = currentNode;
        responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
        if (onResponderTerminationRequest(responderEvent) === false) {
          allowTransfer = false;
        }
      }
      if (allowTransfer) {
        // Terminate existing responder
        if (onResponderTerminate != null) {
          responderEvent.currentTarget = currentNode;
          responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
          onResponderTerminate(responderEvent);
        }
        // Grant next responder
        if (onResponderGrant != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
          onResponderGrant(responderEvent);
        }
        changeCurrentResponder(wantsResponder);
      } else {
        // Reject responder request
        if (onResponderReject != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderReject';
          onResponderReject(responderEvent);
        }
      }
    }
  }

  /* ------------ PUBLIC API ------------ */

  /**
   * Attach Listeners
   *
   * Use native events as ReactDOM doesn't have a non-plugin API to implement
   * this system.
   */
  var documentEventsCapturePhase = ['blur', 'scroll'];
  var documentEventsBubblePhase = [
  // mouse
  'mousedown', 'mousemove', 'mouseup', 'dragstart',
  // touch
  'touchstart', 'touchmove', 'touchend', 'touchcancel',
  // other
  'contextmenu', 'select', 'selectionchange'];
  function attachListeners() {
    if (_canUseDom.default && window.__reactResponderSystemActive == null) {
      window.addEventListener('blur', eventListener);
      documentEventsBubblePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener);
      });
      documentEventsCapturePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener, true);
      });
      window.__reactResponderSystemActive = true;
    }
  }

  /**
   * Register a node with the ResponderSystem.
   */
  function addNode(id, node, config) {
    (0, _utils.setResponderId)(node, id);
    responderListenersMap.set(id, config);
  }

  /**
   * Unregister a node with the ResponderSystem.
   */
  function removeNode(id) {
    if (currentResponder.id === id) {
      terminateResponder();
    }
    if (responderListenersMap.has(id)) {
      responderListenersMap.delete(id);
    }
  }

  /**
   * Allow the current responder to be terminated from within components to support
   * more complex requirements, such as use with other React libraries for working
   * with scroll views, input views, etc.
   */
  function terminateResponder() {
    var _currentResponder3 = currentResponder,
      id = _currentResponder3.id,
      node = _currentResponder3.node;
    if (id != null && node != null) {
      var _getResponderConfig4 = getResponderConfig(id),
        onResponderTerminate = _getResponderConfig4.onResponderTerminate;
      if (onResponderTerminate != null) {
        var event = (0, _createResponderEvent.default)({}, responderTouchHistoryStore);
        event.currentTarget = node;
        onResponderTerminate(event);
      }
      changeCurrentResponder(emptyResponder);
    }
    isEmulatingMouseEvents = false;
    trackedTouchCount = 0;
  }

  /**
   * Allow unit tests to inspect the current responder in the system.
   * FOR TESTING ONLY.
   */
  function getResponderNode() {
    return currentResponder.node;
  }
},121,[17,122,123,124,126,39],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\ResponderSystem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createResponderEvent;
  var _getBoundingClientRect = _interopRequireDefault(require(_dependencyMap[1], "../../modules/getBoundingClientRect"));
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  var emptyObject = {};
  var emptyArray = [];

  /**
   * Safari produces very large identifiers that would cause the `touchBank` array
   * length to be so large as to crash the browser, if not normalized like this.
   * In the future the `touchBank` should use an object/map instead.
   */
  function normalizeIdentifier(identifier) {
    return identifier > 20 ? identifier % 20 : identifier;
  }

  /**
   * Converts a native DOM event to a ResponderEvent.
   * Mouse events are transformed into fake touch events.
   */
  function createResponderEvent(domEvent, responderTouchHistoryStore) {
    var rect;
    var propagationWasStopped = false;
    var changedTouches;
    var touches;
    var domEventChangedTouches = domEvent.changedTouches;
    var domEventType = domEvent.type;
    var metaKey = domEvent.metaKey === true;
    var shiftKey = domEvent.shiftKey === true;
    var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;
    var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);
    var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;
    var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;
    var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;
    var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;
    var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;
    var timestamp = domEvent.timeStamp;
    function normalizeTouches(touches) {
      return Array.prototype.slice.call(touches).map(touch => {
        return {
          force: touch.force,
          identifier: normalizeIdentifier(touch.identifier),
          get locationX() {
            return locationX(touch.clientX);
          },
          get locationY() {
            return locationY(touch.clientY);
          },
          pageX: touch.pageX,
          pageY: touch.pageY,
          target: touch.target,
          timestamp
        };
      });
    }
    if (domEventChangedTouches != null) {
      changedTouches = normalizeTouches(domEventChangedTouches);
      touches = normalizeTouches(domEvent.touches);
    } else {
      var emulatedTouches = [{
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp
      }];
      changedTouches = emulatedTouches;
      touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;
    }
    var responderEvent = {
      bubbles: true,
      cancelable: true,
      // `currentTarget` is set before dispatch
      currentTarget: null,
      defaultPrevented: domEvent.defaultPrevented,
      dispatchConfig: emptyObject,
      eventPhase: domEvent.eventPhase,
      isDefaultPrevented() {
        return domEvent.defaultPrevented;
      },
      isPropagationStopped() {
        return propagationWasStopped;
      },
      isTrusted: domEvent.isTrusted,
      nativeEvent: {
        altKey: false,
        ctrlKey: false,
        metaKey,
        shiftKey,
        changedTouches,
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp,
        touches,
        type: domEventType
      },
      persist: emptyFunction,
      preventDefault,
      stopPropagation() {
        propagationWasStopped = true;
      },
      target: domEvent.target,
      timeStamp: timestamp,
      touchHistory: responderTouchHistoryStore.touchHistory
    };

    // Using getters and functions serves two purposes:
    // 1) The value of `currentTarget` is not initially available.
    // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.
    function locationX(x) {
      rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return x - rect.left;
      }
    }
    function locationY(y) {
      rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return y - rect.top;
      }
    }
    return responderEvent;
  }
},122,[17,98],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\createResponderEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TOUCH_START = exports.TOUCH_MOVE = exports.TOUCH_END = exports.TOUCH_CANCEL = exports.SELECTION_CHANGE = exports.SELECT = exports.SCROLL = exports.MOUSE_UP = exports.MOUSE_MOVE = exports.MOUSE_DOWN = exports.MOUSE_CANCEL = exports.FOCUS_OUT = exports.CONTEXT_MENU = exports.BLUR = void 0;
  exports.isCancelish = isCancelish;
  exports.isEndish = isEndish;
  exports.isMoveish = isMoveish;
  exports.isScroll = isScroll;
  exports.isSelectionChange = isSelectionChange;
  exports.isStartish = isStartish;
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var BLUR = exports.BLUR = 'blur';
  var CONTEXT_MENU = exports.CONTEXT_MENU = 'contextmenu';
  var FOCUS_OUT = exports.FOCUS_OUT = 'focusout';
  var MOUSE_DOWN = exports.MOUSE_DOWN = 'mousedown';
  var MOUSE_MOVE = exports.MOUSE_MOVE = 'mousemove';
  var MOUSE_UP = exports.MOUSE_UP = 'mouseup';
  var MOUSE_CANCEL = exports.MOUSE_CANCEL = 'dragstart';
  var TOUCH_START = exports.TOUCH_START = 'touchstart';
  var TOUCH_MOVE = exports.TOUCH_MOVE = 'touchmove';
  var TOUCH_END = exports.TOUCH_END = 'touchend';
  var TOUCH_CANCEL = exports.TOUCH_CANCEL = 'touchcancel';
  var SCROLL = exports.SCROLL = 'scroll';
  var SELECT = exports.SELECT = 'select';
  var SELECTION_CHANGE = exports.SELECTION_CHANGE = 'selectionchange';
  function isStartish(eventType) {
    return eventType === TOUCH_START || eventType === MOUSE_DOWN;
  }
  function isMoveish(eventType) {
    return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
  }
  function isEndish(eventType) {
    return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
  }
  function isCancelish(eventType) {
    return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
  }
  function isScroll(eventType) {
    return eventType === SCROLL;
  }
  function isSelectionChange(eventType) {
    return eventType === SELECT || eventType === SELECTION_CHANGE;
  }
},123,[],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\ResponderEventTypes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLowestCommonAncestor = getLowestCommonAncestor;
  exports.getResponderPaths = getResponderPaths;
  exports.hasTargetTouches = hasTargetTouches;
  exports.hasValidSelection = hasValidSelection;
  exports.isPrimaryPointerDown = isPrimaryPointerDown;
  exports.setResponderId = setResponderId;
  var _isSelectionValid = _interopRequireDefault(require(_dependencyMap[1], "../../modules/isSelectionValid"));
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var keyName = '__reactResponderId';
  function getEventPath(domEvent) {
    // The 'selectionchange' event always has the 'document' as the target.
    // Use the anchor node as the initial target to reconstruct a path.
    // (We actually only need the first "responder" node in practice.)
    if (domEvent.type === 'selectionchange') {
      var target = window.getSelection().anchorNode;
      return composedPathFallback(target);
    } else {
      var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
      return path;
    }
  }
  function composedPathFallback(target) {
    var path = [];
    while (target != null && target !== document.body) {
      path.push(target);
      target = target.parentNode;
    }
    return path;
  }

  /**
   * Retrieve the responderId from a host node
   */
  function getResponderId(node) {
    if (node != null) {
      return node[keyName];
    }
    return null;
  }

  /**
   * Store the responderId on a host node
   */
  function setResponderId(node, id) {
    if (node != null) {
      node[keyName] = id;
    }
  }

  /**
   * Filter the event path to contain only the nodes attached to the responder system
   */
  function getResponderPaths(domEvent) {
    var idPath = [];
    var nodePath = [];
    var eventPath = getEventPath(domEvent);
    for (var i = 0; i < eventPath.length; i++) {
      var node = eventPath[i];
      var id = getResponderId(node);
      if (id != null) {
        idPath.push(id);
        nodePath.push(node);
      }
    }
    return {
      idPath,
      nodePath
    };
  }

  /**
   * Walk the paths and find the first common ancestor
   */
  function getLowestCommonAncestor(pathA, pathB) {
    var pathALength = pathA.length;
    var pathBLength = pathB.length;
    if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 ||
    // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]) {
      return null;
    }
    var itemA = pathA[0];
    var indexA = 0;
    var itemB = pathB[0];
    var indexB = 0;

    // If A is deeper, skip indices that can't match.
    if (pathALength - pathBLength > 0) {
      indexA = pathALength - pathBLength;
      itemA = pathA[indexA];
      pathALength = pathBLength;
    }

    // If B is deeper, skip indices that can't match
    if (pathBLength - pathALength > 0) {
      indexB = pathBLength - pathALength;
      itemB = pathB[indexB];
      pathBLength = pathALength;
    }

    // Walk in lockstep until a match is found
    var depth = pathALength;
    while (depth--) {
      if (itemA === itemB) {
        return itemA;
      }
      itemA = pathA[indexA++];
      itemB = pathB[indexB++];
    }
    return null;
  }

  /**
   * Determine whether any of the active touches are within the current responder.
   * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.
   */
  function hasTargetTouches(target, touches) {
    if (!touches || touches.length === 0) {
      return false;
    }
    for (var i = 0; i < touches.length; i++) {
      var node = touches[i].target;
      if (node != null) {
        if (target.contains(node)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Ignore 'selectionchange' events that don't correspond with a person's intent to
   * select text.
   */
  function hasValidSelection(domEvent) {
    if (domEvent.type === 'selectionchange') {
      return (0, _isSelectionValid.default)();
    }
    return domEvent.type === 'select';
  }

  /**
   * Events are only valid if the primary button was used without specific modifier keys.
   */
  function isPrimaryPointerDown(domEvent) {
    var altKey = domEvent.altKey,
      button = domEvent.button,
      buttons = domEvent.buttons,
      ctrlKey = domEvent.ctrlKey,
      type = domEvent.type;
    var isTouch = type === 'touchstart' || type === 'touchmove';
    var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);
    var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;
    var noModifiers = altKey === false && ctrlKey === false;
    if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
      return true;
    }
    return false;
  }
},124,[17,125],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSelectionValid;
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function isSelectionValid() {
    var selection = window.getSelection();
    var string = selection.toString();
    var anchorNode = selection.anchorNode;
    var focusNode = selection.focusNode;
    var isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
    return string.length >= 1 && string !== '\n' && isTextNode;
  }
},125,[],"node_modules\\react-native-web\\dist\\modules\\isSelectionValid\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ResponderTouchHistoryStore = void 0;
  var _ResponderEventTypes = require(_dependencyMap[0], "./ResponderEventTypes");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Tracks the position and time of each active touch by `touch.identifier`. We
   * should typically only see IDs in the range of 1-20 because IDs get recycled
   * when touches end and start again.
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var MAX_TOUCH_BANK = 20;
  function timestampForTouch(touch) {
    // The legacy internal implementation provides "timeStamp", which has been
    // renamed to "timestamp".
    return touch.timeStamp || touch.timestamp;
  }

  /**
   * TODO: Instead of making gestures recompute filtered velocity, we could
   * include a built in velocity computation that can be reused globally.
   */
  function createTouchRecord(touch) {
    return {
      touchActive: true,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    };
  }
  function resetTouchRecord(touchRecord, touch) {
    touchRecord.touchActive = true;
    touchRecord.startPageX = touch.pageX;
    touchRecord.startPageY = touch.pageY;
    touchRecord.startTimeStamp = timestampForTouch(touch);
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchRecord.previousPageX = touch.pageX;
    touchRecord.previousPageY = touch.pageY;
    touchRecord.previousTimeStamp = timestampForTouch(touch);
  }
  function getTouchIdentifier(_ref) {
    var identifier = _ref.identifier;
    if (identifier == null) {
      console.error('Touch object is missing identifier.');
    }
    if (__DEV__) {
      if (identifier > MAX_TOUCH_BANK) {
        console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);
      }
    }
    return identifier;
  }
  function recordTouchStart(touch, touchHistory) {
    var identifier = getTouchIdentifier(touch);
    var touchRecord = touchHistory.touchBank[identifier];
    if (touchRecord) {
      resetTouchRecord(touchRecord, touch);
    } else {
      touchHistory.touchBank[identifier] = createTouchRecord(touch);
    }
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }
  function recordTouchMove(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = true;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch move without a touch start.\n', "Touch Move: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function recordTouchEnd(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = false;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch end without a touch start.\n', "Touch End: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }
  function printTouchBank(touchHistory) {
    var touchBank = touchHistory.touchBank;
    var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
    if (touchBank.length > MAX_TOUCH_BANK) {
      printed += ' (original size: ' + touchBank.length + ')';
    }
    return printed;
  }
  class ResponderTouchHistoryStore {
    constructor() {
      this._touchHistory = {
        touchBank: [],
        //Array<TouchRecord>
        numberActiveTouches: 0,
        // If there is only one active touch, we remember its location. This prevents
        // us having to loop through all of the touches all the time in the most
        // common case.
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };
    }
    recordTouchTrack(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));
      } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
        }
      } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          var touchBank = touchHistory.touchBank;
          for (var i = 0; i < touchBank.length; i++) {
            var touchTrackToCheck = touchBank[i];
            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
              touchHistory.indexOfSingleActiveTouch = i;
              break;
            }
          }
          if (__DEV__) {
            var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
            if (!(activeRecord != null && activeRecord.touchActive)) {
              console.error('Cannot find single active touch.');
            }
          }
        }
      }
    }
    get touchHistory() {
      return this._touchHistory;
    }
  }
  exports.ResponderTouchHistoryStore = ResponderTouchHistoryStore;
},126,[123],"node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\ResponderTouchHistoryStore.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _react = require(_dependencyMap[0], "react");
  var TextAncestorContext = /*#__PURE__*/(0, _react.createContext)(false);
  var _default = exports.default = TextAncestorContext;
},127,[3],"node_modules\\react-native-web\\dist\\exports\\Text\\TextAncestorContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /*
   * @returns {bool} true if different, false if equal
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var deepDiffer = function deepDiffer(one, two, maxDepth) {
    if (maxDepth === void 0) {
      maxDepth = -1;
    }
    if (maxDepth === 0) {
      return true;
    }
    if (one === two) {
      // Short circuit on identical object references instead of traversing them.
      return false;
    }
    if (typeof one === 'function' && typeof two === 'function') {
      // We consider all functions equal
      return false;
    }
    if (typeof one !== 'object' || one === null) {
      // Primitives can be directly compared
      return one !== two;
    }
    if (typeof two !== 'object' || two === null) {
      // We know they are different because the previous case would have triggered
      // otherwise.
      return true;
    }
    if (one.constructor !== two.constructor) {
      return true;
    }
    if (Array.isArray(one)) {
      // We know two is also an array because the constructors are equal
      var len = one.length;
      if (two.length !== len) {
        return true;
      }
      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii], maxDepth - 1)) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key], maxDepth - 1)) {
          return true;
        }
      }
      for (var twoKey in two) {
        // The only case we haven't checked yet is keys that are in two but aren't
        // in one, which means they are different.
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }
    return false;
  };
  var _default = exports.default = deepDiffer;
},128,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\deepDiffer\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  var validateFormat = process.env.NODE_ENV !== "production" ? function (format) {
    if (format === undefined) {
      throw new Error('invariant(...): Second argument must be a string.');
    }
  } : function (format) {};
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments to provide
   * information about what broke and what you were expecting.
   *
   * The invariant message will be stripped in production, but the invariant will
   * remain to ensure logic does not differ in production.
   */

  function invariant(condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    validateFormat(format);
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return String(args[argIndex++]);
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // Skip invariant's own stack frame.

      throw error;
    }
  }
  module.exports = invariant;
},129,[],"node_modules\\fbjs\\lib\\invariant.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createForOfIteratorHelperLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/createForOfIteratorHelperLoose"));
  var _extends2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/extends"));
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectSpread2"));
  var _RefreshControl = _interopRequireDefault(require(_dependencyMap[4], "../../../exports/RefreshControl"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[5], "../../../exports/ScrollView"));
  var _View = _interopRequireDefault(require(_dependencyMap[6], "../../../exports/View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "../../../exports/StyleSheet"));
  var _Batchinator = _interopRequireDefault(require(_dependencyMap[8], "../Batchinator"));
  var _clamp = _interopRequireDefault(require(_dependencyMap[9], "../Utilities/clamp"));
  var _infoLog = _interopRequireDefault(require(_dependencyMap[10], "../infoLog"));
  var _CellRenderMask = require(_dependencyMap[11], "./CellRenderMask");
  var _ChildListCollection = _interopRequireDefault(require(_dependencyMap[12], "./ChildListCollection"));
  var _FillRateHelper = _interopRequireDefault(require(_dependencyMap[13], "../FillRateHelper"));
  var _StateSafePureComponent = _interopRequireDefault(require(_dependencyMap[14], "./StateSafePureComponent"));
  var _ViewabilityHelper = _interopRequireDefault(require(_dependencyMap[15], "../ViewabilityHelper"));
  var _VirtualizedListCellRenderer = _interopRequireDefault(require(_dependencyMap[16], "./VirtualizedListCellRenderer"));
  var _VirtualizedListContext = require(_dependencyMap[17], "./VirtualizedListContext.js");
  var _VirtualizeUtils = require(_dependencyMap[18], "../VirtualizeUtils");
  var _invariant = _interopRequireDefault(require(_dependencyMap[19], "fbjs/lib/invariant"));
  var _nullthrows = _interopRequireDefault(require(_dependencyMap[20], "nullthrows"));
  var React = _interopRequireWildcard(require(_dependencyMap[21], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var ON_EDGE_REACHED_EPSILON = 0.001;
  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';
  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // horizontalOrDefault(this.props.horizontal)
  function horizontalOrDefault(horizontal) {
    return horizontal !== null && horizontal !== void 0 ? horizontal : false;
  }

  // initialNumToRenderOrDefault(this.props.initialNumToRender)
  function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender !== null && initialNumToRender !== void 0 ? initialNumToRender : 10;
  }

  // maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)
  function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch !== null && maxToRenderPerBatch !== void 0 ? maxToRenderPerBatch : 10;
  }

  // onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)
  function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold !== null && onStartReachedThreshold !== void 0 ? onStartReachedThreshold : 2;
  }

  // onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)
  function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold !== null && onEndReachedThreshold !== void 0 ? onEndReachedThreshold : 2;
  }

  // getScrollingThreshold(visibleLength, onEndReachedThreshold)
  function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
  }

  // scrollEventThrottleOrDefault(this.props.scrollEventThrottle)
  function scrollEventThrottleOrDefault(scrollEventThrottle) {
    return scrollEventThrottle !== null && scrollEventThrottle !== void 0 ? scrollEventThrottle : 50;
  }

  // windowSizeOrDefault(this.props.windowSize)
  function windowSizeOrDefault(windowSize) {
    return windowSize !== null && windowSize !== void 0 ? windowSize : 21;
  }
  function findLastWhere(arr, predicate) {
    for (var i = arr.length - 1; i >= 0; i--) {
      if (predicate(arr[i])) {
        return arr[i];
      }
    }
    return null;
  }

  /**
   * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
   * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
   * documented. In general, this should only really be used if you need more flexibility than
   * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
   *
   * Virtualization massively improves memory consumption and performance of large lists by
   * maintaining a finite render window of active items and replacing all items outside of the render
   * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
   * are rendered incrementally with low-pri (after any running interactions) if they are far from the
   * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
   *
   * Some caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   * - As an effort to remove defaultProps, use helper functions when referencing certain props
   *
   */
  class VirtualizedList extends _StateSafePureComponent.default {
    // scrollToEnd may be janky without getItemLayout prop
    scrollToEnd(params) {
      var animated = params ? params.animated : true;
      var veryLast = this.props.getItemCount(this.props.data) - 1;
      if (veryLast < 0) {
        return;
      }
      var frame = this.__getFrameMetricsApprox(veryLast, this.props);
      var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToIndex may be janky without getItemLayout prop
    scrollToIndex(params) {
      var _this$props = this.props,
        data = _this$props.data,
        horizontal = _this$props.horizontal,
        getItemCount = _this$props.getItemCount,
        getItemLayout = _this$props.getItemLayout,
        onScrollToIndexFailed = _this$props.onScrollToIndexFailed;
      var animated = params.animated,
        index = params.index,
        viewOffset = params.viewOffset,
        viewPosition = params.viewPosition;
      (0, _invariant.default)(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");
      (0, _invariant.default)(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");
      (0, _invariant.default)(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));
      if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
        (0, _invariant.default)(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
        onScrollToIndexFailed({
          averageItemLength: this._averageCellLength,
          highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
          index
        });
        return;
      }
      var frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);
      var offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontal ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
    // use scrollToIndex instead if possible.
    scrollToItem(params) {
      var item = params.item;
      var _this$props2 = this.props,
        data = _this$props2.data,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount;
      var itemCount = getItemCount(data);
      for (var _index = 0; _index < itemCount; _index++) {
        if (getItem(data, _index) === item) {
          this.scrollToIndex((0, _objectSpread2.default)((0, _objectSpread2.default)({}, params), {}, {
            index: _index
          }));
          break;
        }
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Param `offset` expects the offset to scroll to.
     * In case of `horizontal` is true, the offset is the x-value,
     * in any other case the offset is the y-value.
     *
     * Param `animated` (`true` by default) defines whether the list
     * should do an animation while scrolling.
     */
    scrollToOffset(params) {
      var animated = params.animated,
        offset = params.offset;
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }
    recordInteraction() {
      this._nestedChildLists.forEach(childList => {
        childList.recordInteraction();
      });
      this._viewabilityTuples.forEach(t => {
        t.viewabilityHelper.recordInteraction();
      });
      this._updateViewableItems(this.props, this.state.cellsAroundViewport);
    }
    flashScrollIndicators() {
      if (this._scrollRef == null) {
        return;
      }
      this._scrollRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     * Note that `this._scrollRef` might not be a `ScrollView`, so we
     * need to check that it responds to `getScrollResponder` before calling it.
     */
    getScrollResponder() {
      if (this._scrollRef && this._scrollRef.getScrollResponder) {
        return this._scrollRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        return this._scrollRef.getScrollableNode();
      } else {
        return this._scrollRef;
      }
    }
    getScrollRef() {
      if (this._scrollRef && this._scrollRef.getScrollRef) {
        return this._scrollRef.getScrollRef();
      } else {
        return this._scrollRef;
      }
    }
    _getCellKey() {
      var _this$context;
      return ((_this$context = this.context) == null ? void 0 : _this$context.cellKey) || 'rootList';
    }

    // $FlowFixMe[missing-local-annot]

    hasMore() {
      return this._hasMore;
    }

    // $FlowFixMe[missing-local-annot]

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.

    constructor(_props) {
      var _this$props$updateCel;
      super(_props);
      this._getScrollMetrics = () => {
        return this._scrollMetrics;
      };
      this._getOutermostParentListRef = () => {
        if (this._isNestedWithSameOrientation()) {
          return this.context.getOutermostParentListRef();
        } else {
          return this;
        }
      };
      this._registerAsNestedChild = childList => {
        this._nestedChildLists.add(childList.ref, childList.cellKey);
        if (this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      };
      this._unregisterAsNestedChild = childList => {
        this._nestedChildLists.remove(childList.ref);
      };
      this._onUpdateSeparators = (keys, newProps) => {
        keys.forEach(key => {
          var ref = key != null && this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      };
      this._getSpacerKey = isVertical => isVertical ? 'height' : 'width';
      this._averageCellLength = 0;
      this._cellRefs = {};
      this._frames = {};
      this._footerLength = 0;
      this._hasTriggeredInitialScrollToIndex = false;
      this._hasInteracted = false;
      this._hasMore = false;
      this._hasWarned = {};
      this._headerLength = 0;
      this._hiPriInProgress = false;
      this._highestMeasuredFrameIndex = 0;
      this._indicesToKeys = new Map();
      this._lastFocusedCellKey = null;
      this._nestedChildLists = new _ChildListCollection.default();
      this._offsetFromParentVirtualizedList = 0;
      this._prevParentOffset = 0;
      this._scrollMetrics = {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0,
        zoomScale: 1
      };
      this._scrollRef = null;
      this._sentStartForContentLength = 0;
      this._sentEndForContentLength = 0;
      this._totalCellLength = 0;
      this._totalCellsMeasured = 0;
      this._viewabilityTuples = [];
      this._captureScrollRef = ref => {
        this._scrollRef = ref;
      };
      this._defaultRenderScrollComponent = props => {
        var onRefresh = props.onRefresh;
        if (this._isNestedWithSameOrientation()) {
          // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors
          return /*#__PURE__*/React.createElement(_View.default, props);
        } else if (onRefresh) {
          var _props$refreshing;
          (0, _invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) !== null && _props$refreshing !== void 0 ? _props$refreshing : 'undefined') + '`');
          return (/*#__PURE__*/
            // $FlowFixMe[prop-missing] Invalid prop usage
            // $FlowFixMe[incompatible-use]
            React.createElement(_ScrollView.default, (0, _extends2.default)({}, props, {
              refreshControl: props.refreshControl == null ? /*#__PURE__*/React.createElement(_RefreshControl.default
              // $FlowFixMe[incompatible-type]
              , {
                refreshing: props.refreshing,
                onRefresh: onRefresh,
                progressViewOffset: props.progressViewOffset
              }) : props.refreshControl
            }))
          );
        } else {
          // $FlowFixMe[prop-missing] Invalid prop usage
          // $FlowFixMe[incompatible-use]
          return /*#__PURE__*/React.createElement(_ScrollView.default, props);
        }
      };
      this._onCellLayout = (e, cellKey, index) => {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index,
          inLayout: true
        };
        var curr = this._frames[cellKey];
        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);
          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }
        this._triggerRemeasureForChildListsInCell(cellKey);
        this._computeBlankness();
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
      };
      this._onCellUnmount = cellKey => {
        delete this._cellRefs[cellKey];
        var curr = this._frames[cellKey];
        if (curr) {
          this._frames[cellKey] = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, curr), {}, {
            inLayout: false
          });
        }
      };
      this._onLayout = e => {
        if (this._isNestedWithSameOrientation()) {
          // Need to adjust our scroll metrics to be relative to our containing
          // VirtualizedList before we can make claims about list item viewability
          this.measureLayoutRelativeToContainingList();
        } else {
          this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);
        }
        this.props.onLayout && this.props.onLayout(e);
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._onLayoutEmpty = e => {
        this.props.onLayout && this.props.onLayout(e);
      };
      this._onLayoutFooter = e => {
        this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());
        this._footerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onLayoutHeader = e => {
        this._headerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onContentSizeChange = (width, height) => {
        if (width > 0 && height > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {
          if (this.props.contentOffset == null) {
            if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {
              this.scrollToIndex({
                animated: false,
                index: (0, _nullthrows.default)(this.props.initialScrollIndex)
              });
            } else {
              this.scrollToEnd({
                animated: false
              });
            }
          }
          this._hasTriggeredInitialScrollToIndex = true;
        }
        if (this.props.onContentSizeChange) {
          this.props.onContentSizeChange(width, height);
        }
        this._scrollMetrics.contentLength = this._selectLength({
          height,
          width
        });
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._convertParentScrollMetrics = metrics => {
        // Offset of the top of the nested list relative to the top of its parent's viewport
        var offset = metrics.offset - this._offsetFromParentVirtualizedList;
        // Child's visible length is the same as its parent's
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - this._scrollMetrics.offset;
        var contentLength = this._scrollMetrics.contentLength;
        return {
          visibleLength,
          contentLength,
          offset,
          dOffset
        };
      };
      this._onScroll = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScroll(e);
        });
        if (this.props.onScroll) {
          this.props.onScroll(e);
        }
        var timestamp = e.timeStamp;
        var visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);
        var contentLength = this._selectLength(e.nativeEvent.contentSize);
        var offset = this._selectOffset(e.nativeEvent.contentOffset);
        var dOffset = offset - this._scrollMetrics.offset;
        if (this._isNestedWithSameOrientation()) {
          if (this._scrollMetrics.contentLength === 0) {
            // Ignore scroll events until onLayout has been called and we
            // know our offset from our offset from our parent
            return;
          }
          var _this$_convertParentS = this._convertParentScrollMetrics({
            visibleLength,
            offset
          });
          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }
        var dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;
        if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {
          (0, _infoLog.default)('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
            dt,
            prevDt: this._scrollMetrics.dt,
            contentLength
          });
          this._hasWarned.perf = true;
        }

        // For invalid negative values (w/ RTL), set this to 1.
        var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
        this._scrollMetrics = {
          contentLength,
          dt,
          dOffset,
          offset,
          timestamp,
          velocity,
          visibleLength,
          zoomScale
        };
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        if (!this.props) {
          return;
        }
        this._maybeCallOnEdgeReached();
        if (velocity !== 0) {
          this._fillRateHelper.activate();
        }
        this._computeBlankness();
        this._scheduleCellsToRenderUpdate();
      };
      this._onScrollBeginDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollBeginDrag(e);
        });
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.recordInteraction();
        });
        this._hasInteracted = true;
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this._onScrollEndDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollEndDrag(e);
        });
        var velocity = e.nativeEvent.velocity;
        if (velocity) {
          this._scrollMetrics.velocity = this._selectOffset(velocity);
        }
        this._computeBlankness();
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this._onMomentumScrollBegin = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollBegin(e);
        });
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this._onMomentumScrollEnd = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollEnd(e);
        });
        this._scrollMetrics.velocity = 0;
        this._computeBlankness();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this._updateCellsToRender = () => {
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        this.setState((state, props) => {
          var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport);
          var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));
          if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
            return null;
          }
          return {
            cellsAroundViewport,
            renderMask
          };
        });
      };
      this._createViewToken = (index, isViewable, props
      // $FlowFixMe[missing-local-annot]
      ) => {
        var data = props.data,
          getItem = props.getItem;
        var item = getItem(data, index);
        return {
          index,
          item,
          key: this._keyExtractor(item, index, props),
          isViewable
        };
      };
      this._getOffsetApprox = (index, props) => {
        if (Number.isInteger(index)) {
          return this.__getFrameMetricsApprox(index, props).offset;
        } else {
          var frameMetrics = this.__getFrameMetricsApprox(Math.floor(index), props);
          var remainder = index - Math.floor(index);
          return frameMetrics.offset + remainder * frameMetrics.length;
        }
      };
      this.__getFrameMetricsApprox = (index, props) => {
        var frame = this._getFrameMetrics(index, props);
        if (frame && frame.index === index) {
          // check for invalid frames due to row re-ordering
          return frame;
        } else {
          var data = props.data,
            getItemCount = props.getItemCount,
            getItemLayout = props.getItemLayout;
          (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
          (0, _invariant.default)(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
          return {
            length: this._averageCellLength,
            offset: this._averageCellLength * index
          };
        }
      };
      this._getFrameMetrics = (index, props) => {
        var data = props.data,
          getItem = props.getItem,
          getItemCount = props.getItemCount,
          getItemLayout = props.getItemLayout;
        (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
        var item = getItem(data, index);
        var frame = this._frames[this._keyExtractor(item, index, props)];
        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
             * suppresses an error found when Flow v0.63 was deployed. To see the error
             * delete this comment and run Flow. */
            return getItemLayout(data, index);
          }
        }
        return frame;
      };
      this._getNonViewportRenderRegions = props => {
        // Keep a viewport's worth of content around the last focused cell to allow
        // random navigation around it without any blanking. E.g. tabbing from one
        // focused item out of viewport to another.
        if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {
          return [];
        }
        var lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];
        var focusedCellIndex = lastFocusedCellRenderer.props.index;
        var itemCount = props.getItemCount(props.data);

        // The last cell we rendered may be at a new index. Bail if we don't know
        // where it is.
        if (focusedCellIndex >= itemCount || this._keyExtractor(props.getItem(props.data, focusedCellIndex), focusedCellIndex, props) !== this._lastFocusedCellKey) {
          return [];
        }
        var first = focusedCellIndex;
        var heightOfCellsBeforeFocused = 0;
        for (var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {
          first--;
          heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(i, props).length;
        }
        var last = focusedCellIndex;
        var heightOfCellsAfterFocused = 0;
        for (var _i = last + 1; _i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; _i++) {
          last++;
          heightOfCellsAfterFocused += this.__getFrameMetricsApprox(_i, props).length;
        }
        return [{
          first,
          last
        }];
      };
      this._checkProps(_props);
      this._fillRateHelper = new _FillRateHelper.default(this._getFrameMetrics);
      this._updateCellsToRenderBatcher = new _Batchinator.default(this._updateCellsToRender, (_this$props$updateCel = this.props.updateCellsBatchingPeriod) !== null && _this$props$updateCel !== void 0 ? _this$props$updateCel : 50);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityHelper: new _ViewabilityHelper.default(pair.viewabilityConfig),
          onViewableItemsChanged: pair.onViewableItemsChanged
        }));
      } else {
        var _this$props3 = this.props,
          onViewableItemsChanged = _this$props3.onViewableItemsChanged,
          viewabilityConfig = _this$props3.viewabilityConfig;
        if (onViewableItemsChanged) {
          this._viewabilityTuples.push({
            viewabilityHelper: new _ViewabilityHelper.default(viewabilityConfig),
            onViewableItemsChanged: onViewableItemsChanged
          });
        }
      }
      var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
      this.state = {
        cellsAroundViewport: initialRenderRegion,
        renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)
      };

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      // For issue https://github.com/necolas/react-native-web/issues/995
      this.invertedWheelEventHandler = ev => {
        var scrollOffset = this.props.horizontal ? ev.target.scrollLeft : ev.target.scrollTop;
        var scrollLength = this.props.horizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
        var clientLength = this.props.horizontal ? ev.target.clientWidth : ev.target.clientHeight;
        var isEventTargetScrollable = scrollLength > clientLength;
        var delta = this.props.horizontal ? ev.deltaX || ev.wheelDeltaX : ev.deltaY || ev.wheelDeltaY;
        var leftoverDelta = delta;
        if (isEventTargetScrollable) {
          leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
        }
        var targetDelta = delta - leftoverDelta;
        if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
          var node = this._scrollRef.getScrollableNode();
          if (this.props.horizontal) {
            ev.target.scrollLeft += targetDelta;
            var nextScrollLeft = node.scrollLeft - leftoverDelta;
            node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
          } else {
            ev.target.scrollTop += targetDelta;
            var nextScrollTop = node.scrollTop - leftoverDelta;
            node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
          }
          ev.preventDefault();
        }
      };
    }
    _checkProps(props) {
      var onScroll = props.onScroll,
        windowSize = props.windowSize,
        getItemCount = props.getItemCount,
        data = props.data,
        initialScrollIndex = props.initialScrollIndex;
      (0, _invariant.default)(
      // $FlowFixMe[prop-missing]
      !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
      (0, _invariant.default)(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
      (0, _invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
      var itemCount = getItemCount(data);
      if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
        console.warn("initialScrollIndex \"" + initialScrollIndex + "\" is not valid (list has " + itemCount + " items)");
        this._hasWarned.initialScrollIndex = true;
      }
      if (__DEV__ && !this._hasWarned.flexWrap) {
        // $FlowFixMe[underconstrained-implicit-instantiation]
        var flatStyles = _StyleSheet.default.flatten(this.props.contentContainerStyle);
        if (flatStyles != null && flatStyles.flexWrap === 'wrap') {
          console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
          this._hasWarned.flexWrap = true;
        }
      }
    }
    static _createRenderMask(props, cellsAroundViewport, additionalRegions) {
      var itemCount = props.getItemCount(props.data);
      (0, _invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, "Invalid cells around viewport \"[" + cellsAroundViewport.first + ", " + cellsAroundViewport.last + "]\" was passed to VirtualizedList._createRenderMask");
      var renderMask = new _CellRenderMask.CellRenderMask(itemCount);
      if (itemCount > 0) {
        var allRegions = [cellsAroundViewport, ...(additionalRegions !== null && additionalRegions !== void 0 ? additionalRegions : [])];
        for (var _i2 = 0, _allRegions = allRegions; _i2 < _allRegions.length; _i2++) {
          var region = _allRegions[_i2];
          renderMask.addCells(region);
        }

        // The initially rendered cells are retained as part of the
        // "scroll-to-top" optimization
        if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
          var initialRegion = VirtualizedList._initialRenderRegion(props);
          renderMask.addCells(initialRegion);
        }

        // The layout coordinates of sticker headers may be off-screen while the
        // actual header is on-screen. Keep the most recent before the viewport
        // rendered, even if its layout coordinates are not in viewport.
        var stickyIndicesSet = new Set(props.stickyHeaderIndices);
        VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
      }
      return renderMask;
    }
    static _initialRenderRegion(props) {
      var _props$initialScrollI;
      var itemCount = props.getItemCount(props.data);
      var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor((_props$initialScrollI = props.initialScrollIndex) !== null && _props$initialScrollI !== void 0 ? _props$initialScrollI : 0)));
      var lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;
      return {
        first: firstCellIndex,
        last: lastCellIndex
      };
    }
    static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
      var stickyOffset = props.ListHeaderComponent ? 1 : 0;
      for (var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {
        if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
          renderMask.addCells({
            first: itemIdx,
            last: itemIdx
          });
          break;
        }
      }
    }
    _adjustCellsAroundViewport(props, cellsAroundViewport) {
      var data = props.data,
        getItemCount = props.getItemCount;
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
      var _this$_scrollMetrics = this._scrollMetrics,
        contentLength = _this$_scrollMetrics.contentLength,
        offset = _this$_scrollMetrics.offset,
        visibleLength = _this$_scrollMetrics.visibleLength;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Wait until the scroll view metrics have been set up. And until then,
      // we will trust the initialNumToRender suggestion
      if (visibleLength <= 0 || contentLength <= 0) {
        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
      }
      var newCellsAroundViewport;
      if (props.disableVirtualization) {
        var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;
        newCellsAroundViewport = {
          first: 0,
          last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
        };
      } else {
        // If we have a non-zero initialScrollIndex and run this before we've scrolled,
        // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
        // So let's wait until we've scrolled the view to the right place. And until then,
        // we will trust the initialScrollIndex suggestion.

        // Thus, we want to recalculate the windowed render limits if any of the following hold:
        // - initialScrollIndex is undefined or is 0
        // - initialScrollIndex > 0 AND scrolling is complete
        // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
        //   where the list is shorter than the visible area)
        if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {
          return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
        }
        newCellsAroundViewport = (0, _VirtualizeUtils.computeWindowedRenderLimits)(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
        (0, _invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
      }
      if (this._nestedChildLists.size() > 0) {
        // If some cell in the new state has a child list in it, we should only render
        // up through that item, so that we give that list a chance to render.
        // Otherwise there's churn from multiple child lists mounting and un-mounting
        // their items.

        // Will this prevent rendering if the nested list doesn't realize the end?
        var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
        newCellsAroundViewport.last = childIdx !== null && childIdx !== void 0 ? childIdx : newCellsAroundViewport.last;
      }
      return newCellsAroundViewport;
    }
    _findFirstChildWithMore(first, last) {
      for (var ii = first; ii <= last; ii++) {
        var cellKeyForIndex = this._indicesToKeys.get(ii);
        if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {
          return ii;
        }
      }
      return null;
    }
    componentDidMount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.registerAsNestedChild({
          ref: this,
          cellKey: this.context.cellKey
        });
      }

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.setupWebWheelHandler();
    }
    componentWillUnmount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.unregisterAsNestedChild({
          ref: this
        });
      }
      this._updateCellsToRenderBatcher.dispose({
        abort: true
      });
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.dispose();
      });
      this._fillRateHelper.deactivateAndFlush();

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.teardownWebWheelHandler();
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    setupWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().addEventListener('wheel', this.invertedWheelEventHandler);
      } else {
        setTimeout(() => this.setupWebWheelHandler(), 50);
        return;
      }
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    teardownWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().removeEventListener('wheel', this.invertedWheelEventHandler);
      }
    }
    static getDerivedStateFromProps(newProps, prevState) {
      // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
      // sure we're rendering a reasonable range here.
      var itemCount = newProps.getItemCount(newProps.data);
      if (itemCount === prevState.renderMask.numCells()) {
        return prevState;
      }
      var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);
      return {
        cellsAroundViewport: constrainedCells,
        renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)
      };
    }
    _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
      var _this = this;
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListHeaderComponent = _this$props4.ListHeaderComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        data = _this$props4.data,
        debug = _this$props4.debug,
        getItem = _this$props4.getItem,
        getItemCount = _this$props4.getItemCount,
        getItemLayout = _this$props4.getItemLayout,
        horizontal = _this$props4.horizontal,
        renderItem = _this$props4.renderItem;
      var stickyOffset = ListHeaderComponent ? 1 : 0;
      var end = getItemCount(data) - 1;
      var prevCellKey;
      last = Math.min(end, last);
      var _loop = function _loop() {
        var item = getItem(data, ii);
        var key = _this._keyExtractor(item, ii, _this.props);
        _this._indicesToKeys.set(ii, key);
        if (stickyIndicesFromProps.has(ii + stickyOffset)) {
          stickyHeaderIndices.push(cells.length);
        }
        var shouldListenForLayout = getItemLayout == null || debug || _this._fillRateHelper.enabled();
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListCellRenderer.default, (0, _extends2.default)({
          CellRendererComponent: CellRendererComponent,
          ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
          ListItemComponent: ListItemComponent,
          cellKey: key,
          horizontal: horizontal,
          index: ii,
          inversionStyle: inversionStyle,
          item: item,
          key: key,
          prevCellKey: prevCellKey,
          onUpdateSeparators: _this._onUpdateSeparators,
          onCellFocusCapture: e => _this._onCellFocusCapture(key),
          onUnmount: _this._onCellUnmount,
          ref: _ref => {
            _this._cellRefs[key] = _ref;
          },
          renderItem: renderItem
        }, shouldListenForLayout && {
          onCellLayout: _this._onCellLayout
        })));
        prevCellKey = key;
      };
      for (var ii = first; ii <= last; ii++) {
        _loop();
      }
    }
    static _constrainToItemCount(cells, props) {
      var itemCount = props.getItemCount(props.data);
      var last = Math.min(itemCount - 1, cells.last);
      var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
      return {
        first: (0, _clamp.default)(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
        last
      };
    }
    _isNestedWithSameOrientation() {
      var nestedContext = this.context;
      return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
    }
    _keyExtractor(item, index, props
    // $FlowFixMe[missing-local-annot]
    ) {
      if (props.keyExtractor != null) {
        return props.keyExtractor(item, index);
      }
      var key = (0, _VirtualizeUtils.keyExtractor)(item, index);
      if (key === String(index)) {
        _usedIndexForKey = true;
        if (item.type && item.type.displayName) {
          _keylessItemComponentName = item.type.displayName;
        }
      }
      return key;
    }
    render() {
      this._checkProps(this.props);
      var _this$props5 = this.props,
        ListEmptyComponent = _this$props5.ListEmptyComponent,
        ListFooterComponent = _this$props5.ListFooterComponent,
        ListHeaderComponent = _this$props5.ListHeaderComponent;
      var _this$props6 = this.props,
        data = _this$props6.data,
        horizontal = _this$props6.horizontal;
      var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
      var cells = [];
      var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
      var stickyHeaderIndices = [];

      // 1. Add cell for ListHeaderComponent
      if (ListHeaderComponent) {
        if (stickyIndicesFromProps.has(0)) {
          stickyHeaderIndices.push(0);
        }
        var _element = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListHeaderComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-header',
          key: "$header"
        }, /*#__PURE__*/React.createElement(_View.default, {
          onLayout: this._onLayoutHeader,
          style: [inversionStyle, this.props.ListHeaderComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element)));
      }

      // 2a. Add a cell for ListEmptyComponent if applicable
      var itemCount = this.props.getItemCount(data);
      if (itemCount === 0 && ListEmptyComponent) {
        var _element2 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListEmptyComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-empty',
          key: "$empty"
        }, /*#__PURE__*/React.cloneElement(_element2, {
          onLayout: event => {
            this._onLayoutEmpty(event);
            if (_element2.props.onLayout) {
              _element2.props.onLayout(event);
            }
          },
          style: [inversionStyle, _element2.props.style]
        })));
      }

      // 2b. Add cells and spacers for each item
      if (itemCount > 0) {
        _usedIndexForKey = false;
        _keylessItemComponentName = '';
        var spacerKey = this._getSpacerKey(!horizontal);
        var renderRegions = this.state.renderMask.enumerateRegions();
        var lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);
        for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(renderRegions), _step; !(_step = _iterator()).done;) {
          var section = _step.value;
          if (section.isSpacer) {
            // Legacy behavior is to avoid spacers when virtualization is
            // disabled (including head spacers on initial render).
            if (this.props.disableVirtualization) {
              continue;
            }

            // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
            // prevent the user for hyperscrolling into un-measured area because otherwise content will
            // likely jump around as it renders in above the viewport.
            var isLastSpacer = section === lastSpacer;
            var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
            var last = constrainToMeasured ? (0, _clamp.default)(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;
            var firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);
            var lastMetrics = this.__getFrameMetricsApprox(last, this.props);
            var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
            cells.push(/*#__PURE__*/React.createElement(_View.default, {
              key: "$spacer-" + section.first,
              style: {
                [spacerKey]: spacerSize
              }
            }));
          } else {
            this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
          }
        }
        if (!this._hasWarned.keys && _usedIndexForKey) {
          console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
          this._hasWarned.keys = true;
        }
      }

      // 3. Add cell for ListFooterComponent
      if (ListFooterComponent) {
        var _element3 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListFooterComponent) ? ListFooterComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListFooterComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
          cellKey: this._getFooterCellKey(),
          key: "$footer"
        }, /*#__PURE__*/React.createElement(_View.default, {
          onLayout: this._onLayoutFooter,
          style: [inversionStyle, this.props.ListFooterComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element3)));
      }

      // 4. Render the ScrollView
      var scrollProps = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this.props), {}, {
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        onScroll: this._onScroll,
        onScrollBeginDrag: this._onScrollBeginDrag,
        onScrollEndDrag: this._onScrollEndDrag,
        onMomentumScrollBegin: this._onMomentumScrollBegin,
        onMomentumScrollEnd: this._onMomentumScrollEnd,
        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
        // TODO: Android support
        invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
        stickyHeaderIndices,
        style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
      });
      this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
      var innerRet = /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListContextProvider, {
        value: {
          cellKey: null,
          getScrollMetrics: this._getScrollMetrics,
          horizontal: horizontalOrDefault(this.props.horizontal),
          getOutermostParentListRef: this._getOutermostParentListRef,
          registerAsNestedChild: this._registerAsNestedChild,
          unregisterAsNestedChild: this._unregisterAsNestedChild
        }
      }, /*#__PURE__*/React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
        ref: this._captureScrollRef
      }, cells));
      var ret = innerRet;
      /* https://github.com/necolas/react-native-web/issues/2239: Re-enable when ScrollView.Context.Consumer is available.
      if (__DEV__) {
        ret = (
          <ScrollView.Context.Consumer>
            {scrollContext => {
              if (
                scrollContext != null &&
                !scrollContext.horizontal ===
                  !horizontalOrDefault(this.props.horizontal) &&
                !this._hasWarned.nesting &&
                this.context == null &&
                this.props.scrollEnabled !== false
              ) {
                // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170
                console.error(
                  'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +
                    'orientation because it can break windowing and other functionality - use another ' +
                    'VirtualizedList-backed container instead.',
                );
                this._hasWarned.nesting = true;
              }
              return innerRet;
            }}
          </ScrollView.Context.Consumer>
        );
      }*/
      if (this.props.debug) {
        return /*#__PURE__*/React.createElement(_View.default, {
          style: styles.debug
        }, ret, this._renderDebugOverlay());
      } else {
        return ret;
      }
    }
    componentDidUpdate(prevProps) {
      var _this$props7 = this.props,
        data = _this$props7.data,
        extraData = _this$props7.extraData;
      if (data !== prevProps.data || extraData !== prevProps.extraData) {
        // clear the viewableIndices cache to also trigger
        // the onViewableItemsChanged callback with the new data
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.resetViewableIndices();
        });
      }
      // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
      // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
      // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
      // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
      // `_scheduleCellsToRenderUpdate` will check this condition and not perform
      // another hiPri update.
      var hiPriInProgress = this._hiPriInProgress;
      this._scheduleCellsToRenderUpdate();
      // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
      // is triggered with `this._hiPriInProgress = true`
      if (hiPriInProgress) {
        this._hiPriInProgress = false;
      }
    }

    // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex

    // flag to prevent infinite hiPri cell limit update

    // $FlowFixMe[missing-local-annot]

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _computeBlankness() {
      this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
    }

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _onCellFocusCapture(cellKey) {
      this._lastFocusedCellKey = cellKey;
      this._updateCellsToRender();
    }
    _triggerRemeasureForChildListsInCell(cellKey) {
      this._nestedChildLists.forEachInCell(cellKey, childList => {
        childList.measureLayoutRelativeToContainingList();
      });
    }
    measureLayoutRelativeToContainingList() {
      // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
      // node on an unmounted component" during scrolling
      try {
        if (!this._scrollRef) {
          return;
        }
        // We are assuming that getOutermostParentListRef().getScrollRef()
        // is a non-null reference to a ScrollView
        this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {
          this._offsetFromParentVirtualizedList = this._selectOffset({
            x,
            y
          });
          this._scrollMetrics.contentLength = this._selectLength({
            width,
            height
          });
          var scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());
          var metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;
          if (metricsChanged) {
            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
            this._scrollMetrics.offset = scrollMetrics.offset;

            // If metrics of the scrollView changed, then we triggered remeasure for child list
            // to ensure VirtualizedList has the right information.
            this._nestedChildLists.forEach(childList => {
              childList.measureLayoutRelativeToContainingList();
            });
          }
        }, error => {
          console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
        });
      } catch (error) {
        console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
      }
    }
    _getFooterCellKey() {
      return this._getCellKey() + '-footer';
    }
    // $FlowFixMe[missing-local-annot]
    _renderDebugOverlay() {
      var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
      var framesInLayout = [];
      var itemCount = this.props.getItemCount(this.props.data);
      for (var ii = 0; ii < itemCount; ii++) {
        var frame = this.__getFrameMetricsApprox(ii, this.props);
        /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
         * suppresses an error found when Flow v0.68 was deployed. To see the
         * error delete this comment and run Flow. */
        if (frame.inLayout) {
          framesInLayout.push(frame);
        }
      }
      var windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
      var frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);
      var windowLen = frameLast.offset + frameLast.length - windowTop;
      var visTop = this._scrollMetrics.offset;
      var visLen = this._scrollMetrics.visibleLength;
      return /*#__PURE__*/React.createElement(_View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlay]
      }, framesInLayout.map((f, ii) => /*#__PURE__*/React.createElement(_View.default, {
        key: 'f' + ii,
        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
          top: f.offset * normalize,
          height: f.length * normalize
        }]
      })), /*#__PURE__*/React.createElement(_View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
          top: windowTop * normalize,
          height: windowLen * normalize
        }]
      }), /*#__PURE__*/React.createElement(_View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
          top: visTop * normalize,
          height: visLen * normalize
        }]
      }));
    }
    _selectLength(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
    }
    _selectOffset(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
    }
    _maybeCallOnEdgeReached() {
      var _this$props8 = this.props,
        data = _this$props8.data,
        getItemCount = _this$props8.getItemCount,
        onStartReached = _this$props8.onStartReached,
        onStartReachedThreshold = _this$props8.onStartReachedThreshold,
        onEndReached = _this$props8.onEndReached,
        onEndReachedThreshold = _this$props8.onEndReachedThreshold,
        initialScrollIndex = _this$props8.initialScrollIndex;
      var _this$_scrollMetrics2 = this._scrollMetrics,
        contentLength = _this$_scrollMetrics2.contentLength,
        visibleLength = _this$_scrollMetrics2.visibleLength,
        offset = _this$_scrollMetrics2.offset;
      var distanceFromStart = offset;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
      // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
      // be at the edge of the list with a distance approximating 0 but not quite there.
      if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
        distanceFromStart = 0;
      }
      if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
        distanceFromEnd = 0;
      }

      // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
      // when oERT is not present (different from 2 viewports used elsewhere)
      var DEFAULT_THRESHOLD_PX = 2;
      var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var isWithinStartThreshold = distanceFromStart <= startThreshold;
      var isWithinEndThreshold = distanceFromEnd <= endThreshold;

      // First check if the user just scrolled within the end threshold
      // and call onEndReached only once for a given content length,
      // and only if onStartReached is not being executed
      if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
        this._sentEndForContentLength = this._scrollMetrics.contentLength;
        onEndReached({
          distanceFromEnd
        });
      }

      // Next check if the user just scrolled within the start threshold
      // and call onStartReached only once for a given content length,
      // and only if onEndReached is not being executed
      else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
        // On initial mount when using initialScrollIndex the offset will be 0 initially
        // and will trigger an unexpected onStartReached. To avoid this we can use
        // timestamp to differentiate between the initial scroll metrics and when we actually
        // received the first scroll event.
        if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
          this._sentStartForContentLength = this._scrollMetrics.contentLength;
          onStartReached({
            distanceFromStart
          });
        }
      }

      // If the user scrolls away from the start or end and back again,
      // cause onStartReached or onEndReached to be triggered again
      else {
        this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
        this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
      }
    }

    /* Translates metrics from a scroll event in a parent VirtualizedList into
     * coordinates relative to the child list.
     */

    _scheduleCellsToRenderUpdate() {
      var _this$state$cellsArou = this.state.cellsAroundViewport,
        first = _this$state$cellsArou.first,
        last = _this$state$cellsArou.last;
      var _this$_scrollMetrics3 = this._scrollMetrics,
        offset = _this$_scrollMetrics3.offset,
        visibleLength = _this$_scrollMetrics3.visibleLength,
        velocity = _this$_scrollMetrics3.velocity;
      var itemCount = this.props.getItemCount(this.props.data);
      var hiPri = false;
      var onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
      // Mark as high priority if we're close to the start of the first item
      // But only if there are items before the first rendered item
      if (first > 0) {
        var distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;
        hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
      }
      // Mark as high priority if we're close to the end of the last item
      // But only if there are items after the last rendered item
      if (!hiPri && last >= 0 && last < itemCount - 1) {
        var distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);
        hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
      }
      // Only trigger high-priority updates if we've actually rendered cells,
      // and with that size estimate, accurately compute how many cells we should render.
      // Otherwise, it would just render as many cells as it can (of zero dimension),
      // each time through attempting to render more (limited by maxToRenderPerBatch),
      // starving the renderer from actually laying out the objects and computing _averageCellLength.
      // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
      // We shouldn't do another hipri cellToRenderUpdate
      if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
        this._hiPriInProgress = true;
        // Don't worry about interactions when scrolling quickly; focus on filling content as fast
        // as possible.
        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });
        this._updateCellsToRender();
        return;
      } else {
        this._updateCellsToRenderBatcher.schedule();
      }
    }

    /**
     * Gets an approximate offset to an item at a given index. Supports
     * fractional indices.
     */

    _updateViewableItems(props, cellsAroundViewport) {
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
      });
    }
  }
  VirtualizedList.contextType = _VirtualizedListContext.VirtualizedListContext;
  var styles = _StyleSheet.default.create({
    verticallyInverted: {
      transform: 'scaleY(-1)'
    },
    horizontallyInverted: {
      transform: 'scaleX(-1)'
    },
    debug: {
      flex: 1
    },
    debugOverlayBase: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    debugOverlay: {
      bottom: 0,
      width: 20,
      borderColor: 'blue',
      borderWidth: 1
    },
    debugOverlayFrame: {
      left: 0,
      backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
      left: 0,
      borderColor: 'green',
      borderWidth: 2
    },
    debugOverlayFrameVis: {
      left: 0,
      borderColor: 'red',
      borderWidth: 2
    }
  });
  var _default = exports.default = VirtualizedList;
},130,[17,889,888,868,134,135,111,30,142,147,148,149,150,151,152,153,154,155,156,129,157,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _View = _interopRequireDefault(require(_dependencyMap[2], "../View"));
  var _react = _interopRequireDefault(require(_dependencyMap[3], "react"));
  var _excluded = ["colors", "enabled", "onRefresh", "progressBackgroundColor", "progressViewOffset", "refreshing", "size", "tintColor", "title", "titleColor"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function RefreshControl(props) {
    var colors = props.colors,
      enabled = props.enabled,
      onRefresh = props.onRefresh,
      progressBackgroundColor = props.progressBackgroundColor,
      progressViewOffset = props.progressViewOffset,
      refreshing = props.refreshing,
      size = props.size,
      tintColor = props.tintColor,
      title = props.title,
      titleColor = props.titleColor,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    return /*#__PURE__*/_react.default.createElement(_View.default, rest);
  }
  var _default = exports.default = RefreshControl;
},134,[17,873,111,3],"node_modules\\react-native-web\\dist\\exports\\RefreshControl\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _extends2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[4], "../Dimensions"));
  var _dismissKeyboard = _interopRequireDefault(require(_dependencyMap[5], "../../modules/dismissKeyboard"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[6], "fbjs/lib/invariant"));
  var _mergeRefs = _interopRequireDefault(require(_dependencyMap[7], "../../modules/mergeRefs"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[8], "../Platform"));
  var _ScrollViewBase = _interopRequireDefault(require(_dependencyMap[9], "./ScrollViewBase"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[10], "../StyleSheet"));
  var _TextInputState = _interopRequireDefault(require(_dependencyMap[11], "../../modules/TextInputState"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[12], "../UIManager"));
  var _View = _interopRequireDefault(require(_dependencyMap[13], "../View"));
  var _react = _interopRequireDefault(require(_dependencyMap[14], "react"));
  var _warning = _interopRequireDefault(require(_dependencyMap[15], "fbjs/lib/warning"));
  var _excluded = ["contentContainerStyle", "horizontal", "onContentSizeChange", "refreshControl", "stickyHeaderIndices", "pagingEnabled", "forwardedRef", "keyboardDismissMode", "onScroll", "centerContent"];
  var emptyObject = {};
  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
  class ScrollView extends _react.default.Component {
    constructor() {
      super(...arguments);
      this._scrollNodeRef = null;
      this._innerViewRef = null;
      this.isTouching = false;
      this.lastMomentumScrollBeginTime = 0;
      this.lastMomentumScrollEndTime = 0;
      this.observedScrollSinceBecomingResponder = false;
      this.becameResponderWhileAnimating = false;
      this.scrollResponderHandleScrollShouldSetResponder = () => {
        return this.isTouching;
      };
      this.scrollResponderHandleStartShouldSetResponderCapture = e => {
        // First see if we want to eat taps while the keyboard is up
        // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
        // if (!this.props.keyboardShouldPersistTaps &&
        //   currentlyFocusedTextInput != null &&
        //   e.target !== currentlyFocusedTextInput) {
        //   return true;
        // }
        return this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleTerminationRequest = () => {
        return !this.observedScrollSinceBecomingResponder;
      };
      this.scrollResponderHandleTouchEnd = e => {
        var nativeEvent = e.nativeEvent;
        this.isTouching = nativeEvent.touches.length !== 0;
        this.props.onTouchEnd && this.props.onTouchEnd(e);
      };
      this.scrollResponderHandleResponderRelease = e => {
        this.props.onResponderRelease && this.props.onResponderRelease(e);

        // By default scroll views will unfocus a textField
        // if another touch occurs outside of it
        var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedField();
        if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {
          this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
          _TextInputState.default.blurTextInput(currentlyFocusedTextInput);
        }
      };
      this.scrollResponderHandleScroll = e => {
        this.observedScrollSinceBecomingResponder = true;
        this.props.onScroll && this.props.onScroll(e);
      };
      this.scrollResponderHandleResponderGrant = e => {
        this.observedScrollSinceBecomingResponder = false;
        this.props.onResponderGrant && this.props.onResponderGrant(e);
        this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleScrollBeginDrag = e => {
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this.scrollResponderHandleScrollEndDrag = e => {
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this.scrollResponderHandleMomentumScrollBegin = e => {
        this.lastMomentumScrollBeginTime = Date.now();
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this.scrollResponderHandleMomentumScrollEnd = e => {
        this.lastMomentumScrollEndTime = Date.now();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this.scrollResponderHandleTouchStart = e => {
        this.isTouching = true;
        this.props.onTouchStart && this.props.onTouchStart(e);
      };
      this.scrollResponderHandleTouchMove = e => {
        this.props.onTouchMove && this.props.onTouchMove(e);
      };
      this.scrollResponderIsAnimating = () => {
        var now = Date.now();
        var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;
        var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
        return isAnimating;
      };
      this.scrollResponderScrollTo = (x, y, animated) => {
        if (typeof x === 'number') {
          console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref = x || emptyObject;
          x = _ref.x;
          y = _ref.y;
          animated = _ref.animated;
        }
        var node = this.getScrollableNode();
        var left = x || 0;
        var top = y || 0;
        if (node != null) {
          if (typeof node.scroll === 'function') {
            node.scroll({
              top,
              left,
              behavior: !animated ? 'auto' : 'smooth'
            });
          } else {
            node.scrollLeft = left;
            node.scrollTop = top;
          }
        }
      };
      this.scrollResponderZoomTo = (rect, animated) => {
        if (_Platform.default.OS !== 'ios') {
          (0, _invariant.default)('zoomToRect is not implemented');
        }
      };
      this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
        this.additionalScrollOffset = additionalOffset || 0;
        this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
        _UIManager.default.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
      };
      this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {
        var keyboardScreenY = _Dimensions.default.get('window').height;
        if (this.keyboardWillOpenTo) {
          keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
        }
        var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

        // By default, this can scroll with negative offset, pulling the content
        // down so that the target component's bottom meets the keyboard's top.
        // If requested otherwise, cap the offset at 0 minimum to avoid content
        // shifting down.
        if (this.preventNegativeScrollOffset) {
          scrollOffsetY = Math.max(0, scrollOffsetY);
        }
        this.scrollResponderScrollTo({
          x: 0,
          y: scrollOffsetY,
          animated: true
        });
        this.additionalOffset = 0;
        this.preventNegativeScrollOffset = false;
      };
      this.scrollResponderKeyboardWillShow = e => {
        this.keyboardWillOpenTo = e;
        this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
      };
      this.scrollResponderKeyboardWillHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
      };
      this.scrollResponderKeyboardDidShow = e => {
        // TODO(7693961): The event for DidShow is not available on iOS yet.
        // Use the one from WillShow and do not assign.
        if (e) {
          this.keyboardWillOpenTo = e;
        }
        this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
      };
      this.scrollResponderKeyboardDidHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
      };
      this.flashScrollIndicators = () => {
        this.scrollResponderFlashScrollIndicators();
      };
      this.getScrollResponder = () => {
        return this;
      };
      this.getScrollableNode = () => {
        return this._scrollNodeRef;
      };
      this.getInnerViewRef = () => {
        return this._innerViewRef;
      };
      this.getInnerViewNode = () => {
        return this._innerViewRef;
      };
      this.getNativeScrollRef = () => {
        return this._scrollNodeRef;
      };
      this.scrollTo = (y, x, animated) => {
        if (typeof y === 'number') {
          console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref2 = y || emptyObject;
          x = _ref2.x;
          y = _ref2.y;
          animated = _ref2.animated;
        }
        this.scrollResponderScrollTo({
          x: x || 0,
          y: y || 0,
          animated: animated !== false
        });
      };
      this.scrollToEnd = options => {
        // Default to true
        var animated = (options && options.animated) !== false;
        var horizontal = this.props.horizontal;
        var scrollResponderNode = this.getScrollableNode();
        var x = horizontal ? scrollResponderNode.scrollWidth : 0;
        var y = horizontal ? 0 : scrollResponderNode.scrollHeight;
        this.scrollResponderScrollTo({
          x,
          y,
          animated
        });
      };
      this._handleContentOnLayout = e => {
        var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
        this.props.onContentSizeChange(width, height);
      };
      this._handleScroll = e => {
        if (process.env.NODE_ENV !== 'production') {
          if (this.props.onScroll && this.props.scrollEventThrottle == null) {
            console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + "cause frame drops, use a bigger number if you don't need as " + 'much precision.');
          }
        }
        if (this.props.keyboardDismissMode === 'on-drag') {
          (0, _dismissKeyboard.default)();
        }
        this.scrollResponderHandleScroll(e);
      };
      this._setInnerViewRef = node => {
        this._innerViewRef = node;
      };
      this._setScrollNodeRef = node => {
        this._scrollNodeRef = node;
        // ScrollView needs to add more methods to the hostNode in addition to those
        // added by `usePlatformMethods`. This is temporarily until an API like
        // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.
        if (node != null) {
          node.getScrollResponder = this.getScrollResponder;
          node.getInnerViewNode = this.getInnerViewNode;
          node.getInnerViewRef = this.getInnerViewRef;
          node.getNativeScrollRef = this.getNativeScrollRef;
          node.getScrollableNode = this.getScrollableNode;
          node.scrollTo = this.scrollTo;
          node.scrollToEnd = this.scrollToEnd;
          node.flashScrollIndicators = this.flashScrollIndicators;
          node.scrollResponderZoomTo = this.scrollResponderZoomTo;
          node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;
        }
        var ref = (0, _mergeRefs.default)(this.props.forwardedRef);
        ref(node);
      };
    }
    /**
     * ------------------------------------------------------
     * START SCROLLRESPONDER
     * ------------------------------------------------------
     */
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    /**
     * Invoke this from an `onScroll` event.
     */
    /**
     * Merely touch starting is not sufficient for a scroll view to become the
     * responder. Being the "responder" means that the very next touch move/end
     * event will result in an action/movement.
     *
     * Invoke this from an `onStartShouldSetResponder` event.
     *
     * `onStartShouldSetResponder` is used when the next move/end will trigger
     * some UI movement/action, but when you want to yield priority to views
     * nested inside of the view.
     *
     * There may be some cases where scroll views actually should return `true`
     * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
     * that gives priority to nested views.
     *
     * - If a single tap on the scroll view triggers an action such as
     *   recentering a map style view yet wants to give priority to interaction
     *   views inside (such as dropped pins or labels), then we would return true
     *   from this method when there is a single touch.
     *
     * - Similar to the previous case, if a two finger "tap" should trigger a
     *   zoom, we would check the `touches` count, and if `>= 2`, we would return
     *   true.
     *
     */
    scrollResponderHandleStartShouldSetResponder() {
      return false;
    }

    /**
     * There are times when the scroll view wants to become the responder
     * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
     * that *doesn't* give priority to nested views (hence the capture phase):
     *
     * - Currently animating.
     * - Tapping anywhere that is not the focused input, while the keyboard is
     *   up (which should dismiss the keyboard).
     *
     * Invoke this from an `onStartShouldSetResponderCapture` event.
     */

    /**
     * Invoke this from an `onResponderReject` event.
     *
     * Some other element is not yielding its role as responder. Normally, we'd
     * just disable the `UIScrollView`, but a touch has already began on it, the
     * `UIScrollView` will not accept being disabled after that. The easiest
     * solution for now is to accept the limitation of disallowing this
     * altogether. To improve this, find a way to disable the `UIScrollView` after
     * a touch has already started.
     */
    scrollResponderHandleResponderReject() {
      (0, _warning.default)(false, "ScrollView doesn't take rejection well - scrolls anyway");
    }

    /**
     * We will allow the scroll view to give up its lock iff it acquired the lock
     * during an animation. This is a very useful default that happens to satisfy
     * many common user experiences.
     *
     * - Stop a scroll on the left edge, then turn that into an outer view's
     *   backswipe.
     * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
     *   view dismiss.
     * - However, without catching the scroll view mid-bounce (while it is
     *   motionless), if you drag far enough for the scroll view to become
     *   responder (and therefore drag the scroll view a bit), any backswipe
     *   navigation of a swipe gesture higher in the view hierarchy, should be
     *   rejected.
     */

    /**
     * Invoke this from an `onTouchEnd` event.
     *
     * @param {SyntheticEvent} e Event.
     */

    /**
     * Invoke this from an `onResponderRelease` event.
     */

    /**
     * Invoke this from an `onResponderGrant` event.
     */

    /**
     * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
     * animation, and there's not an easy way to distinguish a drag vs. stopping
     * momentum.
     *
     * Invoke this from an `onScrollBeginDrag` event.
     */

    /**
     * Invoke this from an `onScrollEndDrag` event.
     */

    /**
     * Invoke this from an `onMomentumScrollBegin` event.
     */

    /**
     * Invoke this from an `onMomentumScrollEnd` event.
     */

    /**
     * Invoke this from an `onTouchStart` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * Invoke this from an `onTouchMove` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * A helper function for this class that lets us quickly determine if the
     * view is currently animating. This is particularly useful to know when
     * a touch has just started or ended.
     */

    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */

    /**
     * Displays the scroll indicators momentarily.
     */
    scrollResponderFlashScrollIndicators() {}

    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */

    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */

    scrollResponderTextInputFocusError(e) {
      console.error('Error measuring text field: ', e);
    }

    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */

    /**
     * ------------------------------------------------------
     * END SCROLLRESPONDER
     * ------------------------------------------------------
     */

    /**
     * Returns a reference to the underlying scroll responder, which supports
     * operations like `scrollTo`. All ScrollView-like components should
     * implement this method so that they can be composed while providing access
     * to the underlying scroll responder's methods.
     */

    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */

    render() {
      var _this$props = this.props,
        contentContainerStyle = _this$props.contentContainerStyle,
        horizontal = _this$props.horizontal,
        onContentSizeChange = _this$props.onContentSizeChange,
        refreshControl = _this$props.refreshControl,
        stickyHeaderIndices = _this$props.stickyHeaderIndices,
        pagingEnabled = _this$props.pagingEnabled,
        forwardedRef = _this$props.forwardedRef,
        keyboardDismissMode = _this$props.keyboardDismissMode,
        onScroll = _this$props.onScroll,
        centerContent = _this$props.centerContent,
        other = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      if (process.env.NODE_ENV !== 'production' && this.props.style) {
        var style = _StyleSheet.default.flatten(this.props.style);
        var childLayoutProps = ['alignItems', 'justifyContent'].filter(prop => style && style[prop] !== undefined);
        (0, _invariant.default)(childLayoutProps.length === 0, "ScrollView child layout (" + JSON.stringify(childLayoutProps) + ") " + 'must be applied through the contentContainerStyle prop.');
      }
      var contentSizeChangeProps = {};
      if (onContentSizeChange) {
        contentSizeChangeProps = {
          onLayout: this._handleContentOnLayout
        };
      }
      var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);
      var children = hasStickyHeaderIndices || pagingEnabled ? _react.default.Children.map(this.props.children, (child, i) => {
        var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
        if (child != null && (isSticky || pagingEnabled)) {
          return /*#__PURE__*/_react.default.createElement(_View.default, {
            style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]
          }, child);
        } else {
          return child;
        }
      }) : this.props.children;
      var contentContainer = /*#__PURE__*/_react.default.createElement(_View.default, (0, _extends2.default)({}, contentSizeChangeProps, {
        children: children,
        collapsable: false,
        ref: this._setInnerViewRef,
        style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]
      }));
      var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;
      var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;
      var props = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, other), {}, {
        style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
        onTouchStart: this.scrollResponderHandleTouchStart,
        onTouchMove: this.scrollResponderHandleTouchMove,
        onTouchEnd: this.scrollResponderHandleTouchEnd,
        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
        onScroll: this._handleScroll,
        onResponderGrant: this.scrollResponderHandleResponderGrant,
        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
        onResponderTerminate: this.scrollResponderHandleTerminate,
        onResponderRelease: this.scrollResponderHandleResponderRelease,
        onResponderReject: this.scrollResponderHandleResponderReject
      });
      var ScrollViewClass = _ScrollViewBase.default;
      (0, _invariant.default)(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');
      var scrollView = /*#__PURE__*/_react.default.createElement(ScrollViewClass, (0, _extends2.default)({}, props, {
        ref: this._setScrollNodeRef
      }), contentContainer);
      if (refreshControl) {
        return /*#__PURE__*/_react.default.cloneElement(refreshControl, {
          style: props.style
        }, scrollView);
      }
      return scrollView;
    }
  }
  var commonStyle = {
    flexGrow: 1,
    flexShrink: 1,
    // Enable hardware compositing in modern browsers.
    // Creates a new layer with its own backing surface that can significantly
    // improve scroll performance.
    transform: 'translateZ(0)',
    // iOS native scrolling
    WebkitOverflowScrolling: 'touch'
  };
  var styles = _StyleSheet.default.create({
    baseVertical: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {
      flexDirection: 'column',
      overflowX: 'hidden',
      overflowY: 'auto'
    }),
    baseHorizontal: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {
      flexDirection: 'row',
      overflowX: 'auto',
      overflowY: 'hidden'
    }),
    contentContainerHorizontal: {
      flexDirection: 'row'
    },
    contentContainerCenterContent: {
      justifyContent: 'center',
      flexGrow: 1
    },
    stickyHeader: {
      position: 'sticky',
      top: 0,
      zIndex: 10
    },
    pagingEnabledHorizontal: {
      scrollSnapType: 'x mandatory'
    },
    pagingEnabledVertical: {
      scrollSnapType: 'y mandatory'
    },
    pagingEnabledChild: {
      scrollSnapAlign: 'start'
    }
  });
  var ForwardedScrollView = /*#__PURE__*/_react.default.forwardRef((props, forwardedRef) => {
    return /*#__PURE__*/_react.default.createElement(ScrollView, (0, _extends2.default)({}, props, {
      forwardedRef: forwardedRef
    }));
  });
  ForwardedScrollView.displayName = 'ScrollView';
  var _default = exports.default = ForwardedScrollView;
},135,[17,868,888,873,136,137,129,117,106,139,30,138,97,111,3,140],"node_modules\\react-native-web\\dist\\exports\\ScrollView\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[2], "../../modules/canUseDom"));
  var dimensions = {
    window: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    },
    screen: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    }
  };
  var listeners = {};
  var shouldInit = _canUseDom.default;
  function update() {
    if (!_canUseDom.default) {
      return;
    }
    var win = window;
    var height;
    var width;

    /**
     * iOS does not update viewport dimensions on keyboard open/close.
     * window.visualViewport(https://developer.mozilla.org/en-US/docs/Web/API/VisualViewport)
     * is used instead of document.documentElement.clientHeight (which remains as a fallback)
     */
    if (win.visualViewport) {
      var visualViewport = win.visualViewport;
      /**
       * We are multiplying by scale because height and width from visual viewport
       * also react to pinch zoom, and become smaller when zoomed. But it is not desired
       * behaviour, since originally documentElement client height and width were used,
       * and they do not react to pinch zoom.
       */
      height = Math.round(visualViewport.height * visualViewport.scale);
      width = Math.round(visualViewport.width * visualViewport.scale);
    } else {
      var docEl = win.document.documentElement;
      height = docEl.clientHeight;
      width = docEl.clientWidth;
    }
    dimensions.window = {
      fontScale: 1,
      height,
      scale: win.devicePixelRatio || 1,
      width
    };
    dimensions.screen = {
      fontScale: 1,
      height: win.screen.height,
      scale: win.devicePixelRatio || 1,
      width: win.screen.width
    };
  }
  function handleResize() {
    update();
    if (Array.isArray(listeners['change'])) {
      listeners['change'].forEach(handler => handler(dimensions));
    }
  }
  class Dimensions {
    static get(dimension) {
      if (shouldInit) {
        shouldInit = false;
        update();
      }
      (0, _invariant.default)(dimensions[dimension], "No dimension set for key " + dimension);
      return dimensions[dimension];
    }
    static set(initialDimensions) {
      if (initialDimensions) {
        if (_canUseDom.default) {
          (0, _invariant.default)(false, 'Dimensions cannot be set in the browser');
        } else {
          if (initialDimensions.screen != null) {
            dimensions.screen = initialDimensions.screen;
          }
          if (initialDimensions.window != null) {
            dimensions.window = initialDimensions.window;
          }
        }
      }
    }
    static addEventListener(type, handler) {
      listeners[type] = listeners[type] || [];
      listeners[type].push(handler);
      return {
        remove: () => {
          this.removeEventListener(type, handler);
        }
      };
    }
    static removeEventListener(type, handler) {
      if (Array.isArray(listeners[type])) {
        listeners[type] = listeners[type].filter(_handler => _handler !== handler);
      }
    }
  }
  exports.default = Dimensions;
  if (_canUseDom.default) {
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', handleResize, false);
    } else {
      window.addEventListener('resize', handleResize, false);
    }
  }
},136,[17,129,39],"node_modules\\react-native-web\\dist\\exports\\Dimensions\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _TextInputState = _interopRequireDefault(require(_dependencyMap[1], "../TextInputState"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dismissKeyboard = () => {
    _TextInputState.default.blurTextInput(_TextInputState.default.currentlyFocusedField());
  };
  var _default = exports.default = dismissKeyboard;
},137,[17,138],"node_modules\\react-native-web\\dist\\modules\\dismissKeyboard\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _UIManager = _interopRequireDefault(require(_dependencyMap[1], "../../exports/UIManager"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This class is responsible for coordinating the "focused"
   * state for TextInputs. All calls relating to the keyboard
   * should be funneled through here
   */
  var TextInputState = {
    /**
     * Internal state
     */
    _currentlyFocusedNode: null,
    /**
     * Returns the ID of the currently focused text field, if one exists
     * If no text field is focused it returns null
     */
    currentlyFocusedField() {
      if (document.activeElement !== this._currentlyFocusedNode) {
        this._currentlyFocusedNode = null;
      }
      return this._currentlyFocusedNode;
    },
    /**
     * @param {Object} TextInputID id of the text field to focus
     * Focuses the specified text field
     * noop if the text field was already focused
     */
    focusTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = textFieldNode;
        if (document.activeElement !== textFieldNode) {
          _UIManager.default.focus(textFieldNode);
        }
      }
    },
    /**
     * @param {Object} textFieldNode id of the text field to focus
     * Unfocuses the specified text field
     * noop if it wasn't focused
     */
    blurTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = null;
        if (document.activeElement === textFieldNode) {
          _UIManager.default.blur(textFieldNode);
        }
      }
    }
  };
  var _default = exports.default = TextInputState;
},138,[17,97],"node_modules\\react-native-web\\dist\\modules\\TextInputState\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "../View"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[6], "../../modules/useMergeRefs"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["onScroll", "onTouchMove", "onWheel", "scrollEnabled", "scrollEventThrottle", "showsHorizontalScrollIndicator", "showsVerticalScrollIndicator", "style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function normalizeScrollEvent(e) {
    return {
      nativeEvent: {
        contentOffset: {
          get x() {
            return e.target.scrollLeft;
          },
          get y() {
            return e.target.scrollTop;
          }
        },
        contentSize: {
          get height() {
            return e.target.scrollHeight;
          },
          get width() {
            return e.target.scrollWidth;
          }
        },
        layoutMeasurement: {
          get height() {
            return e.target.offsetHeight;
          },
          get width() {
            return e.target.offsetWidth;
          }
        }
      },
      timeStamp: Date.now()
    };
  }
  function shouldEmitScrollEvent(lastTick, eventThrottle) {
    var timeSinceLastTick = Date.now() - lastTick;
    return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
  }

  /**
   * Encapsulates the Web-specific scroll throttling and disabling logic
   */
  var ScrollViewBase = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var onScroll = props.onScroll,
      onTouchMove = props.onTouchMove,
      onWheel = props.onWheel,
      _props$scrollEnabled = props.scrollEnabled,
      scrollEnabled = _props$scrollEnabled === void 0 ? true : _props$scrollEnabled,
      _props$scrollEventThr = props.scrollEventThrottle,
      scrollEventThrottle = _props$scrollEventThr === void 0 ? 0 : _props$scrollEventThr,
      showsHorizontalScrollIndicator = props.showsHorizontalScrollIndicator,
      showsVerticalScrollIndicator = props.showsVerticalScrollIndicator,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var scrollState = React.useRef({
      isScrolling: false,
      scrollLastTick: 0
    });
    var scrollTimeout = React.useRef(null);
    var scrollRef = React.useRef(null);
    function createPreventableScrollHandler(handler) {
      return e => {
        if (scrollEnabled) {
          if (handler) {
            handler(e);
          }
        }
      };
    }
    function handleScroll(e) {
      e.stopPropagation();
      if (e.target === scrollRef.current) {
        e.persist();
        // A scroll happened, so the scroll resets the scrollend timeout.
        if (scrollTimeout.current != null) {
          clearTimeout(scrollTimeout.current);
        }
        scrollTimeout.current = setTimeout(() => {
          handleScrollEnd(e);
        }, 100);
        if (scrollState.current.isScrolling) {
          // Scroll last tick may have changed, check if we need to notify
          if (shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle)) {
            handleScrollTick(e);
          }
        } else {
          // Weren't scrolling, so we must have just started
          handleScrollStart(e);
        }
      }
    }
    function handleScrollStart(e) {
      scrollState.current.isScrolling = true;
      handleScrollTick(e);
    }
    function handleScrollTick(e) {
      scrollState.current.scrollLastTick = Date.now();
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    function handleScrollEnd(e) {
      scrollState.current.isScrolling = false;
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    var hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
      onScroll: handleScroll,
      onTouchMove: createPreventableScrollHandler(onTouchMove),
      onWheel: createPreventableScrollHandler(onWheel),
      ref: (0, _useMergeRefs.default)(scrollRef, forwardedRef),
      style: [style, !scrollEnabled && styles.scrollDisabled, hideScrollbar && styles.hideScrollbar]
    }));
  });

  // Chrome doesn't support e.preventDefault in this case; touch-action must be
  // used to disable scrolling.
  // https://developers.google.com/web/updates/2017/01/scrolling-intervention
  var styles = _StyleSheet.default.create({
    scrollDisabled: {
      overflowX: 'hidden',
      overflowY: 'hidden',
      touchAction: 'none'
    },
    hideScrollbar: {
      scrollbarWidth: 'none'
    }
  });
  var _default = exports.default = ScrollViewBase;
},139,[17,888,873,3,30,111,116],"node_modules\\react-native-web\\dist\\exports\\ScrollView\\ScrollViewBase.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */
  'use strict';

  var emptyFunction = require(_dependencyMap[0], "./emptyFunction");
  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  function printWarning(format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }
  var warning = process.env.NODE_ENV !== "production" ? function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      printWarning.apply(void 0, [format].concat(args));
    }
  } : emptyFunction;
  module.exports = warning;
},140,[141],"node_modules\\fbjs\\lib\\warning.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }
  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */

  var emptyFunction = function emptyFunction() {};
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };
  module.exports = emptyFunction;
},141,[],"node_modules\\fbjs\\lib\\emptyFunction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _InteractionManager = _interopRequireDefault(require(_dependencyMap[1], "../../../exports/InteractionManager"));
  /**
   * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
   * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
   * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
   * interactions are done running.
   *
   * Make sure to cleanup with dispose().  Example:
   *
   *   class Widget extends React.Component {
   *     _batchedSave: new Batchinator(() => this._saveState, 1000);
   *     _saveSate() {
   *       // save this.state to disk
   *     }
   *     componentDidUpdate() {
   *       this._batchedSave.schedule();
   *     }
   *     componentWillUnmount() {
   *       this._batchedSave.dispose();
   *     }
   *     ...
   *   }
   */
  class Batchinator {
    constructor(callback, delayMS) {
      this._delay = delayMS;
      this._callback = callback;
    }
    /*
     * Cleanup any pending tasks.
     *
     * By default, if there is a pending task the callback is run immediately. Set the option abort to
     * true to not call the callback if it was pending.
     */
    dispose(options) {
      if (options === void 0) {
        options = {
          abort: false
        };
      }
      if (this._taskHandle) {
        this._taskHandle.cancel();
        if (!options.abort) {
          this._callback();
        }
        this._taskHandle = null;
      }
    }
    schedule() {
      if (this._taskHandle) {
        return;
      }
      var timeoutHandle = setTimeout(() => {
        this._taskHandle = _InteractionManager.default.runAfterInteractions(() => {
          // Note that we clear the handle before invoking the callback so that if the callback calls
          // schedule again, it will actually schedule another task.
          this._taskHandle = null;
          this._callback();
        });
      }, this._delay);
      this._taskHandle = {
        cancel: () => clearTimeout(timeoutHandle)
      };
    }
  }
  var _default = exports.default = Batchinator;
},142,[17,143],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Batchinator\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  var _TaskQueue = _interopRequireDefault(require(_dependencyMap[2], "./TaskQueue"));
  var _EventEmitter = _interopRequireDefault(require(_dependencyMap[3], "../../vendor/react-native/vendor/emitter/EventEmitter"));
  var _requestIdleCallback = _interopRequireDefault(require(_dependencyMap[4], "../../modules/requestIdleCallback"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _emitter = new _EventEmitter.default();
  var InteractionManager = {
    Events: {
      interactionStart: 'interactionStart',
      interactionComplete: 'interactionComplete'
    },
    /**
     * Schedule a function to run after all interactions have completed.
     */
    runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(resolve => {
        _scheduleUpdate();
        if (task) {
          tasks.push(task);
        }
        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });
        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: promise.then.bind(promise),
        cancel: () => {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    /**
     * Notify manager that an interaction has started.
     */
    createInteractionHandle() {
      _scheduleUpdate();
      var handle = ++_inc;
      _addInteractionSet.add(handle);
      return handle;
    },
    /**
     * Notify manager that an interaction has completed.
     */
    clearInteractionHandle(handle) {
      (0, _invariant.default)(!!handle, 'Must provide a handle to clear.');
      _scheduleUpdate();
      _addInteractionSet.delete(handle);
      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    /**
     *
     * @param deadline
     */
    setDeadline(deadline) {
      _deadline = deadline;
    }
  };
  var _interactionSet = new Set();
  var _addInteractionSet = new Set();
  var _deleteInteractionSet = new Set();
  var _taskQueue = new _TaskQueue.default({
    onMoreTasks: _scheduleUpdate
  });
  var _nextUpdateHandle = 0;
  var _inc = 0;
  var _deadline = -1;

  /**
   * Schedule an asynchronous update to the interaction state.
   */
  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate);
      } else {
        _nextUpdateHandle = (0, _requestIdleCallback.default)(_processUpdate);
      }
    }
  }

  /**
   * Notify listeners, process queue, etc
   */
  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;
    _addInteractionSet.forEach(handle => _interactionSet.add(handle));
    _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));
    var nextInteractionCount = _interactionSet.size;
    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }
    if (nextInteractionCount === 0) {
      // It seems that we can't know the running time of the current event loop,
      // we can only calculate the running time of the current task queue.
      var begin = Date.now();
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();
        if (_deadline > 0 && Date.now() - begin >= _deadline) {
          _scheduleUpdate();
          break;
        }
      }
    }
    _addInteractionSet.clear();
    _deleteInteractionSet.clear();
  }
  var _default = exports.default = InteractionManager;
},143,[17,129,144,145,146],"node_modules\\react-native-web\\dist\\exports\\InteractionManager\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[2], "fbjs/lib/invariant"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class TaskQueue {
    constructor(_ref) {
      var onMoreTasks = _ref.onMoreTasks;
      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: true
      }];
    }
    enqueue(task) {
      this._getCurrentQueue().push(task);
    }
    enqueueTasks(tasks) {
      tasks.forEach(task => this.enqueue(task));
    }
    cancelTasks(tasksToCancel) {
      this._queueStack = this._queueStack.map(queue => (0, _objectSpread2.default)((0, _objectSpread2.default)({}, queue), {}, {
        tasks: queue.tasks.filter(task => tasksToCancel.indexOf(task) === -1)
      })).filter((queue, idx) => queue.tasks.length > 0 || idx === 0);
    }
    hasTasksToProcess() {
      return this._getCurrentQueue().length > 0;
    }

    /**
     * Executes the next task in the queue.
     */
    processNext() {
      var queue = this._getCurrentQueue();
      if (queue.length) {
        var task = queue.shift();
        try {
          if (typeof task === 'object' && task.gen) {
            this._genPromise(task);
          } else if (typeof task === 'object' && task.run) {
            task.run();
          } else {
            (0, _invariant.default)(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));
            task();
          }
        } catch (e) {
          e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
          throw e;
        }
      }
    }
    _getCurrentQueue() {
      var stackIdx = this._queueStack.length - 1;
      var queue = this._queueStack[stackIdx];
      if (queue.popable && queue.tasks.length === 0 && stackIdx > 0) {
        this._queueStack.pop();
        return this._getCurrentQueue();
      } else {
        return queue.tasks;
      }
    }
    _genPromise(task) {
      var length = this._queueStack.push({
        tasks: [],
        popable: false
      });
      var stackIdx = length - 1;
      var stackItem = this._queueStack[stackIdx];
      task.gen().then(() => {
        stackItem.popable = true;
        this.hasTasksToProcess() && this._onMoreTasks();
      }).catch(ex => {
        setTimeout(() => {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }, 0);
      });
    }
  }
  var _default = exports.default = TaskQueue;
},144,[17,868,129],"node_modules\\react-native-web\\dist\\exports\\InteractionManager\\TaskQueue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * EventEmitter manages listeners and publishes events to them.
   *
   * EventEmitter accepts a single type parameter that defines the valid events
   * and associated listener argument(s).
   *
   * @example
   *
   *   const emitter = new EventEmitter<{
   *     success: [number, string],
   *     error: [Error],
   *   }>();
   *
   *   emitter.on('success', (statusCode, responseText) => {...});
   *   emitter.emit('success', 200, '...');
   *
   *   emitter.on('error', error => {...});
   *   emitter.emit('error', new Error('Resource not found'));
   *
   */
  class EventEmitter {
    constructor() {
      this._registry = {};
    }
    /**
     * Registers a listener that is called when the supplied event is emitted.
     * Returns a subscription that has a `remove` method to undo registration.
     */
    addListener(eventType, listener, context) {
      var registrations = allocate(this._registry, eventType);
      var registration = {
        context,
        listener,
        remove() {
          registrations.delete(registration);
        }
      };
      registrations.add(registration);
      return registration;
    }

    /**
     * Emits the supplied event. Additional arguments supplied to `emit` will be
     * passed through to each of the registered listeners.
     *
     * If a listener modifies the listeners registered for the same event, those
     * changes will not be reflected in the current invocation of `emit`.
     */
    emit(eventType) {
      var registrations = this._registry[eventType];
      if (registrations != null) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _arr = [...registrations]; _i < _arr.length; _i++) {
          var registration = _arr[_i];
          registration.listener.apply(registration.context, args);
        }
      }
    }

    /**
     * Removes all registered listeners.
     */
    removeAllListeners(eventType) {
      if (eventType == null) {
        this._registry = {};
      } else {
        delete this._registry[eventType];
      }
    }

    /**
     * Returns the number of registered listeners for the supplied event.
     */
    listenerCount(eventType) {
      var registrations = this._registry[eventType];
      return registrations == null ? 0 : registrations.size;
    }
  }
  exports.default = EventEmitter;
  function allocate(registry, eventType) {
    var registrations = registry[eventType];
    if (registrations == null) {
      registrations = new Set();
      registry[eventType] = registrations;
    }
    return registrations;
  }
},145,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\vendor\\emitter\\EventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.cancelIdleCallback = void 0;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _requestIdleCallback = function _requestIdleCallback(cb, options) {
    return setTimeout(() => {
      var start = Date.now();
      cb({
        didTimeout: false,
        timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  };
  var _cancelIdleCallback = function _cancelIdleCallback(id) {
    clearTimeout(id);
  };
  var isSupported = _canUseDom.default && typeof window.requestIdleCallback !== 'undefined';
  var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
  var cancelIdleCallback = exports.cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;
  var _default = exports.default = requestIdleCallback;
},146,[17,39],"node_modules\\react-native-web\\dist\\modules\\requestIdleCallback\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function clamp(min, value, max) {
    if (value < min) {
      return min;
    }
    if (value > max) {
      return max;
    }
    return value;
  }
  var _default = exports.default = clamp;
},147,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Utilities\\clamp.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /**
   * Intentional info-level logging for clear separation from ad-hoc console debug logging.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function infoLog() {
    return console.log(...arguments);
  }
  var _default = exports.default = infoLog;
},148,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\infoLog\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CellRenderMask = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[2], "fbjs/lib/invariant"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderMask {
    constructor(numCells) {
      (0, _invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
      this._numCells = numCells;
      if (numCells === 0) {
        this._regions = [];
      } else {
        this._regions = [{
          first: 0,
          last: numCells - 1,
          isSpacer: true
        }];
      }
    }
    enumerateRegions() {
      return this._regions;
    }
    addCells(cells) {
      (0, _invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');

      // VirtualizedList uses inclusive ranges, where zero-count states are
      // possible. E.g. [0, -1] for no cells, starting at 0.
      if (cells.last < cells.first) {
        return;
      }
      var _this$_findRegion = this._findRegion(cells.first),
        firstIntersect = _this$_findRegion[0],
        firstIntersectIdx = _this$_findRegion[1];
      var _this$_findRegion2 = this._findRegion(cells.last),
        lastIntersect = _this$_findRegion2[0],
        lastIntersectIdx = _this$_findRegion2[1];

      // Fast-path if the cells to add are already all present in the mask. We
      // will otherwise need to do some mutation.
      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
        return;
      }

      // We need to replace the existing covered regions with 1-3 new regions
      // depending whether we need to split spacers out of overlapping regions.
      var newLeadRegion = [];
      var newTailRegion = [];
      var newMainRegion = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, cells), {}, {
        isSpacer: false
      });
      if (firstIntersect.first < newMainRegion.first) {
        if (firstIntersect.isSpacer) {
          newLeadRegion.push({
            first: firstIntersect.first,
            last: newMainRegion.first - 1,
            isSpacer: true
          });
        } else {
          newMainRegion.first = firstIntersect.first;
        }
      }
      if (lastIntersect.last > newMainRegion.last) {
        if (lastIntersect.isSpacer) {
          newTailRegion.push({
            first: newMainRegion.last + 1,
            last: lastIntersect.last,
            isSpacer: true
          });
        } else {
          newMainRegion.last = lastIntersect.last;
        }
      }
      var replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion];
      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
      this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
    }
    numCells() {
      return this._numCells;
    }
    equals(other) {
      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
    }
    _findRegion(cellIdx) {
      var firstIdx = 0;
      var lastIdx = this._regions.length - 1;
      while (firstIdx <= lastIdx) {
        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var middleRegion = this._regions[middleIdx];
        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
          return [middleRegion, middleIdx];
        } else if (cellIdx < middleRegion.first) {
          lastIdx = middleIdx - 1;
        } else if (cellIdx > middleRegion.last) {
          firstIdx = middleIdx + 1;
        }
      }
      (0, _invariant.default)(false, "A region was not found containing cellIdx " + cellIdx);
    }
  }
  exports.CellRenderMask = CellRenderMask;
},149,[17,868,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\CellRenderMask.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createForOfIteratorHelperLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/createForOfIteratorHelperLoose"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[2], "fbjs/lib/invariant"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class ChildListCollection {
    constructor() {
      this._cellKeyToChildren = new Map();
      this._childrenToCellKey = new Map();
    }
    add(list, cellKey) {
      var _this$_cellKeyToChild;
      (0, _invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
      var cellLists = (_this$_cellKeyToChild = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild !== void 0 ? _this$_cellKeyToChild : new Set();
      cellLists.add(list);
      this._cellKeyToChildren.set(cellKey, cellLists);
      this._childrenToCellKey.set(list, cellKey);
    }
    remove(list) {
      var cellKey = this._childrenToCellKey.get(list);
      (0, _invariant.default)(cellKey != null, 'Trying to remove non-present child list');
      this._childrenToCellKey.delete(list);
      var cellLists = this._cellKeyToChildren.get(cellKey);
      (0, _invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
      cellLists.delete(list);
      if (cellLists.size === 0) {
        this._cellKeyToChildren.delete(cellKey);
      }
    }
    forEach(fn) {
      for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(this._cellKeyToChildren.values()), _step; !(_step = _iterator()).done;) {
        var listSet = _step.value;
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(listSet), _step2; !(_step2 = _iterator2()).done;) {
          var list = _step2.value;
          fn(list);
        }
      }
    }
    forEachInCell(cellKey, fn) {
      var _this$_cellKeyToChild2;
      var listSet = (_this$_cellKeyToChild2 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild2 !== void 0 ? _this$_cellKeyToChild2 : [];
      for (var _iterator3 = (0, _createForOfIteratorHelperLoose2.default)(listSet), _step3; !(_step3 = _iterator3()).done;) {
        var list = _step3.value;
        fn(list);
      }
    }
    anyInCell(cellKey, fn) {
      var _this$_cellKeyToChild3;
      var listSet = (_this$_cellKeyToChild3 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild3 !== void 0 ? _this$_cellKeyToChild3 : [];
      for (var _iterator4 = (0, _createForOfIteratorHelperLoose2.default)(listSet), _step4; !(_step4 = _iterator4()).done;) {
        var list = _step4.value;
        if (fn(list)) {
          return true;
        }
      }
      return false;
    }
    size() {
      return this._childrenToCellKey.size;
    }
  }
  exports.default = ChildListCollection;
},150,[17,889,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\ChildListCollection.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  class Info {
    constructor() {
      this.any_blank_count = 0;
      this.any_blank_ms = 0;
      this.any_blank_speed_sum = 0;
      this.mostly_blank_count = 0;
      this.mostly_blank_ms = 0;
      this.pixels_blank = 0;
      this.pixels_sampled = 0;
      this.pixels_scrolled = 0;
      this.total_time_spent = 0;
      this.sample_count = 0;
    }
  }
  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;
  var _sampleRate = DEBUG ? 1 : null;

  /**
   * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
   * By default the sampling rate is set to zero and this will do nothing. If you want to collect
   * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
   *
   * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
   * `SceneTracker.getActiveScene` to determine the context of the events.
   */
  class FillRateHelper {
    static addListener(callback) {
      if (_sampleRate === null) {
        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
      }
      _listeners.push(callback);
      return {
        remove: () => {
          _listeners = _listeners.filter(listener => callback !== listener);
        }
      };
    }
    static setSampleRate(sampleRate) {
      _sampleRate = sampleRate;
    }
    static setMinSampleCount(minSampleCount) {
      _minSampleCount = minSampleCount;
    }
    constructor(getFrameMetrics) {
      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();
      this._resetData();
    }
    activate() {
      if (this._enabled && this._samplesStartTime == null) {
        DEBUG && console.debug('FillRateHelper: activate');
        this._samplesStartTime = global.performance.now();
      }
    }
    deactivateAndFlush() {
      if (!this._enabled) {
        return;
      }
      var start = this._samplesStartTime; // const for flow
      if (start == null) {
        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
        return;
      }
      if (this._info.sample_count < _minSampleCount) {
        // Don't bother with under-sampled events.
        this._resetData();
        return;
      }
      var total_time_spent = global.performance.now() - start;
      var info = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._info), {}, {
        total_time_spent
      });
      if (DEBUG) {
        var derived = {
          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
        };
        for (var key in derived) {
          // $FlowFixMe[prop-missing]
          derived[key] = Math.round(1000 * derived[key]) / 1000;
        }
        console.debug('FillRateHelper deactivateAndFlush: ', {
          derived,
          info
        });
      }
      _listeners.forEach(listener => listener(info));
      this._resetData();
    }
    computeBlankness(props, cellsAroundViewport, scrollMetrics) {
      if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
        return 0;
      }
      var dOffset = scrollMetrics.dOffset,
        offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;

      // Denominator metrics that we track for all events - most of the time there is no blankness and
      // we want to capture that.
      this._info.sample_count++;
      this._info.pixels_sampled += Math.round(visibleLength);
      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
      var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec

      // Whether blank now or not, record the elapsed time blank if we were blank last time.
      var now = global.performance.now();
      if (this._anyBlankStartTime != null) {
        this._info.any_blank_ms += now - this._anyBlankStartTime;
      }
      this._anyBlankStartTime = null;
      if (this._mostlyBlankStartTime != null) {
        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
      }
      this._mostlyBlankStartTime = null;
      var blankTop = 0;
      var first = cellsAroundViewport.first;
      var firstFrame = this._getFrameMetrics(first, props);
      while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {
        firstFrame = this._getFrameMetrics(first, props);
        first++;
      }
      // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
      // as blank.
      if (firstFrame && first > 0) {
        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
      }
      var blankBottom = 0;
      var last = cellsAroundViewport.last;
      var lastFrame = this._getFrameMetrics(last, props);
      while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {
        lastFrame = this._getFrameMetrics(last, props);
        last--;
      }
      // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
      // footer as blank.
      if (lastFrame && last < props.getItemCount(props.data) - 1) {
        var bottomEdge = lastFrame.offset + lastFrame.length;
        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
      }
      var pixels_blank = Math.round(blankTop + blankBottom);
      var blankness = pixels_blank / visibleLength;
      if (blankness > 0) {
        this._anyBlankStartTime = now;
        this._info.any_blank_speed_sum += scrollSpeed;
        this._info.any_blank_count++;
        this._info.pixels_blank += pixels_blank;
        if (blankness > 0.5) {
          this._mostlyBlankStartTime = now;
          this._info.mostly_blank_count++;
        }
      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
        this.deactivateAndFlush();
      }
      return blankness;
    }
    enabled() {
      return this._enabled;
    }
    _resetData() {
      this._anyBlankStartTime = null;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
    }
  }
  var _default = exports.default = FillRateHelper;
},151,[17,868],"node_modules\\react-native-web\\dist\\vendor\\react-native\\FillRateHelper\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * `setState` is called asynchronously, and should not rely on the value of
   * `this.props` or `this.state`:
   * https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous
   *
   * SafePureComponent adds runtime enforcement, to catch cases where these
   * variables are read in a state updater function, instead of the ones passed
   * in.
   */
  class StateSafePureComponent extends React.PureComponent {
    constructor(props) {
      super(props);
      this._inAsyncStateUpdate = false;
      this._installSetStateHooks();
    }
    setState(partialState, callback) {
      if (typeof partialState === 'function') {
        super.setState((state, props) => {
          this._inAsyncStateUpdate = true;
          var ret;
          try {
            ret = partialState(state, props);
          } catch (err) {
            throw err;
          } finally {
            this._inAsyncStateUpdate = false;
          }
          return ret;
        }, callback);
      } else {
        super.setState(partialState, callback);
      }
    }
    _installSetStateHooks() {
      var that = this;
      var props = this.props,
        state = this.state;
      Object.defineProperty(this, 'props', {
        get() {
          (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
          return props;
        },
        set(newProps) {
          props = newProps;
        }
      });
      Object.defineProperty(this, 'state', {
        get() {
          (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
          return state;
        },
        set(newState) {
          state = newState;
        }
      });
    }
  }
  exports.default = StateSafePureComponent;
},152,[17,129,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\StateSafePureComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _createForOfIteratorHelperLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/createForOfIteratorHelperLoose"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  /**
   * A Utility class for calculating viewable items based on current metrics like scroll position and
   * layout.
   *
   * An item is said to be in a "viewable" state when any of the following
   * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
   * is true):
   *
   * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
   *   visible in the view area >= `itemVisiblePercentThreshold`.
   * - Entirely visible on screen
   */
  class ViewabilityHelper {
    constructor(config) {
      if (config === void 0) {
        config = {
          viewAreaCoveragePercentThreshold: 0
        };
      }
      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    /**
     * Cleanup, e.g. on unmount. Clears any pending timers.
     */
    dispose() {
      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.63 was deployed. To see
       * the error delete this comment and run Flow. */
      this._timers.forEach(clearTimeout);
    }

    /**
     * Determines which items are viewable based on the current metrics and config.
     */
    computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      var _this$_config = this._config,
        itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
        viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
      var viewAreaMode = viewAreaCoveragePercentThreshold != null;
      var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
      (0, _invariant.default)(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
      var viewableIndices = [];
      if (itemCount === 0) {
        return viewableIndices;
      }
      var firstVisible = -1;
      var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
        first = _ref.first,
        last = _ref.last;
      if (last >= itemCount) {
        console.warn('Invalid render range computing viewability ' + JSON.stringify({
          renderRange,
          itemCount
        }));
        return [];
      }
      for (var idx = first; idx <= last; idx++) {
        var metrics = getFrameMetrics(idx, props);
        if (!metrics) {
          continue;
        }
        var top = metrics.offset - scrollOffset;
        var bottom = top + metrics.length;
        if (top < viewportHeight && bottom > 0) {
          firstVisible = idx;
          if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
            viewableIndices.push(idx);
          }
        } else if (firstVisible >= 0) {
          break;
        }
      }
      return viewableIndices;
    }

    /**
     * Figures out which items are viewable and how that has changed from before and calls
     * `onViewableItemsChanged` as appropriate.
     */
    onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props)) {
        return;
      }
      var viewableIndices = [];
      if (itemCount) {
        viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
      }
      if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])) {
        // We might get a lot of scroll events where visibility doesn't change and we don't want to do
        // extra work in those cases.
        return;
      }
      this._viewableIndices = viewableIndices;
      if (this._config.minimumViewTime) {
        var handle = setTimeout(() => {
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          this._timers.delete(handle);
          this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
        }, this._config.minimumViewTime);
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To see
         * the error delete this comment and run Flow. */
        this._timers.add(handle);
      } else {
        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
      }
    }

    /**
     * clean-up cached _viewableIndices to evaluate changed items on next update
     */
    resetViewableIndices() {
      this._viewableIndices = [];
    }

    /**
     * Records that an interaction has happened even if there has been no scroll.
     */
    recordInteraction() {
      this._hasInteracted = true;
    }
    _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
      // Filter out indices that have gone out of view since this call was scheduled.
      viewableIndicesToCheck = viewableIndicesToCheck.filter(ii => this._viewableIndices.includes(ii));
      var prevItems = this._viewableItems;
      var nextItems = new Map(viewableIndicesToCheck.map(ii => {
        var viewable = createViewToken(ii, true, props);
        return [viewable.key, viewable];
      }));
      var changed = [];
      for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(nextItems), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          viewable = _step$value[1];
        if (!prevItems.has(key)) {
          changed.push(viewable);
        }
      }
      for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(prevItems), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
          _key = _step2$value[0],
          _viewable = _step2$value[1];
        if (!nextItems.has(_key)) {
          changed.push((0, _objectSpread2.default)((0, _objectSpread2.default)({}, _viewable), {}, {
            isViewable: false
          }));
        }
      }
      if (changed.length > 0) {
        this._viewableItems = nextItems;
        onViewableItemsChanged({
          viewableItems: Array.from(nextItems.values()),
          changed,
          viewabilityConfig: this._config
        });
      }
    }
  }
  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);
      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }
  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }
  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }
  var _default = exports.default = ViewabilityHelper;
},153,[17,868,889,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\ViewabilityHelper\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectSpread2"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "../../../exports/View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../../../exports/StyleSheet"));
  var _VirtualizedListContext = require(_dependencyMap[5], "./VirtualizedListContext.js");
  var _invariant = _interopRequireDefault(require(_dependencyMap[6], "fbjs/lib/invariant"));
  var React = _interopRequireWildcard(require(_dependencyMap[7], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderer extends React.Component {
    constructor() {
      super(...arguments);
      this.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: this.props.item
        }
      };
      this._separators = {
        highlight: () => {
          var _this$props = this.props,
            cellKey = _this$props.cellKey,
            prevCellKey = _this$props.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: () => {
          var _this$props2 = this.props,
            cellKey = _this$props2.cellKey,
            prevCellKey = _this$props2.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: (select, newProps) => {
          var _this$props3 = this.props,
            cellKey = _this$props3.cellKey,
            prevCellKey = _this$props3.prevCellKey;
          this.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      };
      this._onLayout = nativeEvent => {
        this.props.onCellLayout && this.props.onCellLayout(nativeEvent, this.props.cellKey, this.props.index);
      };
    }
    static getDerivedStateFromProps(props, prevState) {
      return {
        separatorProps: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, prevState.separatorProps), {}, {
          leadingItem: props.item
        })
      };
    }

    // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
    // reused by SectionList and we can keep VirtualizedList simpler.
    // $FlowFixMe[missing-local-annot]

    updateSeparatorProps(newProps) {
      this.setState(state => ({
        separatorProps: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state.separatorProps), newProps)
      }));
    }
    componentWillUnmount() {
      this.props.onUnmount(this.props.cellKey);
    }
    _renderElement(renderItem, ListItemComponent, item, index) {
      if (renderItem && ListItemComponent) {
        console.warn('VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' + ' precedence over renderItem.');
      }
      if (ListItemComponent) {
        /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.108 was deployed. To
         * see the error, delete this comment and run Flow. */
        /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)
         * This comment suppresses an error found when Flow v0.108 was deployed.
         * To see the error, delete this comment and run Flow. */
        return /*#__PURE__*/React.createElement(ListItemComponent, {
          item,
          index,
          separators: this._separators
        });
      }
      if (renderItem) {
        return renderItem({
          item,
          index,
          separators: this._separators
        });
      }
      (0, _invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
    }
    render() {
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        cellKey = _this$props4.cellKey,
        horizontal = _this$props4.horizontal,
        item = _this$props4.item,
        index = _this$props4.index,
        inversionStyle = _this$props4.inversionStyle,
        onCellFocusCapture = _this$props4.onCellFocusCapture,
        onCellLayout = _this$props4.onCellLayout,
        renderItem = _this$props4.renderItem;
      var element = this._renderElement(renderItem, ListItemComponent, item, index);

      // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
      // called explicitly by `ScrollViewStickyHeader`.
      var itemSeparator = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ItemSeparatorComponent) ?
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent :
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent && /*#__PURE__*/React.createElement(ItemSeparatorComponent, this.state.separatorProps);
      var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
      var result = !CellRendererComponent ? /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator) : /*#__PURE__*/React.createElement(CellRendererComponent, (0, _extends2.default)({
        cellKey: cellKey,
        index: index,
        item: item,
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator);
      return /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
        cellKey: this.props.cellKey
      }, result);
    }
  }
  exports.default = CellRenderer;
  var styles = _StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    },
    rowReverse: {
      flexDirection: 'row-reverse'
    },
    columnReverse: {
      flexDirection: 'column-reverse'
    }
  });
},154,[17,888,868,111,30,155,129,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\VirtualizedListCellRenderer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
  exports.VirtualizedListContext = void 0;
  exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
  exports.VirtualizedListContextResetter = VirtualizedListContextResetter;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _react = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var React = _react;
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var VirtualizedListContext = exports.VirtualizedListContext = /*#__PURE__*/React.createContext(null);
  if (__DEV__) {
    VirtualizedListContext.displayName = 'VirtualizedListContext';
  }

  /**
   * Resets the context. Intended for use by portal-like components (e.g. Modal).
   */
  function VirtualizedListContextResetter(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: null
    }, children);
  }

  /**
   * Sets the context with memoization. Intended to be used by `VirtualizedList`.
   */
  function VirtualizedListContextProvider(_ref2) {
    var children = _ref2.children,
      value = _ref2.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(() => ({
      cellKey: null,
      getScrollMetrics: value.getScrollMetrics,
      horizontal: value.horizontal,
      getOutermostParentListRef: value.getOutermostParentListRef,
      registerAsNestedChild: value.registerAsNestedChild,
      unregisterAsNestedChild: value.unregisterAsNestedChild
    }), [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.registerAsNestedChild, value.unregisterAsNestedChild]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }

  /**
   * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.
   */
  function VirtualizedListCellContextProvider(_ref3) {
    var cellKey = _ref3.cellKey,
      children = _ref3.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(() => currContext == null ? null : (0, _objectSpread2.default)((0, _objectSpread2.default)({}, currContext), {}, {
      cellKey
    }), [currContext, cellKey]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }
},155,[17,868,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedList\\VirtualizedListContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  /**
   * Used to find the indices of the frames that overlap the given offsets. Useful for finding the
   * items that bound different windows of content, such as the visible area or the buffered overscan
   * area.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
  exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
  exports.keyExtractor = keyExtractor;
  exports.newRangeCount = newRangeCount;
  function elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {
    if (zoomScale === void 0) {
      zoomScale = 1;
    }
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {
      var currentOffset = offsets[offsetIndex];
      var left = 0;
      var right = itemCount - 1;
      while (left <= right) {
        // eslint-disable-next-line no-bitwise
        var mid = left + (right - left >>> 1);
        var frame = getFrameMetrics(mid, props);
        var scaledOffsetStart = frame.offset * zoomScale;
        var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;

        // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
        // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
        if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
          right = mid - 1;
        } else if (currentOffset > scaledOffsetEnd) {
          left = mid + 1;
        } else {
          result[offsetIndex] = mid;
          break;
        }
      }
    }
    return result;
  }

  /**
   * Computes the number of elements in the `next` range that are new compared to the `prev` range.
   * Handy for calculating how many new items will be rendered when the render window changes so we
   * can restrict the number of new items render at once so that content can appear on the screen
   * faster.
   */
  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  /**
   * Custom logic for determining which items should be rendered given the current frame and scroll
   * metrics, as well as the previous render state. The algorithm may evolve over time, but generally
   * prioritizes the visible area first, then expands that with overscan regions ahead and behind,
   * biased in the direction of scroll.
   */
  function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
      return {
        first: 0,
        last: -1
      };
    }
    var offset = scrollMetrics.offset,
      velocity = scrollMetrics.velocity,
      visibleLength = scrollMetrics.visibleLength,
      _scrollMetrics$zoomSc = scrollMetrics.zoomScale,
      zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;

    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;

    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));

    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
      // Entire list is before our overscan window
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),
      overscanFirst = _elementsThatOverlapO[0],
      first = _elementsThatOverlapO[1],
      last = _elementsThatOverlapO[2],
      overscanLast = _elementsThatOverlapO[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first,
      last
    };

    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        // If we fill the entire overscan range, we're done.
        break;
      }
      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        // We only want to stop if we've hit maxNewCells AND we cannot increment first or last
        // without rendering new items. This let's us preserve as many already rendered items as
        // possible, reducing render churn and keeping the rendered overscan range as large as
        // possible.
        break;
      }
      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }
        first--;
      }
      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }
        last++;
      }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first,
        last,
        itemCount,
        overscanFirst,
        overscanLast,
        visible
      }));
    }
    return {
      first,
      last
    };
  }
  function keyExtractor(item, index) {
    if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {
      return item.key;
    }
    if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {
      return item.id;
    }
    return String(index);
  }
},156,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizeUtils\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function nullthrows(x, message) {
    if (x != null) {
      return x;
    }
    var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
  }
  module.exports = nullthrows;
  module.exports.default = nullthrows;
  Object.defineProperty(module.exports, '__esModule', {
    value: true
  });
},157,[],"node_modules\\nullthrows\\nullthrows.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createAnimatedComponent;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _useAnimatedProps2 = _interopRequireDefault(require(_dependencyMap[3], "./useAnimatedProps"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[4], "../Utilities/useMergeRefs"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../../../exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[6], "../../../exports/View"));
  var React = _interopRequireWildcard(require(_dependencyMap[7], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Experimental implementation of `createAnimatedComponent` that is intended to
   * be compatible with concurrent rendering.
   */
  function createAnimatedComponent(Component) {
    return /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
      var _useAnimatedProps = (0, _useAnimatedProps2.default)(props),
        reducedProps = _useAnimatedProps[0],
        callbackRef = _useAnimatedProps[1];
      var ref = (0, _useMergeRefs.default)(callbackRef, forwardedRef);

      // Some components require explicit passthrough values for animation
      // to work properly. For example, if an animated component is
      // transformed and Pressable, onPress will not work after transform
      // without these passthrough values.
      // $FlowFixMe[prop-missing]
      var passthroughAnimatedPropExplicitValues = reducedProps.passthroughAnimatedPropExplicitValues,
        style = reducedProps.style;
      var _ref = passthroughAnimatedPropExplicitValues !== null && passthroughAnimatedPropExplicitValues !== void 0 ? passthroughAnimatedPropExplicitValues : {},
        passthroughStyle = _ref.style,
        passthroughProps = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
      var mergedStyle = [style, passthroughStyle];
      return /*#__PURE__*/React.createElement(Component, (0, _extends2.default)({}, reducedProps, passthroughProps, {
        style: mergedStyle,
        ref: ref
      }));
    });
  }
},159,[17,888,873,160,178,30,111,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\createAnimatedComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useAnimatedProps;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedProps = _interopRequireDefault(require(_dependencyMap[2], "./nodes/AnimatedProps"));
  var _AnimatedEvent = require(_dependencyMap[3], "./AnimatedEvent");
  var _useRefEffect = _interopRequireDefault(require(_dependencyMap[4], "../Utilities/useRefEffect"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[5], "./NativeAnimatedHelper"));
  var _react = require(_dependencyMap[6], "react");
  var _useLayoutEffect = _interopRequireDefault(require(_dependencyMap[7], "../../../modules/useLayoutEffect"));
  function useAnimatedProps(props) {
    var _useReducer = (0, _react.useReducer)(count => count + 1, 0),
      scheduleUpdate = _useReducer[1];
    var onUpdateRef = (0, _react.useRef)(null);

    // TODO: Only invalidate `node` if animated props or `style` change. In the
    // previous implementation, we permitted `style` to override props with the
    // same name property name as styles, so we can probably continue doing that.
    // The ordering of other props *should* not matter.
    var node = (0, _react.useMemo)(() => new _AnimatedProps.default(props, () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()), [props]);
    useAnimatedPropsLifecycle(node);

    // TODO: This "effect" does three things:
    //
    //   1) Call `setNativeView`.
    //   2) Update `onUpdateRef`.
    //   3) Update listeners for `AnimatedEvent` props.
    //
    // Ideally, each of these would be separat "effects" so that they are not
    // unnecessarily re-run when irrelevant dependencies change. For example, we
    // should be able to hoist all `AnimatedEvent` props and only do #3 if either
    // the `AnimatedEvent` props change or `instance` changes.
    //
    // But there is no way to transparently compose three separate callback refs,
    // so we just combine them all into one for now.
    var refEffect = (0, _react.useCallback)(instance => {
      // NOTE: This may be called more often than necessary (e.g. when `props`
      // changes), but `setNativeView` already optimizes for that.
      node.setNativeView(instance);

      // NOTE: This callback is only used by the JavaScript animation driver.
      onUpdateRef.current = () => {
        // Schedule an update for this component to update `reducedProps`,
        // but do not compute it immediately. If a parent also updated, we
        // need to merge those new props in before updating.
        scheduleUpdate();
      };
      var target = getEventTarget(instance);
      var events = [];
      for (var propName in props) {
        var propValue = props[propName];
        if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {
          propValue.__attach(target, propName);
          events.push([propName, propValue]);
        }
      }
      return () => {
        onUpdateRef.current = null;
        for (var _i = 0, _events = events; _i < _events.length; _i++) {
          var _events$_i = _events[_i],
            _propName = _events$_i[0],
            _propValue = _events$_i[1];
          _propValue.__detach(target, _propName);
        }
      };
    }, [props, node]);
    var callbackRef = (0, _useRefEffect.default)(refEffect);
    return [reduceAnimatedProps(node), callbackRef];
  }
  function reduceAnimatedProps(node) {
    // Force `collapsable` to be false so that the native view is not flattened.
    // Flattened views cannot be accurately referenced by the native driver.
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, node.__getValue()), {}, {
      collapsable: false
    });
  }

  /**
   * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`
   * and `__detach`. However, this is more complicated because `AnimatedProps`
   * uses reference counting to determine when to recursively detach its children
   * nodes. So in order to optimize this, we avoid detaching until the next attach
   * unless we are unmounting.
   */
  function useAnimatedPropsLifecycle(node) {
    var prevNodeRef = (0, _react.useRef)(null);
    var isUnmountingRef = (0, _react.useRef)(false);
    (0, _react.useEffect)(() => {
      // It is ok for multiple components to call `flushQueue` because it noops
      // if the queue is empty. When multiple animated components are mounted at
      // the same time. Only first component flushes the queue and the others will noop.
      _NativeAnimatedHelper.default.API.flushQueue();
    });
    (0, _useLayoutEffect.default)(() => {
      isUnmountingRef.current = false;
      return () => {
        isUnmountingRef.current = true;
      };
    }, []);
    (0, _useLayoutEffect.default)(() => {
      node.__attach();
      if (prevNodeRef.current != null) {
        var prevNode = prevNodeRef.current;
        // TODO: Stop restoring default values (unless `reset` is called).
        prevNode.__restoreDefaultValues();
        prevNode.__detach();
        prevNodeRef.current = null;
      }
      return () => {
        if (isUnmountingRef.current) {
          // NOTE: Do not restore default values on unmount, see D18197735.
          node.__detach();
        } else {
          prevNodeRef.current = node;
        }
      };
    }, [node]);
  }
  function getEventTarget(instance) {
    return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ?
    // $FlowFixMe[incompatible-use] - Legacy instance assumptions.
    instance.getScrollableNode() : instance;
  }

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.
  function isFabricInstance(instance) {
    var _instance$getScrollRe;
    return hasFabricHandle(instance) ||
    // Some components have a setNativeProps function but aren't a host component
    // such as lists like FlatList and SectionList. These should also use
    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying
    // host component. This crazy hack is essentially special casing those lists and
    // ScrollView itself to use forceUpdate in Fabric.
    // If these components end up using forwardRef then these hacks can go away
    // as instance would actually be the underlying host component and the above check
    // would be sufficient.
    hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());
  }

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.
  function hasFabricHandle(instance) {
    var _instance$_internalIn, _instance$_internalIn2;
    // eslint-disable-next-line dot-notation
    return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;
  }
},160,[17,868,161,162,177,167,3,115],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\useAnimatedProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedEvent = require(_dependencyMap[2], "../AnimatedEvent");
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedNode"));
  var _AnimatedStyle = _interopRequireDefault(require(_dependencyMap[4], "./AnimatedStyle"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[5], "../NativeAnimatedHelper"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[6], "fbjs/lib/invariant"));
  class AnimatedProps extends _AnimatedNode.default {
    constructor(props, callback) {
      super();
      if (props.style) {
        props = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
          style: new _AnimatedStyle.default(props.style)
        });
      }
      this._props = props;
      this._callback = callback;
      this.__attach();
    }
    __getValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof _AnimatedNode.default) {
          if (!value.__isNative || value instanceof _AnimatedStyle.default) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            props[key] = value.__getValue();
          }
        } else if (value instanceof _AnimatedEvent.AnimatedEvent) {
          props[key] = value.__getHandler();
        } else {
          props[key] = value;
        }
      }
      return props;
    }
    __getAnimatedValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof _AnimatedNode.default) {
          props[key] = value.__getAnimatedValue();
        }
      }
      return props;
    }
    __attach() {
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof _AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      if (this.__isNative && this._animatedView) {
        this.__disconnectAnimatedView();
      }
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof _AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    update() {
      this._callback();
    }
    __makeNative() {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var key in this._props) {
          var value = this._props[key];
          if (value instanceof _AnimatedNode.default) {
            value.__makeNative();
          }
        }
        if (this._animatedView) {
          this.__connectAnimatedView();
        }
      }
    }
    setNativeView(animatedView) {
      if (this._animatedView === animatedView) {
        return;
      }
      this._animatedView = animatedView;
      if (this.__isNative) {
        this.__connectAnimatedView();
      }
    }
    __connectAnimatedView() {
      (0, _invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, _invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      _NativeAnimatedHelper.default.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
    }
    __disconnectAnimatedView() {
      (0, _invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, _invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      _NativeAnimatedHelper.default.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
    }
    __restoreDefaultValues() {
      // When using the native driver, view properties need to be restored to
      // their default values manually since react no longer tracks them. This
      // is needed to handle cases where a prop driven by native animated is removed
      // after having been changed natively by an animation.
      if (this.__isNative) {
        _NativeAnimatedHelper.default.API.restoreDefaultValues(this.__getNativeTag());
      }
    }
    __getNativeConfig() {
      var propsConfig = {};
      for (var propKey in this._props) {
        var value = this._props[propKey];
        if (value instanceof _AnimatedNode.default) {
          value.__makeNative();
          propsConfig[propKey] = value.__getNativeTag();
        }
      }
      return {
        type: 'props',
        props: propsConfig
      };
    }
  }
  var _default = exports.default = AnimatedProps;
},161,[17,868,162,166,175,167,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnimatedEvent = void 0;
  exports.attachNativeEvent = attachNativeEvent;
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[1], "./nodes/AnimatedValue"));
  var _NativeAnimatedHelper = _interopRequireWildcard(require(_dependencyMap[2], "./NativeAnimatedHelper"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var __DEV__ = process.env.NODE_ENV !== 'production';
  function attachNativeEvent(viewRef, eventName, argMapping) {
    // Find animated values in `argMapping` and create an array representing their
    // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
    var eventMappings = [];
    var traverse = (value, path) => {
      if (value instanceof _AnimatedValue.default) {
        value.__makeNative();
        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };
    (0, _invariant.default)(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');

    // Assume that the event containing `nativeEvent` is always the first argument.
    traverse(argMapping[0].nativeEvent, []);
    if (viewRef != null) {
      eventMappings.forEach(mapping => {
        _NativeAnimatedHelper.default.API.addAnimatedEventToView(viewRef, eventName, mapping);
      });
    }
    return {
      detach() {
        if (viewRef != null) {
          eventMappings.forEach(mapping => {
            _NativeAnimatedHelper.default.API.removeAnimatedEventFromView(viewRef, eventName,
            // $FlowFixMe[incompatible-call]
            mapping.animatedValueTag);
          });
        }
      }
    };
  }
  function validateMapping(argMapping, args) {
    var validate = (recMapping, recEvt, key) => {
      if (recMapping instanceof _AnimatedValue.default) {
        (0, _invariant.default)(typeof recEvt === 'number', 'Bad mapping of event key ' + key + ', should be number but got ' + typeof recEvt);
        return;
      }
      if (typeof recEvt === 'number') {
        (0, _invariant.default)(recMapping instanceof _AnimatedValue.default, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
        return;
      }
      (0, _invariant.default)(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
      (0, _invariant.default)(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);
      for (var mappingKey in recMapping) {
        validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
      }
    };
    (0, _invariant.default)(args.length >= argMapping.length, 'Event has less arguments than mapping');
    argMapping.forEach((mapping, idx) => {
      validate(mapping, args[idx], 'arg' + idx);
    });
  }
  class AnimatedEvent {
    constructor(argMapping, config) {
      this._listeners = [];
      this._argMapping = argMapping;
      if (config == null) {
        console.warn('Animated.event now requires a second argument for options');
        config = {
          useNativeDriver: false
        };
      }
      if (config.listener) {
        this.__addListener(config.listener);
      }
      this._callListeners = this._callListeners.bind(this);
      this._attachedEvent = null;
      this.__isNative = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    }
    __addListener(callback) {
      this._listeners.push(callback);
    }
    __removeListener(callback) {
      this._listeners = this._listeners.filter(listener => listener !== callback);
    }
    __attach(viewRef, eventName) {
      (0, _invariant.default)(this.__isNative, 'Only native driven events need to be attached.');
      this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
    }
    __detach(viewTag, eventName) {
      (0, _invariant.default)(this.__isNative, 'Only native driven events need to be detached.');
      this._attachedEvent && this._attachedEvent.detach();
    }
    __getHandler() {
      var _this = this;
      if (this.__isNative) {
        if (__DEV__) {
          var _validatedMapping = false;
          return function () {
            for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
              args[_key2] = arguments[_key2];
            }
            if (!_validatedMapping) {
              validateMapping(_this._argMapping, args);
              _validatedMapping = true;
            }
            _this._callListeners(...args);
          };
        } else {
          return this._callListeners;
        }
      }
      var validatedMapping = false;
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }
        if (__DEV__ && !validatedMapping) {
          validateMapping(_this._argMapping, args);
          validatedMapping = true;
        }
        var traverse = (recMapping, recEvt, key) => {
          if (recMapping instanceof _AnimatedValue.default) {
            if (typeof recEvt === 'number') {
              recMapping.setValue(recEvt);
            }
          } else if (typeof recMapping === 'object') {
            for (var mappingKey in recMapping) {
              /* $FlowFixMe(>=0.120.0) This comment suppresses an error found
               * when Flow v0.120 was deployed. To see the error, delete this
               * comment and run Flow. */
              traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
            }
          }
        };
        _this._argMapping.forEach((mapping, idx) => {
          traverse(mapping, args[idx], 'arg' + idx);
        });
        _this._callListeners(...args);
      };
    }
    _callListeners() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this._listeners.forEach(listener => listener(...args));
    }
  }
  exports.AnimatedEvent = AnimatedEvent;
},162,[17,163,167,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\AnimatedEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  var _InteractionManager = _interopRequireDefault(require(_dependencyMap[3], "../../../../exports/InteractionManager"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[4], "../NativeAnimatedHelper"));
  var NativeAnimatedAPI = _NativeAnimatedHelper.default.API;

  /**
   * Animated works by building a directed acyclic graph of dependencies
   * transparently when you render your Animated components.
   *
   *               new Animated.Value(0)
   *     .interpolate()        .interpolate()    new Animated.Value(1)
   *         opacity               translateY      scale
   *          style                         transform
   *         View#234                         style
   *                                         View#123
   *
   * A) Top Down phase
   * When an Animated.Value is updated, we recursively go down through this
   * graph in order to find leaf nodes: the views that we flag as needing
   * an update.
   *
   * B) Bottom Up phase
   * When a view is flagged as needing an update, we recursively go back up
   * in order to build the new value that it needs. The reason why we need
   * this two-phases process is to deal with composite props such as
   * transform which can receive values from multiple parents.
   */
  function _flush(rootNode) {
    var animatedStyles = new Set();
    function findAnimatedStyles(node) {
      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
       * suppresses an error found when Flow v0.68 was deployed. To see the error
       * delete this comment and run Flow. */
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }
    findAnimatedStyles(rootNode);
    // $FlowFixMe[prop-missing]
    animatedStyles.forEach(animatedStyle => animatedStyle.update());
  }

  /**
   * Some operations are executed only on batch end, which is _mostly_ scheduled when
   * Animated component props change. For some of the changes which require immediate execution
   * (e.g. setValue), we create a separate batch in case none is scheduled.
   */
  function _executeAsAnimatedBatch(id, operation) {
    NativeAnimatedAPI.setWaitingForIdentifier(id);
    operation();
    NativeAnimatedAPI.unsetWaitingForIdentifier(id);
  }

  /**
   * Standard value for driving animations.  One `Animated.Value` can drive
   * multiple properties in a synchronized fashion, but can only be driven by one
   * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
   * or calling `setValue`) will stop any previous ones.
   *
   * See https://reactnative.dev/docs/animatedvalue
   */
  class AnimatedValue extends _AnimatedWithChildren.default {
    constructor(value, config) {
      super();
      if (typeof value !== 'number') {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._startingValue = this._value = value;
      this._offset = 0;
      this._animation = null;
      if (config && config.useNativeDriver) {
        this.__makeNative();
      }
    }
    __detach() {
      if (this.__isNative) {
        NativeAnimatedAPI.getValue(this.__getNativeTag(), value => {
          this._value = value - this._offset;
        });
      }
      this.stopAnimation();
      super.__detach();
    }
    __getValue() {
      return this._value + this._offset;
    }

    /**
     * Directly set the value.  This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvalue#setvalue
     */
    setValue(value) {
      if (this._animation) {
        this._animation.stop();
        this._animation = null;
      }
      this._updateValue(value, !this.__isNative /* don't perform a flush for natively driven values */);
      if (this.__isNative) {
        _executeAsAnimatedBatch(this.__getNativeTag().toString(), () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value));
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether via
     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvalue#setoffset
     */
    setOffset(offset) {
      this._offset = offset;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
      }
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#flattenoffset
     */
    flattenOffset() {
      this._value += this._offset;
      this._offset = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Sets the offset value to the base value, and resets the base value to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#extractoffset
     */
    extractOffset() {
      this._offset += this._value;
      this._value = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvalue#stopanimation
     */
    stopAnimation(callback) {
      this.stopTracking();
      this._animation && this._animation.stop();
      this._animation = null;
      if (callback) {
        if (this.__isNative) {
          NativeAnimatedAPI.getValue(this.__getNativeTag(), callback);
        } else {
          callback(this.__getValue());
        }
      }
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvalue#resetanimation
     */
    resetAnimation(callback) {
      this.stopAnimation(callback);
      this._value = this._startingValue;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
      }
    }
    __onAnimatedValueUpdateReceived(value) {
      this._updateValue(value, false /*flush*/);
    }

    /**
     * Interpolates the value before updating the property, e.g. mapping 0-1 to
     * 0-10.
     */
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }

    /**
     * Typically only used internally, but could be used by a custom Animation
     * class.
     *
     * See https://reactnative.dev/docs/animatedvalue#animate
     */
    animate(animation, callback) {
      var handle = null;
      if (animation.__isInteraction) {
        handle = _InteractionManager.default.createInteractionHandle();
      }
      var previousAnimation = this._animation;
      this._animation && this._animation.stop();
      this._animation = animation;
      animation.start(this._value, value => {
        // Natively driven animations will never call into that callback
        this._updateValue(value, true /* flush */);
      }, result => {
        this._animation = null;
        if (handle !== null) {
          _InteractionManager.default.clearInteractionHandle(handle);
        }
        callback && callback(result);
      }, previousAnimation, this);
    }

    /**
     * Typically only used internally.
     */
    stopTracking() {
      this._tracking && this._tracking.__detach();
      this._tracking = null;
    }

    /**
     * Typically only used internally.
     */
    track(tracking) {
      this.stopTracking();
      this._tracking = tracking;
      // Make sure that the tracking animation starts executing
      this._tracking && this._tracking.update();
    }
    _updateValue(value, flush) {
      if (value === undefined) {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._value = value;
      if (flush) {
        _flush(this);
      }
      super.__callListeners(this.__getValue());
    }
    __getNativeConfig() {
      return {
        type: 'value',
        value: this._value,
        offset: this._offset
      };
    }
  }
  var _default = exports.default = AnimatedValue;
},163,[17,164,165,143,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[3], "../NativeAnimatedHelper"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[4], "fbjs/lib/invariant"));
  var _normalizeColors = _interopRequireDefault(require(_dependencyMap[5], "@react-native/normalize-colors"));
  var __DEV__ = process.env.NODE_ENV !== 'production';
  var linear = t => t;

  /**
   * Very handy helper to map input ranges to output ranges with an easing
   * function and custom behavior outside of the ranges.
   */
  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }
    var outputRange = config.outputRange;
    var inputRange = config.inputRange;
    if (__DEV__) {
      checkInfiniteRange('outputRange', outputRange);
      checkInfiniteRange('inputRange', inputRange);
      checkValidInputRange(inputRange);
      (0, _invariant.default)(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
    }
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';
    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }
    var extrapolateRight = 'extend';
    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }
    return input => {
      (0, _invariant.default)(typeof input === 'number', 'Cannot interpolation an input which is not a number');
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    // Extrapolate
    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {
        // noop
      }
    }
    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {
        // noop
      }
    }
    if (outputMin === outputMax) {
      return outputMin;
    }
    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }
      return outputMax;
    }

    // Input Range
    if (inputMin === -Infinity) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    // Easing
    result = easing(result);

    // Output Range
    if (outputMin === -Infinity) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }
    return result;
  }
  function colorToRgba(input) {
    var normalizedColor = (0, _normalizeColors.default)(input);
    if (normalizedColor === null || typeof normalizedColor !== 'number') {
      return input;
    }
    normalizedColor = normalizedColor || 0;
    var r = (normalizedColor & 0xff000000) >>> 24;
    var g = (normalizedColor & 0x00ff0000) >>> 16;
    var b = (normalizedColor & 0x0000ff00) >>> 8;
    var a = (normalizedColor & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }
  var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;

  /**
   * Supports string shapes by extracting numbers so new values can be computed,
   * and recombines those values into new strings of the same shape.  Supports
   * things like:
   *
   *   rgba(123, 42, 99, 0.36) // colors
   *   -45deg                  // values with units
   */
  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;
    (0, _invariant.default)(outputRange.length >= 2, 'Bad output range');
    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);

    // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']
    // ->
    // [
    //   [0, 50],
    //   [100, 150],
    //   [200, 250],
    //   [0, 0.5],
    // ]
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
    outputRange.forEach(value => {
      /* $FlowFixMe[incompatible-use] (>=0.18.0): `value.match()` can return
       * `null`. Need to guard against this possibility. */
      value.match(stringShapeRegex).forEach((number, i) => {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex)
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    /* $FlowFixMe[incompatible-call] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */.map((value, i) => {
      return createInterpolation((0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
        outputRange: outputRanges[i]
      }));
    });

    // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return input => {
      var i = 0;
      // 'rgba(0, 100, 200, 0)'
      // ->
      // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
      return outputRange[0].replace(stringShapeRegex, () => {
        var val = +interpolations[i++](input);
        if (shouldRound) {
          val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        }
        return String(val);
      });
    };
  }
  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }
  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');
    for (var i = 1; i < arr.length; ++i) {
      (0, _invariant.default)(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }
  function findRange(input, inputRange) {
    var i;
    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }
    return i - 1;
  }
  function checkValidInputRange(arr) {
    (0, _invariant.default)(arr.length >= 2, 'inputRange must have at least 2 elements');
    var message = 'inputRange must be monotonically non-decreasing ' + String(arr);
    for (var i = 1; i < arr.length; ++i) {
      (0, _invariant.default)(arr[i] >= arr[i - 1], message);
    }
  }
  function checkInfiniteRange(name, arr) {
    (0, _invariant.default)(arr.length >= 2, name + ' must have at least 2 elements');
    (0, _invariant.default)(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,
    /* $FlowFixMe[incompatible-type] (>=0.13.0) - In the addition expression
     * below this comment, one or both of the operands may be something that
     * doesn't cleanly convert to a string, like undefined, null, and object,
     * etc. If you really mean this implicit string conversion, you can do
     * something like String(myThing) */
    name + 'cannot be ]-infinity;+infinity[ ' + arr);
  }
  class AnimatedInterpolation extends _AnimatedWithChildren.default {
    // Export for testing.

    constructor(parent, config) {
      super();
      this._parent = parent;
      this._config = config;
      this._interpolation = createInterpolation(config);
    }
    __makeNative(platformConfig) {
      this._parent.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var parentValue = this._parent.__getValue();
      (0, _invariant.default)(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
      return this._interpolation(parentValue);
    }
    interpolate(config) {
      return new AnimatedInterpolation(this, config);
    }
    __attach() {
      this._parent.__addChild(this);
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    __transformDataType(range) {
      return range.map(_NativeAnimatedHelper.default.transformDataType);
    }
    __getNativeConfig() {
      if (__DEV__) {
        _NativeAnimatedHelper.default.validateInterpolation(this._config);
      }
      return {
        inputRange: this._config.inputRange,
        // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
        outputRange: this.__transformDataType(this._config.outputRange),
        extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
        extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
        type: 'interpolation'
      };
    }
  }
  AnimatedInterpolation.__createInterpolation = createInterpolation;
  var _default = exports.default = AnimatedInterpolation;
},164,[17,868,165,167,129,38],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedInterpolation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createForOfIteratorHelperLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/createForOfIteratorHelperLoose"));
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedNode"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[3], "../NativeAnimatedHelper"));
  class AnimatedWithChildren extends _AnimatedNode.default {
    constructor() {
      super();
      this._children = [];
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(this._children), _step; !(_step = _iterator()).done;) {
          var child = _step.value;
          child.__makeNative(platformConfig);
          _NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
      super.__makeNative(platformConfig);
    }
    __addChild(child) {
      if (this._children.length === 0) {
        this.__attach();
      }
      this._children.push(child);
      if (this.__isNative) {
        // Only accept "native" animated nodes as children
        child.__makeNative(this.__getPlatformConfig());
        _NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
    }
    __removeChild(child) {
      var index = this._children.indexOf(child);
      if (index === -1) {
        console.warn("Trying to remove a child that doesn't exist");
        return;
      }
      if (this.__isNative && child.__isNative) {
        _NativeAnimatedHelper.default.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
      this._children.splice(index, 1);
      if (this._children.length === 0) {
        this.__detach();
      }
    }
    __getChildren() {
      return this._children;
    }
    __callListeners(value) {
      super.__callListeners(value);
      if (!this.__isNative) {
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(this._children), _step2; !(_step2 = _iterator2()).done;) {
          var child = _step2.value;
          // $FlowFixMe[method-unbinding] added when improving typing for this parameters
          if (child.__getValue) {
            child.__callListeners(child.__getValue());
          }
        }
      }
    }
  }
  var _default = exports.default = AnimatedWithChildren;
},165,[17,889,166,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedWithChildren.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[1], "../NativeAnimatedHelper"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[2], "fbjs/lib/invariant"));
  var NativeAnimatedAPI = _NativeAnimatedHelper.default.API;
  var _uniqueId = 1;

  // Note(vjeux): this would be better as an interface but flow doesn't
  // support them yet
  class AnimatedNode {
    __attach() {}
    __detach() {
      if (this.__isNative && this.__nativeTag != null) {
        _NativeAnimatedHelper.default.API.dropAnimatedNode(this.__nativeTag);
        this.__nativeTag = undefined;
      }
    }
    __getValue() {}
    __getAnimatedValue() {
      return this.__getValue();
    }
    __addChild(child) {}
    __removeChild(child) {}
    __getChildren() {
      return [];
    }

    /* Methods and props used by native Animated impl */

    constructor() {
      this._listeners = {};
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        throw new Error('This node cannot be made a "native" animated node');
      }
      this._platformConfig = platformConfig;
      if (this.hasListeners()) {
        this._startListeningToNativeValueUpdates();
      }
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to
     * synchronously read the value because it might be driven natively.
     *
     * See https://reactnative.dev/docs/animatedvalue#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      this._listeners[id] = callback;
      if (this.__isNative) {
        this._startListeningToNativeValueUpdates();
      }
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvalue#removelistener
     */
    removeListener(id) {
      delete this._listeners[id];
      if (this.__isNative && !this.hasListeners()) {
        this._stopListeningForNativeValueUpdates();
      }
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvalue#removealllisteners
     */
    removeAllListeners() {
      this._listeners = {};
      if (this.__isNative) {
        this._stopListeningForNativeValueUpdates();
      }
    }
    hasListeners() {
      return !!Object.keys(this._listeners).length;
    }
    _startListeningToNativeValueUpdates() {
      if (this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag) {
        return;
      }
      if (this.__shouldUpdateListenersForNewNativeTag) {
        this.__shouldUpdateListenersForNewNativeTag = false;
        this._stopListeningForNativeValueUpdates();
      }
      NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
      this.__nativeAnimatedValueListener = _NativeAnimatedHelper.default.nativeEventEmitter.addListener('onAnimatedValueUpdate', data => {
        if (data.tag !== this.__getNativeTag()) {
          return;
        }
        this.__onAnimatedValueUpdateReceived(data.value);
      });
    }
    __onAnimatedValueUpdateReceived(value) {
      this.__callListeners(value);
    }
    __callListeners(value) {
      for (var _key in this._listeners) {
        this._listeners[_key]({
          value
        });
      }
    }
    _stopListeningForNativeValueUpdates() {
      if (!this.__nativeAnimatedValueListener) {
        return;
      }
      this.__nativeAnimatedValueListener.remove();
      this.__nativeAnimatedValueListener = null;
      NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
    }
    __getNativeTag() {
      var _this$__nativeTag;
      _NativeAnimatedHelper.default.assertNativeAnimatedModule();
      (0, _invariant.default)(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
      var nativeTag = (_this$__nativeTag = this.__nativeTag) !== null && _this$__nativeTag !== void 0 ? _this$__nativeTag : _NativeAnimatedHelper.default.generateNewNodeTag();
      if (this.__nativeTag == null) {
        this.__nativeTag = nativeTag;
        var config = this.__getNativeConfig();
        if (this._platformConfig) {
          config.platformConfig = this._platformConfig;
        }
        _NativeAnimatedHelper.default.API.createAnimatedNode(nativeTag, config);
        this.__shouldUpdateListenersForNewNativeTag = true;
      }
      return nativeTag;
    }
    __getNativeConfig() {
      throw new Error('This JS animated node type cannot be used as native animated node');
    }
    toJSON() {
      return this.__getValue();
    }
    __getPlatformConfig() {
      return this._platformConfig;
    }
    __setPlatformConfig(platformConfig) {
      this._platformConfig = platformConfig;
    }
  }
  var _default = exports.default = AnimatedNode;
},166,[17,167,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedNode.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.API = void 0;
  exports.addWhitelistedInterpolationParam = addWhitelistedInterpolationParam;
  exports.addWhitelistedStyleProp = addWhitelistedStyleProp;
  exports.addWhitelistedTransformProp = addWhitelistedTransformProp;
  exports.assertNativeAnimatedModule = assertNativeAnimatedModule;
  exports.default = void 0;
  exports.generateNewAnimationId = generateNewAnimationId;
  exports.generateNewNodeTag = generateNewNodeTag;
  exports.isSupportedColorStyleProp = isSupportedColorStyleProp;
  exports.isSupportedInterpolationParam = isSupportedInterpolationParam;
  exports.isSupportedStyleProp = isSupportedStyleProp;
  exports.isSupportedTransformProp = isSupportedTransformProp;
  exports.shouldUseNativeDriver = shouldUseNativeDriver;
  exports.transformDataType = transformDataType;
  exports.validateInterpolation = validateInterpolation;
  exports.validateStyles = validateStyles;
  exports.validateTransform = validateTransform;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _NativeAnimatedModule = _interopRequireDefault(require(_dependencyMap[2], "./NativeAnimatedModule"));
  var _NativeAnimatedTurboModule = _interopRequireDefault(require(_dependencyMap[3], "./NativeAnimatedTurboModule"));
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[4], "../EventEmitter/NativeEventEmitter"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "../Utilities/Platform"));
  var _ReactNativeFeatureFlags = _interopRequireDefault(require(_dependencyMap[6], "../ReactNative/ReactNativeFeatureFlags"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[7], "fbjs/lib/invariant"));
  var _RCTDeviceEventEmitter = _interopRequireDefault(require(_dependencyMap[8], "../EventEmitter/RCTDeviceEventEmitter"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // TODO T69437152 @petetheheat - Delete this fork when Fabric ships to 100%.
  var NativeAnimatedModule = _Platform.default.OS === 'ios' && global.RN$Bridgeless === true ? _NativeAnimatedTurboModule.default : _NativeAnimatedModule.default;
  var __nativeAnimatedNodeTagCount = 1; /* used for animated nodes */
  var __nativeAnimationIdCount = 1; /* used for started animations */

  var nativeEventEmitter;
  var waitingForQueuedOperations = new Set();
  var queueOperations = false;
  var queue = [];
  // $FlowFixMe
  var singleOpQueue = [];
  var useSingleOpBatching = false;
  _Platform.default.OS === 'android' && !!(NativeAnimatedModule != null && NativeAnimatedModule.queueAndExecuteBatchedOperations) && _ReactNativeFeatureFlags.default.animatedShouldUseSingleOp();
  var flushQueueTimeout = null;
  var eventListenerGetValueCallbacks = {};
  var eventListenerAnimationFinishedCallbacks = {};
  var globalEventEmitterGetValueListener = null;
  var globalEventEmitterAnimationFinishedListener = null;
  var nativeOps = useSingleOpBatching ? function () {
    var apis = ['createAnimatedNode',
    // 1
    'updateAnimatedNodeConfig',
    // 2
    'getValue',
    // 3
    'startListeningToAnimatedNodeValue',
    // 4
    'stopListeningToAnimatedNodeValue',
    // 5
    'connectAnimatedNodes',
    // 6
    'disconnectAnimatedNodes',
    // 7
    'startAnimatingNode',
    // 8
    'stopAnimation',
    // 9
    'setAnimatedNodeValue',
    // 10
    'setAnimatedNodeOffset',
    // 11
    'flattenAnimatedNodeOffset',
    // 12
    'extractAnimatedNodeOffset',
    // 13
    'connectAnimatedNodeToView',
    // 14
    'disconnectAnimatedNodeFromView',
    // 15
    'restoreDefaultValues',
    // 16
    'dropAnimatedNode',
    // 17
    'addAnimatedEventToView',
    // 18
    'removeAnimatedEventFromView',
    // 19
    'addListener',
    // 20
    'removeListener' // 21
    ];
    return apis.reduce((acc, functionName, i) => {
      // These indices need to be kept in sync with the indices in native (see NativeAnimatedModule in Java, or the equivalent for any other native platform).
      // $FlowFixMe[prop-missing]
      acc[functionName] = i + 1;
      return acc;
    }, {});
  }() : NativeAnimatedModule;

  /**
   * Wrappers around NativeAnimatedModule to provide flow and autocomplete support for
   * the native module methods, and automatic queue management on Android
   */
  var API = exports.API = {
    getValue: function getValue(tag, saveValueCallback) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      if (useSingleOpBatching) {
        if (saveValueCallback) {
          eventListenerGetValueCallbacks[tag] = saveValueCallback;
        }
        // $FlowFixMe
        API.queueOperation(nativeOps.getValue, tag);
      } else {
        API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
      }
    },
    setWaitingForIdentifier: function setWaitingForIdentifier(id) {
      waitingForQueuedOperations.add(id);
      queueOperations = true;
      if (_ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush() && flushQueueTimeout) {
        clearTimeout(flushQueueTimeout);
      }
    },
    unsetWaitingForIdentifier: function unsetWaitingForIdentifier(id) {
      waitingForQueuedOperations.delete(id);
      if (waitingForQueuedOperations.size === 0) {
        queueOperations = false;
        API.disableQueue();
      }
    },
    disableQueue: function disableQueue() {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      if (_ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush()) {
        var prevTimeout = flushQueueTimeout;
        clearImmediate(prevTimeout);
        flushQueueTimeout = setImmediate(API.flushQueue);
      } else {
        API.flushQueue();
      }
    },
    flushQueue: function flushQueue() {
      /*
      invariant(NativeAnimatedModule, 'Native animated module is not available');
      flushQueueTimeout = null;
       // Early returns before calling any APIs
      if (useSingleOpBatching && singleOpQueue.length === 0) {
        return;
      }
      if (!useSingleOpBatching && queue.length === 0) {
        return;
      }
       if (useSingleOpBatching) {
        // Set up event listener for callbacks if it's not set up
        if (
          !globalEventEmitterGetValueListener ||
          !globalEventEmitterAnimationFinishedListener
        ) {
          setupGlobalEventEmitterListeners();
        }
        // Single op batching doesn't use callback functions, instead we
        // use RCTDeviceEventEmitter. This reduces overhead of sending lots of
        // JSI functions across to native code; but also, TM infrastructure currently
        // does not support packing a function into native arrays.
        NativeAnimatedModule.queueAndExecuteBatchedOperations?.(singleOpQueue);
        singleOpQueue.length = 0;
      } else {
        Platform.OS === 'android' && NativeAnimatedModule.startOperationBatch?.();
        for (let q = 0, l = queue.length; q < l; q++) {
          queue[q]();
        }
        queue.length = 0;
        Platform.OS === 'android' &&
          NativeAnimatedModule.finishOperationBatch?.();
      }
      */
    },
    queueOperation: function queueOperation(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (useSingleOpBatching) {
        // Get the command ID from the queued function, and push that ID and any arguments needed to execute the operation
        // $FlowFixMe: surprise, fn is actually a number
        singleOpQueue.push(fn, ...args);
        return;
      }

      // If queueing is explicitly on, *or* the queue has not yet
      // been flushed, use the queue. This is to prevent operations
      // from being executed out of order.
      if (queueOperations || queue.length !== 0) {
        queue.push(() => fn(...args));
      } else {
        fn(...args);
      }
    },
    createAnimatedNode: function createAnimatedNode(tag, config) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.createAnimatedNode, tag, config);
    },
    updateAnimatedNodeConfig: function updateAnimatedNodeConfig(tag, config) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      //if (nativeOps.updateAnimatedNodeConfig) {
      //  API.queueOperation(nativeOps.updateAnimatedNodeConfig, tag, config);
      //}
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      if (useSingleOpBatching) {
        if (endCallback) {
          eventListenerAnimationFinishedCallbacks[animationId] = endCallback;
        }
        // $FlowFixMe
        API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config);
      } else {
        API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config, endCallback);
      }
    },
    stopAnimation: function stopAnimation(animationId) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopAnimation, animationId);
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset);
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
    },
    restoreDefaultValues: function restoreDefaultValues(nodeTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      // Backwards compat with older native runtimes, can be removed later.
      if (nativeOps.restoreDefaultValues != null) {
        API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
      }
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.dropAnimatedNode, tag);
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
    },
    removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      (0, _invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.removeAnimatedEventFromView, viewTag, eventName, animatedNodeTag);
    }
  };
  function setupGlobalEventEmitterListeners() {
    globalEventEmitterGetValueListener = _RCTDeviceEventEmitter.default.addListener('onNativeAnimatedModuleGetValue', function (params) {
      var tag = params.tag;
      var callback = eventListenerGetValueCallbacks[tag];
      if (!callback) {
        return;
      }
      callback(params.value);
      delete eventListenerGetValueCallbacks[tag];
    });
    globalEventEmitterAnimationFinishedListener = _RCTDeviceEventEmitter.default.addListener('onNativeAnimatedModuleAnimationFinished', function (params) {
      var animationId = params.animationId;
      var callback = eventListenerAnimationFinishedCallbacks[animationId];
      if (!callback) {
        return;
      }
      callback(params);
      delete eventListenerAnimationFinishedCallbacks[animationId];
    });
  }

  /**
   * Styles allowed by the native animated implementation.
   *
   * In general native animated implementation should support any numeric or color property that
   * doesn't need to be updated through the shadow view hierarchy (all non-layout properties).
   */
  var SUPPORTED_COLOR_STYLES = {
    backgroundColor: true,
    borderBottomColor: true,
    borderColor: true,
    borderEndColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderStartColor: true,
    borderTopColor: true,
    color: true,
    tintColor: true
  };
  var SUPPORTED_STYLES = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, SUPPORTED_COLOR_STYLES), {}, {
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    elevation: true,
    opacity: true,
    transform: true,
    zIndex: true,
    /* ios styles */
    shadowOpacity: true,
    shadowRadius: true,
    /* legacy android transform properties */
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  });
  var SUPPORTED_TRANSFORMS = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    rotateZ: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };
  function addWhitelistedStyleProp(prop) {
    SUPPORTED_STYLES[prop] = true;
  }
  function addWhitelistedTransformProp(prop) {
    SUPPORTED_TRANSFORMS[prop] = true;
  }
  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }
  function isSupportedColorStyleProp(prop) {
    return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
  }
  function isSupportedStyleProp(prop) {
    return SUPPORTED_STYLES.hasOwnProperty(prop);
  }
  function isSupportedTransformProp(prop) {
    return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
  }
  function isSupportedInterpolationParam(param) {
    return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
  }
  function validateTransform(configs) {
    configs.forEach(config => {
      if (!isSupportedTransformProp(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }
  function validateStyles(styles) {
    for (var _key2 in styles) {
      if (!isSupportedStyleProp(_key2)) {
        throw new Error("Style property '" + _key2 + "' is not supported by native animated module");
      }
    }
  }
  function validateInterpolation(config) {
    for (var _key3 in config) {
      if (!isSupportedInterpolationParam(_key3)) {
        throw new Error("Interpolation property '" + _key3 + "' is not supported by native animated module");
      }
    }
  }
  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }
  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }
  function assertNativeAnimatedModule() {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
  }
  var _warnedMissingNativeAnimated = false;
  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver == null) {
      console.warn('Animated: `useNativeDriver` was not specified. This is a required ' + 'option and must be explicitly set to `true` or `false`');
    }
    if (config.useNativeDriver === true && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn('Animated: `useNativeDriver` is not supported because the native ' + 'animated module is missing. Falling back to JS-based animation. To ' + 'resolve this, add `RCTAnimation` module to this app, or remove ' + '`useNativeDriver`. ' + 'Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md');
        _warnedMissingNativeAnimated = true;
      }
      return false;
    }
    return config.useNativeDriver || false;
  }
  function transformDataType(value) {
    // Change the string type to number type so we can reuse the same logic in
    // iOS and Android platform
    if (typeof value !== 'string') {
      return value;
    }
    if (/deg$/.test(value)) {
      var degrees = parseFloat(value) || 0;
      var radians = degrees * Math.PI / 180.0;
      return radians;
    } else {
      return value;
    }
  }
  var _default = exports.default = {
    API,
    isSupportedColorStyleProp,
    isSupportedStyleProp,
    isSupportedTransformProp,
    isSupportedInterpolationParam,
    addWhitelistedStyleProp,
    addWhitelistedTransformProp,
    addWhitelistedInterpolationParam,
    validateStyles,
    validateTransform,
    validateInterpolation,
    generateNewNodeTag,
    generateNewAnimationId,
    assertNativeAnimatedModule,
    shouldUseNativeDriver,
    transformDataType,
    // $FlowExpectedError[unsafe-getters-setters] - unsafe getter lint suppresion
    // $FlowExpectedError[missing-type-arg] - unsafe getter lint suppresion
    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new _NativeEventEmitter.default(
        // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
        // If you want to use the native module on other platforms, please remove this condition and test its behavior
        _Platform.default.OS !== 'ios' ? null : NativeAnimatedModule);
      }
      return nativeEventEmitter;
    }
  };
},167,[17,868,168,170,171,173,174,129,172],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\NativeAnimatedHelper.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TurboModuleRegistry = _interopRequireWildcard(require(_dependencyMap[0], "../TurboModule/TurboModuleRegistry"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict
  var _default = exports.default = TurboModuleRegistry.get('NativeAnimatedModule');
},168,[169],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\NativeAnimatedModule.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.get = get;
  exports.getEnforcing = getEnforcing;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  function get(name) {
    return null;
  }
  function getEnforcing(name) {
    var module = get(name);
    (0, _invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
},169,[17,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\TurboModule\\TurboModuleRegistry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TurboModuleRegistry = _interopRequireWildcard(require(_dependencyMap[0], "../TurboModule/TurboModuleRegistry"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict
  var _default = exports.default = TurboModuleRegistry.get('NativeAnimatedTurboModule');
},170,[169],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\NativeAnimatedTurboModule.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "../../../exports/Platform"));
  var _RCTDeviceEventEmitter = _interopRequireDefault(require(_dependencyMap[2], "./RCTDeviceEventEmitter"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  /**
   * `NativeEventEmitter` is intended for use by Native Modules to emit events to
   * JavaScript listeners. If a `NativeModule` is supplied to the constructor, it
   * will be notified (via `addListener` and `removeListeners`) when the listener
   * count changes to manage "native memory".
   *
   * Currently, all native events are fired via a global `RCTDeviceEventEmitter`.
   * This means event names must be globally unique, and it means that call sites
   * can theoretically listen to `RCTDeviceEventEmitter` (although discouraged).
   */
  class NativeEventEmitter {
    constructor(nativeModule) {
      if (_Platform.default.OS === 'ios') {
        (0, _invariant.default)(nativeModule != null, '`new NativeEventEmitter()` requires a non-null argument.');
        this._nativeModule = nativeModule;
      }
    }
    addListener(eventType, listener, context) {
      var _this$_nativeModule;
      (_this$_nativeModule = this._nativeModule) == null ? void 0 : _this$_nativeModule.addListener(eventType);
      var subscription = _RCTDeviceEventEmitter.default.addListener(eventType, listener, context);
      return {
        remove: () => {
          if (subscription != null) {
            var _this$_nativeModule2;
            (_this$_nativeModule2 = this._nativeModule) == null ? void 0 : _this$_nativeModule2.removeListeners(1);
            // $FlowFixMe[incompatible-use]
            subscription.remove();
            subscription = null;
          }
        }
      };
    }

    /**
     * @deprecated Use `remove` on the EventSubscription from `addListener`.
     */
    removeListener(eventType, listener) {
      var _this$_nativeModule3;
      (_this$_nativeModule3 = this._nativeModule) == null ? void 0 : _this$_nativeModule3.removeListeners(1);
      // NOTE: This will report a deprecation notice via `console.error`.
      // $FlowFixMe[prop-missing] - `removeListener` exists but is deprecated.
      _RCTDeviceEventEmitter.default.removeListener(eventType, listener);
    }
    emit(eventType) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      // Generally, `RCTDeviceEventEmitter` is directly invoked. But this is
      // included for completeness.
      _RCTDeviceEventEmitter.default.emit(eventType, ...args);
    }
    removeAllListeners(eventType) {
      var _this$_nativeModule4;
      (0, _invariant.default)(eventType != null, '`NativeEventEmitter.removeAllListener()` requires a non-null argument.');
      (_this$_nativeModule4 = this._nativeModule) == null ? void 0 : _this$_nativeModule4.removeListeners(this.listenerCount(eventType));
      _RCTDeviceEventEmitter.default.removeAllListeners(eventType);
    }
    listenerCount(eventType) {
      return _RCTDeviceEventEmitter.default.listenerCount(eventType);
    }
  }
  exports.default = NativeEventEmitter;
},171,[17,106,172,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\EventEmitter\\NativeEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _EventEmitter = _interopRequireDefault(require(_dependencyMap[1], "../vendor/emitter/EventEmitter"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  // FIXME: use typed events
  /**
   * Global EventEmitter used by the native platform to emit events to JavaScript.
   * Events are identified by globally unique event names.
   *
   * NativeModules that emit events should instead subclass `NativeEventEmitter`.
   */
  var _default = exports.default = new _EventEmitter.default();
},172,[17,145],"node_modules\\react-native-web\\dist\\vendor\\react-native\\EventEmitter\\RCTDeviceEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "../../../exports/Platform"));
  var _default = exports.default = _Platform.default;
},173,[17,106],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Utilities\\Platform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ReactNativeFeatureFlags = {
    isLayoutAnimationEnabled: () => true,
    shouldEmitW3CPointerEvents: () => false,
    shouldPressibilityUseW3CPointerEventsForHover: () => false,
    animatedShouldDebounceQueueFlush: () => false,
    animatedShouldUseSingleOp: () => false
  };
  var _default = exports.default = ReactNativeFeatureFlags;
},174,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\ReactNative\\ReactNativeFeatureFlags.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedNode"));
  var _AnimatedTransform = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedTransform"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedWithChildren"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[4], "../NativeAnimatedHelper"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../../../../exports/StyleSheet"));
  var flattenStyle = _StyleSheet.default.flatten;
  function createAnimatedStyle(inputStyle) {
    var style = flattenStyle(inputStyle);
    var animatedStyles = {};
    for (var key in style) {
      var value = style[key];
      if (key === 'transform' && Array.isArray(value)) {
        animatedStyles[key] = new _AnimatedTransform.default(value);
      } else if (value instanceof _AnimatedNode.default) {
        animatedStyles[key] = value;
      } else if (value && !Array.isArray(value) && typeof value === 'object') {
        animatedStyles[key] = createAnimatedStyle(value);
      }
    }
    return animatedStyles;
  }
  class AnimatedStyle extends _AnimatedWithChildren.default {
    constructor(style) {
      super();
      this._inputStyle = style;
      this._style = createAnimatedStyle(style);
    }

    // Recursively get values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof _AnimatedNode.default) {
          if (!value.__isNative) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            updatedStyle[key] = value.__getValue();
          }
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetValues(value);
        } else {
          updatedStyle[key] = value;
        }
      }
      return updatedStyle;
    }
    __getValue() {
      return [this._inputStyle, this._walkStyleAndGetValues(this._style)];
    }

    // Recursively get animated values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetAnimatedValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof _AnimatedNode.default) {
          updatedStyle[key] = value.__getAnimatedValue();
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
        }
      }
      return updatedStyle;
    }
    __getAnimatedValue() {
      return this._walkStyleAndGetAnimatedValues(this._style);
    }
    __attach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof _AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof _AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    __makeNative() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof _AnimatedNode.default) {
          value.__makeNative();
        }
      }
      super.__makeNative();
    }
    __getNativeConfig() {
      var styleConfig = {};
      for (var styleKey in this._style) {
        if (this._style[styleKey] instanceof _AnimatedNode.default) {
          var style = this._style[styleKey];
          style.__makeNative();
          styleConfig[styleKey] = style.__getNativeTag();
        }
      }
      _NativeAnimatedHelper.default.validateStyles(styleConfig);
      return {
        type: 'style',
        style: styleConfig
      };
    }
  }
  var _default = exports.default = AnimatedStyle;
},175,[17,166,176,165,167,30],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedNode"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[3], "../NativeAnimatedHelper"));
  class AnimatedTransform extends _AnimatedWithChildren.default {
    constructor(transforms) {
      super();
      this._transforms = transforms;
    }
    __makeNative() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            value.__makeNative();
          }
        }
      });
      super.__makeNative();
    }
    __getValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            result[key] = value.__getValue();
          } else {
            result[key] = value;
          }
        }
        return result;
      });
    }
    __getAnimatedValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            result[key] = value.__getAnimatedValue();
          } else {
            // All transform components needed to recompose matrix
            result[key] = value;
          }
        }
        return result;
      });
    }
    __attach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            value.__addChild(this);
          }
        }
      });
    }
    __detach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            value.__removeChild(this);
          }
        }
      });
      super.__detach();
    }
    __getNativeConfig() {
      var transConfigs = [];
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof _AnimatedNode.default) {
            transConfigs.push({
              type: 'animated',
              property: key,
              nodeTag: value.__getNativeTag()
            });
          } else {
            transConfigs.push({
              type: 'static',
              property: key,
              value: _NativeAnimatedHelper.default.transformDataType(value)
            });
          }
        }
      });
      _NativeAnimatedHelper.default.validateTransform(transConfigs);
      return {
        type: 'transform',
        transforms: transConfigs
      };
    }
  }
  var _default = exports.default = AnimatedTransform;
},176,[17,166,165,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedTransform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useRefEffect;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a callback ref that provides similar semantics as `useEffect`. The
   * supplied `effect` callback will be called with non-null component instances.
   * The `effect` callback can also optionally return a cleanup function.
   *
   * When a component is updated or unmounted, the cleanup function is called. The
   * `effect` callback will then be called again, if applicable.
   *
   * When a new `effect` callback is supplied, the previously returned cleanup
   * function will be called before the new `effect` callback is called with the
   * same instance.
   *
   * WARNING: The `effect` callback should be stable (e.g. using `useCallback`).
   */
  function useRefEffect(effect) {
    var cleanupRef = (0, _react.useRef)(undefined);
    return (0, _react.useCallback)(instance => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = undefined;
      }
      if (instance != null) {
        cleanupRef.current = effect(instance);
      }
    }, [effect]);
  }
},177,[3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Utilities\\useRefEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useMergeRefs;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a new ref that forwards new values to each of the given refs. The
   * given refs will always be invoked in the order that they are supplied.
   *
   * WARNING: A known problem of merging refs using this approach is that if any
   * of the given refs change, the returned callback ref will also be changed. If
   * the returned callback ref is supplied as a `ref` to a React element, this may
   * lead to problems with the given refs being invoked more times than desired.
   */
  function useMergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return (0, _react.useCallback)(current => {
      for (var _i = 0, _refs = refs; _i < _refs.length; _i++) {
        var ref = _refs[_i];
        if (ref != null) {
          if (typeof ref === 'function') {
            ref(current);
          } else {
            ref.current = current;
          }
        }
      }
    }, [...refs] // eslint-disable-line react-hooks/exhaustive-deps
    );
  }
},178,[3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Utilities\\useMergeRefs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Image = _interopRequireDefault(require(_dependencyMap[2], "../../../../exports/Image"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[3], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  var _default = exports.default = (0, _createAnimatedComponent.default)(_Image.default);
},179,[17,3,180,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedImage.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _extends2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[5], "../createElement"));
  var _AssetRegistry = require(_dependencyMap[6], "../../modules/AssetRegistry");
  var _preprocess = require(_dependencyMap[7], "../StyleSheet/preprocess");
  var _ImageLoader = _interopRequireDefault(require(_dependencyMap[8], "../../modules/ImageLoader"));
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[9], "../PixelRatio"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[10], "../StyleSheet"));
  var _TextAncestorContext = _interopRequireDefault(require(_dependencyMap[11], "../Text/TextAncestorContext"));
  var _View = _interopRequireDefault(require(_dependencyMap[12], "../View"));
  var _warnOnce = require(_dependencyMap[13], "../../modules/warnOnce");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["aria-label", "accessibilityLabel", "blurRadius", "defaultSource", "draggable", "onError", "onLayout", "onLoad", "onLoadEnd", "onLoadStart", "pointerEvents", "source", "style"];
  var ERRORED = 'ERRORED';
  var LOADED = 'LOADED';
  var LOADING = 'LOADING';
  var IDLE = 'IDLE';
  var _filterId = 0;
  var svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
  function createTintColorSVG(tintColor, id) {
    return tintColor && id != null ? /*#__PURE__*/React.createElement("svg", {
      style: {
        position: 'absolute',
        height: 0,
        visibility: 'hidden',
        width: 0
      }
    }, /*#__PURE__*/React.createElement("defs", null, /*#__PURE__*/React.createElement("filter", {
      id: "tint-" + id,
      suppressHydrationWarning: true
    }, /*#__PURE__*/React.createElement("feFlood", {
      floodColor: "" + tintColor,
      key: tintColor
    }), /*#__PURE__*/React.createElement("feComposite", {
      in2: "SourceAlpha",
      operator: "in"
    })))) : null;
  }
  function extractNonStandardStyleProps(style, blurRadius, filterId, tintColorProp) {
    var flatStyle = _StyleSheet.default.flatten(style);
    var filter = flatStyle.filter,
      resizeMode = flatStyle.resizeMode,
      shadowOffset = flatStyle.shadowOffset,
      tintColor = flatStyle.tintColor;
    if (flatStyle.resizeMode) {
      (0, _warnOnce.warnOnce)('Image.style.resizeMode', 'Image: style.resizeMode is deprecated. Please use props.resizeMode.');
    }
    if (flatStyle.tintColor) {
      (0, _warnOnce.warnOnce)('Image.style.tintColor', 'Image: style.tintColor is deprecated. Please use props.tintColor.');
    }

    // Add CSS filters
    // React Native exposes these features as props and proprietary styles
    var filters = [];
    var _filter = null;
    if (filter) {
      filters.push(filter);
    }
    if (blurRadius) {
      filters.push("blur(" + blurRadius + "px)");
    }
    if (shadowOffset) {
      var shadowString = (0, _preprocess.createBoxShadowValue)(flatStyle);
      if (shadowString) {
        filters.push("drop-shadow(" + shadowString + ")");
      }
    }
    if ((tintColorProp || tintColor) && filterId != null) {
      filters.push("url(#tint-" + filterId + ")");
    }
    if (filters.length > 0) {
      _filter = filters.join(' ');
    }
    return [resizeMode, _filter, tintColor];
  }
  function resolveAssetDimensions(source) {
    if (typeof source === 'number') {
      var _getAssetByID = (0, _AssetRegistry.getAssetByID)(source),
        _height = _getAssetByID.height,
        _width = _getAssetByID.width;
      return {
        height: _height,
        width: _width
      };
    } else if (source != null && !Array.isArray(source) && typeof source === 'object') {
      var _height2 = source.height,
        _width2 = source.width;
      return {
        height: _height2,
        width: _width2
      };
    }
  }
  function resolveAssetUri(source) {
    var uri = null;
    if (typeof source === 'number') {
      // get the URI from the packager
      var asset = (0, _AssetRegistry.getAssetByID)(source);
      if (asset == null) {
        throw new Error("Image: asset with ID \"" + source + "\" could not be found. Please check the image source or packager.");
      }
      var scale = asset.scales[0];
      if (asset.scales.length > 1) {
        var preferredScale = _PixelRatio.default.get();
        // Get the scale which is closest to the preferred scale
        scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
      }
      var scaleSuffix = scale !== 1 ? "@" + scale + "x" : '';
      uri = asset ? asset.httpServerLocation + "/" + asset.name + scaleSuffix + "." + asset.type : '';
    } else if (typeof source === 'string') {
      uri = source;
    } else if (source && typeof source.uri === 'string') {
      uri = source.uri;
    }
    if (uri) {
      var match = uri.match(svgDataUriPattern);
      // inline SVG markup may contain characters (e.g., #, ") that need to be escaped
      if (match) {
        var prefix = match[1],
          svg = match[2];
        var encodedSvg = encodeURIComponent(svg);
        return "" + prefix + encodedSvg;
      }
    }
    return uri;
  }
  var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      blurRadius = props.blurRadius,
      defaultSource = props.defaultSource,
      draggable = props.draggable,
      onError = props.onError,
      onLayout = props.onLayout,
      onLoad = props.onLoad,
      onLoadEnd = props.onLoadEnd,
      onLoadStart = props.onLoadStart,
      pointerEvents = props.pointerEvents,
      source = props.source,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var ariaLabel = _ariaLabel || accessibilityLabel;
    if (process.env.NODE_ENV !== 'production') {
      if (props.children) {
        throw new Error('The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
      }
    }
    var _React$useState = React.useState(() => {
        var uri = resolveAssetUri(source);
        if (uri != null) {
          var isLoaded = _ImageLoader.default.has(uri);
          if (isLoaded) {
            return LOADED;
          }
        }
        return IDLE;
      }),
      state = _React$useState[0],
      updateState = _React$useState[1];
    var _React$useState2 = React.useState({}),
      layout = _React$useState2[0],
      updateLayout = _React$useState2[1];
    var hasTextAncestor = React.useContext(_TextAncestorContext.default);
    var hiddenImageRef = React.useRef(null);
    var filterRef = React.useRef(_filterId++);
    var requestRef = React.useRef(null);
    var shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null;
    var _extractNonStandardSt = extractNonStandardStyleProps(style, blurRadius, filterRef.current, props.tintColor),
      _resizeMode = _extractNonStandardSt[0],
      filter = _extractNonStandardSt[1],
      _tintColor = _extractNonStandardSt[2];
    var resizeMode = props.resizeMode || _resizeMode || 'cover';
    var tintColor = props.tintColor || _tintColor;
    var selectedSource = shouldDisplaySource ? source : defaultSource;
    var displayImageUri = resolveAssetUri(selectedSource);
    var imageSizeStyle = resolveAssetDimensions(selectedSource);
    var backgroundImage = displayImageUri ? "url(\"" + displayImageUri + "\")" : null;
    var backgroundSize = getBackgroundSize();

    // Accessibility image allows users to trigger the browser's image context menu
    var hiddenImage = displayImageUri ? (0, _createElement.default)('img', {
      alt: ariaLabel || '',
      style: styles.accessibilityImage$raw,
      draggable: draggable || false,
      ref: hiddenImageRef,
      src: displayImageUri
    }) : null;
    function getBackgroundSize() {
      if (hiddenImageRef.current != null && (resizeMode === 'center' || resizeMode === 'repeat')) {
        var _hiddenImageRef$curre = hiddenImageRef.current,
          naturalHeight = _hiddenImageRef$curre.naturalHeight,
          naturalWidth = _hiddenImageRef$curre.naturalWidth;
        var _height3 = layout.height,
          _width3 = layout.width;
        if (naturalHeight && naturalWidth && _height3 && _width3) {
          var scaleFactor = Math.min(1, _width3 / naturalWidth, _height3 / naturalHeight);
          var x = Math.ceil(scaleFactor * naturalWidth);
          var y = Math.ceil(scaleFactor * naturalHeight);
          return x + "px " + y + "px";
        }
      }
    }
    function handleLayout(e) {
      if (resizeMode === 'center' || resizeMode === 'repeat' || onLayout) {
        var _layout = e.nativeEvent.layout;
        onLayout && onLayout(e);
        updateLayout(_layout);
      }
    }

    // Image loading
    var uri = resolveAssetUri(source);
    React.useEffect(() => {
      abortPendingRequest();
      if (uri != null) {
        updateState(LOADING);
        if (onLoadStart) {
          onLoadStart();
        }
        requestRef.current = _ImageLoader.default.load(uri, function load(e) {
          updateState(LOADED);
          if (onLoad) {
            onLoad(e);
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        }, function error() {
          updateState(ERRORED);
          if (onError) {
            onError({
              nativeEvent: {
                error: "Failed to load resource " + uri
              }
            });
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        });
      }
      function abortPendingRequest() {
        if (requestRef.current != null) {
          _ImageLoader.default.abort(requestRef.current);
          requestRef.current = null;
        }
      }
      return abortPendingRequest;
    }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
      "aria-label": ariaLabel,
      onLayout: handleLayout,
      pointerEvents: pointerEvents,
      ref: ref,
      style: [styles.root, hasTextAncestor && styles.inline, imageSizeStyle, style, styles.undo,
      // TEMP: avoid deprecated shadow props regression
      // until Image refactored to use createElement.
      {
        boxShadow: null
      }]
    }), /*#__PURE__*/React.createElement(_View.default, {
      style: [styles.image, resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current));
  });
  Image.displayName = 'Image';

  // $FlowIgnore: This is the correct type, but casting makes it unhappy since the variables aren't defined yet
  var ImageWithStatics = Image;
  ImageWithStatics.getSize = function (uri, success, failure) {
    _ImageLoader.default.getSize(uri, success, failure);
  };
  ImageWithStatics.prefetch = function (uri) {
    return _ImageLoader.default.prefetch(uri);
  };
  ImageWithStatics.queryCache = function (uris) {
    return _ImageLoader.default.queryCache(uris);
  };
  var styles = _StyleSheet.default.create({
    root: {
      flexBasis: 'auto',
      overflow: 'hidden',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    },
    undo: {
      // These styles are converted to CSS filters applied to the
      // element displaying the background image.
      blurRadius: null,
      shadowColor: null,
      shadowOpacity: null,
      shadowOffset: null,
      shadowRadius: null,
      tintColor: null,
      // These styles are not supported
      overlayColor: null,
      resizeMode: null
    },
    image: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
      backgroundColor: 'transparent',
      backgroundPosition: 'center',
      backgroundRepeat: 'no-repeat',
      backgroundSize: 'cover',
      height: '100%',
      width: '100%',
      zIndex: -1
    }),
    accessibilityImage$raw: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      opacity: 0,
      width: '100%',
      zIndex: -1
    })
  });
  var resizeModeStyles = _StyleSheet.default.create({
    center: {
      backgroundSize: 'auto'
    },
    contain: {
      backgroundSize: 'contain'
    },
    cover: {
      backgroundSize: 'cover'
    },
    none: {
      backgroundPosition: '0',
      backgroundSize: 'auto'
    },
    repeat: {
      backgroundPosition: '0',
      backgroundRepeat: 'repeat',
      backgroundSize: 'auto'
    },
    stretch: {
      backgroundSize: '100% 100%'
    }
  });
  var _default = exports.default = ImageWithStatics;
},180,[17,868,888,873,3,18,181,75,182,183,30,127,111,76],"node_modules\\react-native-web\\dist\\exports\\Image\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const assets = [];
  module.exports = {
    registerAsset: s => assets.push(s),
    getAssetByID: s => assets[s - 1]
  };
},181,[],"\u0000polyfill:assets-registry");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.ImageUriCache = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dataUriPattern = /^data:/;
  class ImageUriCache {
    static has(uri) {
      var entries = ImageUriCache._entries;
      var isDataUri = dataUriPattern.test(uri);
      return isDataUri || Boolean(entries[uri]);
    }
    static add(uri) {
      var entries = ImageUriCache._entries;
      var lastUsedTimestamp = Date.now();
      if (entries[uri]) {
        entries[uri].lastUsedTimestamp = lastUsedTimestamp;
        entries[uri].refCount += 1;
      } else {
        entries[uri] = {
          lastUsedTimestamp,
          refCount: 1
        };
      }
    }
    static remove(uri) {
      var entries = ImageUriCache._entries;
      if (entries[uri]) {
        entries[uri].refCount -= 1;
      }
      // Free up entries when the cache is "full"
      ImageUriCache._cleanUpIfNeeded();
    }
    static _cleanUpIfNeeded() {
      var entries = ImageUriCache._entries;
      var imageUris = Object.keys(entries);
      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {
        var leastRecentlyUsedKey;
        var leastRecentlyUsedEntry;
        imageUris.forEach(uri => {
          var entry = entries[uri];
          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {
            leastRecentlyUsedKey = uri;
            leastRecentlyUsedEntry = entry;
          }
        });
        if (leastRecentlyUsedKey) {
          delete entries[leastRecentlyUsedKey];
        }
      }
    }
  }
  exports.ImageUriCache = ImageUriCache;
  ImageUriCache._maximumEntries = 256;
  ImageUriCache._entries = {};
  var id = 0;
  var requests = {};
  var ImageLoader = {
    abort(requestId) {
      var image = requests["" + requestId];
      if (image) {
        image.onerror = null;
        image.onload = null;
        image = null;
        delete requests["" + requestId];
      }
    },
    getSize(uri, success, failure) {
      var complete = false;
      var interval = setInterval(callback, 16);
      var requestId = ImageLoader.load(uri, callback, errorCallback);
      function callback() {
        var image = requests["" + requestId];
        if (image) {
          var naturalHeight = image.naturalHeight,
            naturalWidth = image.naturalWidth;
          if (naturalHeight && naturalWidth) {
            success(naturalWidth, naturalHeight);
            complete = true;
          }
        }
        if (complete) {
          ImageLoader.abort(requestId);
          clearInterval(interval);
        }
      }
      function errorCallback() {
        if (typeof failure === 'function') {
          failure();
        }
        ImageLoader.abort(requestId);
        clearInterval(interval);
      }
    },
    has(uri) {
      return ImageUriCache.has(uri);
    },
    load(uri, onLoad, onError) {
      id += 1;
      var image = new window.Image();
      image.onerror = onError;
      image.onload = e => {
        // avoid blocking the main thread
        var onDecode = () => onLoad({
          nativeEvent: e
        });
        if (typeof image.decode === 'function') {
          // Safari currently throws exceptions when decoding svgs.
          // We want to catch that error and allow the load handler
          // to be forwarded to the onLoad handler in this case
          image.decode().then(onDecode, onDecode);
        } else {
          setTimeout(onDecode, 0);
        }
      };
      image.src = uri;
      requests["" + id] = image;
      return id;
    },
    prefetch(uri) {
      return new Promise((resolve, reject) => {
        ImageLoader.load(uri, () => {
          // Add the uri to the cache so it can be immediately displayed when used
          // but also immediately remove it to correctly reflect that it has no active references
          ImageUriCache.add(uri);
          ImageUriCache.remove(uri);
          resolve();
        }, reject);
      });
    },
    queryCache(uris) {
      var result = {};
      uris.forEach(u => {
        if (ImageUriCache.has(u)) {
          result[u] = 'disk/memory';
        }
      });
      return Promise.resolve(result);
    }
  };
  var _default = exports.default = ImageLoader;
},182,[],"node_modules\\react-native-web\\dist\\modules\\ImageLoader\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[1], "../Dimensions"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * PixelRatio gives access to the device pixel density.
   */
  class PixelRatio {
    /**
     * Returns the device pixel density.
     */
    static get() {
      return _Dimensions.default.get('window').scale;
    }

    /**
     * No equivalent for Web
     */
    static getFontScale() {
      return _Dimensions.default.get('window').fontScale || PixelRatio.get();
    }

    /**
     * Converts a layout size (dp) to pixel size (px).
     * Guaranteed to return an integer number.
     */
    static getPixelSizeForLayoutSize(layoutSize) {
      return Math.round(layoutSize * PixelRatio.get());
    }

    /**
     * Rounds a layout size (dp) to the nearest layout size that corresponds to
     * an integer number of pixels. For example, on a device with a PixelRatio
     * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
     * exactly (8.33 * 3) = 25 pixels.
     */
    static roundToNearestPixel(layoutSize) {
      var ratio = PixelRatio.get();
      return Math.round(layoutSize * ratio) / ratio;
    }
  }
  exports.default = PixelRatio;
},183,[17,136],"node_modules\\react-native-web\\dist\\exports\\PixelRatio\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[3], "../../../../exports/ScrollView"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[4], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var ScrollViewWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_ScrollView.default, (0, _extends2.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = exports.default = (0, _createAnimatedComponent.default)(ScrollViewWithEventThrottle);
},184,[17,888,3,135,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedScrollView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _SectionList = _interopRequireDefault(require(_dependencyMap[3], "../../../../exports/SectionList"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[4], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var SectionListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_SectionList.default, (0, _extends2.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = exports.default = (0, _createAnimatedComponent.default)(SectionListWithEventThrottle);
},185,[17,888,3,186,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedSectionList.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _SectionList = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/SectionList"));
  var _default = exports.default = _SectionList.default;
},186,[17,187],"node_modules\\react-native-web\\dist\\exports\\SectionList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "../../../exports/Platform"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _VirtualizedSectionList = _interopRequireDefault(require(_dependencyMap[5], "../VirtualizedSectionList"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["stickySectionHeadersEnabled"];
  /**
   * A performant interface for rendering sectioned lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Configurable viewability callbacks.
   *  - List header support.
   *  - List footer support.
   *  - Item separator support.
   *  - Section header support.
   *  - Section separator support.
   *  - Heterogeneous data and item rendering support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *
   * If you don't need section support and want a simpler interface, use
   * [`<FlatList>`](https://reactnative.dev/docs/flatlist).
   *
   * Simple Examples:
   *
   *     <SectionList
   *       renderItem={({item}) => <ListItem title={item} />}
   *       renderSectionHeader={({section}) => <Header title={section.title} />}
   *       sections={[ // homogeneous rendering between sections
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *       ]}
   *     />
   *
   *     <SectionList
   *       sections={[ // heterogeneous rendering between sections
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *       ]}
   *     />
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   */
  class SectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._captureRef = ref => {
        this._wrapperListRef = ref;
      };
    }
    /**
     * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)
     * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be
     * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a
     * fixed number of pixels to offset the final target position, e.g. to compensate for sticky
     * headers.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToLocation(params) {
      if (this._wrapperListRef != null) {
        this._wrapperListRef.scrollToLocation(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.recordInteraction();
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollableNode();
      }
    }
    render() {
      var _this$props = this.props,
        _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== void 0 ? _stickySectionHeadersEnabled : _Platform.default.OS === 'ios';
      return /*#__PURE__*/React.createElement(_VirtualizedSectionList.default, (0, _extends2.default)({}, restProps, {
        stickySectionHeadersEnabled: stickySectionHeadersEnabled,
        ref: this._captureRef,
        getItemCount: items => items.length,
        getItem: (items, index) => items[index]
      }));
    }
  }
  exports.default = SectionList;
},187,[17,888,873,106,3,188],"node_modules\\react-native-web\\dist\\vendor\\react-native\\SectionList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _createForOfIteratorHelperLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/createForOfIteratorHelperLoose"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[4], "@babel/runtime/helpers/objectSpread2"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "../../../exports/View"));
  var _VirtualizedList = _interopRequireDefault(require(_dependencyMap[6], "../VirtualizedList"));
  var _VirtualizeUtils = require(_dependencyMap[7], "../VirtualizeUtils");
  var _invariant = _interopRequireDefault(require(_dependencyMap[8], "fbjs/lib/invariant"));
  var React = _interopRequireWildcard(require(_dependencyMap[9], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Right now this just flattens everything into one list and uses VirtualizedList under the
   * hood. The only operation that might not scale well is concatting the data arrays of all the
   * sections when new props are received, which should be plenty fast for up to ~10,000 items.
   */
  class VirtualizedSectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._keyExtractor = (item, index) => {
        var info = this._subExtractor(index);
        return info && info.key || String(index);
      };
      this._convertViewable = viewable => {
        var _info$index;
        (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');
        var info = this._subExtractor(viewable.index);
        if (!info) {
          return null;
        }
        var keyExtractorWithNullableIndex = info.section.keyExtractor;
        var keyExtractorWithNonNullableIndex = this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
        var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) !== null && _info$index !== void 0 ? _info$index : 0);
        return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, viewable), {}, {
          index: info.index,
          key,
          section: info.section
        });
      };
      this._onViewableItemsChanged = _ref => {
        var viewableItems = _ref.viewableItems,
          changed = _ref.changed;
        var onViewableItemsChanged = this.props.onViewableItemsChanged;
        if (onViewableItemsChanged != null) {
          onViewableItemsChanged({
            viewableItems: viewableItems.map(this._convertViewable, this).filter(Boolean),
            changed: changed.map(this._convertViewable, this).filter(Boolean)
          });
        }
      };
      this._renderItem = listItemCount =>
      // eslint-disable-next-line react/no-unstable-nested-components
      _ref2 => {
        var item = _ref2.item,
          index = _ref2.index;
        var info = this._subExtractor(index);
        if (!info) {
          return null;
        }
        var infoIndex = info.index;
        if (infoIndex == null) {
          var section = info.section;
          if (info.header === true) {
            var renderSectionHeader = this.props.renderSectionHeader;
            return renderSectionHeader ? renderSectionHeader({
              section
            }) : null;
          } else {
            var renderSectionFooter = this.props.renderSectionFooter;
            return renderSectionFooter ? renderSectionFooter({
              section
            }) : null;
          }
        } else {
          var renderItem = info.section.renderItem || this.props.renderItem;
          var SeparatorComponent = this._getSeparatorComponent(index, info, listItemCount);
          (0, _invariant.default)(renderItem, 'no renderItem!');
          return /*#__PURE__*/React.createElement(ItemWithSeparator, {
            SeparatorComponent: SeparatorComponent,
            LeadingSeparatorComponent: infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined,
            cellKey: info.key,
            index: infoIndex,
            item: item,
            leadingItem: info.leadingItem,
            leadingSection: info.leadingSection,
            prevCellKey: (this._subExtractor(index - 1) || {}).key
            // Callback to provide updateHighlight for this item
            ,

            setSelfHighlightCallback: this._setUpdateHighlightFor,
            setSelfUpdatePropsCallback: this._setUpdatePropsFor
            // Provide child ability to set highlight/updateProps for previous item using prevCellKey
            ,

            updateHighlightFor: this._updateHighlightFor,
            updatePropsFor: this._updatePropsFor,
            renderItem: renderItem,
            section: info.section,
            trailingItem: info.trailingItem,
            trailingSection: info.trailingSection,
            inverted: !!this.props.inverted
          });
        }
      };
      this._updatePropsFor = (cellKey, value) => {
        var updateProps = this._updatePropsMap[cellKey];
        if (updateProps != null) {
          updateProps(value);
        }
      };
      this._updateHighlightFor = (cellKey, value) => {
        var updateHighlight = this._updateHighlightMap[cellKey];
        if (updateHighlight != null) {
          updateHighlight(value);
        }
      };
      this._setUpdateHighlightFor = (cellKey, updateHighlightFn) => {
        if (updateHighlightFn != null) {
          this._updateHighlightMap[cellKey] = updateHighlightFn;
        } else {
          // $FlowFixMe[prop-missing]
          delete this._updateHighlightFor[cellKey];
        }
      };
      this._setUpdatePropsFor = (cellKey, updatePropsFn) => {
        if (updatePropsFn != null) {
          this._updatePropsMap[cellKey] = updatePropsFn;
        } else {
          delete this._updatePropsMap[cellKey];
        }
      };
      this._updateHighlightMap = {};
      this._updatePropsMap = {};
      this._captureRef = ref => {
        this._listRef = ref;
      };
    }
    scrollToLocation(params) {
      var index = params.itemIndex;
      for (var i = 0; i < params.sectionIndex; i++) {
        index += this.props.getItemCount(this.props.sections[i].data) + 2;
      }
      var viewOffset = params.viewOffset || 0;
      if (this._listRef == null) {
        return;
      }
      if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
        var frame = this._listRef.__getFrameMetricsApprox(index - params.itemIndex, this._listRef.props);
        viewOffset += frame.length;
      }
      var toIndexParams = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, params), {}, {
        viewOffset,
        index
      });
      // $FlowFixMe[incompatible-use]
      this._listRef.scrollToIndex(toIndexParams);
    }
    getListRef() {
      return this._listRef;
    }
    render() {
      var _this$props = this.props,
        ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
        SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
        _renderItem = _this$props.renderItem,
        renderSectionFooter = _this$props.renderSectionFooter,
        renderSectionHeader = _this$props.renderSectionHeader,
        _sections = _this$props.sections,
        stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        passThroughProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
      var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
      var itemCount = 0;
      for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(this.props.sections), _step; !(_step = _iterator()).done;) {
        var section = _step.value;
        // Track the section header indices
        if (stickyHeaderIndices != null) {
          stickyHeaderIndices.push(itemCount + listHeaderOffset);
        }

        // Add two for the section header and footer.
        itemCount += 2;
        itemCount += this.props.getItemCount(section.data);
      }
      var renderItem = this._renderItem(itemCount);
      return /*#__PURE__*/React.createElement(_VirtualizedList.default, (0, _extends2.default)({}, passThroughProps, {
        keyExtractor: this._keyExtractor,
        stickyHeaderIndices: stickyHeaderIndices,
        renderItem: renderItem,
        data: this.props.sections,
        getItem: (sections, index) => this._getItem(this.props, sections, index),
        getItemCount: () => itemCount,
        onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
        ref: this._captureRef
      }));
    }
    _getItem(props, sections, index) {
      if (!sections) {
        return null;
      }
      var itemIdx = index - 1;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var itemCount = props.getItemCount(sectionData);
        if (itemIdx === -1 || itemIdx === itemCount) {
          // We intend for there to be overflow by one on both ends of the list.
          // This will be for headers and footers. When returning a header or footer
          // item the section itself is the item.
          return section;
        } else if (itemIdx < itemCount) {
          // If we are in the bounds of the list's data then return the item.
          return props.getItem(sectionData, itemIdx);
        } else {
          itemIdx -= itemCount + 2; // Add two for the header and footer
        }
      }
      return null;
    }

    // $FlowFixMe[missing-local-annot]

    _subExtractor(index) {
      var itemIndex = index;
      var _this$props2 = this.props,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount,
        keyExtractor = _this$props2.keyExtractor,
        sections = _this$props2.sections;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var key = section.key || String(i);
        itemIndex -= 1; // The section adds an item for the header
        if (itemIndex >= getItemCount(sectionData) + 1) {
          itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
        } else if (itemIndex === -1) {
          return {
            section,
            key: key + ':header',
            index: null,
            header: true,
            trailingSection: sections[i + 1]
          };
        } else if (itemIndex === getItemCount(sectionData)) {
          return {
            section,
            key: key + ':footer',
            index: null,
            header: false,
            trailingSection: sections[i + 1]
          };
        } else {
          var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
          return {
            section,
            key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
            index: itemIndex,
            leadingItem: getItem(sectionData, itemIndex - 1),
            leadingSection: sections[i - 1],
            trailingItem: getItem(sectionData, itemIndex + 1),
            trailingSection: sections[i + 1]
          };
        }
      }
    }
    _getSeparatorComponent(index, info, listItemCount) {
      info = info || this._subExtractor(index);
      if (!info) {
        return null;
      }
      var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
      var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
      var isLastItemInList = index === listItemCount - 1;
      var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
      if (SectionSeparatorComponent && isLastItemInSection) {
        return SectionSeparatorComponent;
      }
      if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
        return ItemSeparatorComponent;
      }
      return null;
    }
  }
  function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
      SeparatorComponent = props.SeparatorComponent,
      cellKey = props.cellKey,
      prevCellKey = props.prevCellKey,
      setSelfHighlightCallback = props.setSelfHighlightCallback,
      updateHighlightFor = props.updateHighlightFor,
      setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
      updatePropsFor = props.updatePropsFor,
      item = props.item,
      index = props.index,
      section = props.section,
      inverted = props.inverted;
    var _React$useState = React.useState(false),
      leadingSeparatorHiglighted = _React$useState[0],
      setLeadingSeparatorHighlighted = _React$useState[1];
    var _React$useState2 = React.useState(false),
      separatorHighlighted = _React$useState2[0],
      setSeparatorHighlighted = _React$useState2[1];
    var _React$useState3 = React.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
      }),
      leadingSeparatorProps = _React$useState3[0],
      setLeadingSeparatorProps = _React$useState3[1];
    var _React$useState4 = React.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
      }),
      separatorProps = _React$useState4[0],
      setSeparatorProps = _React$useState4[1];
    React.useEffect(() => {
      setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
      // $FlowFixMe[incompatible-call]
      setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
      return () => {
        setSelfUpdatePropsCallback(cellKey, null);
        setSelfHighlightCallback(cellKey, null);
      };
    }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
    var separators = {
      highlight: () => {
        setLeadingSeparatorHighlighted(true);
        setSeparatorHighlighted(true);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, true);
        }
      },
      unhighlight: () => {
        setLeadingSeparatorHighlighted(false);
        setSeparatorHighlighted(false);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, false);
        }
      },
      updateProps: (select, newProps) => {
        if (select === 'leading') {
          if (LeadingSeparatorComponent != null) {
            setLeadingSeparatorProps((0, _objectSpread2.default)((0, _objectSpread2.default)({}, leadingSeparatorProps), newProps));
          } else if (prevCellKey != null) {
            // update the previous item's separator
            updatePropsFor(prevCellKey, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, leadingSeparatorProps), newProps));
          }
        } else if (select === 'trailing' && SeparatorComponent != null) {
          setSeparatorProps((0, _objectSpread2.default)((0, _objectSpread2.default)({}, separatorProps), newProps));
        }
      }
    };
    var element = props.renderItem({
      item,
      index,
      section,
      separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/React.createElement(LeadingSeparatorComponent, (0, _extends2.default)({
      highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/React.createElement(SeparatorComponent, (0, _extends2.default)({
      highlighted: separatorHighlighted
    }, separatorProps));
    return leadingSeparator || separator ? /*#__PURE__*/React.createElement(_View.default, null, inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator) : element;
  }

  /* $FlowFixMe[class-object-subtyping] added when improving typing for this
   * parameters */
  // $FlowFixMe[method-unbinding]
  var _default = exports.default = VirtualizedSectionList;
},188,[17,888,889,873,868,111,130,156,129,3],"node_modules\\react-native-web\\dist\\vendor\\react-native\\VirtualizedSectionList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Text = _interopRequireDefault(require(_dependencyMap[2], "../../../../exports/Text"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[3], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  var _default = exports.default = (0, _createAnimatedComponent.default)(_Text.default);
},189,[17,3,190,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedText.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[4], "../createElement"));
  var forwardedProps = _interopRequireWildcard(require(_dependencyMap[5], "../../modules/forwardedProps"));
  var _pick = _interopRequireDefault(require(_dependencyMap[6], "../../modules/pick"));
  var _useElementLayout = _interopRequireDefault(require(_dependencyMap[7], "../../modules/useElementLayout"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[8], "../../modules/useMergeRefs"));
  var _usePlatformMethods = _interopRequireDefault(require(_dependencyMap[9], "../../modules/usePlatformMethods"));
  var _useResponderEvents = _interopRequireDefault(require(_dependencyMap[10], "../../modules/useResponderEvents"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[11], "../StyleSheet"));
  var _TextAncestorContext = _interopRequireDefault(require(_dependencyMap[12], "./TextAncestorContext"));
  var _useLocale = require(_dependencyMap[13], "../../modules/useLocale");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["hrefAttrs", "numberOfLines", "onClick", "onLayout", "onPress", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture", "selectable"];
  //import { warnOnce } from '../../modules/warnOnce';

  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    pointerEvents: true
  });
  var pickProps = props => (0, _pick.default)(props, forwardPropsList);
  var Text = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      numberOfLines = props.numberOfLines,
      onClick = props.onClick,
      onLayout = props.onLayout,
      onPress = props.onPress,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      selectable = props.selectable,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

    /*
    if (selectable != null) {
      warnOnce(
        'selectable',
        'selectable prop is deprecated. Use styles.userSelect.'
      );
    }
    */

    var hasTextAncestor = React.useContext(_TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, _useElementLayout.default)(hostRef, onLayout);
    (0, _useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var handleClick = React.useCallback(e => {
      if (onClick != null) {
        onClick(e);
      } else if (onPress != null) {
        e.stopPropagation();
        onPress(e);
      }
    }, [onClick, onPress]);
    var component = hasTextAncestor ? 'span' : 'div';
    var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    // 'auto' by default allows browsers to infer writing direction (root elements only)
    if (!hasTextAncestor) {
      supportedProps.dir = componentDirection != null ? componentDirection : 'auto';
    }
    if (onClick || onPress) {
      supportedProps.onClick = handleClick;
    }
    supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
      WebkitLineClamp: numberOfLines
    }, hasTextAncestor === true ? styles.textHasAncestor$raw : styles.text$raw, numberOfLines === 1 && styles.textOneLine, numberOfLines != null && numberOfLines > 1 && styles.textMultiLine, props.style, selectable === true && styles.selectable, selectable === false && styles.notSelectable, onPress && styles.pressable];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
    var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    var element = (0, _createElement.default)(component, supportedProps, {
      writingDirection
    });
    return hasTextAncestor ? element : /*#__PURE__*/React.createElement(_TextAncestorContext.default.Provider, {
      value: true
    }, element);
  });
  Text.displayName = 'Text';
  var textStyle = {
    backgroundColor: 'transparent',
    border: '0 solid black',
    boxSizing: 'border-box',
    color: 'black',
    display: 'inline',
    font: '14px System',
    listStyle: 'none',
    margin: 0,
    padding: 0,
    position: 'relative',
    textAlign: 'start',
    textDecoration: 'none',
    whiteSpace: 'pre-wrap',
    wordWrap: 'break-word'
  };
  var styles = _StyleSheet.default.create({
    text$raw: textStyle,
    textHasAncestor$raw: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, textStyle), {}, {
      color: 'inherit',
      font: 'inherit',
      textAlign: 'inherit',
      whiteSpace: 'inherit'
    }),
    textOneLine: {
      maxWidth: '100%',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    },
    // See #13
    textMultiLine: {
      display: '-webkit-box',
      maxWidth: '100%',
      overflow: 'clip',
      textOverflow: 'ellipsis',
      WebkitBoxOrient: 'vertical'
    },
    notSelectable: {
      userSelect: 'none'
    },
    selectable: {
      userSelect: 'text'
    },
    pressable: {
      cursor: 'pointer'
    }
  });
  var _default = exports.default = Text;
},190,[17,868,873,3,18,112,113,114,116,118,120,30,127,85],"node_modules\\react-native-web\\dist\\exports\\Text\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[2], "../../../../exports/View"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[3], "../createAnimatedComponent"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  var _default = exports.default = (0, _createAnimatedComponent.default)(_View.default);
},191,[17,3,111,159],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\components\\AnimatedView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedEvent = require(_dependencyMap[2], "./AnimatedEvent");
  var _AnimatedImplementation = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedImplementation"));
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[4], "./nodes/AnimatedInterpolation"));
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[5], "./nodes/AnimatedNode"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[6], "./nodes/AnimatedValue"));
  var _AnimatedValueXY = _interopRequireDefault(require(_dependencyMap[7], "./nodes/AnimatedValueXY"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[8], "./createAnimatedComponent"));
  var _AnimatedColor = _interopRequireDefault(require(_dependencyMap[9], "./nodes/AnimatedColor"));
  /**
   * Animations are a source of flakiness in snapshot testing. This mock replaces
   * animation functions from AnimatedImplementation with empty animations for
   * predictability in tests. When possible the animation will run immediately
   * to the final state.
   */

  // Prevent any callback invocation from recursively triggering another
  // callback, which may trigger another animation
  var inAnimationCallback = false;
  function mockAnimationStart(start) {
    return callback => {
      var guardedCallback = callback == null ? callback : function () {
        if (inAnimationCallback) {
          console.warn('Ignoring recursive animation callback when running mock animations');
          return;
        }
        inAnimationCallback = true;
        try {
          callback(...arguments);
        } finally {
          inAnimationCallback = false;
        }
      };
      start(guardedCallback);
    };
  }
  var emptyAnimation = {
    start: () => {},
    stop: () => {},
    reset: () => {},
    _startNativeLoop: () => {},
    _isUsingNativeDriver: () => {
      return false;
    }
  };
  var mockCompositeAnimation = animations => (0, _objectSpread2.default)((0, _objectSpread2.default)({}, emptyAnimation), {}, {
    start: mockAnimationStart(callback => {
      animations.forEach(animation => animation.start());
      callback == null ? void 0 : callback({
        finished: true
      });
    })
  });
  var spring = function spring(value, config) {
    var anyValue = value;
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? void 0 : callback({
          finished: true
        });
      })
    });
  };
  var timing = function timing(value, config) {
    var anyValue = value;
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? void 0 : callback({
          finished: true
        });
      })
    });
  };
  var decay = function decay(value, config) {
    return emptyAnimation;
  };
  var sequence = function sequence(animations) {
    return mockCompositeAnimation(animations);
  };
  var parallel = function parallel(animations, config) {
    return mockCompositeAnimation(animations);
  };
  var delay = function delay(time) {
    return emptyAnimation;
  };
  var stagger = function stagger(time, animations) {
    return mockCompositeAnimation(animations);
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations;
    return emptyAnimation;
  };
  var _default = exports.default = {
    Value: _AnimatedValue.default,
    ValueXY: _AnimatedValueXY.default,
    Color: _AnimatedColor.default,
    Interpolation: _AnimatedInterpolation.default,
    Node: _AnimatedNode.default,
    decay,
    timing,
    spring,
    add: _AnimatedImplementation.default.add,
    subtract: _AnimatedImplementation.default.subtract,
    divide: _AnimatedImplementation.default.divide,
    multiply: _AnimatedImplementation.default.multiply,
    modulo: _AnimatedImplementation.default.modulo,
    diffClamp: _AnimatedImplementation.default.diffClamp,
    delay,
    sequence,
    parallel,
    stagger,
    loop,
    event: _AnimatedImplementation.default.event,
    createAnimatedComponent: _createAnimatedComponent.default,
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    forkEvent: _AnimatedImplementation.default.forkEvent,
    unforkEvent: _AnimatedImplementation.default.unforkEvent,
    Event: _AnimatedEvent.AnimatedEvent
  };
},192,[17,868,162,193,164,166,163,201,159,206],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\AnimatedMock.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedEvent = require(_dependencyMap[2], "./AnimatedEvent");
  var _AnimatedAddition = _interopRequireDefault(require(_dependencyMap[3], "./nodes/AnimatedAddition"));
  var _AnimatedDiffClamp = _interopRequireDefault(require(_dependencyMap[4], "./nodes/AnimatedDiffClamp"));
  var _AnimatedDivision = _interopRequireDefault(require(_dependencyMap[5], "./nodes/AnimatedDivision"));
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[6], "./nodes/AnimatedInterpolation"));
  var _AnimatedModulo = _interopRequireDefault(require(_dependencyMap[7], "./nodes/AnimatedModulo"));
  var _AnimatedMultiplication = _interopRequireDefault(require(_dependencyMap[8], "./nodes/AnimatedMultiplication"));
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[9], "./nodes/AnimatedNode"));
  var _AnimatedProps = _interopRequireDefault(require(_dependencyMap[10], "./nodes/AnimatedProps"));
  var _AnimatedSubtraction = _interopRequireDefault(require(_dependencyMap[11], "./nodes/AnimatedSubtraction"));
  var _AnimatedTracking = _interopRequireDefault(require(_dependencyMap[12], "./nodes/AnimatedTracking"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[13], "./nodes/AnimatedValue"));
  var _AnimatedValueXY = _interopRequireDefault(require(_dependencyMap[14], "./nodes/AnimatedValueXY"));
  var _DecayAnimation = _interopRequireDefault(require(_dependencyMap[15], "./animations/DecayAnimation"));
  var _SpringAnimation = _interopRequireDefault(require(_dependencyMap[16], "./animations/SpringAnimation"));
  var _TimingAnimation = _interopRequireDefault(require(_dependencyMap[17], "./animations/TimingAnimation"));
  var _createAnimatedComponent = _interopRequireDefault(require(_dependencyMap[18], "./createAnimatedComponent"));
  var _AnimatedColor = _interopRequireDefault(require(_dependencyMap[19], "./nodes/AnimatedColor"));
  var add = function add(a, b) {
    return new _AnimatedAddition.default(a, b);
  };
  var subtract = function subtract(a, b) {
    return new _AnimatedSubtraction.default(a, b);
  };
  var divide = function divide(a, b) {
    return new _AnimatedDivision.default(a, b);
  };
  var multiply = function multiply(a, b) {
    return new _AnimatedMultiplication.default(a, b);
  };
  var modulo = function modulo(a, modulus) {
    return new _AnimatedModulo.default(a, modulus);
  };
  var diffClamp = function diffClamp(a, min, max) {
    return new _AnimatedDiffClamp.default(a, min, max);
  };
  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete(...arguments);
        callback && callback(...arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };
  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof _AnimatedValueXY.default) {
      var configX = (0, _objectSpread2.default)({}, config);
      var configY = (0, _objectSpread2.default)({}, config);
      for (var key in config) {
        var _config$key = config[key],
          x = _config$key.x,
          y = _config$key.y;
        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }
      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aX, aY], {
        stopTogether: false
      });
    } else if (value instanceof _AnimatedColor.default) {
      var configR = (0, _objectSpread2.default)({}, config);
      var configG = (0, _objectSpread2.default)({}, config);
      var configB = (0, _objectSpread2.default)({}, config);
      var configA = (0, _objectSpread2.default)({}, config);
      for (var _key in config) {
        var _config$_key = config[_key],
          r = _config$_key.r,
          g = _config$_key.g,
          b = _config$_key.b,
          a = _config$_key.a;
        if (r !== undefined && g !== undefined && b !== undefined && a !== undefined) {
          configR[_key] = r;
          configG[_key] = g;
          configB[_key] = b;
          configA[_key] = a;
        }
      }
      var aR = anim(value.r, configR);
      var aG = anim(value.g, configG);
      var aB = anim(value.b, configB);
      var aA = anim(value.a, configA);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aR, aG, aB, aA], {
        stopTogether: false
      });
    }
    return null;
  };
  var spring = function spring(value, config) {
    var _start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof _AnimatedNode.default) {
        singleValue.track(new _AnimatedTracking.default(singleValue, configuration.toValue, _SpringAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new _SpringAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, spring) || {
      start: function start(callback) {
        _start(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
          iterations
        });
        _start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var timing = function timing(value, config) {
    var _start2 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof _AnimatedNode.default) {
        singleValue.track(new _AnimatedTracking.default(singleValue, configuration.toValue, _TimingAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new _TimingAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, timing) || {
      start: function start(callback) {
        _start2(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
          iterations
        });
        _start2(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var decay = function decay(value, config) {
    var _start3 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new _DecayAnimation.default(singleConfig), callback);
    };
    return maybeVectorAnim(value, config, decay) || {
      start: function start(callback) {
        _start3(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
          iterations
        });
        _start3(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }
          current++;
          if (current === animations.length) {
            callback && callback(result);
            return;
          }
          animations[current].start(onComplete);
        };
        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };
  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    // Make sure we only call stop() at most once for each animation
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }
        animations.forEach((animation, idx) => {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;
            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }
            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };
          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach((animation, idx) => {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };
  var delay = function delay(time) {
    // Would be nice to make a specialized implementation
    return timing(new _AnimatedValue.default(0), {
      toValue: 0,
      delay: time,
      duration: 0,
      useNativeDriver: false
    });
  };
  var stagger = function stagger(time, animations) {
    return parallel(animations.map((animation, i) => {
      return sequence([delay(time * i), animation]);
    }));
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations,
      _ref$resetBeforeItera = _ref.resetBeforeIteration,
      resetBeforeIteration = _ref$resetBeforeItera === void 0 ? true : _ref$resetBeforeItera;
    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart(result) {
          if (result === void 0) {
            result = {
              finished: true
            };
          }
          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            resetBeforeIteration && animation.reset();
            animation.start(restart);
          }
        };
        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart(); // Start looping recursively on the js thread
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };
  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__addListener(listener);
      return event;
    } else {
      return function () {
        typeof event === 'function' && event(...arguments);
        listener(...arguments);
      };
    }
  }
  function unforkEvent(event, listener) {
    if (event && event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__removeListener(listener);
    }
  }
  var event = function event(argMapping, config) {
    var animatedEvent = new _AnimatedEvent.AnimatedEvent(argMapping, config);
    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  // All types of animated nodes that represent scalar numbers and can be interpolated (etc)

  /**
   * The `Animated` library is designed to make animations fluid, powerful, and
   * easy to build and maintain. `Animated` focuses on declarative relationships
   * between inputs and outputs, with configurable transforms in between, and
   * simple `start`/`stop` methods to control time-based animation execution.
   * If additional transforms are added, be sure to include them in
   * AnimatedMock.js as well.
   *
   * See https://reactnative.dev/docs/animated
   */
  var _default = exports.default = {
    /**
     * Standard value class for driving animations.  Typically initialized with
     * `new Animated.Value(0);`
     *
     * See https://reactnative.dev/docs/animated#value
     */
    Value: _AnimatedValue.default,
    /**
     * 2D value class for driving 2D animations, such as pan gestures.
     *
     * See https://reactnative.dev/docs/animatedvaluexy
     */
    ValueXY: _AnimatedValueXY.default,
    /**
     * Value class for driving color animations.
     */
    Color: _AnimatedColor.default,
    /**
     * Exported to use the Interpolation type in flow.
     *
     * See https://reactnative.dev/docs/animated#interpolation
     */
    Interpolation: _AnimatedInterpolation.default,
    /**
     * Exported for ease of type checking. All animated values derive from this
     * class.
     *
     * See https://reactnative.dev/docs/animated#node
     */
    Node: _AnimatedNode.default,
    /**
     * Animates a value from an initial velocity to zero based on a decay
     * coefficient.
     *
     * See https://reactnative.dev/docs/animated#decay
     */
    decay,
    /**
     * Animates a value along a timed easing curve. The Easing module has tons of
     * predefined curves, or you can use your own function.
     *
     * See https://reactnative.dev/docs/animated#timing
     */
    timing,
    /**
     * Animates a value according to an analytical spring model based on
     * damped harmonic oscillation.
     *
     * See https://reactnative.dev/docs/animated#spring
     */
    spring,
    /**
     * Creates a new Animated value composed from two Animated values added
     * together.
     *
     * See https://reactnative.dev/docs/animated#add
     */
    add,
    /**
     * Creates a new Animated value composed by subtracting the second Animated
     * value from the first Animated value.
     *
     * See https://reactnative.dev/docs/animated#subtract
     */
    subtract,
    /**
     * Creates a new Animated value composed by dividing the first Animated value
     * by the second Animated value.
     *
     * See https://reactnative.dev/docs/animated#divide
     */
    divide,
    /**
     * Creates a new Animated value composed from two Animated values multiplied
     * together.
     *
     * See https://reactnative.dev/docs/animated#multiply
     */
    multiply,
    /**
     * Creates a new Animated value that is the (non-negative) modulo of the
     * provided Animated value.
     *
     * See https://reactnative.dev/docs/animated#modulo
     */
    modulo,
    /**
     * Create a new Animated value that is limited between 2 values. It uses the
     * difference between the last value so even if the value is far from the
     * bounds it will start changing when the value starts getting closer again.
     *
     * See https://reactnative.dev/docs/animated#diffclamp
     */
    diffClamp,
    /**
     * Starts an animation after the given delay.
     *
     * See https://reactnative.dev/docs/animated#delay
     */
    delay,
    /**
     * Starts an array of animations in order, waiting for each to complete
     * before starting the next. If the current running animation is stopped, no
     * following animations will be started.
     *
     * See https://reactnative.dev/docs/animated#sequence
     */
    sequence,
    /**
     * Starts an array of animations all at the same time. By default, if one
     * of the animations is stopped, they will all be stopped. You can override
     * this with the `stopTogether` flag.
     *
     * See https://reactnative.dev/docs/animated#parallel
     */
    parallel,
    /**
     * Array of animations may run in parallel (overlap), but are started in
     * sequence with successive delays.  Nice for doing trailing effects.
     *
     * See https://reactnative.dev/docs/animated#stagger
     */
    stagger,
    /**
     * Loops a given animation continuously, so that each time it reaches the
     * end, it resets and begins again from the start.
     *
     * See https://reactnative.dev/docs/animated#loop
     */
    loop,
    /**
     * Takes an array of mappings and extracts values from each arg accordingly,
     * then calls `setValue` on the mapped outputs.
     *
     * See https://reactnative.dev/docs/animated#event
     */
    event,
    /**
     * Make any React component Animatable.  Used to create `Animated.View`, etc.
     *
     * See https://reactnative.dev/docs/animated#createanimatedcomponent
     */
    createAnimatedComponent: _createAnimatedComponent.default,
    /**
     * Imperative API to attach an animated value to an event on a view. Prefer
     * using `Animated.event` with `useNativeDrive: true` if possible.
     *
     * See https://reactnative.dev/docs/animated#attachnativeevent
     */
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    /**
     * Advanced imperative API for snooping on animated events that are passed in
     * through props. Use values directly where possible.
     *
     * See https://reactnative.dev/docs/animated#forkevent
     */
    forkEvent,
    unforkEvent,
    /**
     * Expose Event class, so it can be used as a type for type checkers.
     */
    Event: _AnimatedEvent.AnimatedEvent
  };
},193,[17,868,162,194,195,196,164,197,198,166,161,199,200,163,201,202,204,207,159,206],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\AnimatedImplementation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedWithChildren"));
  class AnimatedAddition extends _AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() + this._b.__getValue();
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'addition',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = exports.default = AnimatedAddition;
},194,[17,164,163,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedAddition.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  class AnimatedDiffClamp extends _AnimatedWithChildren.default {
    constructor(a, min, max) {
      super();
      this._a = a;
      this._min = min;
      this._max = max;
      this._value = this._lastValue = this._a.__getValue();
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __getValue() {
      var value = this._a.__getValue();
      var diff = value - this._lastValue;
      this._lastValue = value;
      this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
      return this._value;
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'diffclamp',
        input: this._a.__getNativeTag(),
        min: this._min,
        max: this._max
      };
    }
  }
  var _default = exports.default = AnimatedDiffClamp;
},195,[17,164,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedDiffClamp.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedNode"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[4], "./AnimatedWithChildren"));
  class AnimatedDivision extends _AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._warnedAboutDivideByZero = false;
      if (b === 0 || b instanceof _AnimatedNode.default && b.__getValue() === 0) {
        console.error('Detected potential division by zero in AnimatedDivision');
      }
      this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var a = this._a.__getValue();
      var b = this._b.__getValue();
      if (b === 0) {
        // Prevent spamming the console/LogBox
        if (!this._warnedAboutDivideByZero) {
          console.error('Detected division by zero in AnimatedDivision');
          this._warnedAboutDivideByZero = true;
        }
        // Passing infinity/NaN to Fabric will cause a native crash
        return 0;
      }
      this._warnedAboutDivideByZero = false;
      return a / b;
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'division',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = exports.default = AnimatedDivision;
},196,[17,164,166,163,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedDivision.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  class AnimatedModulo extends _AnimatedWithChildren.default {
    constructor(a, modulus) {
      super();
      this._a = a;
      this._modulus = modulus;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'modulus',
        input: this._a.__getNativeTag(),
        modulus: this._modulus
      };
    }
  }
  var _default = exports.default = AnimatedModulo;
},197,[17,164,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedModulo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedWithChildren"));
  class AnimatedMultiplication extends _AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() * this._b.__getValue();
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'multiplication',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = exports.default = AnimatedMultiplication;
},198,[17,164,163,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedMultiplication.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedInterpolation"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedWithChildren"));
  class AnimatedSubtraction extends _AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() - this._b.__getValue();
    }
    interpolate(config) {
      return new _AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'subtraction',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = exports.default = AnimatedSubtraction;
},199,[17,164,163,165],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedSubtraction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedValue"));
  var _AnimatedNode = _interopRequireDefault(require(_dependencyMap[3], "./AnimatedNode"));
  var _NativeAnimatedHelper = require(_dependencyMap[4], "../NativeAnimatedHelper");
  class AnimatedTracking extends _AnimatedNode.default {
    constructor(value, parent, animationClass, animationConfig, callback) {
      super();
      this._value = value;
      this._parent = parent;
      this._animationClass = animationClass;
      this._animationConfig = animationConfig;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(animationConfig);
      this._callback = callback;
      this.__attach();
    }
    __makeNative() {
      this.__isNative = true;
      this._parent.__makeNative();
      super.__makeNative();
      this._value.__makeNative();
    }
    __getValue() {
      return this._parent.__getValue();
    }
    __attach() {
      this._parent.__addChild(this);
      if (this._useNativeDriver) {
        // when the tracking starts we need to convert this node to a "native node"
        // so that the parent node will be made "native" too. This is necessary as
        // if we don't do this `update` method will get called. At that point it
        // may be too late as it would mean the JS driver has already started
        // updating node values
        this.__makeNative();
      }
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    update() {
      this._value.animate(new this._animationClass((0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._animationConfig), {}, {
        toValue: this._animationConfig.toValue.__getValue()
      })), this._callback);
    }
    __getNativeConfig() {
      var animation = new this._animationClass((0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._animationConfig), {}, {
        // remove toValue from the config as it's a ref to Animated.Value
        toValue: undefined
      }));
      var animationConfig = animation.__getNativeAnimationConfig();
      return {
        type: 'tracking',
        animationId: (0, _NativeAnimatedHelper.generateNewAnimationId)(),
        animationConfig,
        toValue: this._parent.__getNativeTag(),
        value: this._value.__getNativeTag()
      };
    }
  }
  var _default = exports.default = AnimatedTracking;
},200,[17,868,163,166,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedTracking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  var _uniqueId = 1;

  /**
   * 2D Value for driving 2D animations, such as pan gestures. Almost identical
   * API to normal `Animated.Value`, but multiplexed.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html
   */
  class AnimatedValueXY extends _AnimatedWithChildren.default {
    constructor(valueIn) {
      super();
      var value = valueIn || {
        x: 0,
        y: 0
      }; // fixme: shouldn't need `: any`
      if (typeof value.x === 'number' && typeof value.y === 'number') {
        this.x = new _AnimatedValue.default(value.x);
        this.y = new _AnimatedValue.default(value.y);
      } else {
        (0, _invariant.default)(value.x instanceof _AnimatedValue.default && value.y instanceof _AnimatedValue.default, 'AnimatedValueXY must be initialized with an object of numbers or ' + 'AnimatedValues.');
        this.x = value.x;
        this.y = value.y;
      }
      this._listeners = {};
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setvalue
     */
    setValue(value) {
      this.x.setValue(value.x);
      this.y.setValue(value.y);
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setoffset
     */
    setOffset(offset) {
      this.x.setOffset(offset.x);
      this.y.setOffset(offset.y);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#flattenoffset
     */
    flattenOffset() {
      this.x.flattenOffset();
      this.y.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#extractoffset
     */
    extractOffset() {
      this.x.extractOffset();
      this.y.extractOffset();
    }
    __getValue() {
      return {
        x: this.x.__getValue(),
        y: this.y.__getValue()
      };
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#resetanimation
     */
    resetAnimation(callback) {
      this.x.resetAnimation();
      this.y.resetAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#stopanimation
     */
    stopAnimation(callback) {
      this.x.stopAnimation();
      this.y.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        x: this.x.addListener(jointCallback),
        y: this.y.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removelistener
     */
    removeListener(id) {
      this.x.removeListener(this._listeners[id].x);
      this.y.removeListener(this._listeners[id].y);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removealllisteners
     */
    removeAllListeners() {
      this.x.removeAllListeners();
      this.y.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Converts `{x, y}` into `{left, top}` for use in style.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#getlayout
     */
    getLayout() {
      return {
        left: this.x,
        top: this.y
      };
    }

    /**
     * Converts `{x, y}` into a useable translation transform.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#gettranslatetransform
     */
    getTranslateTransform() {
      return [{
        translateX: this.x
      }, {
        translateY: this.y
      }];
    }
  }
  var _default = exports.default = AnimatedValueXY;
},201,[17,163,165,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedValueXY.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Animation = _interopRequireDefault(require(_dependencyMap[1], "./Animation"));
  var _NativeAnimatedHelper = require(_dependencyMap[2], "../NativeAnimatedHelper");
  class DecayAnimation extends _Animation.default {
    constructor(config) {
      var _config$deceleration, _config$isInteraction, _config$iterations;
      super();
      this._deceleration = (_config$deceleration = config.deceleration) !== null && _config$deceleration !== void 0 ? _config$deceleration : 0.998;
      this._velocity = config.velocity;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
    }
    __getNativeAnimationConfig() {
      return {
        type: 'decay',
        deceleration: this._deceleration,
        velocity: this._velocity,
        iterations: this.__iterations
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._lastValue = fromValue;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._startTime = Date.now();
      if (this._useNativeDriver) {
        this.__startNativeAnimation(animatedValue);
      } else {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    onUpdate() {
      var now = Date.now();
      var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));
      this._onUpdate(value);
      if (Math.abs(this._lastValue - value) < 0.1) {
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._lastValue = value;
      if (this.__active) {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = exports.default = DecayAnimation;
},202,[17,203,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\animations\\DecayAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[1], "../NativeAnimatedHelper"));
  var startNativeAnimationNextId = 1;

  // Important note: start() and stop() will only be called at most once.
  // Once an animation has been stopped or finished its course, it will
  // not be reused.
  class Animation {
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    stop() {
      if (this.__nativeId) {
        _NativeAnimatedHelper.default.API.stopAnimation(this.__nativeId);
      }
    }
    __getNativeAnimationConfig() {
      // Subclasses that have corresponding animation implementation done in native
      // should override this method
      throw new Error('This animation type cannot be offloaded to native');
    }
    // Helper function for subclasses to make sure onEnd is only called once.
    __debouncedOnEnd(result) {
      var onEnd = this.__onEnd;
      this.__onEnd = null;
      onEnd && onEnd(result);
    }
    __startNativeAnimation(animatedValue) {
      var startNativeAnimationWaitId = startNativeAnimationNextId + ":startAnimation";
      startNativeAnimationNextId += 1;
      _NativeAnimatedHelper.default.API.setWaitingForIdentifier(startNativeAnimationWaitId);
      try {
        var config = this.__getNativeAnimationConfig();
        animatedValue.__makeNative(config.platformConfig);
        this.__nativeId = _NativeAnimatedHelper.default.generateNewAnimationId();
        _NativeAnimatedHelper.default.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), config,
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.__debouncedOnEnd.bind(this));
      } catch (e) {
        throw e;
      } finally {
        _NativeAnimatedHelper.default.API.unsetWaitingForIdentifier(startNativeAnimationWaitId);
      }
    }
  }
  var _default = exports.default = Animation;
},203,[17,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\animations\\Animation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Animation = _interopRequireDefault(require(_dependencyMap[1], "./Animation"));
  var _SpringConfig = _interopRequireDefault(require(_dependencyMap[2], "../SpringConfig"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  var _NativeAnimatedHelper = require(_dependencyMap[4], "../NativeAnimatedHelper");
  var _AnimatedColor = _interopRequireDefault(require(_dependencyMap[5], "../nodes/AnimatedColor"));
  class SpringAnimation extends _Animation.default {
    constructor(config) {
      var _config$overshootClam, _config$restDisplacem, _config$restSpeedThre, _config$velocity, _config$velocity2, _config$delay, _config$isInteraction, _config$iterations;
      super();
      this._overshootClamping = (_config$overshootClam = config.overshootClamping) !== null && _config$overshootClam !== void 0 ? _config$overshootClam : false;
      this._restDisplacementThreshold = (_config$restDisplacem = config.restDisplacementThreshold) !== null && _config$restDisplacem !== void 0 ? _config$restDisplacem : 0.001;
      this._restSpeedThreshold = (_config$restSpeedThre = config.restSpeedThreshold) !== null && _config$restSpeedThre !== void 0 ? _config$restSpeedThre : 0.001;
      this._initialVelocity = (_config$velocity = config.velocity) !== null && _config$velocity !== void 0 ? _config$velocity : 0;
      this._lastVelocity = (_config$velocity2 = config.velocity) !== null && _config$velocity2 !== void 0 ? _config$velocity2 : 0;
      this._toValue = config.toValue;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        var _config$stiffness, _config$damping, _config$mass;
        (0, _invariant.default)(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        this._stiffness = (_config$stiffness = config.stiffness) !== null && _config$stiffness !== void 0 ? _config$stiffness : 100;
        this._damping = (_config$damping = config.damping) !== null && _config$damping !== void 0 ? _config$damping : 10;
        this._mass = (_config$mass = config.mass) !== null && _config$mass !== void 0 ? _config$mass : 1;
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        var _config$bounciness, _config$speed;
        // Convert the origami bounciness/speed values to stiffness/damping
        // We assume mass is 1.
        (0, _invariant.default)(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        var springConfig = _SpringConfig.default.fromBouncinessAndSpeed((_config$bounciness = config.bounciness) !== null && _config$bounciness !== void 0 ? _config$bounciness : 8, (_config$speed = config.speed) !== null && _config$speed !== void 0 ? _config$speed : 12);
        this._stiffness = springConfig.stiffness;
        this._damping = springConfig.damping;
        this._mass = 1;
      } else {
        var _config$tension, _config$friction;
        // Convert the origami tension/friction values to stiffness/damping
        // We assume mass is 1.
        var _springConfig = _SpringConfig.default.fromOrigamiTensionAndFriction((_config$tension = config.tension) !== null && _config$tension !== void 0 ? _config$tension : 40, (_config$friction = config.friction) !== null && _config$friction !== void 0 ? _config$friction : 7);
        this._stiffness = _springConfig.stiffness;
        this._damping = _springConfig.damping;
        this._mass = 1;
      }
      (0, _invariant.default)(this._stiffness > 0, 'Stiffness value must be greater than 0');
      (0, _invariant.default)(this._damping > 0, 'Damping value must be greater than 0');
      (0, _invariant.default)(this._mass > 0, 'Mass value must be greater than 0');
    }
    __getNativeAnimationConfig() {
      var _this$_initialVelocit;
      return {
        type: 'spring',
        overshootClamping: this._overshootClamping,
        restDisplacementThreshold: this._restDisplacementThreshold,
        restSpeedThreshold: this._restSpeedThreshold,
        stiffness: this._stiffness,
        damping: this._damping,
        mass: this._mass,
        initialVelocity: (_this$_initialVelocit = this._initialVelocity) !== null && _this$_initialVelocit !== void 0 ? _this$_initialVelocit : this._lastVelocity,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._startPosition = fromValue;
      this._lastPosition = this._startPosition;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._lastTime = Date.now();
      this._frameTime = 0.0;
      if (previousAnimation instanceof SpringAnimation) {
        var internalState = previousAnimation.getInternalState();
        this._lastPosition = internalState.lastPosition;
        this._lastVelocity = internalState.lastVelocity;
        // Set the initial velocity to the last velocity
        this._initialVelocity = this._lastVelocity;
        this._lastTime = internalState.lastTime;
      }
      var start = () => {
        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this.onUpdate();
        }
      };

      //  If this._delay is more than 0, we start after the timeout.
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    getInternalState() {
      return {
        lastPosition: this._lastPosition,
        lastVelocity: this._lastVelocity,
        lastTime: this._lastTime
      };
    }

    /**
     * This spring model is based off of a damped harmonic oscillator
     * (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
     *
     * We use the closed form of the second order differential equation:
     *
     * x'' + (2_0)x' + ^2x = 0
     *
     * where
     *    _0 = (k / m) (undamped angular frequency of the oscillator),
     *     = c / 2mk (damping ratio),
     *    c = damping constant
     *    k = stiffness
     *    m = mass
     *
     * The derivation of the closed form is described in detail here:
     * http://planetmath.org/sites/default/files/texpdf/39745.pdf
     *
     * This algorithm happens to match the algorithm used by CASpringAnimation,
     * a QuartzCore (iOS) API that creates spring animations.
     */
    onUpdate() {
      // If for some reason we lost a lot of frames (e.g. process large payload or
      // stopped in the debugger), we only advance by 4 frames worth of
      // computation and will continue on the next frame. It's better to have it
      // running at faster speed than jumping to the end.
      var MAX_STEPS = 64;
      var now = Date.now();
      if (now > this._lastTime + MAX_STEPS) {
        now = this._lastTime + MAX_STEPS;
      }
      var deltaTime = (now - this._lastTime) / 1000;
      this._frameTime += deltaTime;
      var c = this._damping;
      var m = this._mass;
      var k = this._stiffness;
      var v0 = -this._initialVelocity;
      var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
      var omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
      var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay
      var x0 = this._toValue - this._startPosition; // calculate the oscillation from x0 = 1 to x = 0

      var position = 0.0;
      var velocity = 0.0;
      var t = this._frameTime;
      if (zeta < 1) {
        // Under damped
        var envelope = Math.exp(-zeta * omega0 * t);
        position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
        // This looks crazy -- it's actually just the derivative of the
        // oscillation function
        velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
      } else {
        // Critically damped
        var _envelope = Math.exp(-omega0 * t);
        position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
        velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
      }
      this._lastTime = now;
      this._lastPosition = position;
      this._lastVelocity = velocity;
      this._onUpdate(position);
      if (!this.__active) {
        // a listener might have stopped us in _onUpdate
        return;
      }

      // Conditions for stopping the spring animation
      var isOvershooting = false;
      if (this._overshootClamping && this._stiffness !== 0) {
        if (this._startPosition < this._toValue) {
          isOvershooting = position > this._toValue;
        } else {
          isOvershooting = position < this._toValue;
        }
      }
      var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;
      var isDisplacement = true;
      if (this._stiffness !== 0) {
        isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
      }
      if (isOvershooting || isVelocity && isDisplacement) {
        if (this._stiffness !== 0) {
          // Ensure that we end up with a round value
          this._lastPosition = this._toValue;
          this._lastVelocity = 0;
          this._onUpdate(this._toValue);
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      // $FlowFixMe[method-unbinding] added when improving typing for this parameters
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = exports.default = SpringAnimation;
},204,[17,203,205,129,167,206],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\animations\\SpringAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }
  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }
  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }
  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }
    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }
    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }
    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }
    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }
    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }
    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }
    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }
    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }
  var _default = exports.default = {
    fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed
  };
},205,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\SpringConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[1], "./AnimatedValue"));
  var _AnimatedWithChildren = _interopRequireDefault(require(_dependencyMap[2], "./AnimatedWithChildren"));
  var _normalizeColors = _interopRequireDefault(require(_dependencyMap[3], "@react-native/normalize-colors"));
  var _NativeAnimatedHelper = _interopRequireDefault(require(_dependencyMap[4], "../NativeAnimatedHelper"));
  var NativeAnimatedAPI = _NativeAnimatedHelper.default.API;
  var defaultColor = {
    r: 0,
    g: 0,
    b: 0,
    a: 1.0
  };
  var _uniqueId = 1;
  var processColorObject = color => {
    return color;
  };

  /* eslint no-bitwise: 0 */
  function processColor(color) {
    if (color === undefined || color === null) {
      return null;
    }
    if (isRgbaValue(color)) {
      // $FlowIgnore[incompatible-cast] - Type is verified above
      return color;
    }
    var normalizedColor = (0, _normalizeColors.default)(
    // $FlowIgnore[incompatible-cast] - Type is verified above
    color);
    if (normalizedColor === undefined || normalizedColor === null) {
      return null;
    }
    if (typeof normalizedColor === 'object') {
      var processedColorObj = processColorObject(normalizedColor);
      if (processedColorObj != null) {
        return processedColorObj;
      }
    } else if (typeof normalizedColor === 'number') {
      var r = (normalizedColor & 0xff000000) >>> 24;
      var g = (normalizedColor & 0x00ff0000) >>> 16;
      var b = (normalizedColor & 0x0000ff00) >>> 8;
      var a = (normalizedColor & 0x000000ff) / 255;
      return {
        r,
        g,
        b,
        a
      };
    }
    return null;
  }
  function isRgbaValue(value) {
    return value && typeof value.r === 'number' && typeof value.g === 'number' && typeof value.b === 'number' && typeof value.a === 'number';
  }
  function isRgbaAnimatedValue(value) {
    return value && value.r instanceof _AnimatedValue.default && value.g instanceof _AnimatedValue.default && value.b instanceof _AnimatedValue.default && value.a instanceof _AnimatedValue.default;
  }
  class AnimatedColor extends _AnimatedWithChildren.default {
    constructor(valueIn, config) {
      super();
      this._listeners = {};
      var value = valueIn !== null && valueIn !== void 0 ? valueIn : defaultColor;
      if (isRgbaAnimatedValue(value)) {
        // $FlowIgnore[incompatible-cast] - Type is verified above
        var rgbaAnimatedValue = value;
        this.r = rgbaAnimatedValue.r;
        this.g = rgbaAnimatedValue.g;
        this.b = rgbaAnimatedValue.b;
        this.a = rgbaAnimatedValue.a;
      } else {
        var _processColor;
        var processedColor =
        // $FlowIgnore[incompatible-cast] - Type is verified above
        (_processColor = processColor(value)) !== null && _processColor !== void 0 ? _processColor : defaultColor;
        var initColor = defaultColor;
        if (isRgbaValue(processedColor)) {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          initColor = processedColor;
        } else {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          this.nativeColor = processedColor;
        }
        this.r = new _AnimatedValue.default(initColor.r);
        this.g = new _AnimatedValue.default(initColor.g);
        this.b = new _AnimatedValue.default(initColor.b);
        this.a = new _AnimatedValue.default(initColor.a);
      }
      if (this.nativeColor || config && config.useNativeDriver) {
        this.__makeNative();
      }
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     */
    setValue(value) {
      var _processColor2;
      var shouldUpdateNodeConfig = false;
      if (this.__isNative) {
        var nativeTag = this.__getNativeTag();
        NativeAnimatedAPI.setWaitingForIdentifier(nativeTag.toString());
      }
      var processedColor = (_processColor2 = processColor(value)) !== null && _processColor2 !== void 0 ? _processColor2 : defaultColor;
      if (isRgbaValue(processedColor)) {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var rgbaValue = processedColor;
        this.r.setValue(rgbaValue.r);
        this.g.setValue(rgbaValue.g);
        this.b.setValue(rgbaValue.b);
        this.a.setValue(rgbaValue.a);
        if (this.nativeColor != null) {
          this.nativeColor = null;
          shouldUpdateNodeConfig = true;
        }
      } else {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var nativeColor = processedColor;
        if (this.nativeColor !== nativeColor) {
          this.nativeColor = nativeColor;
          shouldUpdateNodeConfig = true;
        }
      }
      if (this.__isNative) {
        var _nativeTag = this.__getNativeTag();
        if (shouldUpdateNodeConfig) {
          NativeAnimatedAPI.updateAnimatedNodeConfig(_nativeTag, this.__getNativeConfig());
        }
        NativeAnimatedAPI.unsetWaitingForIdentifier(_nativeTag.toString());
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     */
    setOffset(offset) {
      this.r.setOffset(offset.r);
      this.g.setOffset(offset.g);
      this.b.setOffset(offset.b);
      this.a.setOffset(offset.a);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     */
    flattenOffset() {
      this.r.flattenOffset();
      this.g.flattenOffset();
      this.b.flattenOffset();
      this.a.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     */
    extractOffset() {
      this.r.extractOffset();
      this.g.extractOffset();
      this.b.extractOffset();
      this.a.extractOffset();
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        r: this.r.addListener(jointCallback),
        g: this.g.addListener(jointCallback),
        b: this.b.addListener(jointCallback),
        a: this.a.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     */
    removeListener(id) {
      this.r.removeListener(this._listeners[id].r);
      this.g.removeListener(this._listeners[id].g);
      this.b.removeListener(this._listeners[id].b);
      this.a.removeListener(this._listeners[id].a);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     */
    removeAllListeners() {
      this.r.removeAllListeners();
      this.g.removeAllListeners();
      this.b.removeAllListeners();
      this.a.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     */
    stopAnimation(callback) {
      this.r.stopAnimation();
      this.g.stopAnimation();
      this.b.stopAnimation();
      this.a.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any animation and resets the value to its original.
     */
    resetAnimation(callback) {
      this.r.resetAnimation();
      this.g.resetAnimation();
      this.b.resetAnimation();
      this.a.resetAnimation();
      callback && callback(this.__getValue());
    }
    __getValue() {
      if (this.nativeColor != null) {
        return this.nativeColor;
      } else {
        return "rgba(" + this.r.__getValue() + ", " + this.g.__getValue() + ", " + this.b.__getValue() + ", " + this.a.__getValue() + ")";
      }
    }
    __attach() {
      this.r.__addChild(this);
      this.g.__addChild(this);
      this.b.__addChild(this);
      this.a.__addChild(this);
      super.__attach();
    }
    __detach() {
      this.r.__removeChild(this);
      this.g.__removeChild(this);
      this.b.__removeChild(this);
      this.a.__removeChild(this);
      super.__detach();
    }
    __makeNative(platformConfig) {
      this.r.__makeNative(platformConfig);
      this.g.__makeNative(platformConfig);
      this.b.__makeNative(platformConfig);
      this.a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getNativeConfig() {
      return {
        type: 'color',
        r: this.r.__getNativeTag(),
        g: this.g.__getNativeTag(),
        b: this.b.__getNativeTag(),
        a: this.a.__getNativeTag(),
        nativeColor: this.nativeColor
      };
    }
  }
  exports.default = AnimatedColor;
},206,[17,163,165,38,167],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\nodes\\AnimatedColor.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AnimatedValue = _interopRequireDefault(require(_dependencyMap[1], "../nodes/AnimatedValue"));
  var _AnimatedValueXY = _interopRequireDefault(require(_dependencyMap[2], "../nodes/AnimatedValueXY"));
  var _AnimatedInterpolation = _interopRequireDefault(require(_dependencyMap[3], "../nodes/AnimatedInterpolation"));
  var _Easing = _interopRequireDefault(require(_dependencyMap[4], "../../../../exports/Easing"));
  var _Animation = _interopRequireDefault(require(_dependencyMap[5], "./Animation"));
  var _NativeAnimatedHelper = require(_dependencyMap[6], "../NativeAnimatedHelper");
  var _AnimatedColor = _interopRequireDefault(require(_dependencyMap[7], "../nodes/AnimatedColor"));
  var _easeInOut;
  function easeInOut() {
    if (!_easeInOut) {
      _easeInOut = _Easing.default.inOut(_Easing.default.ease);
    }
    return _easeInOut;
  }
  class TimingAnimation extends _Animation.default {
    constructor(config) {
      var _config$easing, _config$duration, _config$delay, _config$iterations, _config$isInteraction;
      super();
      this._toValue = config.toValue;
      this._easing = (_config$easing = config.easing) !== null && _config$easing !== void 0 ? _config$easing : easeInOut();
      this._duration = (_config$duration = config.duration) !== null && _config$duration !== void 0 ? _config$duration : 500;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
    }
    __getNativeAnimationConfig() {
      var frameDuration = 1000.0 / 60.0;
      var frames = [];
      var numFrames = Math.round(this._duration / frameDuration);
      for (var frame = 0; frame < numFrames; frame++) {
        frames.push(this._easing(frame / numFrames));
      }
      frames.push(this._easing(1));
      return {
        type: 'frames',
        frames,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      var start = () => {
        // Animations that sometimes have 0 duration and sometimes do not
        // still need to use the native driver when duration is 0 so as to
        // not cause intermixed JS and native animations.
        if (this._duration === 0 && !this._useNativeDriver) {
          this._onUpdate(this._toValue);
          this.__debouncedOnEnd({
            finished: true
          });
        } else {
          this._startTime = Date.now();
          if (this._useNativeDriver) {
            this.__startNativeAnimation(animatedValue);
          } else {
            this._animationFrame = requestAnimationFrame(
            // $FlowFixMe[method-unbinding] added when improving typing for this parameters
            this.onUpdate.bind(this));
          }
        }
      };
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    onUpdate() {
      var now = Date.now();
      if (now >= this._startTime + this._duration) {
        if (this._duration === 0) {
          this._onUpdate(this._toValue);
        } else {
          this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));
      if (this.__active) {
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = exports.default = TimingAnimation;
},207,[17,163,201,164,208,203,167,206],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\animations\\TimingAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Easing = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/Animated/Easing"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  var _default = exports.default = _Easing.default;
},208,[17,209],"node_modules\\react-native-web\\dist\\exports\\Easing\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _bezier2 = _interopRequireDefault(require(_dependencyMap[1], "./bezier"));
  var ease;

  /**
   * The `Easing` module implements common easing functions. This module is used
   * by [Animate.timing()](docs/animate.html#timing) to convey physically
   * believable motion in animations.
   *
   * You can find a visualization of some common easing functions at
   * http://easings.net/
   *
   * ### Predefined animations
   *
   * The `Easing` module provides several predefined animations through the
   * following methods:
   *
   * - [`back`](docs/easing.html#back) provides a simple animation where the
   *   object goes slightly back before moving forward
   * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
   * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
   * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
   *
   * ### Standard functions
   *
   * Three standard easing functions are provided:
   *
   * - [`linear`](docs/easing.html#linear)
   * - [`quad`](docs/easing.html#quad)
   * - [`cubic`](docs/easing.html#cubic)
   *
   * The [`poly`](docs/easing.html#poly) function can be used to implement
   * quartic, quintic, and other higher power functions.
   *
   * ### Additional functions
   *
   * Additional mathematical functions are provided by the following methods:
   *
   * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
   * - [`circle`](docs/easing.html#circle) provides a circular function
   * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
   * - [`exp`](docs/easing.html#exp) provides an exponential function
   *
   * The following helpers are used to modify other easing functions.
   *
   * - [`in`](docs/easing.html#in) runs an easing function forwards
   * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
   * - [`out`](docs/easing.html#out) runs an easing function backwards
   */
  class Easing {
    /**
     * A stepping function, returns 1 for any positive value of `n`.
     */
    static step0(n) {
      return n > 0 ? 1 : 0;
    }

    /**
     * A stepping function, returns 1 if `n` is greater than or equal to 1.
     */
    static step1(n) {
      return n >= 1 ? 1 : 0;
    }

    /**
     * A linear function, `f(t) = t`. Position correlates to elapsed time one to
     * one.
     *
     * http://cubic-bezier.com/#0,0,1,1
     */
    static linear(t) {
      return t;
    }

    /**
     * A simple inertial interaction, similar to an object slowly accelerating to
     * speed.
     *
     * http://cubic-bezier.com/#.42,0,1,1
     */
    static ease(t) {
      if (!ease) {
        ease = Easing.bezier(0.42, 0, 1, 1);
      }
      return ease(t);
    }

    /**
     * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
     * time.
     *
     * http://easings.net/#easeInQuad
     */
    static quad(t) {
      return t * t;
    }

    /**
     * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
     * time.
     *
     * http://easings.net/#easeInCubic
     */
    static cubic(t) {
      return t * t * t;
    }

    /**
     * A power function. Position is equal to the Nth power of elapsed time.
     *
     * n = 4: http://easings.net/#easeInQuart
     * n = 5: http://easings.net/#easeInQuint
     */
    static poly(n) {
      return t => Math.pow(t, n);
    }

    /**
     * A sinusoidal function.
     *
     * http://easings.net/#easeInSine
     */
    static sin(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    }

    /**
     * A circular function.
     *
     * http://easings.net/#easeInCirc
     */
    static circle(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    /**
     * An exponential function.
     *
     * http://easings.net/#easeInExpo
     */
    static exp(t) {
      return Math.pow(2, 10 * (t - 1));
    }

    /**
     * A simple elastic interaction, similar to a spring oscillating back and
     * forth.
     *
     * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
     * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
     * times.
     *
     * http://easings.net/#easeInElastic
     */
    static elastic(bounciness) {
      if (bounciness === void 0) {
        bounciness = 1;
      }
      var p = bounciness * Math.PI;
      return t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
    }

    /**
     * Use with `Animated.parallel()` to create a simple effect where the object
     * animates back slightly as the animation starts.
     *
     * Wolfram Plot:
     *
     * - http://tiny.cc/back_default (s = 1.70158, default)
     */
    static back(s) {
      if (s === void 0) {
        s = 1.70158;
      }
      return t => t * t * ((s + 1) * t - s);
    }

    /**
     * Provides a simple bouncing effect.
     *
     * http://easings.net/#easeInBounce
     */
    static bounce(t) {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      }
      if (t < 2 / 2.75) {
        var _t = t - 1.5 / 2.75;
        return 7.5625 * _t * _t + 0.75;
      }
      if (t < 2.5 / 2.75) {
        var _t2 = t - 2.25 / 2.75;
        return 7.5625 * _t2 * _t2 + 0.9375;
      }
      var t2 = t - 2.625 / 2.75;
      return 7.5625 * t2 * t2 + 0.984375;
    }

    /**
     * Provides a cubic bezier curve, equivalent to CSS Transitions'
     * `transition-timing-function`.
     *
     * A useful tool to visualize cubic bezier curves can be found at
     * http://cubic-bezier.com/
     */
    static bezier(x1, y1, x2, y2) {
      return (0, _bezier2.default)(x1, y1, x2, y2);
    }

    /**
     * Runs an easing function forwards.
     */
    static in(easing) {
      return easing;
    }

    /**
     * Runs an easing function backwards.
     */
    static out(easing) {
      return t => 1 - easing(1 - t);
    }

    /**
     * Makes any easing function symmetrical. The easing function will run
     * forwards for half of the duration, then backwards for the rest of the
     * duration.
     */
    static inOut(easing) {
      return t => {
        if (t < 0.5) {
          return easing(t * 2) / 2;
        }
        return 1 - easing((1 - t) * 2) / 2;
      };
    }
  }
  var _default = exports.default = Easing;
},209,[17,210],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\Easing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Portions Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * BezierEasing - use bezier curve for transition easing function
   * https://github.com/gre/bezier-easing
   * @copyright 2014-2015 Gatan Renaudeau. MIT License.
   */

  'use strict';

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = bezier;
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';
  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }
  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }
  function C(aA1) {
    return 3.0 * aA1;
  }

  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }
  function binarySubdivide(aX, _aA, _aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0,
      aA = _aA,
      aB = _aB;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }
  function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
    var aGuessT = _aGuessT;
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) {
        return aGuessT;
      }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }
  function bezier(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }
    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }
    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x; // linear
      }
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) {
        return 0;
      }
      if (x === 1) {
        return 1;
      }
      return calcBezier(getTForX(x), mY1, mY2);
    };
  }
  ;
},210,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\Animated\\bezier.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../../modules/canUseDom"));
  function getQuery() {
    return _canUseDom.default && window.matchMedia != null ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  }
  var query = getQuery();
  var listenerMapping = new WeakMap();
  var Appearance = {
    getColorScheme() {
      return query && query.matches ? 'dark' : 'light';
    },
    addChangeListener(listener) {
      var mappedListener = listenerMapping.get(listener);
      if (!mappedListener) {
        mappedListener = _ref => {
          var matches = _ref.matches;
          listener({
            colorScheme: matches ? 'dark' : 'light'
          });
        };
        listenerMapping.set(listener, mappedListener);
      }
      if (query) {
        query.addListener(mappedListener);
      }
      function remove() {
        var mappedListener = listenerMapping.get(listener);
        if (query && mappedListener) {
          query.removeListener(mappedListener);
        }
        listenerMapping.delete(listener);
      }
      return {
        remove
      };
    }
  };
  var _default = exports.default = Appearance;
},211,[17,39],"node_modules\\react-native-web\\dist\\exports\\Appearance\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[2], "fbjs/lib/invariant"));
  var _unmountComponentAtNode = _interopRequireDefault(require(_dependencyMap[3], "../unmountComponentAtNode"));
  var _renderApplication = _interopRequireWildcard(require(_dependencyMap[4], "./renderApplication"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var emptyObject = {};
  var runnables = {};
  var componentProviderInstrumentationHook = component => component();
  var wrapperComponentProvider;

  /**
   * `AppRegistry` is the JS entry point to running all React Native apps.
   */
  class AppRegistry {
    static getAppKeys() {
      return Object.keys(runnables);
    }
    static getApplication(appKey, appParameters) {
      (0, _invariant.default)(runnables[appKey] && runnables[appKey].getApplication, "Application " + appKey + " has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].getApplication(appParameters);
    }
    static registerComponent(appKey, componentProvider) {
      runnables[appKey] = {
        getApplication: appParameters => (0, _renderApplication.getApplication)(componentProviderInstrumentationHook(componentProvider), appParameters ? appParameters.initialProps : emptyObject, wrapperComponentProvider && wrapperComponentProvider(appParameters)),
        run: appParameters => (0, _renderApplication.default)(componentProviderInstrumentationHook(componentProvider), wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.callback, {
          hydrate: appParameters.hydrate || false,
          initialProps: appParameters.initialProps || emptyObject,
          mode: appParameters.mode || 'concurrent',
          rootTag: appParameters.rootTag
        })
      };
      return appKey;
    }
    static registerConfig(config) {
      config.forEach(_ref => {
        var appKey = _ref.appKey,
          component = _ref.component,
          run = _ref.run;
        if (run) {
          AppRegistry.registerRunnable(appKey, run);
        } else {
          (0, _invariant.default)(component, 'No component provider passed in');
          AppRegistry.registerComponent(appKey, component);
        }
      });
    }

    // TODO: fix style sheet creation when using this method
    static registerRunnable(appKey, run) {
      runnables[appKey] = {
        run
      };
      return appKey;
    }
    static runApplication(appKey, appParameters) {
      var isDevelopment = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
      if (isDevelopment) {
        var params = (0, _objectSpread2.default)({}, appParameters);
        params.rootTag = "#" + params.rootTag.id;
        console.log("Running application \"" + appKey + "\" with appParams:\n", params, "\nDevelopment-level warnings: " + (isDevelopment ? 'ON' : 'OFF') + "." + ("\nPerformance optimizations: " + (isDevelopment ? 'OFF' : 'ON') + "."));
      }
      (0, _invariant.default)(runnables[appKey] && runnables[appKey].run, "Application \"" + appKey + "\" has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].run(appParameters);
    }
    static setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    }
    static setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    }
    static unmountApplicationComponentAtRootTag(rootTag) {
      (0, _unmountComponentAtNode.default)(rootTag);
    }
  }
  exports.default = AppRegistry;
},212,[17,868,129,95,213],"node_modules\\react-native-web\\dist\\exports\\AppRegistry\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = renderApplication;
  exports.getApplication = getApplication;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _AppContainer = _interopRequireDefault(require(_dependencyMap[2], "./AppContainer"));
  var _invariant = _interopRequireDefault(require(_dependencyMap[3], "fbjs/lib/invariant"));
  var _render = _interopRequireWildcard(require(_dependencyMap[4], "../render"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../StyleSheet"));
  var _react = _interopRequireDefault(require(_dependencyMap[6], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function renderApplication(RootComponent, WrapperComponent, callback, options) {
    var shouldHydrate = options.hydrate,
      initialProps = options.initialProps,
      rootTag = options.rootTag;
    var renderFn = shouldHydrate ? _render.hydrate : _render.default;
    (0, _invariant.default)(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
    return renderFn(/*#__PURE__*/_react.default.createElement(_AppContainer.default, {
      WrapperComponent: WrapperComponent,
      ref: callback,
      rootTag: rootTag
    }, /*#__PURE__*/_react.default.createElement(RootComponent, initialProps)), rootTag);
  }
  function getApplication(RootComponent, initialProps, WrapperComponent) {
    var element = /*#__PURE__*/_react.default.createElement(_AppContainer.default, {
      WrapperComponent: WrapperComponent,
      rootTag: {}
    }, /*#__PURE__*/_react.default.createElement(RootComponent, initialProps));
    // Don't escape CSS text
    var getStyleElement = props => {
      var sheet = _StyleSheet.default.getSheet();
      return /*#__PURE__*/_react.default.createElement("style", (0, _extends2.default)({}, props, {
        dangerouslySetInnerHTML: {
          __html: sheet.textContent
        },
        id: sheet.id
      }));
    };
    return {
      element,
      getStyleElement
    };
  }
},213,[17,888,214,129,88,30,3],"node_modules\\react-native-web\\dist\\exports\\AppRegistry\\renderApplication.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  // NOTE(EvanBacon): `react-native-web` adds a extra `div`s around the root HTML, these
  // make static rendering much harder as we expect the root element to be `<html>`.
  // This resolution will alias to a simple in-out component to avoid the extra HTML.
  function AppContainer({
    children
  }) {
    return children;
  }
  _c = AppContainer;
  if (process.env.NODE_ENV !== 'production') {
    AppContainer.displayName = 'AppContainer';
  }
  var _default = exports.default = AppContainer;
  var _c;
  $RefreshReg$(_c, "AppContainer");
},214,[],"\u0000shim:react-native-web\\dist\\exports\\AppRegistry\\AppContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  var _EventEmitter = _interopRequireDefault(require(_dependencyMap[2], "../../vendor/react-native/vendor/emitter/EventEmitter"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[3], "../../modules/canUseDom"));
  // Android 4.4 browser
  var isPrefixed = _canUseDom.default && !document.hasOwnProperty('hidden') && document.hasOwnProperty('webkitHidden');
  var EVENT_TYPES = ['change', 'memoryWarning'];
  var VISIBILITY_CHANGE_EVENT = isPrefixed ? 'webkitvisibilitychange' : 'visibilitychange';
  var VISIBILITY_STATE_PROPERTY = isPrefixed ? 'webkitVisibilityState' : 'visibilityState';
  var AppStates = {
    BACKGROUND: 'background',
    ACTIVE: 'active'
  };
  var changeEmitter = null;
  class AppState {
    static get currentState() {
      if (!AppState.isAvailable) {
        return AppStates.ACTIVE;
      }
      switch (document[VISIBILITY_STATE_PROPERTY]) {
        case 'hidden':
        case 'prerender':
        case 'unloaded':
          return AppStates.BACKGROUND;
        default:
          return AppStates.ACTIVE;
      }
    }
    static addEventListener(type, handler) {
      if (AppState.isAvailable) {
        (0, _invariant.default)(EVENT_TYPES.indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);
        if (type === 'change') {
          if (!changeEmitter) {
            changeEmitter = new _EventEmitter.default();
            document.addEventListener(VISIBILITY_CHANGE_EVENT, () => {
              if (changeEmitter) {
                changeEmitter.emit('change', AppState.currentState);
              }
            }, false);
          }
          return changeEmitter.addListener(type, handler);
        }
      }
    }
  }
  exports.default = AppState;
  AppState.isAvailable = _canUseDom.default && !!document[VISIBILITY_STATE_PROPERTY];
},215,[17,129,145,39],"node_modules\\react-native-web\\dist\\exports\\AppState\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function emptyFunction() {}
  var BackHandler = {
    exitApp: emptyFunction,
    addEventListener: () => ({
      remove: emptyFunction
    }),
    removeEventListener: emptyFunction
  };
  var _default = exports.default = BackHandler;
},216,[],"\u0000shim:react-native-web\\dist\\exports\\BackHandler\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var clipboardAvailable;
  class Clipboard {
    static isAvailable() {
      if (clipboardAvailable === undefined) {
        clipboardAvailable = typeof document.queryCommandSupported === 'function' && document.queryCommandSupported('copy');
      }
      return clipboardAvailable;
    }
    static getString() {
      return Promise.resolve('');
    }
    static setString(text) {
      var success = false;
      var body = document.body;
      if (body) {
        // add the text to a hidden node
        var node = document.createElement('span');
        node.textContent = text;
        node.style.opacity = '0';
        node.style.position = 'absolute';
        node.style.whiteSpace = 'pre-wrap';
        node.style.userSelect = 'auto';
        body.appendChild(node);

        // select the text
        var selection = window.getSelection();
        selection.removeAllRanges();
        var range = document.createRange();
        range.selectNodeContents(node);
        selection.addRange(range);

        // attempt to copy
        try {
          document.execCommand('copy');
          success = true;
        } catch (e) {}

        // remove selection and node
        selection.removeAllRanges();
        body.removeChild(node);
      }
      return success;
    }
  }
  exports.default = Clipboard;
},217,[],"node_modules\\react-native-web\\dist\\exports\\Clipboard\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var I18nManager = {
    allowRTL() {
      return;
    },
    forceRTL() {
      return;
    },
    getConstants() {
      return {
        isRTL: false
      };
    }
  };
  var _default = exports.default = I18nManager;
},218,[],"node_modules\\react-native-web\\dist\\exports\\I18nManager\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _dismissKeyboard = _interopRequireDefault(require(_dependencyMap[1], "../../modules/dismissKeyboard"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // in the future we can use https://github.com/w3c/virtual-keyboard
  var Keyboard = {
    isVisible() {
      return false;
    },
    addListener() {
      return {
        remove: () => {}
      };
    },
    dismiss() {
      (0, _dismissKeyboard.default)();
    },
    removeAllListeners() {},
    removeListener() {}
  };
  var _default = exports.default = Keyboard;
},219,[17,137],"node_modules\\react-native-web\\dist\\exports\\Keyboard\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _LayoutAnimation = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/LayoutAnimation"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  var _default = exports.default = _LayoutAnimation.default;
},220,[17,221],"node_modules\\react-native-web\\dist\\exports\\LayoutAnimation\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "../../../exports/Platform"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[2], "../../../exports/UIManager"));
  var __DEV__ = process.env.NODE_ENV !== 'production';
  function configureNext(config, onAnimationDidEnd) {
    if (!_Platform.default.isTesting) {
      _UIManager.default.configureNextLayoutAnimation(config, onAnimationDidEnd !== null && onAnimationDidEnd !== void 0 ? onAnimationDidEnd : function () {}, function () {} /* unused onError */);
    }
  }
  function create(duration, type, property) {
    return {
      duration,
      create: {
        type,
        property
      },
      update: {
        type
      },
      delete: {
        type,
        property
      }
    };
  }
  var Presets = {
    easeInEaseOut: create(300, 'easeInEaseOut', 'opacity'),
    linear: create(500, 'linear', 'opacity'),
    spring: {
      duration: 700,
      create: {
        type: 'linear',
        property: 'opacity'
      },
      update: {
        type: 'spring',
        springDamping: 0.4
      },
      delete: {
        type: 'linear',
        property: 'opacity'
      }
    }
  };

  /**
   * Automatically animates views to their new positions when the
   * next layout happens.
   *
   * A common way to use this API is to call it before calling `setState`.
   *
   * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
   *
   *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
   */
  var LayoutAnimation = {
    /**
     * Schedules an animation to happen on the next layout.
     *
     * @param config Specifies animation properties:
     *
     *   - `duration` in milliseconds
     *   - `create`, `AnimationConfig` for animating in new views
     *   - `update`, `AnimationConfig` for animating views that have been updated
     *
     * @param onAnimationDidEnd Called when the animation finished.
     * Only supported on iOS.
     * @param onError Called on error. Only supported on iOS.
     */
    configureNext,
    /**
     * Helper for creating a config for `configureNext`.
     */
    create,
    Types: Object.freeze({
      spring: 'spring',
      linear: 'linear',
      easeInEaseOut: 'easeInEaseOut',
      easeIn: 'easeIn',
      easeOut: 'easeOut',
      keyboard: 'keyboard'
    }),
    Properties: Object.freeze({
      opacity: 'opacity',
      scaleX: 'scaleX',
      scaleY: 'scaleY',
      scaleXY: 'scaleXY'
    }),
    checkConfig() {
      console.error('LayoutAnimation.checkConfig(...) has been disabled.');
    },
    Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  var _default = exports.default = LayoutAnimation;
},221,[17,106,97],"node_modules\\react-native-web\\dist\\vendor\\react-native\\LayoutAnimation\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[2], "../../modules/canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var initialURL = _canUseDom.default ? window.location.href : '';
  class Linking {
    constructor() {
      this._eventCallbacks = {};
    }
    /**
     * An object mapping of event name
     * and all the callbacks subscribing to it
     */
    _dispatchEvent(event) {
      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }
      var listeners = this._eventCallbacks[event];
      if (listeners != null && Array.isArray(listeners)) {
        listeners.map(listener => {
          listener(...data);
        });
      }
    }

    /**
     * Adds a event listener for the specified event. The callback will be called when the
     * said event is dispatched.
     */
    addEventListener(eventType, callback) {
      var _this = this;
      if (!_this._eventCallbacks[eventType]) {
        _this._eventCallbacks[eventType] = [callback];
      }
      _this._eventCallbacks[eventType].push(callback);
      return {
        remove() {
          var callbacks = _this._eventCallbacks[eventType];
          var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
          _this._eventCallbacks[eventType] = filteredCallbacks;
        }
      };
    }

    /**
     * Removes a previously added event listener for the specified event. The callback must
     * be the same object as the one passed to `addEventListener`.
     */
    removeEventListener(eventType, callback) {
      console.error("Linking.removeEventListener('" + eventType + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `Linking.addEventListener`.');
      var callbacks = this._eventCallbacks[eventType];
      var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
      this._eventCallbacks[eventType] = filteredCallbacks;
    }
    canOpenURL() {
      return Promise.resolve(true);
    }
    getInitialURL() {
      return Promise.resolve(initialURL);
    }

    /**
     * Try to open the given url in a secure fashion. The method returns a Promise object.
     * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
     * If the url opens, the promise is resolved. If not, the promise is rejected.
     * Dispatches the `onOpen` event if `url` is opened successfully.
     */
    openURL(url, target) {
      if (arguments.length === 1) {
        target = '_blank';
      }
      try {
        open(url, target);
        this._dispatchEvent('onOpen', url);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _validateURL(url) {
      (0, _invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
      (0, _invariant.default)(url, 'Invalid URL: cannot be empty');
    }
  }
  var open = (url, target) => {
    if (_canUseDom.default) {
      var urlToOpen = new URL(url, window.location).toString();
      if (urlToOpen.indexOf('tel:') === 0) {
        window.location = urlToOpen;
      } else {
        window.open(urlToOpen, target, 'noopener');
      }
    }
  };
  var _default = exports.default = new Linking();
},222,[17,129,39],"node_modules\\react-native-web\\dist\\exports\\Linking\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/EventEmitter/NativeEventEmitter"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  var _default = exports.default = _NativeEventEmitter.default;
},223,[17,171],"node_modules\\react-native-web\\dist\\exports\\NativeEventEmitter\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _PanResponder = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/PanResponder"));
  var _default = exports.default = _PanResponder.default;
},224,[17,225],"node_modules\\react-native-web\\dist\\exports\\PanResponder\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _InteractionManager = _interopRequireDefault(require(_dependencyMap[1], "../../../exports/InteractionManager"));
  var _TouchHistoryMath = _interopRequireDefault(require(_dependencyMap[2], "../TouchHistoryMath"));
  var currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter;
  var currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter;
  var previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter;
  var previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;
  var currentCentroidX = _TouchHistoryMath.default.currentCentroidX;
  var currentCentroidY = _TouchHistoryMath.default.currentCentroidY;

  /**
   * `PanResponder` reconciles several touches into a single gesture. It makes
   * single-touch gestures resilient to extra touches, and can be used to
   * recognize simple multi-touch gestures.
   *
   * By default, `PanResponder` holds an `InteractionManager` handle to block
   * long-running JS events from interrupting active gestures.
   *
   * It provides a predictable wrapper of the responder handlers provided by the
   * [gesture responder system](docs/gesture-responder-system.html).
   * For each handler, it provides a new `gestureState` object alongside the
   * native event object:
   *
   * ```
   * onPanResponderMove: (event, gestureState) => {}
   * ```
   *
   * A native event is a synthetic touch event with the following form:
   *
   *  - `nativeEvent`
   *      + `changedTouches` - Array of all touch events that have changed since the last event
   *      + `identifier` - The ID of the touch
   *      + `locationX` - The X position of the touch, relative to the element
   *      + `locationY` - The Y position of the touch, relative to the element
   *      + `pageX` - The X position of the touch, relative to the root element
   *      + `pageY` - The Y position of the touch, relative to the root element
   *      + `target` - The node id of the element receiving the touch event
   *      + `timestamp` - A time identifier for the touch, useful for velocity calculation
   *      + `touches` - Array of all current touches on the screen
   *
   * A `gestureState` object has the following:
   *
   *  - `stateID` - ID of the gestureState- persisted as long as there at least
   *     one touch on screen
   *  - `moveX` - the latest screen coordinates of the recently-moved touch
   *  - `moveY` - the latest screen coordinates of the recently-moved touch
   *  - `x0` - the screen coordinates of the responder grant
   *  - `y0` - the screen coordinates of the responder grant
   *  - `dx` - accumulated distance of the gesture since the touch started
   *  - `dy` - accumulated distance of the gesture since the touch started
   *  - `vx` - current velocity of the gesture
   *  - `vy` - current velocity of the gesture
   *  - `numberActiveTouches` - Number of touches currently on screen
   *
   * ### Basic Usage
   *
   * ```
   *   componentWillMount: function() {
   *     this._panResponder = PanResponder.create({
   *       // Ask to be the responder:
   *       onStartShouldSetPanResponder: (evt, gestureState) => true,
   *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponder: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
   *
   *       onPanResponderGrant: (evt, gestureState) => {
   *         // The gesture has started. Show visual feedback so the user knows
   *         // what is happening!
   *
   *         // gestureState.d{x,y} will be set to zero now
   *       },
   *       onPanResponderMove: (evt, gestureState) => {
   *         // The most recent move distance is gestureState.move{X,Y}
   *
   *         // The accumulated gesture distance since becoming responder is
   *         // gestureState.d{x,y}
   *       },
   *       onPanResponderTerminationRequest: (evt, gestureState) => true,
   *       onPanResponderRelease: (evt, gestureState) => {
   *         // The user has released all touches while this view is the
   *         // responder. This typically means a gesture has succeeded
   *       },
   *       onPanResponderTerminate: (evt, gestureState) => {
   *         // Another component has become the responder, so this gesture
   *         // should be cancelled
   *       },
   *       onShouldBlockNativeResponder: (evt, gestureState) => {
   *         // Returns whether this component should block native components from becoming the JS
   *         // responder. Returns true by default. Is currently only supported on android.
   *         return true;
   *       },
   *     });
   *   },
   *
   *   render: function() {
   *     return (
   *       <View {...this._panResponder.panHandlers} />
   *     );
   *   },
   *
   * ```
   *
   * ### Working Example
   *
   * To see it in action, try the
   * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)
   */

  var PanResponder = {
    /**
     *
     * A graphical explanation of the touch data flow:
     *
     * +----------------------------+             +--------------------------------+
     * | ResponderTouchHistoryStore |             |TouchHistoryMath                |
     * +----------------------------+             +----------+---------------------+
     * |Global store of touchHistory|             |Allocation-less math util       |
     * |including activeness, start |             |on touch history (centroids     |
     * |position, prev/cur position.|             |and multitouch movement etc)    |
     * |                            |             |                                |
     * +----^-----------------------+             +----^---------------------------+
     *      |                                          |
     *      | (records relevant history                |
     *      |  of touches relevant for                 |
     *      |  implementing higher level               |
     *      |  gestures)                               |
     *      |                                          |
     * +----+-----------------------+             +----|---------------------------+
     * | ResponderEventPlugin       |             |    |   Your App/Component      |
     * +----------------------------+             +----|---------------------------+
     * |Negotiates which view gets  | Low level   |    |             High level    |
     * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |
     * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
     * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
     * +----------------------------+ attached to |  |         |     distance and  |
     *                                 each event |  +---------+     velocity.     |
     *                                            |                                |
     *                                            |                                |
     *                                            +--------------------------------+
     *
     *
     *
     * Gesture that calculates cumulative movement over time in a way that just
     * "does the right thing" for multiple touches. The "right thing" is very
     * nuanced. When moving two touches in opposite directions, the cumulative
     * distance is zero in each dimension. When two touches move in parallel five
     * pixels in the same direction, the cumulative distance is five, not ten. If
     * two touches start, one moves five in a direction, then stops and the other
     * touch moves fives in the same direction, the cumulative distance is ten.
     *
     * This logic requires a kind of processing of time "clusters" of touch events
     * so that two touch moves that essentially occur in parallel but move every
     * other frame respectively, are considered part of the same movement.
     *
     * Explanation of some of the non-obvious fields:
     *
     * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
     *   invalid. If a move event has been observed, `(moveX, moveY)` is the
     *   centroid of the most recently moved "cluster" of active touches.
     *   (Currently all move have the same timeStamp, but later we should add some
     *   threshold for what is considered to be "moving"). If a palm is
     *   accidentally counted as a touch, but a finger is moving greatly, the palm
     *   will move slightly, but we only want to count the single moving touch.
     * - x0/y0: Centroid location (non-cumulative) at the time of becoming
     *   responder.
     * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch
     *   distance. Accounts for touch moves that are clustered together in time,
     *   moving the same direction. Only valid when currently responder (otherwise,
     *   it only represents the drag distance below the threshold).
     * - vx/vy: Velocity.
     */

    _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      // All `gestureState` accounts for timeStamps up until:
      gestureState._accountsForMovesUpTo = 0;
    },
    /**
     * This is nuanced and is necessary. It is incorrect to continuously take all
     * active *and* recently moved touches, find the centroid, and track how that
     * result changes over time. Instead, we must take all recently moved
     * touches, and calculate how the centroid has changed just for those
     * recently moved touches, and append that change to an accumulator. This is
     * to (at least) handle the case where the user is moving three fingers, and
     * then one of the fingers stops but the other two continue.
     *
     * This is very different than taking all of the recently moved touches and
     * storing their centroid as `dx/dy`. For correctness, we must *accumulate
     * changes* in the centroid of recently moved touches.
     *
     * There is also some nuance with how we handle multiple moved touches in a
     * single event. With the way `ReactNativeEventEmitter` dispatches touches as
     * individual events, multiple touches generate two 'move' events, each of
     * them triggering `onResponderMove`. But with the way `PanResponder` works,
     * all of the gesture inference is performed on the first dispatch, since it
     * looks at all of the touches (even the ones for which there hasn't been a
     * native dispatch yet). Therefore, `PanResponder` does not call
     * `onResponderMove` passed the first dispatch. This diverges from the
     * typical responder callback pattern (without using `PanResponder`), but
     * avoids more dispatches than necessary.
     */
    _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;
      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);

      // TODO: This must be filtered intelligently.
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    /**
     * @param {object} config Enhanced versions of all of the responder callbacks
     * that provide not only the typical `ResponderSyntheticEvent`, but also the
     * `PanResponder` gesture state.  Simply replace the word `Responder` with
     * `PanResponder` in each of the typical `onResponder*` callbacks. For
     * example, the `config` object would look like:
     *
     *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onPanResponderReject: (e, gestureState) => {...}`
     *  - `onPanResponderGrant: (e, gestureState) => {...}`
     *  - `onPanResponderStart: (e, gestureState) => {...}`
     *  - `onPanResponderEnd: (e, gestureState) => {...}`
     *  - `onPanResponderRelease: (e, gestureState) => {...}`
     *  - `onPanResponderMove: (e, gestureState) => {...}`
     *  - `onPanResponderTerminate: (e, gestureState) => {...}`
     *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
     *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`
     *
     *  In general, for events that have capture equivalents, we update the
     *  gestureState once in the capture phase and can use it in the bubble phase
     *  as well.
     *
     *  Be careful with onStartShould* callbacks. They only reflect updated
     *  `gestureState` for start/end events that bubble/capture to the Node.
     *  Once the node is the responder, you can rely on every start/end event
     *  being processed by the gesture and `gestureState` being updated
     *  accordingly. (numberActiveTouches) may not be totally accurate unless you
     *  are the responder.
     */
    create(config) {
      var interactionState = {
        handle: null,
        shouldCancelClick: false,
        timeout: null
      };
      var gestureState = {
        // Useful for debugging
        stateID: Math.random(),
        moveX: 0,
        moveY: 0,
        x0: 0,
        y0: 0,
        dx: 0,
        dy: 0,
        vx: 0,
        vy: 0,
        numberActiveTouches: 0,
        _accountsForMovesUpTo: 0
      };
      var panHandlers = {
        onStartShouldSetResponder(event) {
          return config.onStartShouldSetPanResponder == null ? false : config.onStartShouldSetPanResponder(event, gestureState);
        },
        onMoveShouldSetResponder(event) {
          return config.onMoveShouldSetPanResponder == null ? false : config.onMoveShouldSetPanResponder(event, gestureState);
        },
        onStartShouldSetResponderCapture(event) {
          // TODO: Actually, we should reinitialize the state any time
          // touches.length increases from 0 active to > 0 active.
          if (event.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }
          gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture != null ? config.onStartShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onMoveShouldSetResponderCapture(event) {
          var touchHistory = event.touchHistory;
          // Responder system incorrectly dispatches should* to current responder
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onResponderGrant(event) {
          if (!interactionState.handle) {
            interactionState.handle = _InteractionManager.default.createInteractionHandle();
          }
          if (interactionState.timeout) {
            clearInteractionTimeout(interactionState);
          }
          interactionState.shouldCancelClick = true;
          gestureState.x0 = currentCentroidX(event.touchHistory);
          gestureState.y0 = currentCentroidY(event.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;
          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(event, gestureState);
          }
          // TODO: t7467124 investigate if this can be removed
          return config.onShouldBlockNativeResponder == null ? true : config.onShouldBlockNativeResponder(event, gestureState);
        },
        onResponderReject(event) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, event, gestureState);
        },
        onResponderRelease(event) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          if (config.onPanResponderStart) {
            config.onPanResponderStart(event, gestureState);
          }
        },
        onResponderMove(event) {
          var touchHistory = event.touchHistory;
          // Guard against the dispatch of two touch moves when there are two
          // simultaneously changed touches.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          if (config.onPanResponderMove) {
            config.onPanResponderMove(event, gestureState);
          }
        },
        onResponderEnd(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, event, gestureState);
        },
        onResponderTerminate(event) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest(event) {
          return config.onPanResponderTerminationRequest == null ? true : config.onPanResponderTerminationRequest(event, gestureState);
        },
        // We do not want to trigger 'click' activated gestures or native behaviors
        // on any pan target that is under a mouse cursor when it is released.
        // Browsers will natively cancel 'click' events on a target if a non-mouse
        // active pointer moves.
        onClickCapture: event => {
          if (interactionState.shouldCancelClick === true) {
            event.stopPropagation();
            event.preventDefault();
          }
        }
      };
      return {
        panHandlers,
        getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };
  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      _InteractionManager.default.clearInteractionHandle(interactionState.handle);
      interactionState.handle = null;
    }
    if (callback) {
      callback(event, gestureState);
    }
  }
  function clearInteractionTimeout(interactionState) {
    clearTimeout(interactionState.timeout);
  }
  function setInteractionTimeout(interactionState) {
    interactionState.timeout = setTimeout(() => {
      interactionState.shouldCancelClick = false;
    }, 250);
  }
  var _default = exports.default = PanResponder;
},225,[17,143,226],"node_modules\\react-native-web\\dist\\vendor\\react-native\\PanResponder\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  var TouchHistoryMath = {
    /**
     * This code is optimized and not intended to look beautiful. This allows
     * computing of touch centroids that have moved after `touchesChangedAfter`
     * timeStamp. You can compute the current centroid involving all touches
     * moves after `touchesChangedAfter`, or you can compute the previous
     * centroid of all touches that were moved after `touchesChangedAfter`.
     *
     * @param {TouchHistoryMath} touchHistory Standard Responder touch track
     * data.
     * @param {number} touchesChangedAfter timeStamp after which moved touches
     * are considered "actively moving" - not just "active".
     * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
     * @param {boolean} ofCurrent Compute current centroid for actively moving
     * touches vs. previous centroid of now actively moving touches.
     * @return {number} value of centroid in specified dimension.
     */
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank;
      var total = 0;
      var count = 0;
      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
      if (oneTouchData !== null) {
        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
          count = 1;
        }
      } else {
        for (var i = 0; i < touchBank.length; i++) {
          var touchTrack = touchBank[i];
          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
            var toAdd = void 0; // Yuck, program temporarily in invalid state.
            if (ofCurrent && isXAxis) {
              toAdd = touchTrack.currentPageX;
            } else if (ofCurrent && !isXAxis) {
              toAdd = touchTrack.currentPageY;
            } else if (!ofCurrent && isXAxis) {
              toAdd = touchTrack.previousPageX;
            } else {
              toAdd = touchTrack.previousPageY;
            }
            total += toAdd;
            count++;
          }
        }
      }
      return count > 0 ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      true // ofCurrent
      );
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      false // ofCurrent
      );
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      false // ofCurrent
      );
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      false,
      // isXAxis
      true // ofCurrent
      );
    },
    noCentroid: -1
  };
  var _default = exports.default = TouchHistoryMath;
},226,[],"node_modules\\react-native-web\\dist\\vendor\\react-native\\TouchHistoryMath\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Share {
    static share(content, options) {
      if (options === void 0) {
        options = {};
      }
      (0, _invariant.default)(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
      (0, _invariant.default)(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
      (0, _invariant.default)(typeof options === 'object' && options !== null, 'Options must be a valid object');
      (0, _invariant.default)(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');
      if (window.navigator.share !== undefined) {
        return window.navigator.share({
          title: content.title,
          text: content.message,
          url: content.url
        });
      } else {
        return Promise.reject(new Error('Share is not supported in this browser'));
      }
    }

    /**
     * The content was successfully shared.
     */
    static get sharedAction() {
      return 'sharedAction';
    }

    /**
     * The dialog has been dismissed.
     * @platform ios
     */
    static get dismissedAction() {
      return 'dismissedAction';
    }
  }
  var _default = exports.default = Share;
},227,[17,129],"node_modules\\react-native-web\\dist\\exports\\Share\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var vibrate = pattern => {
    if ('vibrate' in window.navigator) {
      window.navigator.vibrate(pattern);
    }
  };
  var Vibration = {
    cancel() {
      vibrate(0);
    },
    vibrate(pattern) {
      if (pattern === void 0) {
        pattern = 400;
      }
      vibrate(pattern);
    }
  };
  var _default = exports.default = Vibration;
},228,[],"node_modules\\react-native-web\\dist\\exports\\Vibration\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["animating", "color", "hidesWhenStopped", "size", "style"];
  var createSvgCircle = style => /*#__PURE__*/React.createElement("circle", {
    cx: "16",
    cy: "16",
    fill: "none",
    r: "14",
    strokeWidth: "4",
    style: style
  });
  var ActivityIndicator = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$animating = props.animating,
      animating = _props$animating === void 0 ? true : _props$animating,
      _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$hidesWhenStopp = props.hidesWhenStopped,
      hidesWhenStopped = _props$hidesWhenStopp === void 0 ? true : _props$hidesWhenStopp,
      _props$size = props.size,
      size = _props$size === void 0 ? 'small' : _props$size,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var svg = /*#__PURE__*/React.createElement("svg", {
      height: "100%",
      viewBox: "0 0 32 32",
      width: "100%"
    }, createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    }));
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
      "aria-valuemax": 1,
      "aria-valuemin": 0,
      ref: forwardedRef,
      role: "progressbar",
      style: [styles.container, style]
    }), /*#__PURE__*/React.createElement(_View.default, {
      children: svg,
      style: [typeof size === 'number' ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles.animation, !animating && styles.animationPause, !animating && hidesWhenStopped && styles.hidesWhenStopped]
    }));
  });
  ActivityIndicator.displayName = 'ActivityIndicator';
  var styles = _StyleSheet.default.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    hidesWhenStopped: {
      visibility: 'hidden'
    },
    animation: {
      animationDuration: '0.75s',
      animationKeyframes: [{
        '0%': {
          transform: 'rotate(0deg)'
        },
        '100%': {
          transform: 'rotate(360deg)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    },
    animationPause: {
      animationPlayState: 'paused'
    }
  });
  var indicatorSizes = _StyleSheet.default.create({
    small: {
      width: 20,
      height: 20
    },
    large: {
      width: 36,
      height: 36
    }
  });
  var _default = exports.default = ActivityIndicator;
},229,[17,888,873,3,30,111],"node_modules\\react-native-web\\dist\\exports\\ActivityIndicator\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "../StyleSheet"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[3], "../TouchableOpacity"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "../Text"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  //import { warnOnce } from '../../modules/warnOnce';

  var Button = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    // warnOnce('Button', 'Button is deprecated. Please use Pressable.');

    var accessibilityLabel = props.accessibilityLabel,
      color = props.color,
      disabled = props.disabled,
      onPress = props.onPress,
      testID = props.testID,
      title = props.title;
    return /*#__PURE__*/React.createElement(_TouchableOpacity.default, {
      accessibilityLabel: accessibilityLabel,
      accessibilityRole: "button",
      disabled: disabled,
      focusable: !disabled,
      onPress: onPress,
      ref: forwardedRef,
      style: [styles.button, color && {
        backgroundColor: color
      }, disabled && styles.buttonDisabled],
      testID: testID
    }, /*#__PURE__*/React.createElement(_Text.default, {
      style: [styles.text, disabled && styles.textDisabled]
    }, title));
  });
  Button.displayName = 'Button';
  var styles = _StyleSheet.default.create({
    button: {
      backgroundColor: '#2196F3',
      borderRadius: 2
    },
    text: {
      color: '#fff',
      fontWeight: '500',
      padding: 8,
      textAlign: 'center',
      textTransform: 'uppercase'
    },
    buttonDisabled: {
      backgroundColor: '#dfdfdf'
    },
    textDisabled: {
      color: '#a1a1a1'
    }
  });
  var _default = exports.default = Button;
},230,[17,3,30,231,190],"node_modules\\react-native-web\\dist\\exports\\Button\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var React = _react;
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[4], "../../modules/useMergeRefs"));
  var _usePressEvents = _interopRequireDefault(require(_dependencyMap[5], "../../modules/usePressEvents"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["activeOpacity", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onLongPress", "onPress", "onPressIn", "onPressOut", "rejectResponderTermination", "style"];
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, dimming it.
   */
  function TouchableOpacity(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableOpacity',
      'TouchableOpacity is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)('0s'),
      duration = _useState[0],
      setDuration = _useState[1];
    var _useState2 = (0, _react.useState)(null),
      opacityOverride = _useState2[0],
      setOpacityOverride = _useState2[1];
    var setOpacityTo = (0, _react.useCallback)((value, duration) => {
      setOpacityOverride(value);
      setDuration(duration ? duration / 1000 + "s" : '0s');
    }, [setOpacityOverride, setDuration]);
    var setOpacityActive = (0, _react.useCallback)(duration => {
      setOpacityTo(activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.2, duration);
    }, [activeOpacity, setOpacityTo]);
    var setOpacityInactive = (0, _react.useCallback)(duration => {
      setOpacityTo(null, duration);
    }, [setOpacityTo]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        var isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === 'onResponderGrant' : event.type === 'keydown';
        setOpacityActive(isGrant ? 0 : 150);
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        setOpacityInactive(250);
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]);
    var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, !disabled && styles.actionable, style, opacityOverride != null && {
        opacity: opacityOverride
      }, {
        transitionDuration: duration
      }]
    }));
  }
  var styles = _StyleSheet.default.create({
    root: {
      transitionProperty: 'opacity',
      transitionDuration: '0.15s',
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableOpacity = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableOpacity));
  MemoedTouchableOpacity.displayName = 'TouchableOpacity';
  var _default = exports.default = MemoedTouchableOpacity;
},231,[17,888,873,3,116,232,30,111],"node_modules\\react-native-web\\dist\\exports\\TouchableOpacity\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = usePressEvents;
  var _PressResponder = _interopRequireDefault(require(_dependencyMap[1], "./PressResponder"));
  var _react = require(_dependencyMap[2], "react");
  function usePressEvents(hostRef, config) {
    var pressResponderRef = (0, _react.useRef)(null);
    if (pressResponderRef.current == null) {
      pressResponderRef.current = new _PressResponder.default(config);
    }
    var pressResponder = pressResponderRef.current;

    // Re-configure to use the current node and configuration.
    (0, _react.useEffect)(() => {
      pressResponder.configure(config);
    }, [config, pressResponder]);

    // Reset the `pressResponder` when cleanup needs to occur. This is
    // a separate effect because we do not want to rest the responder when `config` changes.
    (0, _react.useEffect)(() => {
      return () => {
        pressResponder.reset();
      };
    }, [pressResponder]);
    (0, _react.useDebugValue)(config);
    return pressResponder.getEventHandlers();
  }
},232,[17,233,3],"node_modules\\react-native-web\\dist\\modules\\usePressEvents\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DELAY = 'DELAY';
  var ERROR = 'ERROR';
  var LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';
  var NOT_RESPONDER = 'NOT_RESPONDER';
  var RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';
  var RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';
  var RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';
  var RESPONDER_GRANT = 'RESPONDER_GRANT';
  var RESPONDER_RELEASE = 'RESPONDER_RELEASE';
  var RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';
  var Transitions = Object.freeze({
    NOT_RESPONDER: {
      DELAY: ERROR,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: ERROR,
      RESPONDER_TERMINATED: ERROR,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_INACTIVE_PRESS_START: {
      DELAY: RESPONDER_ACTIVE_PRESS_START,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_ACTIVE_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    RESPONDER_ACTIVE_LONG_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    ERROR: {
      DELAY: NOT_RESPONDER,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: NOT_RESPONDER
    }
  });
  var getElementRole = element => element.getAttribute('role');
  var getElementType = element => element.tagName.toLowerCase();
  var isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isButtonRole = element => getElementRole(element) === 'button';
  var isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;
  var isValidKeyPress = event => {
    var key = event.key,
      target = event.target;
    var isSpacebar = key === ' ' || key === 'Spacebar';
    var isButtonish = getElementType(target) === 'button' || isButtonRole(target);
    return key === 'Enter' || isSpacebar && isButtonish;
  };
  var DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50
  var DEFAULT_PRESS_DELAY_MS = 50;

  /**
   * =========================== PressResponder Tutorial ===========================
   *
   * The `PressResponder` class helps you create press interactions by analyzing the
   * geometry of elements and observing when another responder (e.g. ScrollView)
   * has stolen the touch lock. It offers hooks for your component to provide
   * interaction feedback to the user:
   *
   * - When a press has activated (e.g. highlight an element)
   * - When a press has deactivated (e.g. un-highlight an element)
   * - When a press sould trigger an action, meaning it activated and deactivated
   *   while within the geometry of the element without the lock being stolen.
   *
   * A high quality interaction isn't as simple as you might think. There should
   * be a slight delay before activation. Moving your finger beyond an element's
   * bounds should trigger deactivation, but moving the same finger back within an
   * element's bounds should trigger reactivation.
   *
   * In order to use `PressResponder`, do the following:
   *
   *     const pressResponder = new PressResponder(config);
   *
   * 2. Choose the rendered component who should collect the press events. On that
   *    element, spread `pressability.getEventHandlers()` into its props.
   *
   *    return (
   *      <View {...this.state.pressResponder.getEventHandlers()} />
   *    );
   *
   * 3. Reset `PressResponder` when your component unmounts.
   *
   *    componentWillUnmount() {
   *      this.state.pressResponder.reset();
   *    }
   *
   * ==================== Implementation Details ====================
   *
   * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   * # Geometry
   *
   *  
   *       - Presses start anywhere within `HitRect`.
   *          
   *       VisualRect     
   *           - When pressed down for sufficient amount of time
   *        HitRect            before letting up, `VisualRect` activates.
   *      
   *         Out Region   o   
   *  
   *                        When the press is released outside the `HitRect`,
   *                               the responder is NOT eligible for a "press".
   *
   * # State Machine
   *
   *   RESPONDER_RELEASE
   *  NOT_RESPONDER 
   *   RESPONDER_TERMINATED
   *     
   *      RESPONDER_GRANT (HitRect)
   *     
   *     
   *                         
   *  RESPONDER_INACTIVE_   DELAY    RESPONDER_ACTIVE_   T + DELAY    RESPONDER_ACTIVE_ 
   *  PRESS_START           PRESS_START         LONG_PRESS_START  
   *                         
   *
   * T + DELAY => LONG_PRESS_DELAY + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the invocation of `onLongPress`. Only when the browser produces a
   * `click` event is `onPress` invoked.
   */
  class PressResponder {
    constructor(config) {
      this._eventHandlers = null;
      this._isPointerTouch = false;
      this._longPressDelayTimeout = null;
      this._longPressDispatched = false;
      this._pressDelayTimeout = null;
      this._pressOutDelayTimeout = null;
      this._touchState = NOT_RESPONDER;
      this._responderElement = null;
      this.configure(config);
    }
    configure(config) {
      this._config = config;
    }

    /**
     * Resets any pending timers. This should be called on unmount.
     */
    reset() {
      this._cancelLongPressDelayTimeout();
      this._cancelPressDelayTimeout();
      this._cancelPressOutDelayTimeout();
    }

    /**
     * Returns a set of props to spread into the interactive element.
     */
    getEventHandlers() {
      if (this._eventHandlers == null) {
        this._eventHandlers = this._createEventHandlers();
      }
      return this._eventHandlers;
    }
    _createEventHandlers() {
      var start = (event, shouldDelay) => {
        event.persist();
        this._cancelPressOutDelayTimeout();
        this._longPressDispatched = false;
        this._selectionTerminated = false;
        this._touchState = NOT_RESPONDER;
        this._isPointerTouch = event.nativeEvent.type === 'touchstart';
        this._receiveSignal(RESPONDER_GRANT, event);
        var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);
        if (shouldDelay !== false && delayPressStart > 0) {
          this._pressDelayTimeout = setTimeout(() => {
            this._receiveSignal(DELAY, event);
          }, delayPressStart);
        } else {
          this._receiveSignal(DELAY, event);
        }
        var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
        this._longPressDelayTimeout = setTimeout(() => {
          this._handleLongPress(event);
        }, delayLongPress + delayPressStart);
      };
      var end = event => {
        this._receiveSignal(RESPONDER_RELEASE, event);
      };
      var keyupHandler = event => {
        var onPress = this._config.onPress;
        var target = event.target;
        if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
          end(event);
          document.removeEventListener('keyup', keyupHandler);
          var role = target.getAttribute('role');
          var elementType = getElementType(target);
          var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';
          var isActiveElement = this._responderElement === target;
          if (onPress != null && !isNativeInteractiveElement && isActiveElement) {
            onPress(event);
          }
          this._responderElement = null;
        }
      };
      return {
        onStartShouldSetResponder: event => {
          var disabled = this._config.disabled;
          if (disabled && isButtonRole(event.currentTarget)) {
            event.stopPropagation();
          }
          if (disabled == null) {
            return true;
          }
          return !disabled;
        },
        onKeyDown: event => {
          var disabled = this._config.disabled;
          var key = event.key,
            target = event.target;
          if (!disabled && isValidKeyPress(event)) {
            if (this._touchState === NOT_RESPONDER) {
              start(event, false);
              this._responderElement = target;
              // Listen to 'keyup' on document to account for situations where
              // focus is moved to another element during 'keydown'.
              document.addEventListener('keyup', keyupHandler);
            }
            var isSpacebarKey = key === ' ' || key === 'Spacebar';
            var role = getElementRole(target);
            var isButtonLikeRole = role === 'button' || role === 'menuitem';
            if (isSpacebarKey && isButtonLikeRole && getElementType(target) !== 'button') {
              // Prevent spacebar scrolling the window if using non-native button
              event.preventDefault();
            }
            event.stopPropagation();
          }
        },
        onResponderGrant: event => start(event),
        onResponderMove: event => {
          if (this._config.onPressMove != null) {
            this._config.onPressMove(event);
          }
          var touch = getTouchFromResponderEvent(event);
          if (this._touchActivatePosition != null) {
            var deltaX = this._touchActivatePosition.pageX - touch.pageX;
            var deltaY = this._touchActivatePosition.pageY - touch.pageY;
            if (Math.hypot(deltaX, deltaY) > 10) {
              this._cancelLongPressDelayTimeout();
            }
          }
        },
        onResponderRelease: event => end(event),
        onResponderTerminate: event => {
          if (event.nativeEvent.type === 'selectionchange') {
            this._selectionTerminated = true;
          }
          this._receiveSignal(RESPONDER_TERMINATED, event);
        },
        onResponderTerminationRequest: event => {
          var _this$_config = this._config,
            cancelable = _this$_config.cancelable,
            disabled = _this$_config.disabled,
            onLongPress = _this$_config.onLongPress;
          // If `onLongPress` is provided, don't terminate on `contextmenu` as default
          // behavior will be prevented for non-mouse pointers.
          if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {
            return false;
          }
          if (cancelable == null) {
            return true;
          }
          return cancelable;
        },
        // NOTE: this diverges from react-native in 3 significant ways:
        // * The `onPress` callback is not connected to the responder system (the native
        //  `click` event must be used but is dispatched in many scenarios where no pointers
        //   are on the screen.) Therefore, it's possible for `onPress` to be called without
        //   `onPress{Start,End}` being called first.
        // * The `onPress` callback is only be called on the first ancestor of the native
        //   `click` target that is using the PressResponder.
        // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
        onClick: event => {
          var _this$_config2 = this._config,
            disabled = _this$_config2.disabled,
            onPress = _this$_config2.onPress;
          if (!disabled) {
            // If long press dispatched, cancel default click behavior.
            // If the responder terminated because text was selected during the gesture,
            // cancel the default click behavior.
            event.stopPropagation();
            if (this._longPressDispatched || this._selectionTerminated) {
              event.preventDefault();
            } else if (onPress != null && event.altKey === false) {
              onPress(event);
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        },
        // If `onLongPress` is provided and a touch pointer is being used, prevent the
        // default context menu from opening.
        onContextMenu: event => {
          var _this$_config3 = this._config,
            disabled = _this$_config3.disabled,
            onLongPress = _this$_config3.onLongPress;
          if (!disabled) {
            if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {
              event.preventDefault();
              event.stopPropagation();
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        }
      };
    }

    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     */
    _receiveSignal(signal, event) {
      var prevState = this._touchState;
      var nextState = null;
      if (Transitions[prevState] != null) {
        nextState = Transitions[prevState][signal];
      }
      if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {
        return;
      }
      if (nextState == null || nextState === ERROR) {
        console.error("PressResponder: Invalid signal " + signal + " for state " + prevState + " on responder");
      } else if (prevState !== nextState) {
        this._performTransitionSideEffects(prevState, nextState, signal, event);
        this._touchState = nextState;
      }
    }

    /**
     * Performs a transition between touchable states and identify any activations
     * or deactivations (and callback invocations).
     */
    _performTransitionSideEffects(prevState, nextState, signal, event) {
      if (isTerminalSignal(signal)) {
        // Pressable suppression of contextmenu on windows.
        // On Windows, the contextmenu is displayed after pointerup.
        // https://github.com/necolas/react-native-web/issues/2296
        setTimeout(() => {
          this._isPointerTouch = false;
        }, 0);
        this._touchActivatePosition = null;
        this._cancelLongPressDelayTimeout();
      }
      if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
        var onLongPress = this._config.onLongPress;
        // Long press is not supported for keyboards because 'click' can be dispatched
        // immediately (and multiple times) after 'keydown'.
        if (onLongPress != null && event.nativeEvent.key == null) {
          onLongPress(event);
          this._longPressDispatched = true;
        }
      }
      var isPrevActive = isActiveSignal(prevState);
      var isNextActive = isActiveSignal(nextState);
      if (!isPrevActive && isNextActive) {
        this._activate(event);
      } else if (isPrevActive && !isNextActive) {
        this._deactivate(event);
      }
      if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
        var _this$_config4 = this._config,
          _onLongPress = _this$_config4.onLongPress,
          onPress = _this$_config4.onPress;
        if (onPress != null) {
          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;
          if (!isPressCanceledByLongPress) {
            // If we never activated (due to delays), activate and deactivate now.
            if (!isNextActive && !isPrevActive) {
              this._activate(event);
              this._deactivate(event);
            }
          }
        }
      }
      this._cancelPressDelayTimeout();
    }
    _activate(event) {
      var _this$_config5 = this._config,
        onPressChange = _this$_config5.onPressChange,
        onPressStart = _this$_config5.onPressStart;
      var touch = getTouchFromResponderEvent(event);
      this._touchActivatePosition = {
        pageX: touch.pageX,
        pageY: touch.pageY
      };
      if (onPressStart != null) {
        onPressStart(event);
      }
      if (onPressChange != null) {
        onPressChange(true);
      }
    }
    _deactivate(event) {
      var _this$_config6 = this._config,
        onPressChange = _this$_config6.onPressChange,
        onPressEnd = _this$_config6.onPressEnd;
      function end() {
        if (onPressEnd != null) {
          onPressEnd(event);
        }
        if (onPressChange != null) {
          onPressChange(false);
        }
      }
      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);
      if (delayPressEnd > 0) {
        this._pressOutDelayTimeout = setTimeout(() => {
          end();
        }, delayPressEnd);
      } else {
        end();
      }
    }
    _handleLongPress(event) {
      if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {
        this._receiveSignal(LONG_PRESS_DETECTED, event);
      }
    }
    _cancelLongPressDelayTimeout() {
      if (this._longPressDelayTimeout != null) {
        clearTimeout(this._longPressDelayTimeout);
        this._longPressDelayTimeout = null;
      }
    }
    _cancelPressDelayTimeout() {
      if (this._pressDelayTimeout != null) {
        clearTimeout(this._pressDelayTimeout);
        this._pressDelayTimeout = null;
      }
    }
    _cancelPressOutDelayTimeout() {
      if (this._pressOutDelayTimeout != null) {
        clearTimeout(this._pressOutDelayTimeout);
        this._pressOutDelayTimeout = null;
      }
    }
  }
  exports.default = PressResponder;
  function normalizeDelay(delay, min, fallback) {
    if (min === void 0) {
      min = 0;
    }
    if (fallback === void 0) {
      fallback = 0;
    }
    return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);
  }
  function getTouchFromResponderEvent(event) {
    var _event$nativeEvent = event.nativeEvent,
      changedTouches = _event$nativeEvent.changedTouches,
      touches = _event$nativeEvent.touches;
    if (touches != null && touches.length > 0) {
      return touches[0];
    }
    if (changedTouches != null && changedTouches.length > 0) {
      return changedTouches[0];
    }
    return event.nativeEvent;
  }
},233,[],"node_modules\\react-native-web\\dist\\modules\\usePressEvents\\PressResponder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _extends2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[5], "../createElement"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["aria-readonly", "color", "disabled", "onChange", "onValueChange", "readOnly", "style", "value"];
  var CheckBox = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaReadOnly = props['aria-readonly'],
      color = props.color,
      disabled = props.disabled,
      onChange = props.onChange,
      onValueChange = props.onValueChange,
      readOnly = props.readOnly,
      style = props.style,
      value = props.value,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    function handleChange(event) {
      var value = event.nativeEvent.target.checked;
      event.nativeEvent.value = value;
      onChange && onChange(event);
      onValueChange && onValueChange(value);
    }
    var fakeControl = /*#__PURE__*/React.createElement(_View.default, {
      style: [styles.fakeControl, value && styles.fakeControlChecked,
      // custom color
      value && color && {
        backgroundColor: color,
        borderColor: color
      }, disabled && styles.fakeControlDisabled, value && disabled && styles.fakeControlCheckedAndDisabled]
    });
    var nativeControl = (0, _createElement.default)('input', {
      checked: value,
      disabled: disabled,
      onChange: handleChange,
      readOnly: readOnly === true || ariaReadOnly === true || other.accessibilityReadOnly === true,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox'
    });
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
      "aria-disabled": disabled,
      "aria-readonly": ariaReadOnly,
      style: [styles.root, style, disabled && styles.cursorDefault]
    }), fakeControl, nativeControl);
  });
  CheckBox.displayName = 'CheckBox';
  var styles = _StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      height: 16,
      userSelect: 'none',
      width: 16
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    fakeControl: {
      alignItems: 'center',
      backgroundColor: '#fff',
      borderColor: '#657786',
      borderRadius: 2,
      borderStyle: 'solid',
      borderWidth: 2,
      height: '100%',
      justifyContent: 'center',
      width: '100%'
    },
    fakeControlChecked: {
      backgroundColor: '#009688',
      backgroundImage: 'url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICB2aWV3Qm94PSIwIDAgMSAxIgogICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWluWU1pbiBtZWV0Ij4KICA8cGF0aAogICAgIGQ9Ik0gMC4wNDAzODA1OSwwLjYyNjc3NjcgMC4xNDY0NDY2MSwwLjUyMDcxMDY4IDAuNDI5Mjg5MzIsMC44MDM1NTMzOSAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IE0gMC4yMTcxNTcyOSwwLjgwMzU1MzM5IDAuODUzNTUzMzksMC4xNjcxNTcyOSAwLjk1OTYxOTQxLDAuMjczMjIzMyAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IgogICAgIGlkPSJyZWN0Mzc4MCIKICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L3N2Zz4K")',
      backgroundRepeat: 'no-repeat',
      borderColor: '#009688'
    },
    fakeControlDisabled: {
      borderColor: '#CCD6DD'
    },
    fakeControlCheckedAndDisabled: {
      backgroundColor: '#AAB8C2',
      borderColor: '#AAB8C2'
    },
    nativeControl: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = exports.default = CheckBox;
},234,[17,868,888,873,3,18,30,111],"node_modules\\react-native-web\\dist\\exports\\CheckBox\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var React = _react;
  var _Image = _interopRequireDefault(require(_dependencyMap[4], "../Image"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[6], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["children", "style", "imageStyle", "imageRef"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Very simple drop-in replacement for <Image> which supports nesting views.
   */
  var ImageBackground = /*#__PURE__*/(0, _react.forwardRef)((props, forwardedRef) => {
    var children = props.children,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      imageStyle = props.imageStyle,
      imageRef = props.imageRef,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var _StyleSheet$flatten = _StyleSheet.default.flatten(style),
      height = _StyleSheet$flatten.height,
      width = _StyleSheet$flatten.width;
    return /*#__PURE__*/React.createElement(_View.default, {
      ref: forwardedRef,
      style: style
    }, /*#__PURE__*/React.createElement(_Image.default, (0, _extends2.default)({}, rest, {
      ref: imageRef,
      style: [{
        // Temporary Workaround:
        // Current (imperfect yet) implementation of <Image> overwrites width and height styles
        // (which is not quite correct), and these styles conflict with explicitly set styles
        // of <ImageBackground> and with our internal layout model here.
        // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
        // This workaround should be removed after implementing proper support of
        // intrinsic content size of the <Image>.
        width,
        height,
        zIndex: -1
      }, _StyleSheet.default.absoluteFill, imageStyle]
    })), children);
  });
  ImageBackground.displayName = 'ImageBackground';
  var _default = exports.default = ImageBackground;
},235,[17,888,873,3,180,30,111],"node_modules\\react-native-web\\dist\\exports\\ImageBackground\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["behavior", "contentContainerStyle", "keyboardVerticalOffset"];
  class KeyboardAvoidingView extends React.Component {
    constructor() {
      super(...arguments);
      this.frame = null;
      this.onLayout = event => {
        this.frame = event.nativeEvent.layout;
      };
    }
    relativeKeyboardHeight(keyboardFrame) {
      var frame = this.frame;
      if (!frame || !keyboardFrame) {
        return 0;
      }
      var keyboardY = keyboardFrame.screenY - (this.props.keyboardVerticalOffset || 0);
      return Math.max(frame.y + frame.height - keyboardY, 0);
    }
    onKeyboardChange(event) {}
    render() {
      var _this$props = this.props,
        behavior = _this$props.behavior,
        contentContainerStyle = _this$props.contentContainerStyle,
        keyboardVerticalOffset = _this$props.keyboardVerticalOffset,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({
        onLayout: this.onLayout
      }, rest));
    }
  }
  var _default = exports.default = KeyboardAvoidingView;
},236,[17,888,873,3,111],"node_modules\\react-native-web\\dist\\exports\\KeyboardAvoidingView\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _ModalPortal = _interopRequireDefault(require(_dependencyMap[4], "./ModalPortal"));
  var _ModalAnimation = _interopRequireDefault(require(_dependencyMap[5], "./ModalAnimation"));
  var _ModalContent = _interopRequireDefault(require(_dependencyMap[6], "./ModalContent"));
  var _ModalFocusTrap = _interopRequireDefault(require(_dependencyMap[7], "./ModalFocusTrap"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["animationType", "children", "onDismiss", "onRequestClose", "onShow", "transparent", "visible"];
  var uniqueModalIdentifier = 0;
  var activeModalStack = [];
  var activeModalListeners = {};
  function notifyActiveModalListeners() {
    if (activeModalStack.length === 0) {
      return;
    }
    var activeModalId = activeModalStack[activeModalStack.length - 1];
    activeModalStack.forEach(modalId => {
      if (modalId in activeModalListeners) {
        activeModalListeners[modalId](modalId === activeModalId);
      }
    });
  }
  function removeActiveModal(modalId) {
    if (modalId in activeModalListeners) {
      // Before removing this listener we should probably tell it
      // that it's no longer the active modal for sure.
      activeModalListeners[modalId](false);
      delete activeModalListeners[modalId];
    }
    var index = activeModalStack.indexOf(modalId);
    if (index !== -1) {
      activeModalStack.splice(index, 1);
      notifyActiveModalListeners();
    }
  }
  function addActiveModal(modalId, listener) {
    removeActiveModal(modalId);
    activeModalStack.push(modalId);
    activeModalListeners[modalId] = listener;
    notifyActiveModalListeners();
  }
  var Modal = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onRequestClose = props.onRequestClose,
      onShow = props.onShow,
      transparent = props.transparent,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

    // Set a unique model identifier so we can correctly route
    // dismissals and check the layering of modals.
    var modalId = React.useMemo(() => uniqueModalIdentifier++, []);
    var _React$useState = React.useState(false),
      isActive = _React$useState[0],
      setIsActive = _React$useState[1];
    var onDismissCallback = React.useCallback(() => {
      removeActiveModal(modalId);
      if (onDismiss) {
        onDismiss();
      }
    }, [modalId, onDismiss]);
    var onShowCallback = React.useCallback(() => {
      addActiveModal(modalId, setIsActive);
      if (onShow) {
        onShow();
      }
    }, [modalId, onShow]);
    React.useEffect(() => {
      return () => removeActiveModal(modalId);
    }, [modalId]);
    return /*#__PURE__*/React.createElement(_ModalPortal.default, null, /*#__PURE__*/React.createElement(_ModalAnimation.default, {
      animationType: animationType,
      onDismiss: onDismissCallback,
      onShow: onShowCallback,
      visible: visible
    }, /*#__PURE__*/React.createElement(_ModalFocusTrap.default, {
      active: isActive
    }, /*#__PURE__*/React.createElement(_ModalContent.default, (0, _extends2.default)({}, rest, {
      active: isActive,
      onRequestClose: onRequestClose,
      ref: forwardedRef,
      transparent: transparent
    }), children))));
  });
  var _default = exports.default = Modal;
},237,[17,888,873,3,238,239,240,241],"node_modules\\react-native-web\\dist\\exports\\Modal\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _reactDom = _interopRequireDefault(require(_dependencyMap[2], "react-dom"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[3], "../../modules/canUseDom"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function ModalPortal(props) {
    var children = props.children;
    var elementRef = React.useRef(null);
    if (_canUseDom.default && !elementRef.current) {
      var element = document.createElement('div');
      if (element && document.body) {
        document.body.appendChild(element);
        elementRef.current = element;
      }
    }
    React.useEffect(() => {
      if (_canUseDom.default) {
        return () => {
          if (document.body && elementRef.current) {
            document.body.removeChild(elementRef.current);
            elementRef.current = null;
          }
        };
      }
    }, []);
    return elementRef.current && _canUseDom.default ? /*#__PURE__*/_reactDom.default.createPortal(children, elementRef.current) : null;
  }
  var _default = exports.default = ModalPortal;
},238,[17,3,93,39],"node_modules\\react-native-web\\dist\\exports\\Modal\\ModalPortal.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "../StyleSheet"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[3], "../createElement"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ANIMATION_DURATION = 300;
  function getAnimationStyle(animationType, visible) {
    if (animationType === 'slide') {
      return visible ? animatedSlideInStyles : animatedSlideOutStyles;
    }
    if (animationType === 'fade') {
      return visible ? animatedFadeInStyles : animatedFadeOutStyles;
    }
    return visible ? styles.container : styles.hidden;
  }
  function ModalAnimation(props) {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onShow = props.onShow,
      visible = props.visible;
    var _React$useState = React.useState(false),
      isRendering = _React$useState[0],
      setIsRendering = _React$useState[1];
    var wasVisible = React.useRef(false);
    var wasRendering = React.useRef(false);
    var isAnimated = animationType && animationType !== 'none';
    var animationEndCallback = React.useCallback(e => {
      if (e && e.currentTarget !== e.target) {
        // If the event was generated for something NOT this element we
        // should ignore it as it's not relevant to us
        return;
      }
      if (visible) {
        if (onShow) {
          onShow();
        }
      } else {
        setIsRendering(false);
      }
    }, [onShow, visible]);
    React.useEffect(() => {
      if (wasRendering.current && !isRendering && onDismiss) {
        onDismiss();
      }
      wasRendering.current = isRendering;
    }, [isRendering, onDismiss]);
    React.useEffect(() => {
      if (visible) {
        setIsRendering(true);
      }
      if (visible !== wasVisible.current && !isAnimated) {
        // Manually call `animationEndCallback` if no animation is used
        animationEndCallback();
      }
      wasVisible.current = visible;
    }, [isAnimated, visible, animationEndCallback]);
    return isRendering || visible ? (0, _createElement.default)('div', {
      style: isRendering ? getAnimationStyle(animationType, visible) : styles.hidden,
      onAnimationEnd: animationEndCallback,
      children
    }) : null;
  }
  var styles = _StyleSheet.default.create({
    container: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      zIndex: 9999
    },
    animatedIn: {
      animationDuration: ANIMATION_DURATION + "ms",
      animationTimingFunction: 'ease-in'
    },
    animatedOut: {
      pointerEvents: 'none',
      animationDuration: ANIMATION_DURATION + "ms",
      animationTimingFunction: 'ease-out'
    },
    fadeIn: {
      opacity: 1,
      animationKeyframes: {
        '0%': {
          opacity: 0
        },
        '100%': {
          opacity: 1
        }
      }
    },
    fadeOut: {
      opacity: 0,
      animationKeyframes: {
        '0%': {
          opacity: 1
        },
        '100%': {
          opacity: 0
        }
      }
    },
    slideIn: {
      transform: 'translateY(0%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(100%)'
        },
        '100%': {
          transform: 'translateY(0%)'
        }
      }
    },
    slideOut: {
      transform: 'translateY(100%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(0%)'
        },
        '100%': {
          transform: 'translateY(100%)'
        }
      }
    },
    hidden: {
      opacity: 0
    }
  });
  var animatedSlideInStyles = [styles.container, styles.animatedIn, styles.slideIn];
  var animatedSlideOutStyles = [styles.container, styles.animatedOut, styles.slideOut];
  var animatedFadeInStyles = [styles.container, styles.animatedIn, styles.fadeIn];
  var animatedFadeOutStyles = [styles.container, styles.animatedOut, styles.fadeOut];
  var _default = exports.default = ModalAnimation;
},239,[17,3,30,18],"node_modules\\react-native-web\\dist\\exports\\Modal\\ModalAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "../View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "../StyleSheet"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[6], "../../modules/canUseDom"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["active", "children", "onRequestClose", "transparent"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ModalContent = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var active = props.active,
      children = props.children,
      onRequestClose = props.onRequestClose,
      transparent = props.transparent,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    React.useEffect(() => {
      if (_canUseDom.default) {
        var closeOnEscape = e => {
          if (active && e.key === 'Escape') {
            e.stopPropagation();
            if (onRequestClose) {
              onRequestClose();
            }
          }
        };
        document.addEventListener('keyup', closeOnEscape, false);
        return () => document.removeEventListener('keyup', closeOnEscape, false);
      }
    }, [active, onRequestClose]);
    var style = React.useMemo(() => {
      return [styles.modal, transparent ? styles.modalTransparent : styles.modalOpaque];
    }, [transparent]);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
      "aria-modal": true,
      ref: forwardedRef,
      role: active ? 'dialog' : null,
      style: style
    }), /*#__PURE__*/React.createElement(_View.default, {
      style: styles.container
    }, children));
  });
  var styles = _StyleSheet.default.create({
    modal: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    modalTransparent: {
      backgroundColor: 'transparent'
    },
    modalOpaque: {
      backgroundColor: 'white'
    },
    container: {
      top: 0,
      flex: 1
    }
  });
  var _default = exports.default = ModalContent;
},240,[17,888,873,3,111,30,39],"node_modules\\react-native-web\\dist\\exports\\Modal\\ModalContent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[2], "../View"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[3], "../createElement"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../StyleSheet"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[5], "../UIManager"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[6], "../../modules/canUseDom"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This Component is used to "wrap" the modal we're opening
   * so that changing focus via tab will never leave the document.
   *
   * This allows us to properly trap the focus within a modal
   * even if the modal is at the start or end of a document.
   */

  var FocusBracket = () => {
    return (0, _createElement.default)('div', {
      role: 'none',
      tabIndex: 0,
      style: styles.focusBracket
    });
  };
  function attemptFocus(element) {
    if (!_canUseDom.default) {
      return false;
    }
    try {
      element.focus();
    } catch (e) {
      // Do nothing
    }
    return document.activeElement === element;
  }
  function focusFirstDescendant(element) {
    for (var i = 0; i < element.childNodes.length; i++) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  function focusLastDescendant(element) {
    for (var i = element.childNodes.length - 1; i >= 0; i--) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  var ModalFocusTrap = _ref => {
    var active = _ref.active,
      children = _ref.children;
    var trapElementRef = React.useRef();
    var focusRef = React.useRef({
      trapFocusInProgress: false,
      lastFocusedElement: null
    });
    React.useEffect(() => {
      if (_canUseDom.default) {
        var trapFocus = () => {
          // We should not trap focus if:
          // - The modal hasn't fully initialized with an HTMLElement ref
          // - Focus is already in the process of being trapped (e.g., we're refocusing)
          // - isTrapActive prop being falsey tells us to do nothing
          if (trapElementRef.current == null || focusRef.current.trapFocusInProgress || !active) {
            return;
          }
          try {
            focusRef.current.trapFocusInProgress = true;
            if (document.activeElement instanceof Node && !trapElementRef.current.contains(document.activeElement)) {
              // To handle keyboard focusing we can make an assumption here.
              // If you're tabbing through the focusable elements, the previously
              // active element will either be the first or the last.
              // If the previously selected element is the "first" descendant
              // and we're leaving it - this means that we should be looping
              // around to the other side of the modal.
              var hasFocused = focusFirstDescendant(trapElementRef.current);
              if (focusRef.current.lastFocusedElement === document.activeElement) {
                hasFocused = focusLastDescendant(trapElementRef.current);
              }
              // If we couldn't focus a new element then we need to focus onto the trap target
              if (!hasFocused && trapElementRef.current != null && document.activeElement) {
                _UIManager.default.focus(trapElementRef.current);
              }
            }
          } finally {
            focusRef.current.trapFocusInProgress = false;
          }
          focusRef.current.lastFocusedElement = document.activeElement;
        };

        // Call the trapFocus callback at least once when this modal has been activated.
        trapFocus();
        document.addEventListener('focus', trapFocus, true);
        return () => document.removeEventListener('focus', trapFocus, true);
      }
    }, [active]);

    // To be fully compliant with WCAG we need to refocus element that triggered opening modal
    // after closing it
    React.useEffect(function () {
      if (_canUseDom.default) {
        var lastFocusedElementOutsideTrap = document.activeElement;
        return function () {
          if (lastFocusedElementOutsideTrap && document.contains(lastFocusedElementOutsideTrap)) {
            _UIManager.default.focus(lastFocusedElementOutsideTrap);
          }
        };
      }
    }, []);
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FocusBracket, null), /*#__PURE__*/React.createElement(_View.default, {
      ref: trapElementRef
    }, children), /*#__PURE__*/React.createElement(FocusBracket, null));
  };
  var _default = exports.default = ModalFocusTrap;
  var styles = _StyleSheet.default.create({
    focusBracket: {
      outlineStyle: 'none'
    }
  });
},241,[17,3,111,18,30,97,39],"node_modules\\react-native-web\\dist\\exports\\Modal\\ModalFocusTrap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[4], "../createElement"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[5], "../../modules/useMergeRefs"));
  var _usePlatformMethods = _interopRequireDefault(require(_dependencyMap[6], "../../modules/usePlatformMethods"));
  var _PickerItem = _interopRequireDefault(require(_dependencyMap[7], "./PickerItem"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[8], "../StyleSheet"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["children", "enabled", "onValueChange", "selectedValue", "style", "testID", "itemStyle", "mode", "prompt"];
  var Picker = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var children = props.children,
      enabled = props.enabled,
      onValueChange = props.onValueChange,
      selectedValue = props.selectedValue,
      style = props.style,
      testID = props.testID,
      itemStyle = props.itemStyle,
      mode = props.mode,
      prompt = props.prompt,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var hostRef = React.useRef(null);
    function handleChange(e) {
      var _e$target = e.target,
        selectedIndex = _e$target.selectedIndex,
        value = _e$target.value;
      if (onValueChange) {
        onValueChange(value, selectedIndex);
      }
    }

    // $FlowFixMe
    var supportedProps = (0, _objectSpread2.default)({
      children,
      disabled: enabled === false ? true : undefined,
      onChange: handleChange,
      style: [styles.initial, style],
      testID,
      value: selectedValue
    }, other);
    var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
    var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, _createElement.default)('select', supportedProps);
  });

  // $FlowFixMe
  Picker.Item = _PickerItem.default;
  var styles = _StyleSheet.default.create({
    initial: {
      fontFamily: 'System',
      fontSize: 'inherit',
      margin: 0
    }
  });
  var _default = exports.default = Picker;
},242,[17,868,873,3,18,116,118,243,30],"node_modules\\react-native-web\\dist\\exports\\Picker\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = PickerItem;
  var _createElement = _interopRequireDefault(require(_dependencyMap[1], "../createElement"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function PickerItem(props) {
    var color = props.color,
      label = props.label,
      testID = props.testID,
      value = props.value;
    var style = {
      color
    };
    return (0, _createElement.default)('option', {
      children: label,
      style,
      testID,
      value
    });
  }
},243,[17,18],"node_modules\\react-native-web\\dist\\exports\\Picker\\PickerItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var React = _react;
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[4], "../../modules/useMergeRefs"));
  var _useHover = _interopRequireDefault(require(_dependencyMap[5], "../../modules/useHover"));
  var _usePressEvents = _interopRequireDefault(require(_dependencyMap[6], "../../modules/usePressEvents"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[8], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["children", "delayLongPress", "delayPressIn", "delayPressOut", "disabled", "onBlur", "onContextMenu", "onFocus", "onHoverIn", "onHoverOut", "onKeyDown", "onLongPress", "onPress", "onPressMove", "onPressIn", "onPressOut", "style", "tabIndex", "testOnly_hovered", "testOnly_pressed"];
  /**
   * Component used to build display components that should respond to whether the
   * component is currently pressed or not.
   */
  function Pressable(props, forwardedRef) {
    var children = props.children,
      delayLongPress = props.delayLongPress,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      disabled = props.disabled,
      onBlur = props.onBlur,
      onContextMenu = props.onContextMenu,
      onFocus = props.onFocus,
      onHoverIn = props.onHoverIn,
      onHoverOut = props.onHoverOut,
      onKeyDown = props.onKeyDown,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressMove = props.onPressMove,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      style = props.style,
      tabIndex = props.tabIndex,
      testOnly_hovered = props.testOnly_hovered,
      testOnly_pressed = props.testOnly_pressed,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var _useForceableState = useForceableState(testOnly_hovered === true),
      hovered = _useForceableState[0],
      setHovered = _useForceableState[1];
    var _useForceableState2 = useForceableState(false),
      focused = _useForceableState2[0],
      setFocused = _useForceableState2[1];
    var _useForceableState3 = useForceableState(testOnly_pressed === true),
      pressed = _useForceableState3[0],
      setPressed = _useForceableState3[1];
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);
    var pressConfig = (0, _react.useMemo)(() => ({
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressChange: setPressed,
      onPressStart: onPressIn,
      onPressMove,
      onPressEnd: onPressOut
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]);
    var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
    var onContextMenuPress = pressEventHandlers.onContextMenu,
      onKeyDownPress = pressEventHandlers.onKeyDown;
    (0, _useHover.default)(hostRef, {
      contain: true,
      disabled,
      onHoverChange: setHovered,
      onHoverStart: onHoverIn,
      onHoverEnd: onHoverOut
    });
    var interactionState = {
      hovered,
      focused,
      pressed
    };
    var blurHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(false);
        if (onBlur != null) {
          onBlur(e);
        }
      }
    }, [hostRef, setFocused, onBlur]);
    var focusHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(true);
        if (onFocus != null) {
          onFocus(e);
        }
      }
    }, [hostRef, setFocused, onFocus]);
    var contextMenuHandler = React.useCallback(e => {
      if (onContextMenuPress != null) {
        onContextMenuPress(e);
      }
      if (onContextMenu != null) {
        onContextMenu(e);
      }
    }, [onContextMenu, onContextMenuPress]);
    var keyDownHandler = React.useCallback(e => {
      if (onKeyDownPress != null) {
        onKeyDownPress(e);
      }
      if (onKeyDown != null) {
        onKeyDown(e);
      }
    }, [onKeyDown, onKeyDownPress]);
    var _tabIndex;
    if (tabIndex !== undefined) {
      _tabIndex = tabIndex;
    } else {
      _tabIndex = disabled ? -1 : 0;
    }
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
      "aria-disabled": disabled,
      onBlur: blurHandler,
      onContextMenu: contextMenuHandler,
      onFocus: focusHandler,
      onKeyDown: keyDownHandler,
      ref: setRef,
      style: [disabled ? styles.disabled : styles.active, typeof style === 'function' ? style(interactionState) : style],
      tabIndex: _tabIndex
    }), typeof children === 'function' ? children(interactionState) : children);
  }
  function useForceableState(forced) {
    var _useState = (0, _react.useState)(false),
      bool = _useState[0],
      setBool = _useState[1];
    return [bool || forced, setBool];
  }
  var styles = _StyleSheet.default.create({
    active: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    },
    disabled: {
      pointerEvents: 'box-none'
    }
  });
  var MemoedPressable = /*#__PURE__*/(0, _react.memo)(/*#__PURE__*/(0, _react.forwardRef)(Pressable));
  MemoedPressable.displayName = 'Pressable';
  var _default = exports.default = MemoedPressable;
},244,[17,888,873,3,116,245,232,30,111],"node_modules\\react-native-web\\dist\\exports\\Pressable\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useHover;
  var _modality = require(_dependencyMap[1], "../modality");
  var _useEvent = _interopRequireDefault(require(_dependencyMap[2], "../useEvent"));
  var _useLayoutEffect = _interopRequireDefault(require(_dependencyMap[3], "../useLayoutEffect"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Types
   */

  /**
   * Implementation
   */

  var emptyObject = {};
  var opts = {
    passive: true
  };
  var lockEventType = 'react-gui:hover:lock';
  var unlockEventType = 'react-gui:hover:unlock';
  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  function dispatchCustomEvent(target, type, payload) {
    var event = document.createEvent('CustomEvent');
    var _ref = payload || emptyObject,
      _ref$bubbles = _ref.bubbles,
      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,
      _ref$cancelable = _ref.cancelable,
      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,
      detail = _ref.detail;
    event.initCustomEvent(type, bubbles, cancelable, detail);
    target.dispatchEvent(event);
  }

  // This accounts for the non-PointerEvent fallback events.
  function getPointerType(event) {
    var pointerType = event.pointerType;
    return pointerType != null ? pointerType : (0, _modality.getModality)();
  }
  function useHover(targetRef, config) {
    var contain = config.contain,
      disabled = config.disabled,
      onHoverStart = config.onHoverStart,
      onHoverChange = config.onHoverChange,
      onHoverUpdate = config.onHoverUpdate,
      onHoverEnd = config.onHoverEnd;
    var canUsePE = supportsPointerEvent();
    var addMoveListener = (0, _useEvent.default)(canUsePE ? 'pointermove' : 'mousemove', opts);
    var addEnterListener = (0, _useEvent.default)(canUsePE ? 'pointerenter' : 'mouseenter', opts);
    var addLeaveListener = (0, _useEvent.default)(canUsePE ? 'pointerleave' : 'mouseleave', opts);
    // These custom events are used to implement the "contain" prop.
    var addLockListener = (0, _useEvent.default)(lockEventType, opts);
    var addUnlockListener = (0, _useEvent.default)(unlockEventType, opts);
    (0, _useLayoutEffect.default)(() => {
      var target = targetRef.current;
      if (target !== null) {
        /**
         * End the hover gesture
         */
        var hoverEnd = function hoverEnd(e) {
          if (onHoverEnd != null) {
            onHoverEnd(e);
          }
          if (onHoverChange != null) {
            onHoverChange(false);
          }
          // Remove the listeners once finished.
          addMoveListener(target, null);
          addLeaveListener(target, null);
        };

        /**
         * Leave element
         */
        var leaveListener = function leaveListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, unlockEventType);
            }
            hoverEnd(e);
          }
        };

        /**
         * Move within element
         */
        var moveListener = function moveListener(e) {
          if (getPointerType(e) !== 'touch') {
            if (onHoverUpdate != null) {
              // Not all browsers have these properties
              if (e.x == null) {
                e.x = e.clientX;
              }
              if (e.y == null) {
                e.y = e.clientY;
              }
              onHoverUpdate(e);
            }
          }
        };

        /**
         * Start the hover gesture
         */
        var hoverStart = function hoverStart(e) {
          if (onHoverStart != null) {
            onHoverStart(e);
          }
          if (onHoverChange != null) {
            onHoverChange(true);
          }
          // Set the listeners needed for the rest of the hover gesture.
          if (onHoverUpdate != null) {
            addMoveListener(target, !disabled ? moveListener : null);
          }
          addLeaveListener(target, !disabled ? leaveListener : null);
        };

        /**
         * Enter element
         */
        var enterListener = function enterListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, lockEventType);
            }
            hoverStart(e);
            var lockListener = function lockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverEnd(e);
              }
            };
            var unlockListener = function unlockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverStart(e);
              }
            };
            addLockListener(target, !disabled ? lockListener : null);
            addUnlockListener(target, !disabled ? unlockListener : null);
          }
        };
        addEnterListener(target, !disabled ? enterListener : null);
      }
    }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
  }
},245,[17,246,248,115],"node_modules\\react-native-web\\dist\\modules\\useHover\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addModalityListener = addModalityListener;
  exports.getActiveModality = getActiveModality;
  exports.getModality = getModality;
  exports.testOnly_resetActiveModality = testOnly_resetActiveModality;
  var _addEventListener = require(_dependencyMap[1], "../addEventListener");
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[2], "../canUseDom"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  var activeModality = 'keyboard';
  var modality = 'keyboard';
  var previousModality;
  var previousActiveModality;
  var isEmulatingMouseEvents = false;
  var listeners = new Set();
  var KEYBOARD = 'keyboard';
  var MOUSE = 'mouse';
  var TOUCH = 'touch';
  var BLUR = 'blur';
  var CONTEXTMENU = 'contextmenu';
  var FOCUS = 'focus';
  var KEYDOWN = 'keydown';
  var MOUSEDOWN = 'mousedown';
  var MOUSEMOVE = 'mousemove';
  var MOUSEUP = 'mouseup';
  var POINTERDOWN = 'pointerdown';
  var POINTERMOVE = 'pointermove';
  var SCROLL = 'scroll';
  var SELECTIONCHANGE = 'selectionchange';
  var TOUCHCANCEL = 'touchcancel';
  var TOUCHMOVE = 'touchmove';
  var TOUCHSTART = 'touchstart';
  var VISIBILITYCHANGE = 'visibilitychange';
  var bubbleOptions = {
    passive: true
  };
  var captureOptions = {
    capture: true,
    passive: true
  };
  function restoreModality() {
    if (previousModality != null || previousActiveModality != null) {
      if (previousModality != null) {
        modality = previousModality;
        previousModality = null;
      }
      if (previousActiveModality != null) {
        activeModality = previousActiveModality;
        previousActiveModality = null;
      }
      callListeners();
    }
  }
  function onBlurWindow() {
    previousModality = modality;
    previousActiveModality = activeModality;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
    callListeners();
    // for fallback events
    isEmulatingMouseEvents = false;
  }
  function onFocusWindow() {
    restoreModality();
  }
  function onKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    if (modality !== KEYBOARD) {
      modality = KEYBOARD;
      activeModality = KEYBOARD;
      callListeners();
    }
  }
  function onVisibilityChange() {
    if (document.visibilityState !== 'hidden') {
      restoreModality();
    }
  }
  function onPointerish(event) {
    var eventType = event.type;
    if (supportsPointerEvent()) {
      if (eventType === POINTERDOWN) {
        if (activeModality !== event.pointerType) {
          modality = event.pointerType;
          activeModality = event.pointerType;
          callListeners();
        }
        return;
      }
      if (eventType === POINTERMOVE) {
        if (modality !== event.pointerType) {
          modality = event.pointerType;
          callListeners();
        }
        return;
      }
    }
    // Fallback for non-PointerEvent environment
    else {
      if (!isEmulatingMouseEvents) {
        if (eventType === MOUSEDOWN) {
          if (activeModality !== MOUSE) {
            modality = MOUSE;
            activeModality = MOUSE;
            callListeners();
          }
        }
        if (eventType === MOUSEMOVE) {
          if (modality !== MOUSE) {
            modality = MOUSE;
            callListeners();
          }
        }
      }

      // Flag when browser may produce emulated events
      if (eventType === TOUCHSTART) {
        isEmulatingMouseEvents = true;
        if (event.touches && event.touches.length > 1) {
          isEmulatingMouseEvents = false;
        }
        if (activeModality !== TOUCH) {
          modality = TOUCH;
          activeModality = TOUCH;
          callListeners();
        }
        return;
      }

      // Remove flag after emulated events are finished or cancelled, and if an
      // event occurs that cuts short a touch event sequence.
      if (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) {
        isEmulatingMouseEvents = false;
      }
    }
  }
  if (_canUseDom.default) {
    // Window events
    (0, _addEventListener.addEventListener)(window, BLUR, onBlurWindow, bubbleOptions);
    (0, _addEventListener.addEventListener)(window, FOCUS, onFocusWindow, bubbleOptions);
    // Must be capture phase because 'stopPropagation' might prevent these
    // events bubbling to the document.
    (0, _addEventListener.addEventListener)(document, KEYDOWN, onKeyDown, captureOptions);
    (0, _addEventListener.addEventListener)(document, VISIBILITYCHANGE, onVisibilityChange, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERMOVE, onPointerish, captureOptions);
    // Fallback events
    (0, _addEventListener.addEventListener)(document, CONTEXTMENU, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEUP, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHCANCEL, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHSTART, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SELECTIONCHANGE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SCROLL, onPointerish, captureOptions);
  }
  function callListeners() {
    var value = {
      activeModality,
      modality
    };
    listeners.forEach(listener => {
      listener(value);
    });
  }
  function getActiveModality() {
    return activeModality;
  }
  function getModality() {
    return modality;
  }
  function addModalityListener(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  function testOnly_resetActiveModality() {
    isEmulatingMouseEvents = false;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
  }
},246,[17,247,39],"node_modules\\react-native-web\\dist\\modules\\modality\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addEventListener = addEventListener;
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[1], "../canUseDom"));
  var emptyFunction = () => {};
  function supportsPassiveEvents() {
    var supported = false;
    // Check if browser supports event with passive listeners
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    if (_canUseDom.default) {
      try {
        var options = {};
        Object.defineProperty(options, 'passive', {
          get() {
            supported = true;
            return false;
          }
        });
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
      } catch (e) {}
    }
    return supported;
  }
  var canUsePassiveEvents = supportsPassiveEvents();
  function getOptions(options) {
    if (options == null) {
      return false;
    }
    return canUsePassiveEvents ? options : Boolean(options.capture);
  }

  /**
   * Shim generic API compatibility with ReactDOM's synthetic events, without needing the
   * large amount of code ReactDOM uses to do this. Ideally we wouldn't use a synthetic
   * event wrapper at all.
   */
  function isPropagationStopped() {
    return this.cancelBubble;
  }
  function isDefaultPrevented() {
    return this.defaultPrevented;
  }
  function normalizeEvent(event) {
    event.nativeEvent = event;
    event.persist = emptyFunction;
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    return event;
  }

  /**
   *
   */
  function addEventListener(target, type, listener, options) {
    var opts = getOptions(options);
    var compatListener = e => listener(normalizeEvent(e));
    target.addEventListener(type, compatListener, opts);
    return function removeEventListener() {
      if (target != null) {
        target.removeEventListener(type, compatListener, opts);
      }
    };
  }
},247,[17,39],"node_modules\\react-native-web\\dist\\modules\\addEventListener\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useEvent;
  var _addEventListener = require(_dependencyMap[1], "../addEventListener");
  var _useLayoutEffect = _interopRequireDefault(require(_dependencyMap[2], "../useLayoutEffect"));
  var _useStable = _interopRequireDefault(require(_dependencyMap[3], "../useStable"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This can be used with any event type include custom events.
   *
   * const click = useEvent('click', options);
   * useEffect(() => {
   *   click.setListener(target, onClick);
   *   return () => click.clear();
   * }).
   */
  function useEvent(eventType, options) {
    var targetListeners = (0, _useStable.default)(() => new Map());
    var addListener = (0, _useStable.default)(() => {
      return (target, callback) => {
        var removeTargetListener = targetListeners.get(target);
        if (removeTargetListener != null) {
          removeTargetListener();
        }
        if (callback == null) {
          targetListeners.delete(target);
          callback = () => {};
        }
        var removeEventListener = (0, _addEventListener.addEventListener)(target, eventType, callback, options);
        targetListeners.set(target, removeEventListener);
        return removeEventListener;
      };
    });
    (0, _useLayoutEffect.default)(() => {
      return () => {
        targetListeners.forEach(removeListener => {
          removeListener();
        });
        targetListeners.clear();
      };
    }, [targetListeners]);
    return addListener;
  }
},248,[17,247,115,119],"node_modules\\react-native-web\\dist\\modules\\useEvent\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["color", "indeterminate", "progress", "trackColor", "style"];
  var ProgressBar = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
      _props$progress = props.progress,
      progress = _props$progress === void 0 ? 0 : _props$progress,
      _props$trackColor = props.trackColor,
      trackColor = _props$trackColor === void 0 ? 'transparent' : _props$trackColor,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var percentageProgress = progress * 100;
    var width = indeterminate ? '25%' : percentageProgress + "%";
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
      "aria-valuemax": 100,
      "aria-valuemin": 0,
      "aria-valuenow": indeterminate ? null : percentageProgress,
      ref: ref,
      role: "progressbar",
      style: [styles.track, style, {
        backgroundColor: trackColor
      }]
    }), /*#__PURE__*/React.createElement(_View.default, {
      style: [{
        backgroundColor: color,
        width
      }, styles.progress, indeterminate && styles.animation]
    }));
  });
  ProgressBar.displayName = 'ProgressBar';
  var styles = _StyleSheet.default.create({
    track: {
      forcedColorAdjust: 'none',
      height: 5,
      overflow: 'hidden',
      userSelect: 'none',
      zIndex: 0
    },
    progress: {
      forcedColorAdjust: 'none',
      height: '100%',
      zIndex: -1
    },
    animation: {
      animationDuration: '1s',
      animationKeyframes: [{
        '0%': {
          transform: 'translateX(-100%)'
        },
        '100%': {
          transform: 'translateX(400%)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    }
  });
  var _default = exports.default = ProgressBar;
},249,[17,888,873,3,30,111],"node_modules\\react-native-web\\dist\\exports\\ProgressBar\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "../View"));
  var _canUseDom = _interopRequireDefault(require(_dependencyMap[6], "../../modules/canUseDom"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cssFunction = function () {
    if (_canUseDom.default && window.CSS && window.CSS.supports && window.CSS.supports('top: constant(safe-area-inset-top)')) {
      return 'constant';
    }
    return 'env';
  }();
  var SafeAreaView = /*#__PURE__*/React.forwardRef((props, ref) => {
    var style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
      ref: ref,
      style: [styles.root, style]
    }));
  });
  SafeAreaView.displayName = 'SafeAreaView';
  var styles = _StyleSheet.default.create({
    root: {
      paddingTop: cssFunction + "(safe-area-inset-top)",
      paddingRight: cssFunction + "(safe-area-inset-right)",
      paddingBottom: cssFunction + "(safe-area-inset-bottom)",
      paddingLeft: cssFunction + "(safe-area-inset-left)"
    }
  });
  var _default = exports.default = SafeAreaView;
},250,[17,888,873,3,30,111,39],"node_modules\\react-native-web\\dist\\exports\\SafeAreaView\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  function StatusBar() {
    return null;
  }
  StatusBar.setBackgroundColor = emptyFunction;
  StatusBar.setBarStyle = emptyFunction;
  StatusBar.setHidden = emptyFunction;
  StatusBar.setNetworkActivityIndicatorVisible = emptyFunction;
  StatusBar.setTranslucent = emptyFunction;
  var _default = exports.default = StatusBar;
},251,[],"node_modules\\react-native-web\\dist\\exports\\StatusBar\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2"));
  var _extends2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[5], "../createElement"));
  var _multiplyStyleLengthValue = _interopRequireDefault(require(_dependencyMap[6], "../../modules/multiplyStyleLengthValue"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[8], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["aria-label", "accessibilityLabel", "activeThumbColor", "activeTrackColor", "disabled", "onValueChange", "style", "thumbColor", "trackColor", "value"];
  var emptyObject = {};
  var thumbDefaultBoxShadow = '0px 1px 3px rgba(0,0,0,0.5)';
  var thumbFocusedBoxShadow = thumbDefaultBoxShadow + ", 0 0 0 10px rgba(0,0,0,0.1)";
  var defaultActiveTrackColor = '#A3D3CF';
  var defaultTrackColor = '#939393';
  var defaultDisabledTrackColor = '#D5D5D5';
  var defaultActiveThumbColor = '#009688';
  var defaultThumbColor = '#FAFAFA';
  var defaultDisabledThumbColor = '#BDBDBD';
  var Switch = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      activeThumbColor = props.activeThumbColor,
      activeTrackColor = props.activeTrackColor,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      onValueChange = props.onValueChange,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      thumbColor = props.thumbColor,
      trackColor = props.trackColor,
      _props$value = props.value,
      value = _props$value === void 0 ? false : _props$value,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var thumbRef = React.useRef(null);
    function handleChange(event) {
      if (onValueChange != null) {
        onValueChange(event.nativeEvent.target.checked);
      }
    }
    function handleFocusState(event) {
      var isFocused = event.nativeEvent.type === 'focus';
      var boxShadow = isFocused ? thumbFocusedBoxShadow : thumbDefaultBoxShadow;
      if (thumbRef.current != null) {
        thumbRef.current.style.boxShadow = boxShadow;
      }
    }
    var _StyleSheet$flatten = _StyleSheet.default.flatten(style),
      styleHeight = _StyleSheet$flatten.height,
      styleWidth = _StyleSheet$flatten.width;
    var height = styleHeight || '20px';
    var minWidth = (0, _multiplyStyleLengthValue.default)(height, 2);
    var width = styleWidth > minWidth ? styleWidth : minWidth;
    var trackBorderRadius = (0, _multiplyStyleLengthValue.default)(height, 0.5);
    var trackCurrentColor = function () {
      if (value === true) {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.true;
        } else {
          return activeTrackColor !== null && activeTrackColor !== void 0 ? activeTrackColor : defaultActiveTrackColor;
        }
      } else {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.false;
        } else {
          return trackColor !== null && trackColor !== void 0 ? trackColor : defaultTrackColor;
        }
      }
    }();
    var thumbCurrentColor = value ? activeThumbColor !== null && activeThumbColor !== void 0 ? activeThumbColor : defaultActiveThumbColor : thumbColor !== null && thumbColor !== void 0 ? thumbColor : defaultThumbColor;
    var thumbHeight = height;
    var thumbWidth = thumbHeight;
    var rootStyle = [styles.root, style, disabled && styles.cursorDefault, {
      height,
      width
    }];
    var disabledTrackColor = function () {
      if (value === true) {
        if (typeof activeTrackColor === 'string' && activeTrackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.true) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      } else {
        if (typeof trackColor === 'string' && trackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.false) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      }
    }();
    var disabledThumbColor = function () {
      if (value === true) {
        if (activeThumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      } else {
        if (thumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      }
    }();
    var trackStyle = [styles.track, {
      backgroundColor: disabled ? disabledTrackColor : trackCurrentColor,
      borderRadius: trackBorderRadius
    }];
    var thumbStyle = [styles.thumb, value && styles.thumbActive, {
      backgroundColor: disabled ? disabledThumbColor : thumbCurrentColor,
      height: thumbHeight,
      marginStart: value ? (0, _multiplyStyleLengthValue.default)(thumbWidth, -1) : 0,
      width: thumbWidth
    }];
    var nativeControl = (0, _createElement.default)('input', {
      'aria-label': ariaLabel || accessibilityLabel,
      checked: value,
      disabled: disabled,
      onBlur: handleFocusState,
      onChange: handleChange,
      onFocus: handleFocusState,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox',
      role: 'switch'
    });
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
      style: rootStyle
    }), /*#__PURE__*/React.createElement(_View.default, {
      style: trackStyle
    }), /*#__PURE__*/React.createElement(_View.default, {
      ref: thumbRef,
      style: thumbStyle
    }), nativeControl);
  });
  Switch.displayName = 'Switch';
  var styles = _StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      userSelect: 'none'
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    track: (0, _objectSpread2.default)((0, _objectSpread2.default)({
      forcedColorAdjust: 'none'
    }, _StyleSheet.default.absoluteFillObject), {}, {
      height: '70%',
      margin: 'auto',
      transitionDuration: '0.1s',
      width: '100%'
    }),
    thumb: {
      forcedColorAdjust: 'none',
      alignSelf: 'flex-start',
      borderRadius: '100%',
      boxShadow: thumbDefaultBoxShadow,
      start: '0%',
      transform: 'translateZ(0)',
      transitionDuration: '0.1s'
    },
    thumbActive: {
      insetInlineStart: '100%'
    },
    nativeControl: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = exports.default = Switch;
},252,[17,868,888,873,3,18,253,30,111],"node_modules\\react-native-web\\dist\\exports\\Switch\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var CSS_UNIT_RE = /^[+-]?\d*(?:\.\d+)?(?:[Ee][+-]?\d+)?(%|\w*)/;
  var getUnit = str => str.match(CSS_UNIT_RE)[1];
  var isNumeric = n => {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };
  var multiplyStyleLengthValue = (value, multiple) => {
    if (typeof value === 'string') {
      var number = parseFloat(value) * multiple;
      var unit = getUnit(value);
      return "" + number + unit;
    } else if (isNumeric(value)) {
      return value * multiple;
    }
  };
  var _default = exports.default = multiplyStyleLengthValue;
},253,[],"node_modules\\react-native-web\\dist\\modules\\multiplyStyleLengthValue\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[2], "../createElement"));
  var forwardedProps = _interopRequireWildcard(require(_dependencyMap[3], "../../modules/forwardedProps"));
  var _pick = _interopRequireDefault(require(_dependencyMap[4], "../../modules/pick"));
  var _useElementLayout = _interopRequireDefault(require(_dependencyMap[5], "../../modules/useElementLayout"));
  var _useLayoutEffect = _interopRequireDefault(require(_dependencyMap[6], "../../modules/useLayoutEffect"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[7], "../../modules/useMergeRefs"));
  var _usePlatformMethods = _interopRequireDefault(require(_dependencyMap[8], "../../modules/usePlatformMethods"));
  var _useResponderEvents = _interopRequireDefault(require(_dependencyMap[9], "../../modules/useResponderEvents"));
  var _useLocale = require(_dependencyMap[10], "../../modules/useLocale");
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[11], "../StyleSheet"));
  var _TextInputState = _interopRequireDefault(require(_dependencyMap[12], "../../modules/TextInputState"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * Determines whether a 'selection' prop differs from a node's existing
   * selection state.
   */
  var isSelectionStale = (node, selection) => {
    var selectionEnd = node.selectionEnd,
      selectionStart = node.selectionStart;
    var start = selection.start,
      end = selection.end;
    return start !== selectionStart || end !== selectionEnd;
  };

  /**
   * Certain input types do no support 'selectSelectionRange' and will throw an
   * error.
   */
  var setSelection = (node, selection) => {
    if (isSelectionStale(node, selection)) {
      var start = selection.start,
        end = selection.end;
      try {
        node.setSelectionRange(start, end || start);
      } catch (e) {}
    }
  };
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    autoCapitalize: true,
    autoComplete: true,
    autoCorrect: true,
    autoFocus: true,
    defaultValue: true,
    disabled: true,
    lang: true,
    maxLength: true,
    onChange: true,
    onScroll: true,
    placeholder: true,
    pointerEvents: true,
    readOnly: true,
    rows: true,
    spellCheck: true,
    value: true,
    type: true
  });
  var pickProps = props => (0, _pick.default)(props, forwardPropsList);

  // If an Input Method Editor is processing key input, the 'keyCode' is 229.
  // https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
  function isEventComposing(nativeEvent) {
    return nativeEvent.isComposing || nativeEvent.keyCode === 229;
  }
  var focusTimeout = null;
  var TextInput = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$autoCapitalize = props.autoCapitalize,
      autoCapitalize = _props$autoCapitalize === void 0 ? 'sentences' : _props$autoCapitalize,
      autoComplete = props.autoComplete,
      autoCompleteType = props.autoCompleteType,
      _props$autoCorrect = props.autoCorrect,
      autoCorrect = _props$autoCorrect === void 0 ? true : _props$autoCorrect,
      blurOnSubmit = props.blurOnSubmit,
      caretHidden = props.caretHidden,
      clearTextOnFocus = props.clearTextOnFocus,
      dir = props.dir,
      editable = props.editable,
      enterKeyHint = props.enterKeyHint,
      inputMode = props.inputMode,
      keyboardType = props.keyboardType,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      numberOfLines = props.numberOfLines,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onChangeText = props.onChangeText,
      onContentSizeChange = props.onContentSizeChange,
      onFocus = props.onFocus,
      onKeyPress = props.onKeyPress,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChange = props.onSelectionChange,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      onSubmitEditing = props.onSubmitEditing,
      placeholderTextColor = props.placeholderTextColor,
      _props$readOnly = props.readOnly,
      readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
      returnKeyType = props.returnKeyType,
      rows = props.rows,
      _props$secureTextEntr = props.secureTextEntry,
      secureTextEntry = _props$secureTextEntr === void 0 ? false : _props$secureTextEntr,
      selection = props.selection,
      selectTextOnFocus = props.selectTextOnFocus,
      showSoftInputOnFocus = props.showSoftInputOnFocus,
      spellCheck = props.spellCheck;
    var type;
    var _inputMode;
    if (inputMode != null) {
      _inputMode = inputMode;
      if (inputMode === 'email') {
        type = 'email';
      } else if (inputMode === 'tel') {
        type = 'tel';
      } else if (inputMode === 'search') {
        type = 'search';
      } else if (inputMode === 'url') {
        type = 'url';
      } else {
        type = 'text';
      }
    } else if (keyboardType != null) {
      // warnOnce('keyboardType', 'keyboardType is deprecated. Use inputMode.');
      switch (keyboardType) {
        case 'email-address':
          type = 'email';
          break;
        case 'number-pad':
        case 'numeric':
          _inputMode = 'numeric';
          break;
        case 'decimal-pad':
          _inputMode = 'decimal';
          break;
        case 'phone-pad':
          type = 'tel';
          break;
        case 'search':
        case 'web-search':
          type = 'search';
          break;
        case 'url':
          type = 'url';
          break;
        default:
          type = 'text';
      }
    }
    if (secureTextEntry) {
      type = 'password';
    }
    var dimensions = React.useRef({
      height: null,
      width: null
    });
    var hostRef = React.useRef(null);
    var prevSelection = React.useRef(null);
    var prevSecureTextEntry = React.useRef(false);
    React.useEffect(() => {
      if (hostRef.current && prevSelection.current) {
        setSelection(hostRef.current, prevSelection.current);
      }
      prevSecureTextEntry.current = secureTextEntry;
    }, [secureTextEntry]);
    var handleContentSizeChange = React.useCallback(hostNode => {
      if (multiline && onContentSizeChange && hostNode != null) {
        var newHeight = hostNode.scrollHeight;
        var newWidth = hostNode.scrollWidth;
        if (newHeight !== dimensions.current.height || newWidth !== dimensions.current.width) {
          dimensions.current.height = newHeight;
          dimensions.current.width = newWidth;
          onContentSizeChange({
            nativeEvent: {
              contentSize: {
                height: dimensions.current.height,
                width: dimensions.current.width
              }
            }
          });
        }
      }
    }, [multiline, onContentSizeChange]);
    var imperativeRef = React.useMemo(() => hostNode => {
      // TextInput needs to add more methods to the hostNode in addition to those
      // added by `usePlatformMethods`. This is temporarily until an API like
      // `TextInput.clear(hostRef)` is added to React Native.
      if (hostNode != null) {
        hostNode.clear = function () {
          if (hostNode != null) {
            hostNode.value = '';
          }
        };
        hostNode.isFocused = function () {
          return hostNode != null && _TextInputState.default.currentlyFocusedField() === hostNode;
        };
        handleContentSizeChange(hostNode);
      }
    }, [handleContentSizeChange]);
    function handleBlur(e) {
      _TextInputState.default._currentlyFocusedNode = null;
      if (onBlur) {
        e.nativeEvent.text = e.target.value;
        onBlur(e);
      }
    }
    function handleChange(e) {
      var hostNode = e.target;
      var text = hostNode.value;
      e.nativeEvent.text = text;
      handleContentSizeChange(hostNode);
      if (onChange) {
        onChange(e);
      }
      if (onChangeText) {
        onChangeText(text);
      }
    }
    function handleFocus(e) {
      var hostNode = e.target;
      if (onFocus) {
        e.nativeEvent.text = hostNode.value;
        onFocus(e);
      }
      if (hostNode != null) {
        _TextInputState.default._currentlyFocusedNode = hostNode;
        if (clearTextOnFocus) {
          hostNode.value = '';
        }
        if (selectTextOnFocus) {
          // Safari requires selection to occur in a setTimeout
          if (focusTimeout != null) {
            clearTimeout(focusTimeout);
          }
          focusTimeout = setTimeout(() => {
            // Check if the input is still focused after the timeout
            // (see #2704)
            if (hostNode != null && document.activeElement === hostNode) {
              hostNode.select();
            }
          }, 0);
        }
      }
    }
    function handleKeyDown(e) {
      var hostNode = e.target;
      // Prevent key events bubbling (see #612)
      e.stopPropagation();
      var blurOnSubmitDefault = !multiline;
      var shouldBlurOnSubmit = blurOnSubmit == null ? blurOnSubmitDefault : blurOnSubmit;
      var nativeEvent = e.nativeEvent;
      var isComposing = isEventComposing(nativeEvent);
      if (onKeyPress) {
        onKeyPress(e);
      }
      if (e.key === 'Enter' && !e.shiftKey &&
      // Do not call submit if composition is occuring.
      !isComposing && !e.isDefaultPrevented()) {
        if ((blurOnSubmit || !multiline) && onSubmitEditing) {
          // prevent "Enter" from inserting a newline or submitting a form
          e.preventDefault();
          nativeEvent.text = e.target.value;
          onSubmitEditing(e);
        }
        if (shouldBlurOnSubmit && hostNode != null) {
          setTimeout(() => hostNode.blur(), 0);
        }
      }
    }
    function handleSelectionChange(e) {
      try {
        var _e$target = e.target,
          selectionStart = _e$target.selectionStart,
          selectionEnd = _e$target.selectionEnd;
        var _selection = {
          start: selectionStart,
          end: selectionEnd
        };
        if (onSelectionChange) {
          e.nativeEvent.selection = _selection;
          e.nativeEvent.text = e.target.value;
          onSelectionChange(e);
        }
        if (prevSecureTextEntry.current === secureTextEntry) {
          prevSelection.current = _selection;
        }
      } catch (e) {}
    }
    (0, _useLayoutEffect.default)(() => {
      var node = hostRef.current;
      if (node != null && selection != null) {
        setSelection(node, selection);
      }
      if (document.activeElement === node) {
        _TextInputState.default._currentlyFocusedNode = node;
      }
    }, [hostRef, selection]);
    var component = multiline ? 'textarea' : 'input';
    (0, _useElementLayout.default)(hostRef, onLayout);
    (0, _useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    var supportedProps = pickProps(props);
    supportedProps.autoCapitalize = autoCapitalize;
    supportedProps.autoComplete = autoComplete || autoCompleteType || 'on';
    supportedProps.autoCorrect = autoCorrect ? 'on' : 'off';
    // 'auto' by default allows browsers to infer writing direction
    supportedProps.dir = dir !== undefined ? dir : 'auto';
    /*
    if (returnKeyType != null) {
      warnOnce('returnKeyType', 'returnKeyType is deprecated. Use enterKeyHint.');
    }
    */
    supportedProps.enterKeyHint = enterKeyHint || returnKeyType;
    supportedProps.inputMode = _inputMode;
    supportedProps.onBlur = handleBlur;
    supportedProps.onChange = handleChange;
    supportedProps.onFocus = handleFocus;
    supportedProps.onKeyDown = handleKeyDown;
    supportedProps.onSelect = handleSelectionChange;
    /*
    if (editable != null) {
      warnOnce('editable', 'editable is deprecated. Use readOnly.');
    }
    */
    supportedProps.readOnly = readOnly === true || editable === false;
    /*
    if (numberOfLines != null) {
      warnOnce(
        'numberOfLines',
        'TextInput numberOfLines is deprecated. Use rows.'
      );
    }
    */
    supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1;
    supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect;
    supportedProps.style = [{
      '--placeholderTextColor': placeholderTextColor
    }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden];
    supportedProps.type = multiline ? undefined : type;
    supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? 'manual' : 'auto';
    var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
    var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
    supportedProps.ref = setRef;
    var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var element = (0, _createElement.default)(component, supportedProps, {
      writingDirection
    });
    return element;
  });
  TextInput.displayName = 'TextInput';
  // $FlowFixMe
  TextInput.State = _TextInputState.default;
  var styles = _StyleSheet.default.create({
    textinput$raw: {
      MozAppearance: 'textfield',
      WebkitAppearance: 'none',
      backgroundColor: 'transparent',
      border: '0 solid black',
      borderRadius: 0,
      boxSizing: 'border-box',
      font: '14px System',
      margin: 0,
      padding: 0,
      resize: 'none'
    },
    placeholder: {
      placeholderTextColor: 'var(--placeholderTextColor)'
    },
    caretHidden: {
      caretColor: 'transparent'
    }
  });
  var _default = exports.default = TextInput;
},254,[17,3,18,112,113,114,115,116,118,120,85,30,138],"node_modules\\react-native-web\\dist\\exports\\TextInput\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _objectSpread2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectSpread2"));
  var _AccessibilityUtil = _interopRequireDefault(require(_dependencyMap[3], "../../modules/AccessibilityUtil"));
  var _BoundingDimensions = _interopRequireDefault(require(_dependencyMap[4], "./BoundingDimensions"));
  var _normalizeColors = _interopRequireDefault(require(_dependencyMap[5], "@react-native/normalize-colors"));
  var _Position = _interopRequireDefault(require(_dependencyMap[6], "./Position"));
  var _react = _interopRequireDefault(require(_dependencyMap[7], "react"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[8], "../UIManager"));
  var _View = _interopRequireDefault(require(_dependencyMap[9], "../View"));
  var _warnOnce = require(_dependencyMap[10], "../../modules/warnOnce");
  var extractSingleTouch = nativeEvent => {
    var touches = nativeEvent.touches;
    var changedTouches = nativeEvent.changedTouches;
    var hasTouches = touches && touches.length > 0;
    var hasChangedTouches = changedTouches && changedTouches.length > 0;
    return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
  };

  /**
   * `Touchable`: Taps done right.
   *
   * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`
   * will measure time/geometry and tells you when to give feedback to the user.
   *
   * ====================== Touchable Tutorial ===============================
   * The `Touchable` mixin helps you handle the "press" interaction. It analyzes
   * the geometry of elements, and observes when another responder (scroll view
   * etc) has stolen the touch lock. It notifies your component when it should
   * give feedback to the user. (bouncing/highlighting/unhighlighting).
   *
   * - When a touch was activated (typically you highlight)
   * - When a touch was deactivated (typically you unhighlight)
   * - When a touch was "pressed" - a touch ended while still within the geometry
   *   of the element, and no other element (like scroller) has "stolen" touch
   *   lock ("responder") (Typically you bounce the element).
   *
   * A good tap interaction isn't as simple as you might think. There should be a
   * slight delay before showing a highlight when starting a touch. If a
   * subsequent touch move exceeds the boundary of the element, it should
   * unhighlight, but if that same touch is brought back within the boundary, it
   * should rehighlight again. A touch can move in and out of that boundary
   * several times, each time toggling highlighting, but a "press" is only
   * triggered if that touch ends while within the element's boundary and no
   * scroller (or anything else) has stolen the lock on touches.
   *
   * To create a new type of component that handles interaction using the
   * `Touchable` mixin, do the following:
   *
   * - Initialize the `Touchable` state.
   *
   *   getInitialState: function() {
   *     return merge(this.touchableGetInitialState(), yourComponentState);
   *   }
   *
   * - Add a method to get your touchable component's node.
   *   getTouchableNode: function() {
   *     return this.touchableRef.current
   *   }
   *
   * - Choose the rendered component who's touches should start the interactive
   *   sequence. On that rendered node, forward all `Touchable` responder
   *   handlers. You can choose any rendered node you like. Choose a node whose
   *   hit target you'd like to instigate the interaction sequence:
   *
   *   // In render function:
   *   return (
   *     <View
   *       ref={this.touchableRef}
   *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}
   *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}
   *       onResponderGrant={this.touchableHandleResponderGrant}
   *       onResponderMove={this.touchableHandleResponderMove}
   *       onResponderRelease={this.touchableHandleResponderRelease}
   *       onResponderTerminate={this.touchableHandleResponderTerminate}>
   *       <View>
   *         Even though the hit detection/interactions are triggered by the
   *         wrapping (typically larger) node, we usually end up implementing
   *         custom logic that highlights this inner one.
   *       </View>
   *     </View>
   *   );
   *
   * - You may set up your own handlers for each of these events, so long as you
   *   also invoke the `touchable*` handlers inside of your custom handler.
   *
   * - Implement the handlers on your component class in order to provide
   *   feedback to the user. See documentation for each of these class methods
   *   that you should implement.
   *
   *   touchableHandlePress: function() {
   *      this.performBounceAnimation();  // or whatever you want to do.
   *   },
   *   touchableHandleActivePressIn: function() {
   *     this.beginHighlighting(...);  // Whatever you like to convey activation
   *   },
   *   touchableHandleActivePressOut: function() {
   *     this.endHighlighting(...);  // Whatever you like to convey deactivation
   *   },
   *
   * - There are more advanced methods you can implement (see documentation below):
   *   touchableGetHighlightDelayMS: function() {
   *     return 20;
   *   }
   *   // In practice, *always* use a predeclared constant (conserve memory).
   *   touchableGetPressRectOffset: function() {
   *     return {top: 20, left: 20, right: 20, bottom: 100};
   *   }
   */

  /**
   * Touchable states.
   */

  var States = {
    NOT_RESPONDER: 'NOT_RESPONDER',
    // Not the responder
    RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',
    // Responder, inactive, in the `PressRect`
    RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',
    // Responder, inactive, out of `PressRect`
    RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',
    // Responder, active, in the `PressRect`
    RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',
    // Responder, active, out of `PressRect`
    RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    // Responder, active, in the `PressRect`, after long press threshold
    RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
    // Responder, active, out of `PressRect`, after long press threshold
    ERROR: 'ERROR'
  };
  /*
   * Quick lookup map for states that are considered to be "active"
   */

  var baseStatesConditions = {
    NOT_RESPONDER: false,
    RESPONDER_INACTIVE_PRESS_IN: false,
    RESPONDER_INACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_PRESS_IN: false,
    RESPONDER_ACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_LONG_PRESS_IN: false,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: false,
    ERROR: false
  };
  var IsActive = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  });

  /**
   * Quick lookup for states that are considered to be "pressing" and are
   * therefore eligible to result in a "selection" if the press stops.
   */
  var IsPressingIn = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });
  var IsLongPressingIn = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });

  /**
   * Inputs to the state machine.
   */
  var Signals = {
    DELAY: 'DELAY',
    RESPONDER_GRANT: 'RESPONDER_GRANT',
    RESPONDER_RELEASE: 'RESPONDER_RELEASE',
    RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',
    ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',
    LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',
    LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'
  };
  /**
   * Mapping from States x Signals => States
   */
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };

  // ==== Typical Constants for integrating into UI components ====
  // var HIT_EXPAND_PX = 20;
  // var HIT_VERT_OFFSET_PX = 10;
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;

  // Default amount "active" region protrudes beyond box

  /**
   * By convention, methods prefixed with underscores are meant to be @private,
   * and not @protected. Mixers shouldn't access them - not even to provide them
   * as callback handlers.
   *
   *
   * ========== Geometry =========
   * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   *  +--------------------------+
   *  |                          | - "Start" events in `HitRect` cause `HitRect`
   *  |  +--------------------+  |   to become the responder.
   *  |  |  +--------------+  |  | - `HitRect` is typically expanded around
   *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.
   *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,
   *  |  |  |              |  |  |   and before letting up, the Visual React
   *  |  |  +--------------+  |  |   will become "active". This makes it eligible
   *  |  |     HitRect        |  |   for being highlighted (so long as the
   *  |  +--------------------+  |   press remains in the `PressRect`).
   *  |        PressRect     o   |
   *  +----------------------|---+
   *           Out Region    |
   *                         +-----+ This gap between the `HitRect` and
   *                                 `PressRect` allows a touch to move far away
   *                                 from the original hit rect, and remain
   *                                 highlighted, and eligible for a "Press".
   *                                 Customize this via
   *                                 `touchableGetPressRectOffset()`.
   *
   *
   *
   * ======= State Machine =======
   *
   * +-------------+ <---+ RESPONDER_RELEASE
   * |NOT_RESPONDER|
   * +-------------+ <---+ RESPONDER_TERMINATED
   *     +
   *     | RESPONDER_GRANT (HitRect)
   *     v
   * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+
   * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|
   * +---------------------------+          +-------------------------+                +------------------------------+
   *     +            ^                         +           ^                                 +           ^
   *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_
   *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT
   *     |            |                         |           |                                 |           |
   *     v            +                         v           +                                 v           +
   * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+
   * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|
   * +----------------------------+         +--------------------------+               +-------------------------------+
   *
   * T + DELAY => LONG_PRESS_DELAY_MS + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the `touchableHandlePress` abstract method invocation that occurs
   * when a responder is released while in either of the "Press" states.
   *
   * The other important side effects are the highlight abstract method
   * invocations (internal callbacks) to be implemented by the mixer.
   *
   *
   * @lends Touchable.prototype
   */
  var TouchableMixin = {
    // HACK (part 1): basic support for touchable interactions using a keyboard
    componentDidMount: function componentDidMount() {
      (0, _warnOnce.warnOnce)('TouchableMixin', 'TouchableMixin is deprecated. Please use Pressable.');
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        this._touchableBlurListener = e => {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderTerminate({
                nativeEvent: e
              });
            }
            this._isTouchableKeyboardActive = false;
          }
        };
        touchableNode.addEventListener('blur', this._touchableBlurListener);
      }
    },
    /**
     * Clear all timeouts on unmount
     */
    componentWillUnmount: function componentWillUnmount() {
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        touchableNode.removeEventListener('blur', this._touchableBlurListener);
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      // Clear DOM nodes
      this.pressInLocation = null;
      this.state.touchable.responderID = null;
    },
    /**
     * It's prefer that mixins determine state in this way, having the class
     * explicitly mix the state in the one and only `getInitialState` method.
     *
     * @return {object} State object to be placed inside of
     * `this.state.touchable`.
     */
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    // ==== Hooks to Gesture Responder system ====
    /**
     * Must return true if embedded in a native platform scroll view.
     */
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    /**
     * Must return true to start the process of `Touchable`.
     */
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    /**
     * Return true to cancel press on long press.
     */
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    /**
     * Place as callback for a DOM element's `onResponderGrant` event.
     * @param {SyntheticEvent} e Synthetic event from event system.
     *
     */
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      // Since e is used in a callback invoked on another event loop
      // (as in setTimeout etc), we need to call e.persist() on the
      // event to make sure it doesn't get reused in the event object pool.
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;
      this._receiveSignal(Signals.RESPONDER_GRANT, e);
      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;
      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }
      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    /**
     * Place as callback for a DOM element's `onResponderRelease` event.
     */
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderTerminate` event.
     */
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderMove` event.
     */
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      // Measurement may not have returned yet.
      if (!this.state.touchable.positionOnActivate) {
        return;
      }
      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;
      if (hitSlop) {
        pressExpandLeft += hitSlop.left || 0;
        pressExpandTop += hitSlop.top || 0;
        pressExpandRight += hitSlop.right || 0;
        pressExpandBottom += hitSlop.bottom || 0;
      }
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);
        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }
      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;
      if (isTouchWithinActive) {
        var prevState = this.state.touchable.touchState;
        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);
        var curState = this.state.touchable.touchState;
        if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {
          // fix for t7967420
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();
        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    /**
     * Invoked when the item receives focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * currently has the focus. Most platforms only support a single element being
     * focused at a time, in which case there may have been a previously focused
     * element that was blurred just prior to this. This can be overridden when
     * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleFocus: function touchableHandleFocus(e) {
      this.props.onFocus && this.props.onFocus(e);
    },
    /**
     * Invoked when the item loses focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * no longer has focus. Most platforms only support a single element being
     * focused at a time, in which case the focus may have moved to another.
     * This can be overridden when using
     * `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleBlur: function touchableHandleBlur(e) {
      this.props.onBlur && this.props.onBlur(e);
    },
    // ==== Abstract Application Callbacks ====

    /**
     * Invoked when the item should be highlighted. Mixers should implement this
     * to visually distinguish the `VisualRect` so that the user knows that
     * releasing a touch will result in a "selection" (analog to click).
     *
     * @abstract
     * touchableHandleActivePressIn: function,
     */

    /**
     * Invoked when the item is "active" (in that it is still eligible to become
     * a "select") but the touch has left the `PressRect`. Usually the mixer will
     * want to unhighlight the `VisualRect`. If the user (while pressing) moves
     * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
     * again and the mixer should probably highlight the `VisualRect` again. This
     * event will not fire on an `touchEnd/mouseUp` event, only move events while
     * the user is depressing the mouse/touch.
     *
     * @abstract
     * touchableHandleActivePressOut: function
     */

    /**
     * Invoked when the item is "selected" - meaning the interaction ended by
     * letting up while the item was either in the state
     * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
     *
     * @abstract
     * touchableHandlePress: function
     */

    /**
     * Invoked when the item is long pressed - meaning the interaction ended by
     * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
     * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
     * be called as it normally is. If `touchableHandleLongPress` is provided, by
     * default any `touchableHandlePress` callback will not be invoked. To
     * override this default behavior, override `touchableLongPressCancelsPress`
     * to return false. As a result, `touchableHandlePress` will be called when
     * lifting up, even if `touchableHandleLongPress` has also been called.
     *
     * @abstract
     * touchableHandleLongPress: function
     */

    /**
     * Returns the number of millis to wait before triggering a highlight.
     *
     * @abstract
     * touchableGetHighlightDelayMS: function
     */

    /**
     * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
     * numbers mean the size expands outwards.
     *
     * @abstract
     * touchableGetPressRectOffset: function
     */

    // ==== Internal Logic ====

    /**
     * Measures the `HitRect` node on activation. The Bounding rectangle is with
     * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`
     * should result in points that are in the same coordinate system as an
     * event's `globalX/globalY` data values.
     *
     * - Consider caching this for the lifetime of the component, or possibly
     *   being able to share this cache between any `ScrollMap` view.
     *
     * @sideeffects
     * @private
     */
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var tag = this.state.touchable.responderID;
      if (tag == null) {
        return;
      }
      _UIManager.default.measure(tag, this._handleQueryLayout);
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      //don't do anything UIManager failed to measure node
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }
      this.state.touchable.positionOnActivate && _Position.default.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate &&
      // $FlowFixMe
      _BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = _Position.default.getPooled(globalX, globalY);
      // $FlowFixMe
      this.state.touchable.dimensionsOnActivate = _BoundingDimensions.default.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;
      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;
      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
      } else {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     *
     * @param {Signals} signal State machine signal.
     * @throws Error if invalid state transition or unrecognized signal.
     * @sideeffects
     */
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];
      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }
      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
      }
      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
      }
      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);
        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX,
        pageY,
        locationX,
        locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    /**
     * Will perform a transition between touchable states, and identify any
     * highlighting or unhighlighting that must be performed for this particular
     * transition.
     *
     * @param {States} curState Current Touchable state.
     * @param {States} nextState Next Touchable state.
     * @param {Signal} signal Signal that triggered the transition.
     * @param {Event} e Native event.
     * @sideeffects
     */
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);
      var newIsHighlight = this._isHighlight(nextState);
      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;
      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }
      var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;
      var isActiveTransition = !IsActive[curState] && IsActive[nextState];
      if (isInitialTransition || isActiveTransition) {
        this._remeasureMetricsOnActivation();
      }
      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }
      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }
      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (
        // We *are* long pressing.. // But either has no long handler
        !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.

        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;
        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            // we never highlighted because of delay, but we should highlight now
            this._startHighlight(e);
            this._endHighlight(e);
          }
          this.touchableHandlePress(e);
        }
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _playTouchSound: function _playTouchSound() {
      _UIManager.default.playTouchSound();
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);
      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(() => {
            this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    },
    // HACK (part 2): basic support for touchable interactions using a keyboard (including
    // delays and longPress)
    touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {
      var type = e.type,
        key = e.key;
      if (key === 'Enter' || key === ' ') {
        if (type === 'keydown') {
          if (!this._isTouchableKeyboardActive) {
            if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {
              this.touchableHandleResponderGrant(e);
              this._isTouchableKeyboardActive = true;
            }
          }
        } else if (type === 'keyup') {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderRelease(e);
              this._isTouchableKeyboardActive = false;
            }
          }
        }
        e.stopPropagation();
        // prevent the default behaviour unless the Touchable functions as a link
        // and Enter is pressed
        if (!(key === 'Enter' && _AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {
          e.preventDefault();
        }
      }
    },
    withoutDefaultFocusAndBlur: {}
  };

  /**
   * Provide an optional version of the mixin where `touchableHandleFocus` and
   * `touchableHandleBlur` can be overridden. This allows appropriate defaults to
   * be set on TV platforms, without breaking existing implementations of
   * `Touchable`.
   */
  var touchableHandleFocus = TouchableMixin.touchableHandleFocus,
    touchableHandleBlur = TouchableMixin.touchableHandleBlur,
    TouchableMixinWithoutDefaultFocusAndBlur = (0, _objectWithoutPropertiesLoose2.default)(TouchableMixin, ["touchableHandleFocus", "touchableHandleBlur"]);
  TouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;
  var Touchable = {
    Mixin: TouchableMixin,
    TOUCH_TARGET_DEBUG: false,
    // Highlights all touchable targets. Toggle with Inspector.
    /**
     * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).
     */
    renderDebugView: _ref => {
      var color = _ref.color,
        hitSlop = _ref.hitSlop;
      if (!Touchable.TOUCH_TARGET_DEBUG) {
        return null;
      }
      if (process.env.NODE_ENV !== 'production') {
        throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');
      }
      var debugHitSlopStyle = {};
      hitSlop = hitSlop || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      for (var key in hitSlop) {
        debugHitSlopStyle[key] = -hitSlop[key];
      }
      var normalizedColor = (0, _normalizeColors.default)(color);
      if (typeof normalizedColor !== 'number') {
        return null;
      }
      var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);
      return /*#__PURE__*/_react.default.createElement(_View.default, {
        pointerEvents: "none",
        style: (0, _objectSpread2.default)({
          position: 'absolute',
          borderColor: hexColor.slice(0, -2) + '55',
          // More opaque
          borderWidth: 1,
          borderStyle: 'dashed',
          backgroundColor: hexColor.slice(0, -2) + '0F'
        }, debugHitSlopStyle)
      });
    }
  };
  var _default = exports.default = Touchable;
},255,[17,873,868,19,256,38,258,3,97,111,76],"node_modules\\react-native-web\\dist\\exports\\Touchable\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _PooledClass = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/PooledClass"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;

  /**
   * PooledClass representing the bounding rectangle of a region.
   */
  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }
  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };
  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };
  _PooledClass.default.addPoolingTo(BoundingDimensions, twoArgumentPooler);
  var _default = exports.default = BoundingDimensions;
},256,[17,257],"node_modules\\react-native-web\\dist\\exports\\Touchable\\BoundingDimensions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "fbjs/lib/invariant"));
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   */

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };
  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };
  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = twoArgumentPooler;

  /**
   * Augments `CopyConstructor` to be a poolable class, augmenting only the class
   * itself (statically) not adding any prototypical fields. Any CopyConstructor
   * you give this may have a `poolSize` property, and will look for a
   * prototypical `destructor` on instances.
   *
   * @param {Function} CopyConstructor Constructor that can be used to reset.
   * @param {Function} pooler Customizable pooler.
   */
  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    // Casting as any so that flow ignores the actual implementation and trusts
    // it to match the type we declared
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };
  var PooledClass = {
    addPoolingTo: addPoolingTo,
    twoArgumentPooler: twoArgumentPooler
  };
  var _default = exports.default = PooledClass;
},257,[17,129],"node_modules\\react-native-web\\dist\\vendor\\react-native\\PooledClass\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _PooledClass = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/PooledClass"));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;
  function Position(left, top) {
    this.left = left;
    this.top = top;
  }
  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };
  _PooledClass.default.addPoolingTo(Position, twoArgumentPooler);
  var _default = exports.default = Position;
},258,[17,257],"node_modules\\react-native-web\\dist\\exports\\Touchable\\Position.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var React = _react;
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[4], "../../modules/useMergeRefs"));
  var _usePressEvents = _interopRequireDefault(require(_dependencyMap[5], "../../modules/usePressEvents"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "../StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "../View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _excluded = ["activeOpacity", "children", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onHideUnderlay", "onLongPress", "onPress", "onPressIn", "onPressOut", "onShowUnderlay", "rejectResponderTermination", "style", "testOnly_pressed", "underlayColor"];
  //import { warnOnce } from '../../modules/warnOnce';

  function createExtraStyles(activeOpacity, underlayColor) {
    return {
      child: {
        opacity: activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.85
      },
      underlay: {
        backgroundColor: underlayColor === undefined ? 'black' : underlayColor
      }
    };
  }
  function hasPressHandler(props) {
    return props.onPress != null || props.onPressIn != null || props.onPressOut != null || props.onLongPress != null;
  }

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, which allows
   * the underlay color to show through, darkening or tinting the view.
   *
   * The underlay comes from wrapping the child in a new View, which can affect
   * layout, and sometimes cause unwanted visual artifacts if not used correctly,
   * for example if the backgroundColor of the wrapped view isn't explicitly set
   * to an opaque color.
   *
   * TouchableHighlight must have one child (not zero or more than one).
   * If you wish to have several child components, wrap them in a View.
   */
  function TouchableHighlight(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableHighlight',
      'TouchableHighlight is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      children = props.children,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onHideUnderlay = props.onHideUnderlay,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      onShowUnderlay = props.onShowUnderlay,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      testOnly_pressed = props.testOnly_pressed,
      underlayColor = props.underlayColor,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)(testOnly_pressed === true ? createExtraStyles(activeOpacity, underlayColor) : null),
      extraStyles = _useState[0],
      setExtraStyles = _useState[1];
    var showUnderlay = (0, _react.useCallback)(() => {
      if (!hasPressHandler(props)) {
        return;
      }
      setExtraStyles(createExtraStyles(activeOpacity, underlayColor));
      if (onShowUnderlay != null) {
        onShowUnderlay();
      }
    }, [activeOpacity, onShowUnderlay, props, underlayColor]);
    var hideUnderlay = (0, _react.useCallback)(() => {
      if (testOnly_pressed === true) {
        return;
      }
      if (hasPressHandler(props)) {
        setExtraStyles(null);
        if (onHideUnderlay != null) {
          onHideUnderlay();
        }
      }
    }, [onHideUnderlay, props, testOnly_pressed]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        showUnderlay();
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        hideUnderlay();
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, showUnderlay, hideUnderlay]);
    var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
    var child = React.Children.only(children);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, style, !disabled && styles.actionable, extraStyles && extraStyles.underlay]
    }), /*#__PURE__*/React.cloneElement(child, {
      style: [child.props.style, extraStyles && extraStyles.child]
    }));
  }
  var styles = _StyleSheet.default.create({
    root: {
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableHighlight = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableHighlight));
  MemoedTouchableHighlight.displayName = 'TouchableHighlight';
  var _default = exports.default = MemoedTouchableHighlight;
},259,[17,888,873,3,116,232,30,111],"node_modules\\react-native-web\\dist\\exports\\TouchableHighlight\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _UnimplementedView = _interopRequireDefault(require(_dependencyMap[1], "../../modules/UnimplementedView"));
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  var _default = exports.default = _UnimplementedView.default;
},260,[17,261],"node_modules\\react-native-web\\dist\\exports\\TouchableNativeFeedback\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _extends2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/extends"));
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "../../exports/View"));
  var _react = _interopRequireDefault(require(_dependencyMap[4], "react"));
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Common implementation for a simple stubbed view.
   */
  function UnimplementedView(_ref) {
    var style = _ref.style,
      props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    return /*#__PURE__*/_react.default.createElement(_View.default, (0, _extends2.default)({}, props, {
      style: [unimplementedViewStyles, style]
    }));
  }
  var unimplementedViewStyles = process.env.NODE_ENV !== 'production' ? {
    alignSelf: 'flex-start',
    borderColor: 'red',
    borderWidth: 1
  } : {};
  var _default = exports.default = UnimplementedView;
},261,[17,888,873,111,3],"node_modules\\react-native-web\\dist\\modules\\UnimplementedView\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var React = _react;
  var _pick = _interopRequireDefault(require(_dependencyMap[2], "../../modules/pick"));
  var _useMergeRefs = _interopRequireDefault(require(_dependencyMap[3], "../../modules/useMergeRefs"));
  var _usePressEvents = _interopRequireDefault(require(_dependencyMap[4], "../../modules/usePressEvents"));
  var _warnOnce = require(_dependencyMap[5], "../../modules/warnOnce");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var forwardPropsList = {
    accessibilityDisabled: true,
    accessibilityLabel: true,
    accessibilityLiveRegion: true,
    accessibilityRole: true,
    accessibilityState: true,
    accessibilityValue: true,
    children: true,
    disabled: true,
    focusable: true,
    nativeID: true,
    onBlur: true,
    onFocus: true,
    onLayout: true,
    testID: true
  };
  var pickProps = props => (0, _pick.default)(props, forwardPropsList);
  function TouchableWithoutFeedback(props, forwardedRef) {
    (0, _warnOnce.warnOnce)('TouchableWithoutFeedback', 'TouchableWithoutFeedback is deprecated. Please use Pressable.');
    var delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination;
    var hostRef = (0, _react.useRef)(null);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart: onPressIn,
      onPressEnd: onPressOut
    }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]);
    var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
    var element = React.Children.only(props.children);
    var children = [element.props.children];
    var supportedProps = pickProps(props);
    supportedProps.accessibilityDisabled = disabled;
    supportedProps.focusable = !disabled && focusable !== false;
    supportedProps.ref = (0, _useMergeRefs.default)(forwardedRef, hostRef, element.ref);
    var elementProps = Object.assign(supportedProps, pressEventHandlers);
    return /*#__PURE__*/React.cloneElement(element, elementProps, ...children);
  }
  var MemoedTouchableWithoutFeedback = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableWithoutFeedback));
  MemoedTouchableWithoutFeedback.displayName = 'TouchableWithoutFeedback';
  var _default = exports.default = MemoedTouchableWithoutFeedback;
},262,[17,3,113,116,232,76],"node_modules\\react-native-web\\dist\\exports\\TouchableWithoutFeedback\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _VirtualizedList = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/VirtualizedList"));
  var _default = exports.default = _VirtualizedList.default;
},263,[17,130],"node_modules\\react-native-web\\dist\\exports\\VirtualizedList\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _UnimplementedView = _interopRequireDefault(require(_dependencyMap[2], "../../modules/UnimplementedView"));
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function YellowBox(props) {
    return /*#__PURE__*/_react.default.createElement(_UnimplementedView.default, props);
  }
  YellowBox.ignoreWarnings = () => {};
  var _default = exports.default = YellowBox;
},264,[17,3,261],"node_modules\\react-native-web\\dist\\exports\\YellowBox\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) 2016-present, Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var LogBox = {
    ignoreLogs() {},
    ignoreAllLogs() {},
    uninstall() {},
    install() {}
  };
  var _default = exports.default = LogBox;
},265,[],"node_modules\\react-native-web\\dist\\exports\\LogBox\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _RCTDeviceEventEmitter = _interopRequireDefault(require(_dependencyMap[1], "../../vendor/react-native/EventEmitter/RCTDeviceEventEmitter"));
  var _default = exports.default = _RCTDeviceEventEmitter.default;
},266,[17,172],"node_modules\\react-native-web\\dist\\exports\\DeviceEventEmitter\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useColorScheme;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Appearance = _interopRequireDefault(require(_dependencyMap[2], "../Appearance"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useColorScheme() {
    var _React$useState = React.useState(_Appearance.default.getColorScheme()),
      colorScheme = _React$useState[0],
      setColorScheme = _React$useState[1];
    React.useEffect(() => {
      function listener(appearance) {
        setColorScheme(appearance.colorScheme);
      }
      var _Appearance$addChange = _Appearance.default.addChangeListener(listener),
        remove = _Appearance$addChange.remove;
      return remove;
    });
    return colorScheme;
  }
},267,[17,3,211],"node_modules\\react-native-web\\dist\\exports\\useColorScheme\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _useLocale = require(_dependencyMap[0], "../../modules/useLocale");
  var _default = exports.default = _useLocale.useLocaleContext;
},268,[85],"node_modules\\react-native-web\\dist\\exports\\useLocaleContext\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useWindowDimensions;
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[1], "../Dimensions"));
  var _react = require(_dependencyMap[2], "react");
  function useWindowDimensions() {
    var _useState = (0, _react.useState)(() => _Dimensions.default.get('window')),
      dims = _useState[0],
      setDims = _useState[1];
    (0, _react.useEffect)(() => {
      function handleChange(_ref) {
        var window = _ref.window;
        if (window != null) {
          setDims(window);
        }
      }
      _Dimensions.default.addEventListener('change', handleChange);
      // We might have missed an update between calling `get` in render and
      // `addEventListener` in this handler, so we set it here. If there was
      // no change, React will filter out this update as a no-op.
      setDims(_Dimensions.default.get('window'));
      return () => {
        _Dimensions.default.removeEventListener('change', handleChange);
      };
    }, []);
    return dims;
  }
},269,[17,136,3],"node_modules\\react-native-web\\dist\\exports\\useWindowDimensions\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.colorScheme = void 0;
  const react_native_1 = require(_dependencyMap[0], "react-native-web/dist/index");
  const shared_1 = require(_dependencyMap[1], "../../shared");
  const observable_1 = require(_dependencyMap[2], "../observable");
  const stylesheet_1 = require(_dependencyMap[3], "./stylesheet");
  let appearance = react_native_1.Appearance;
  let appearanceListener;
  const darkModeFlag = stylesheet_1.StyleSheet.getFlag("darkMode");
  let darkMode;
  let darkModeValue;
  let initialColor = undefined;
  if (darkModeFlag) {
    const flags = darkModeFlag.split(" ");
    darkMode = flags[0];
    darkModeValue = flags[1];
    if (darkMode === "class") {
      initialColor = "window" in globalThis.window && globalThis.window.document.documentElement.classList.contains(darkModeValue) ? "dark" : "light";
    }
  } else if ("window" in globalThis) {
    const headNode = globalThis.window.document.getElementsByTagName("head")[0];
    new MutationObserver(function (_, observer) {
      const darkModeFlag = stylesheet_1.StyleSheet.getFlag("darkMode");
      if (!darkModeFlag) return;
      observer.disconnect();
      const flags = darkModeFlag.split(" ");
      darkMode = flags[0];
      darkModeValue = flags[1];
      exports.colorScheme.set(globalThis.window.document.documentElement.classList.contains(darkModeValue) ? "dark" : "system");
    }).observe(headNode, {
      attributes: false,
      childList: true,
      subtree: false
    });
  }
  const systemColorScheme = (0, observable_1.observable)(appearance.getColorScheme() ?? "light");
  const colorSchemeObservable = (0, observable_1.observable)(initialColor, {
    fallback: systemColorScheme
  });
  exports.colorScheme = {
    set(value) {
      if (darkMode === "media") {
        throw new Error("Cannot manually set color scheme, as dark mode is type 'media'. Please use StyleSheet.setFlag('darkMode', 'class')");
      }
      if (!globalThis.window) {
        throw new Error("Cannot manually set color scheme while not in a browser environment.");
      }
      if (value === "system") {
        colorSchemeObservable.set(undefined);
      } else {
        colorSchemeObservable.set(value);
      }
      if (darkModeValue) {
        if (value === "dark") {
          globalThis.window?.document.documentElement.classList.add(darkModeValue);
        } else {
          globalThis.window?.document.documentElement.classList.remove(darkModeValue);
        }
      }
    },
    get: colorSchemeObservable.get,
    toggle() {
      let current = colorSchemeObservable.get();
      if (current === undefined) current = appearance.getColorScheme() ?? "light";
      exports.colorScheme.set(current === "light" ? "dark" : "light");
    },
    [shared_1.INTERNAL_RESET]: appearance => {
      colorSchemeObservable.set(undefined);
      resetAppearanceListeners(appearance);
    }
  };
  function resetAppearanceListeners($appearance) {
    appearance = $appearance;
    appearanceListener?.remove();
    appearanceListener = appearance.addChangeListener(state => {
      if (react_native_1.AppState.currentState === "active") {
        systemColorScheme.set(state.colorScheme ?? "light");
      }
    });
  }
  resetAppearanceListeners(appearance);
},270,[16,11,271,15],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\color-scheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.observable = observable;
  exports.cleanupEffect = cleanupEffect;
  function observable(value, {
    fallback,
    name
  } = {}) {
    const effects = new Set();
    return {
      name,
      get(effect) {
        if (effect) {
          effects.add(effect);
          effect.dependencies.add(() => effects.delete(effect));
        }
        return value ?? fallback?.get(effect);
      },
      set(newValue) {
        if (Object.is(newValue, value)) return;
        value = newValue;
        for (const effect of Array.from(effects)) {
          effect.run();
        }
      }
    };
  }
  function cleanupEffect(effect) {
    for (const dep of Array.from(effect.dependencies)) {
      dep();
    }
    effect.dependencies.clear();
  }
},271,[],"node_modules\\react-native-css-interop\\dist\\runtime\\observable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rem = exports._rem = void 0;
  const shared_1 = require(_dependencyMap[0], "../../shared");
  const observable_1 = require(_dependencyMap[1], "../observable");
  const isSSR = globalThis.window === undefined;
  exports._rem = (0, observable_1.observable)(isSSR ? 16 : Number.parseFloat(globalThis.window.getComputedStyle(globalThis.window.document.documentElement).fontSize) || 16);
  exports.rem = {
    get(effect) {
      return exports._rem.get(effect);
    },
    set(value) {
      exports._rem.set(value);
      if (!isSSR) {
        globalThis.window.document.documentElement.style.fontSize = `${value}px`;
      }
    },
    [shared_1.INTERNAL_RESET](value = 16) {
      exports._rem.set(value);
    }
  };
},272,[11,271],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\rem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useColorScheme = useColorScheme;
  const react_1 = require(_dependencyMap[0], "react");
  const color_scheme_1 = require(_dependencyMap[1], "./color-scheme");
  function useColorScheme() {
    const [effect, setEffect] = (0, react_1.useState)(() => ({
      run: () => setEffect(s => Object.assign({}, s)),
      dependencies: new Set()
    }));
    return {
      colorScheme: color_scheme_1.colorScheme.get(effect),
      setColorScheme: color_scheme_1.colorScheme.set,
      toggleColorScheme: color_scheme_1.colorScheme.toggle
    };
  }
},273,[3,270],"node_modules\\react-native-css-interop\\dist\\runtime\\web\\useColorScheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.maybeHijackSafeAreaProvider = maybeHijackSafeAreaProvider;
  function maybeHijackSafeAreaProvider(type) {
    return type;
  }
},274,[],"node_modules\\react-native-css-interop\\dist\\runtime\\third-party-libs\\react-native-safe-area-context.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  "use client";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const react_native_1 = require(_dependencyMap[0], "react-native-web/dist/index");
  const api_1 = require(_dependencyMap[1], "./api");
  (0, api_1.cssInterop)(react_native_1.Image, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.Pressable, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.SafeAreaView, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.Switch, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.Text, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.TouchableHighlight, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.TouchableOpacity, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.TouchableWithoutFeedback, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.View, {
    className: "style"
  });
  (0, api_1.cssInterop)(react_native_1.ActivityIndicator, {
    className: {
      target: "style",
      nativeStyleToProp: {
        color: true
      }
    }
  });
  (0, api_1.cssInterop)(react_native_1.StatusBar, {
    className: {
      target: false,
      nativeStyleToProp: {
        backgroundColor: true
      }
    }
  });
  (0, api_1.cssInterop)(react_native_1.ScrollView, {
    className: "style",
    contentContainerClassName: "contentContainerStyle"
  });
  (0, api_1.cssInterop)(react_native_1.TextInput, {
    className: {
      target: "style",
      nativeStyleToProp: {
        textAlign: true
      }
    }
  });
  (0, api_1.remapProps)(react_native_1.FlatList, {
    className: "style",
    ListFooterComponentClassName: "ListFooterComponentStyle",
    ListHeaderComponentClassName: "ListHeaderComponentStyle",
    columnWrapperClassName: "columnWrapperStyle",
    contentContainerClassName: "contentContainerStyle"
  });
  (0, api_1.remapProps)(react_native_1.ImageBackground, {
    className: "style",
    imageClassName: "imageStyle"
  });
  (0, api_1.remapProps)(react_native_1.KeyboardAvoidingView, {
    className: "style",
    contentContainerClassName: "contentContainerStyle"
  });
  (0, api_1.remapProps)(react_native_1.VirtualizedList, {
    className: "style",
    ListFooterComponentClassName: "ListFooterComponentStyle",
    ListHeaderComponentClassName: "ListHeaderComponentStyle",
    contentContainerClassName: "contentContainerStyle"
  });
  try {
    const SafeAreaView = require(_dependencyMap[2], "react-native-safe-area-context").SafeAreaView;
    (0, api_1.cssInterop)(SafeAreaView, {
      className: "style"
    });
  } catch {}
},275,[16,9,893],"node_modules\\react-native-css-interop\\dist\\runtime\\components.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  require(_dependencyMap[0], "./location/install");
  require(_dependencyMap[1], "./effects");
  require(_dependencyMap[2], "./async-require");
  require(_dependencyMap[3], "@expo/metro-runtime/rsc/runtime");
},282,[283,284,341,349],"node_modules\\@expo\\metro-runtime\\src\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},283,[],"node_modules\\@expo\\metro-runtime\\src\\location\\install.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Only during development.
  if (process.env.NODE_ENV !== 'production') {
    if (
    // Disable for SSR
    typeof window !== 'undefined') {
      require(_dependencyMap[0], "./setupFastRefresh");
      require(_dependencyMap[1], "./setupHMR");
      require(_dependencyMap[2], "./messageSocket");
    }
  }
},284,[285,288,340],"node_modules\\@expo\\metro-runtime\\src\\effects.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // This needs to run before the renderer initializes.

  const ReactRefreshRuntime = require(_dependencyMap[0], "react-refresh/runtime");
  ReactRefreshRuntime.injectIntoGlobalHook(global);
  const Refresh = {
    performFullRefresh() {
      location.reload();
    },
    createSignatureFunctionForTransform: ReactRefreshRuntime.createSignatureFunctionForTransform,
    isLikelyComponentType: ReactRefreshRuntime.isLikelyComponentType,
    getFamilyByType: ReactRefreshRuntime.getFamilyByType,
    register: ReactRefreshRuntime.register,
    performReactRefresh() {
      if (ReactRefreshRuntime.hasUnrecoverableErrors()) {
        location.reload();
        return;
      }
      ReactRefreshRuntime.performReactRefresh();
    }
  };

  // The metro require polyfill can not have dependencies (applies for all polyfills).
  // Expose `Refresh` by assigning it to global to make it available in the polyfill.
  global[(global.__METRO_GLOBAL_PREFIX__ || '') + '__ReactRefresh'] = Refresh;
},285,[286],"node_modules\\@expo\\metro-runtime\\src\\setupFastRefresh.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-refresh-runtime.production.min.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-refresh-runtime.development.js");
  }
},286,[4,287],"node_modules\\react-refresh\\runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-refresh-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      // ATTENTION
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
      var REACT_MEMO_TYPE = Symbol.for('react.memo');
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
      // It's OK to reference families, but use WeakMap/Set for types.

      var allFamiliesByID = new Map();
      var allFamiliesByType = new PossiblyWeakMap();
      var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
      // that have actually been edited here. This keeps checks fast.
      // $FlowIssue

      var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
      // It is an array of [Family, NextType] tuples.

      var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.

      var helpersByRendererID = new Map();
      var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.

      var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.

      var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
      // It needs to be weak because we do this even for roots that failed to mount.
      // If there is no WeakMap, we won't attempt to do retrying.
      // $FlowIssue

      var rootElements =
      // $FlowIssue
      typeof WeakMap === 'function' ? new WeakMap() : null;
      var isPerformingRefresh = false;
      function computeFullKey(signature) {
        if (signature.fullKey !== null) {
          return signature.fullKey;
        }
        var fullKey = signature.ownKey;
        var hooks;
        try {
          hooks = signature.getCustomHooks();
        } catch (err) {
          // This can happen in an edge case, e.g. if expression like Foo.useSomething
          // depends on Foo which is lazily initialized during rendering.
          // In that case just assume we'll have to remount.
          signature.forceReset = true;
          signature.fullKey = fullKey;
          return fullKey;
        }
        for (var i = 0; i < hooks.length; i++) {
          var hook = hooks[i];
          if (typeof hook !== 'function') {
            // Something's wrong. Assume we need to remount.
            signature.forceReset = true;
            signature.fullKey = fullKey;
            return fullKey;
          }
          var nestedHookSignature = allSignaturesByType.get(hook);
          if (nestedHookSignature === undefined) {
            // No signature means Hook wasn't in the source code, e.g. in a library.
            // We'll skip it because we can assume it won't change during this session.
            continue;
          }
          var nestedHookKey = computeFullKey(nestedHookSignature);
          if (nestedHookSignature.forceReset) {
            signature.forceReset = true;
          }
          fullKey += '\n---\n' + nestedHookKey;
        }
        signature.fullKey = fullKey;
        return fullKey;
      }
      function haveEqualSignatures(prevType, nextType) {
        var prevSignature = allSignaturesByType.get(prevType);
        var nextSignature = allSignaturesByType.get(nextType);
        if (prevSignature === undefined && nextSignature === undefined) {
          return true;
        }
        if (prevSignature === undefined || nextSignature === undefined) {
          return false;
        }
        if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
          return false;
        }
        if (nextSignature.forceReset) {
          return false;
        }
        return true;
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function canPreserveStateBetween(prevType, nextType) {
        if (isReactClass(prevType) || isReactClass(nextType)) {
          return false;
        }
        if (haveEqualSignatures(prevType, nextType)) {
          return true;
        }
        return false;
      }
      function resolveFamily(type) {
        // Only check updated types to keep lookups fast.
        return updatedFamiliesByType.get(type);
      } // If we didn't care about IE11, we could use new Map/Set(iterable).

      function cloneMap(map) {
        var clone = new Map();
        map.forEach(function (value, key) {
          clone.set(key, value);
        });
        return clone;
      }
      function cloneSet(set) {
        var clone = new Set();
        set.forEach(function (value) {
          clone.add(value);
        });
        return clone;
      } // This is a safety mechanism to protect against rogue getters and Proxies.

      function getProperty(object, property) {
        try {
          return object[property];
        } catch (err) {
          // Intentionally ignore.
          return undefined;
        }
      }
      function performReactRefresh() {
        if (pendingUpdates.length === 0) {
          return null;
        }
        if (isPerformingRefresh) {
          return null;
        }
        isPerformingRefresh = true;
        try {
          var staleFamilies = new Set();
          var updatedFamilies = new Set();
          var updates = pendingUpdates;
          pendingUpdates = [];
          updates.forEach(function (_ref) {
            var family = _ref[0],
              nextType = _ref[1];
            // Now that we got a real edit, we can create associations
            // that will be read by the React reconciler.
            var prevType = family.current;
            updatedFamiliesByType.set(prevType, family);
            updatedFamiliesByType.set(nextType, family);
            family.current = nextType; // Determine whether this should be a re-render or a re-mount.

            if (canPreserveStateBetween(prevType, nextType)) {
              updatedFamilies.add(family);
            } else {
              staleFamilies.add(family);
            }
          }); // TODO: rename these fields to something more meaningful.

          var update = {
            updatedFamilies: updatedFamilies,
            // Families that will re-render preserving state
            staleFamilies: staleFamilies // Families that will be remounted
          };
          helpersByRendererID.forEach(function (helpers) {
            // Even if there are no roots, set the handler on first update.
            // This ensures that if *new* roots are mounted, they'll use the resolve handler.
            helpers.setRefreshHandler(resolveFamily);
          });
          var didError = false;
          var firstError = null; // We snapshot maps and sets that are mutated during commits.
          // If we don't do this, there is a risk they will be mutated while
          // we iterate over them. For example, trying to recover a failed root
          // may cause another root to be added to the failed list -- an infinite loop.

          var failedRootsSnapshot = cloneSet(failedRoots);
          var mountedRootsSnapshot = cloneSet(mountedRoots);
          var helpersByRootSnapshot = cloneMap(helpersByRoot);
          failedRootsSnapshot.forEach(function (root) {
            var helpers = helpersByRootSnapshot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            if (!failedRoots.has(root)) {// No longer failed.
            }
            if (rootElements === null) {
              return;
            }
            if (!rootElements.has(root)) {
              return;
            }
            var element = rootElements.get(root);
            try {
              helpers.scheduleRoot(root, element);
            } catch (err) {
              if (!didError) {
                didError = true;
                firstError = err;
              } // Keep trying other roots.
            }
          });
          mountedRootsSnapshot.forEach(function (root) {
            var helpers = helpersByRootSnapshot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            if (!mountedRoots.has(root)) {// No longer mounted.
            }
            try {
              helpers.scheduleRefresh(root, update);
            } catch (err) {
              if (!didError) {
                didError = true;
                firstError = err;
              } // Keep trying other roots.
            }
          });
          if (didError) {
            throw firstError;
          }
          return update;
        } finally {
          isPerformingRefresh = false;
        }
      }
      function register(type, id) {
        {
          if (type === null) {
            return;
          }
          if (typeof type !== 'function' && typeof type !== 'object') {
            return;
          } // This can happen in an edge case, e.g. if we register
          // return value of a HOC but it returns a cached component.
          // Ignore anything but the first registration for each type.

          if (allFamiliesByType.has(type)) {
            return;
          } // Create family or remember to update it.
          // None of this bookkeeping affects reconciliation
          // until the first performReactRefresh() call above.

          var family = allFamiliesByID.get(id);
          if (family === undefined) {
            family = {
              current: type
            };
            allFamiliesByID.set(id, family);
          } else {
            pendingUpdates.push([family, type]);
          }
          allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.

          if (typeof type === 'object' && type !== null) {
            switch (getProperty(type, '$$typeof')) {
              case REACT_FORWARD_REF_TYPE:
                register(type.render, id + '$render');
                break;
              case REACT_MEMO_TYPE:
                register(type.type, id + '$type');
                break;
            }
          }
        }
      }
      function setSignature(type, key) {
        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
        {
          if (!allSignaturesByType.has(type)) {
            allSignaturesByType.set(type, {
              forceReset: forceReset,
              ownKey: key,
              fullKey: null,
              getCustomHooks: getCustomHooks || function () {
                return [];
              }
            });
          } // Visit inner types because we might not have signed them.

          if (typeof type === 'object' && type !== null) {
            switch (getProperty(type, '$$typeof')) {
              case REACT_FORWARD_REF_TYPE:
                setSignature(type.render, key, forceReset, getCustomHooks);
                break;
              case REACT_MEMO_TYPE:
                setSignature(type.type, key, forceReset, getCustomHooks);
                break;
            }
          }
        }
      } // This is lazily called during first render for a type.
      // It captures Hook list at that time so inline requires don't break comparisons.

      function collectCustomHooksForSignature(type) {
        {
          var signature = allSignaturesByType.get(type);
          if (signature !== undefined) {
            computeFullKey(signature);
          }
        }
      }
      function getFamilyByID(id) {
        {
          return allFamiliesByID.get(id);
        }
      }
      function getFamilyByType(type) {
        {
          return allFamiliesByType.get(type);
        }
      }
      function findAffectedHostInstances(families) {
        {
          var affectedInstances = new Set();
          mountedRoots.forEach(function (root) {
            var helpers = helpersByRoot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
            instancesForRoot.forEach(function (inst) {
              affectedInstances.add(inst);
            });
          });
          return affectedInstances;
        }
      }
      function injectIntoGlobalHook(globalObject) {
        {
          // For React Native, the global hook will be set up by require('react-devtools-core').
          // That code will run before us. So we need to monkeypatch functions on existing hook.
          // For React Web, the global hook will be set up by the extension.
          // This will also run before us.
          var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook === undefined) {
            // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
            // Note that in this case it's important that renderer code runs *after* this method call.
            // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
            var nextID = 0;
            globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
              renderers: new Map(),
              supportsFiber: true,
              inject: function (injected) {
                return nextID++;
              },
              onScheduleFiberRoot: function (id, root, children) {},
              onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},
              onCommitFiberUnmount: function () {}
            };
          }
          if (hook.isDisabled) {
            // This isn't a real property on the hook, but it can be set to opt out
            // of DevTools integration and associated warnings and logs.
            // Using console['warn'] to evade Babel and ESLint
            console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
            return;
          } // Here, we just want to get a reference to scheduleRefresh.

          var oldInject = hook.inject;
          hook.inject = function (injected) {
            var id = oldInject.apply(this, arguments);
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
              // This version supports React Refresh.
              helpersByRendererID.set(id, injected);
            }
            return id;
          }; // Do the same for any already injected roots.
          // This is useful if ReactDOM has already been initialized.
          // https://github.com/facebook/react/issues/17626

          hook.renderers.forEach(function (injected, id) {
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
              // This version supports React Refresh.
              helpersByRendererID.set(id, injected);
            }
          }); // We also want to track currently mounted roots.

          var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
          var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};
          hook.onScheduleFiberRoot = function (id, root, children) {
            if (!isPerformingRefresh) {
              // If it was intentionally scheduled, don't attempt to restore.
              // This includes intentionally scheduled unmounts.
              failedRoots.delete(root);
              if (rootElements !== null) {
                rootElements.set(root, children);
              }
            }
            return oldOnScheduleFiberRoot.apply(this, arguments);
          };
          hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {
            var helpers = helpersByRendererID.get(id);
            if (helpers !== undefined) {
              helpersByRoot.set(root, helpers);
              var current = root.current;
              var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
              // This logic is copy-pasted from similar logic in the DevTools backend.
              // If this breaks with some refactoring, you'll want to update DevTools too.

              if (alternate !== null) {
                var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);
                var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                if (!wasMounted && isMounted) {
                  // Mount a new root.
                  mountedRoots.add(root);
                  failedRoots.delete(root);
                } else if (wasMounted && isMounted) ;else if (wasMounted && !isMounted) {
                  // Unmount an existing root.
                  mountedRoots.delete(root);
                  if (didError) {
                    // We'll remount it on future edits.
                    failedRoots.add(root);
                  } else {
                    helpersByRoot.delete(root);
                  }
                } else if (!wasMounted && !isMounted) {
                  if (didError) {
                    // We'll remount it on future edits.
                    failedRoots.add(root);
                  }
                }
              } else {
                // Mount a new root.
                mountedRoots.add(root);
              }
            } // Always call the decorated DevTools hook.

            return oldOnCommitFiberRoot.apply(this, arguments);
          };
        }
      }
      function hasUnrecoverableErrors() {
        // TODO: delete this after removing dependency in RN.
        return false;
      } // Exposed for testing.

      function _getMountedRootCount() {
        {
          return mountedRoots.size;
        }
      } // This is a wrapper over more primitive functions for setting signature.
      // Signatures let us decide whether the Hook order has changed on refresh.
      //
      // This function is intended to be used as a transform target, e.g.:
      // var _s = createSignatureFunctionForTransform()
      //
      // function Hello() {
      //   const [foo, setFoo] = useState(0);
      //   const value = useCustomHook();
      //   _s(); /* Call without arguments triggers collecting the custom Hook list.
      //          * This doesn't happen during the module evaluation because we
      //          * don't want to change the module order with inline requires.
      //          * Next calls are noops. */
      //   return <h1>Hi</h1>;
      // }
      //
      // /* Call with arguments attaches the signature to the type: */
      // _s(
      //   Hello,
      //   'useState{[foo, setFoo]}(0)',
      //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
      // );

      function createSignatureFunctionForTransform() {
        {
          var savedType;
          var hasCustomHooks;
          var didCollectHooks = false;
          return function (type, key, forceReset, getCustomHooks) {
            if (typeof key === 'string') {
              // We're in the initial phase that associates signatures
              // with the functions. Note this may be called multiple times
              // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
              if (!savedType) {
                // We're in the innermost call, so this is the actual type.
                savedType = type;
                hasCustomHooks = typeof getCustomHooks === 'function';
              } // Set the signature for all types (even wrappers!) in case
              // they have no signatures of their own. This is to prevent
              // problems like https://github.com/facebook/react/issues/20417.

              if (type != null && (typeof type === 'function' || typeof type === 'object')) {
                setSignature(type, key, forceReset, getCustomHooks);
              }
              return type;
            } else {
              // We're in the _s() call without arguments, which means
              // this is the time to collect custom Hook signatures.
              // Only do this once. This path is hot and runs *inside* every render!
              if (!didCollectHooks && hasCustomHooks) {
                didCollectHooks = true;
                collectCustomHooksForSignature(savedType);
              }
            }
          };
        }
      }
      function isLikelyComponentType(type) {
        {
          switch (typeof type) {
            case 'function':
              {
                // First, deal with classes.
                if (type.prototype != null) {
                  if (type.prototype.isReactComponent) {
                    // React class.
                    return true;
                  }
                  var ownNames = Object.getOwnPropertyNames(type.prototype);
                  if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                    // This looks like a class.
                    return false;
                  } // eslint-disable-next-line no-proto

                  if (type.prototype.__proto__ !== Object.prototype) {
                    // It has a superclass.
                    return false;
                  } // Pass through.
                  // This looks like a regular function with empty prototype.
                } // For plain functions and arrows, use name as a heuristic.

                var name = type.name || type.displayName;
                return typeof name === 'string' && /^[A-Z]/.test(name);
              }
            case 'object':
              {
                if (type != null) {
                  switch (getProperty(type, '$$typeof')) {
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_MEMO_TYPE:
                      // Definitely React components.
                      return true;
                    default:
                      return false;
                  }
                }
                return false;
              }
            default:
              {
                return false;
              }
          }
        }
      }
      exports._getMountedRootCount = _getMountedRootCount;
      exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
      exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
      exports.findAffectedHostInstances = findAffectedHostInstances;
      exports.getFamilyByID = getFamilyByID;
      exports.getFamilyByType = getFamilyByType;
      exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
      exports.injectIntoGlobalHook = injectIntoGlobalHook;
      exports.isLikelyComponentType = isLikelyComponentType;
      exports.performReactRefresh = performReactRefresh;
      exports.register = register;
      exports.setSignature = setSignature;
    })();
  }
},287,[],"node_modules\\react-refresh\\cjs\\react-refresh-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  var _HMRClient = _interopRequireDefault(require(_dependencyMap[1], "./HMRClient"));
  if (typeof window !== 'undefined' &&
  // @ts-expect-error: Added via react-native-webview
  typeof window.ReactNativeWebView !== 'undefined') {
    // Sets up developer tools for web platforms when running in a webview. This ensures that logs are visible in the terminal.
    // We assume full control over the console and send JavaScript logs to Metro.
    const LEVELS = ['trace', 'info', 'warn', 'error', 'log', 'group', 'groupCollapsed', 'groupEnd', 'debug'];
    LEVELS.forEach(level => {
      const originalFunction = console[level];
      console[level] = function (...args) {
        _HMRClient.default.log(level, args);
        originalFunction.apply(console, args);
      };
    });
    _HMRClient.default.log('log', [`[webview] Logs will also appear in the Safari/Chrome debug console`]);
  } else {
    _HMRClient.default.log('log', [`[web] Logs will appear in the browser console`]);
  }

  // This is called native on native platforms
  _HMRClient.default.setup({
    isEnabled: true
  });
},288,[17,289],"node_modules\\@expo\\metro-runtime\\src\\setupHMR.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _HMRClient = _interopRequireDefault(require(_dependencyMap[1], "metro-runtime/src/modules/HMRClient"));
  var _prettyFormat = _interopRequireWildcard(require(_dependencyMap[2], "pretty-format"));
  var _LoadingView = _interopRequireDefault(require(_dependencyMap[3], "./LoadingView"));
  var _LogBox = _interopRequireDefault(require(_dependencyMap[4], "./error-overlay/LogBox"));
  var _getDevServer = _interopRequireDefault(require(_dependencyMap[5], "./getDevServer"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Based on this but with web support:
   * https://github.com/facebook/react-native/blob/086714b02b0fb838dee5a66c5bcefe73b53cf3df/Libraries/Utilities/HMRClient.js
   */

  const pendingEntryPoints = [];

  // @ts-expect-error: Account for multiple versions of pretty-format inside of a monorepo.
  const prettyFormatFunc = typeof _prettyFormat.default === 'function' ? _prettyFormat.default : _prettyFormat.default.default;
  let hmrClient = null;
  let hmrUnavailableReason = null;
  let currentCompileErrorMessage = null;
  let didConnect = false;
  const pendingLogs = [];
  function assert(foo, msg) {
    if (!foo) throw new Error(msg);
  }

  /**
   * HMR Client that receives from the server HMR updates and propagates them
   * runtime to reflects those changes.
   */
  const HMRClient = {
    enable() {
      if (hmrUnavailableReason !== null) {
        // If HMR became unavailable while you weren't using it,
        // explain why when you try to turn it on.
        // This is an error (and not a warning) because it is shown
        // in response to a direct user action.
        throw new Error(hmrUnavailableReason);
      }
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');

      // We use this for internal logging only.
      // It doesn't affect the logic.
      hmrClient.send(JSON.stringify({
        type: 'log-opt-in'
      }));

      // When toggling Fast Refresh on, we might already have some stashed updates.
      // Since they'll get applied now, we'll show a banner.
      const hasUpdates = hmrClient.hasPendingUpdates();
      if (hasUpdates) {
        _LoadingView.default.showMessage('Refreshing...', 'refresh');
      }
      try {
        hmrClient.enable();
      } finally {
        if (hasUpdates) {
          _LoadingView.default.hide();
        }
      }

      // There could be a compile error while Fast Refresh was off,
      // but we ignored it at the time. Show it now.
      showCompileError();
    },
    disable() {
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
      hmrClient.disable();
    },
    registerBundle(requestUrl) {
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
      pendingEntryPoints.push(requestUrl);
      registerBundleEntryPoints(hmrClient);
    },
    log(level, data) {
      if (!hmrClient) {
        // Catch a reasonable number of early logs
        // in case hmrClient gets initialized later.
        pendingLogs.push([level, data]);
        if (pendingLogs.length > 100) {
          pendingLogs.shift();
        }
        return;
      }
      try {
        hmrClient.send(JSON.stringify({
          type: 'log',
          level,
          platform: 'web',
          mode: 'BRIDGE',
          data: data.map(item => typeof item === 'string' ? item : prettyFormatFunc(item, {
            escapeString: true,
            highlight: true,
            maxDepth: 3,
            min: true,
            plugins: [_prettyFormat.plugins.ReactElement]
          }))
        }));
      } catch {
        // If sending logs causes any failures we want to silently ignore them
        // to ensure we do not cause infinite-logging loops.
      }
    },
    // Called once by the bridge on startup, even if Fast Refresh is off.
    // It creates the HMR client but doesn't actually set up the socket yet.
    setup({
      isEnabled
    }) {
      assert(!hmrClient, 'Cannot initialize hmrClient twice');
      const serverScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const client = new _HMRClient.default(`${serverScheme}://${window.location.host}/hot`);
      hmrClient = client;
      const {
        fullBundleUrl
      } = (0, _getDevServer.default)();
      pendingEntryPoints.push(
      // HMRServer understands regular bundle URLs, so prefer that in case
      // there are any important URL parameters we can't reconstruct from
      // `setup()`'s arguments.
      fullBundleUrl);
      client.on('connection-error', e => {
        let error = `Cannot connect to Metro.
 
 Try the following to fix the issue:
 - Ensure the Metro dev server is running and available on the same network as this device`;
        error += `
 
 URL: ${window.location.host}
 
 Error: ${e.message}`;
        setHMRUnavailableReason(error);
      });
      client.on('update-start', ({
        isInitialUpdate
      }) => {
        currentCompileErrorMessage = null;
        didConnect = true;
        if (client.isEnabled() && !isInitialUpdate) {
          _LoadingView.default.showMessage('Refreshing...', 'refresh');
        }
      });
      client.on('update', ({
        isInitialUpdate
      }) => {
        if (client.isEnabled() && !isInitialUpdate) {
          dismissRedbox();
          _LogBox.default.clearAllLogs();
        }
      });
      client.on('update-done', () => {
        _LoadingView.default.hide();
      });
      client.on('error', data => {
        _LoadingView.default.hide();
        if (data.type === 'GraphNotFoundError') {
          client.close();
          setHMRUnavailableReason('Metro has restarted since the last edit. Reload to reconnect.');
        } else if (data.type === 'RevisionNotFoundError') {
          client.close();
          setHMRUnavailableReason('Metro and the client are out of sync. Reload to reconnect.');
        } else {
          currentCompileErrorMessage = `${data.type} ${data.message}`;
          if (client.isEnabled()) {
            showCompileError();
          }
        }
      });
      client.on('close', closeEvent => {
        _LoadingView.default.hide();

        // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1
        // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.1.5
        const isNormalOrUnsetCloseReason = closeEvent == null || closeEvent.code === 1000 || closeEvent.code === 1005 || closeEvent.code == null;
        setHMRUnavailableReason(`${isNormalOrUnsetCloseReason ? 'Disconnected from Metro.' : `Disconnected from Metro (${closeEvent.code}: "${closeEvent.reason}").`}

To reconnect:
- Ensure that Metro is running and available on the same network
- Reload this app (will trigger further help if Metro cannot be connected to)
      `);
      });
      if (isEnabled) {
        HMRClient.enable();
      } else {
        HMRClient.disable();
      }
      registerBundleEntryPoints(hmrClient);
      flushEarlyLogs();
    }
  };
  function setHMRUnavailableReason(reason) {
    assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
    if (hmrUnavailableReason !== null) {
      // Don't show more than one warning.
      return;
    }
    hmrUnavailableReason = reason;

    // We only want to show a warning if Fast Refresh is on *and* if we ever
    // previously managed to connect successfully. We don't want to show
    // the warning to native engineers who use cached bundles without Metro.
    if (hmrClient.isEnabled() && didConnect) {
      console.warn(reason);
      // (Not using the `warning` module to prevent a Buck cycle.)
    }
  }
  function registerBundleEntryPoints(client) {
    if (hmrUnavailableReason != null) {
      // "Bundle Splitting  Metro disconnected"
      window.location.reload();
      return;
    }
    if (pendingEntryPoints.length > 0) {
      client?.send(JSON.stringify({
        type: 'register-entrypoints',
        entryPoints: pendingEntryPoints
      }));
      pendingEntryPoints.length = 0;
    }
  }
  function flushEarlyLogs() {
    try {
      pendingLogs.forEach(([level, data]) => {
        HMRClient.log(level, data);
      });
    } finally {
      pendingLogs.length = 0;
    }
  }
  function dismissRedbox() {
    // TODO(EvanBacon): Error overlay for web.
  }
  function showCompileError() {
    if (currentCompileErrorMessage === null) {
      return;
    }

    // Even if there is already a redbox, syntax errors are more important.
    // Otherwise you risk seeing a stale runtime error while a syntax error is more recent.
    dismissRedbox();
    const message = currentCompileErrorMessage;
    currentCompileErrorMessage = null;
    const error = new Error(message);
    // Symbolicating compile errors is wasted effort
    // because the stack trace is meaningless:
    // @ts-expect-error
    error.preventSymbolication = true;
    throw error;
  }
  var _default = exports.default = HMRClient;
},289,[17,290,292,305,306,339],"node_modules\\@expo\\metro-runtime\\src\\HMRClient.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const EventEmitter = require(_dependencyMap[0], "./vendor/eventemitter3");
  const inject = ({
    module: [id, code],
    sourceURL
  }) => {
    if (global.globalEvalWithSourceUrl) {
      global.globalEvalWithSourceUrl(code, sourceURL);
    } else {
      eval(code);
    }
  };
  const injectUpdate = update => {
    update.added.forEach(inject);
    update.modified.forEach(inject);
  };
  class HMRClient extends EventEmitter {
    _isEnabled = false;
    _pendingUpdate = null;
    _queue = [];
    _state = "opening";
    constructor(url) {
      super();
      this._ws = new global.WebSocket(url);
      this._ws.onopen = () => {
        this._state = "open";
        this.emit("open");
        this._flushQueue();
      };
      this._ws.onerror = error => {
        this.emit("connection-error", error);
      };
      this._ws.onclose = closeEvent => {
        this._state = "closed";
        this.emit("close", closeEvent);
      };
      this._ws.onmessage = message => {
        const data = JSON.parse(String(message.data));
        switch (data.type) {
          case "bundle-registered":
            this.emit("bundle-registered");
            break;
          case "update-start":
            this.emit("update-start", data.body);
            break;
          case "update":
            this.emit("update", data.body);
            break;
          case "update-done":
            this.emit("update-done");
            break;
          case "error":
            this.emit("error", data.body);
            break;
          default:
            this.emit("error", {
              type: "unknown-message",
              message: data
            });
        }
      };
      this.on("update", update => {
        if (this._isEnabled) {
          injectUpdate(update);
        } else if (this._pendingUpdate == null) {
          this._pendingUpdate = update;
        } else {
          this._pendingUpdate = mergeUpdates(this._pendingUpdate, update);
        }
      });
    }
    close() {
      this._ws.close();
    }
    send(message) {
      switch (this._state) {
        case "opening":
          this._queue.push(message);
          break;
        case "open":
          this._ws.send(message);
          break;
        case "closed":
          break;
        default:
          throw new Error("[WebSocketHMRClient] Unknown state: " + this._state);
      }
    }
    _flushQueue() {
      this._queue.forEach(message => this.send(message));
      this._queue.length = 0;
    }
    enable() {
      this._isEnabled = true;
      const update = this._pendingUpdate;
      this._pendingUpdate = null;
      if (update != null) {
        injectUpdate(update);
      }
    }
    disable() {
      this._isEnabled = false;
    }
    isEnabled() {
      return this._isEnabled;
    }
    hasPendingUpdates() {
      return this._pendingUpdate != null;
    }
  }
  function mergeUpdates(base, next) {
    const addedIDs = new Set();
    const deletedIDs = new Set();
    const moduleMap = new Map();
    applyUpdateLocally(base);
    applyUpdateLocally(next);
    function applyUpdateLocally(update) {
      update.deleted.forEach(id => {
        if (addedIDs.has(id)) {
          addedIDs.delete(id);
        } else {
          deletedIDs.add(id);
        }
        moduleMap.delete(id);
      });
      update.added.forEach(item => {
        const id = item.module[0];
        if (deletedIDs.has(id)) {
          deletedIDs.delete(id);
        } else {
          addedIDs.add(id);
        }
        moduleMap.set(id, item);
      });
      update.modified.forEach(item => {
        const id = item.module[0];
        moduleMap.set(id, item);
      });
    }
    const result = {
      isInitialUpdate: next.isInitialUpdate,
      revisionId: next.revisionId,
      added: [],
      modified: [],
      deleted: []
    };
    deletedIDs.forEach(id => {
      result.deleted.push(id);
    });
    moduleMap.forEach((item, id) => {
      if (deletedIDs.has(id)) {
        return;
      }
      if (addedIDs.has(id)) {
        result.added.push(item);
      } else {
        result.modified.push(item);
      }
    });
    return result;
  }
  module.exports = HMRClient;
},290,[291],"node_modules\\metro-runtime\\src\\modules\\HMRClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var has = Object.prototype.hasOwnProperty,
    prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
      events,
      name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
        j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if ("undefined" !== typeof module) {
    module.exports = EventEmitter;
  }
},291,[],"node_modules\\metro-runtime\\src\\modules\\vendor\\eventemitter3.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.default = exports.DEFAULT_OPTIONS = void 0;
  exports.format = format;
  exports.plugins = void 0;
  var _ansiStyles = _interopRequireDefault(require(_dependencyMap[0], "ansi-styles"));
  var _collections = require(_dependencyMap[1], "./collections");
  var _AsymmetricMatcher = _interopRequireDefault(require(_dependencyMap[2], "./plugins/AsymmetricMatcher"));
  var _DOMCollection = _interopRequireDefault(require(_dependencyMap[3], "./plugins/DOMCollection"));
  var _DOMElement = _interopRequireDefault(require(_dependencyMap[4], "./plugins/DOMElement"));
  var _Immutable = _interopRequireDefault(require(_dependencyMap[5], "./plugins/Immutable"));
  var _ReactElement = _interopRequireDefault(require(_dependencyMap[6], "./plugins/ReactElement"));
  var _ReactTestComponent = _interopRequireDefault(require(_dependencyMap[7], "./plugins/ReactTestComponent"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /* eslint-disable local/ban-types-eventually */

  const toString = Object.prototype.toString;
  const toISOString = Date.prototype.toISOString;
  const errorToString = Error.prototype.toString;
  const regExpToString = RegExp.prototype.toString;

  /**
   * Explicitly comparing typeof constructor to function avoids undefined as name
   * when mock identity-obj-proxy returns the key as the value for any key.
   */
  const getConstructorName = val => typeof val.constructor === 'function' && val.constructor.name || 'Object';

  /* global window */
  /** Is val is equal to global window object? Works even if it does not exist :) */
  const isWindow = val => typeof window !== 'undefined' && val === window;
  const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  const NEWLINE_REGEXP = /\n/gi;
  class PrettyFormatPluginError extends Error {
    constructor(message, stack) {
      super(message);
      this.stack = stack;
      this.name = this.constructor.name;
    }
  }
  function isToStringedArrayType(toStringed) {
    return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
  }
  function printNumber(val) {
    return Object.is(val, -0) ? '-0' : String(val);
  }
  function printBigInt(val) {
    return String(`${val}n`);
  }
  function printFunction(val, printFunctionName) {
    if (!printFunctionName) {
      return '[Function]';
    }
    return `[Function ${val.name || 'anonymous'}]`;
  }
  function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  }
  function printError(val) {
    return `[${errorToString.call(val)}]`;
  }

  /**
   * The first port of call for printing an object, handles most of the
   * data-types in JS.
   */
  function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === true || val === false) {
      return `${val}`;
    }
    if (val === undefined) {
      return 'undefined';
    }
    if (val === null) {
      return 'null';
    }
    const typeOf = typeof val;
    if (typeOf === 'number') {
      return printNumber(val);
    }
    if (typeOf === 'bigint') {
      return printBigInt(val);
    }
    if (typeOf === 'string') {
      if (escapeString) {
        return `"${val.replace(/"|\\/g, '\\$&')}"`;
      }
      return `"${val}"`;
    }
    if (typeOf === 'function') {
      return printFunction(val, printFunctionName);
    }
    if (typeOf === 'symbol') {
      return printSymbol(val);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object WeakMap]') {
      return 'WeakMap {}';
    }
    if (toStringed === '[object WeakSet]') {
      return 'WeakSet {}';
    }
    if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
      return printFunction(val, printFunctionName);
    }
    if (toStringed === '[object Symbol]') {
      return printSymbol(val);
    }
    if (toStringed === '[object Date]') {
      return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
    }
    if (toStringed === '[object Error]') {
      return printError(val);
    }
    if (toStringed === '[object RegExp]') {
      if (escapeRegex) {
        // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
        return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
      }
      return regExpToString.call(val);
    }
    if (val instanceof Error) {
      return printError(val);
    }
    return null;
  }

  /**
   * Handles more complex objects ( such as objects with circular references.
   * maps and sets etc )
   */
  function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
    if (refs.indexOf(val) !== -1) {
      return '[Circular]';
    }
    refs = refs.slice();
    refs.push(val);
    const hitMaxDepth = ++depth > config.maxDepth;
    const min = config.min;
    if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function' && !hasCalledToJSON) {
      return printer(val.toJSON(), config, indentation, depth, refs, true);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object Arguments]') {
      return hitMaxDepth ? '[Arguments]' : `${min ? '' : 'Arguments '}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (isToStringedArrayType(toStringed)) {
      return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? '' : !config.printBasicPrototype && val.constructor.name === 'Array' ? '' : `${val.constructor.name} `}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (toStringed === '[object Map]') {
      return hitMaxDepth ? '[Map]' : `Map {${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer, ' => ')}}`;
    }
    if (toStringed === '[object Set]') {
      return hitMaxDepth ? '[Set]' : `Set {${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}}`;
    }

    // Avoid failure to serialize global window object in jsdom test environment.
    // For example, not even relevant if window is prop of React element.
    return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? '' : !config.printBasicPrototype && getConstructorName(val) === 'Object' ? '' : `${getConstructorName(val)} `}{${(0, _collections.printObjectProperties)(val, config, indentation, depth, refs, printer)}}`;
  }
  function isNewPlugin(plugin) {
    return plugin.serialize != null;
  }
  function printPlugin(plugin, val, config, indentation, depth, refs) {
    let printed;
    try {
      printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, valChild => printer(valChild, config, indentation, depth, refs), str => {
        const indentationNext = indentation + config.indent;
        return indentationNext + str.replace(NEWLINE_REGEXP, `\n${indentationNext}`);
      }, {
        edgeSpacing: config.spacingOuter,
        min: config.min,
        spacing: config.spacingInner
      }, config.colors);
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed !== 'string') {
      throw new Error(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    }
    return printed;
  }
  function findPlugin(plugins, val) {
    for (let p = 0; p < plugins.length; p++) {
      try {
        if (plugins[p].test(val)) {
          return plugins[p];
        }
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    }
    return null;
  }
  function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
    const plugin = findPlugin(config.plugins, val);
    if (plugin !== null) {
      return printPlugin(plugin, val, config, indentation, depth, refs);
    }
    const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
    if (basicResult !== null) {
      return basicResult;
    }
    return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
  }
  const DEFAULT_THEME = {
    comment: 'gray',
    content: 'reset',
    prop: 'yellow',
    tag: 'cyan',
    value: 'green'
  };
  const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);

  // could be replaced by `satisfies` operator in the future: https://github.com/microsoft/TypeScript/issues/47920
  const toOptionsSubtype = options => options;
  const DEFAULT_OPTIONS = toOptionsSubtype({
    callToJSON: true,
    compareKeys: undefined,
    escapeRegex: false,
    escapeString: true,
    highlight: false,
    indent: 2,
    maxDepth: Infinity,
    maxWidth: Infinity,
    min: false,
    plugins: [],
    printBasicPrototype: true,
    printFunctionName: true,
    theme: DEFAULT_THEME
  });
  exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
  function validateOptions(options) {
    Object.keys(options).forEach(key => {
      if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
        throw new Error(`pretty-format: Unknown option "${key}".`);
      }
    });
    if (options.min && options.indent !== undefined && options.indent !== 0) {
      throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
    }
    if (options.theme !== undefined) {
      if (options.theme === null) {
        throw new Error('pretty-format: Option "theme" must not be null.');
      }
      if (typeof options.theme !== 'object') {
        throw new Error(`pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`);
      }
    }
  }
  const getColorsHighlight = options => DEFAULT_THEME_KEYS.reduce((colors, key) => {
    const value = options.theme && options.theme[key] !== undefined ? options.theme[key] : DEFAULT_THEME[key];
    const color = value && _ansiStyles.default[value];
    if (color && typeof color.close === 'string' && typeof color.open === 'string') {
      colors[key] = color;
    } else {
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    }
    return colors;
  }, Object.create(null));
  const getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key) => {
    colors[key] = {
      close: '',
      open: ''
    };
    return colors;
  }, Object.create(null));
  const getPrintFunctionName = options => options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
  const getEscapeRegex = options => options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
  const getEscapeString = options => options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
  const getConfig = options => ({
    callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
    colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),
    compareKeys: typeof options?.compareKeys === 'function' || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: options?.min ? '' : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
    maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
    min: options?.min ?? DEFAULT_OPTIONS.min,
    plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: options?.printBasicPrototype ?? true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: options?.min ? ' ' : '\n',
    spacingOuter: options?.min ? '' : '\n'
  });
  function createIndent(indent) {
    return new Array(indent + 1).join(' ');
  }

  /**
   * Returns a presentation string of your `val` object
   * @param val any potential JavaScript object
   * @param options Custom settings
   */
  function format(val, options) {
    if (options) {
      validateOptions(options);
      if (options.plugins) {
        const plugin = findPlugin(options.plugins, val);
        if (plugin !== null) {
          return printPlugin(plugin, val, getConfig(options), '', 0, []);
        }
      }
    }
    const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    if (basicResult !== null) {
      return basicResult;
    }
    return printComplexValue(val, getConfig(options), '', 0, []);
  }
  const plugins = {
    AsymmetricMatcher: _AsymmetricMatcher.default,
    DOMCollection: _DOMCollection.default,
    DOMElement: _DOMElement.default,
    Immutable: _Immutable.default,
    ReactElement: _ReactElement.default,
    ReactTestComponent: _ReactTestComponent.default
  };
  exports.plugins = plugins;
  var _default = format;
  exports.default = _default;
},292,[293,294,295,296,297,300,301,304],"node_modules\\pretty-format\\build\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  const ANSI_BACKGROUND_OFFSET = 10;
  const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;
  const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };

    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\u001B[${style[0]}m`,
          close: `\u001B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
      rgbToAnsi256: {
        value: (red, green, blue) => {
          // We use the extended greyscale palette here, with the exception of
          // black and white. normal palette only has 4 greyscale shades.
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value: hex => {
          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let {
            colorString
          } = matches.groups;
          if (colorString.length === 3) {
            colorString = colorString.split('').map(character => character + character).join('');
          }
          const integer = Number.parseInt(colorString, 16);
          return [integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
        enumerable: false
      }
    });
    return styles;
  }

  // Make the export immutable
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
},293,[],"node_modules\\pretty-format\\node_modules\\ansi-styles\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.printIteratorEntries = printIteratorEntries;
  exports.printIteratorValues = printIteratorValues;
  exports.printListItems = printListItems;
  exports.printObjectProperties = printObjectProperties;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  const getKeysOfEnumerableProperties = (object, compareKeys) => {
    const rawKeys = Object.keys(object);
    const keys = compareKeys !== null ? rawKeys.sort(compareKeys) : rawKeys;
    if (Object.getOwnPropertySymbols) {
      Object.getOwnPropertySymbols(object).forEach(symbol => {
        if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
          keys.push(symbol);
        }
      });
    }
    return keys;
  };

  /**
   * Return entries (for example, of a map)
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, braces)
   */
  function printIteratorEntries(iterator, config, indentation, depth, refs, printer,
  // Too bad, so sad that separator for ECMAScript Map has been ' => '
  // What a distracting diff if you change a data structure to/from
  // ECMAScript Object or Immutable.Map/OrderedMap which use the default.
  separator = ': ') {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      while (!current.done) {
        result += indentationNext;
        if (width++ === config.maxWidth) {
          result += '';
          break;
        }
        const name = printer(current.value[0], config, indentationNext, depth, refs);
        const value = printer(current.value[1], config, indentationNext, depth, refs);
        result += name + separator + value;
        current = iterator.next();
        if (!current.done) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return values (for example, of a set)
   * with spacing, indentation, and comma
   * without surrounding punctuation (braces or brackets)
   */
  function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      while (!current.done) {
        result += indentationNext;
        if (width++ === config.maxWidth) {
          result += '';
          break;
        }
        result += printer(current.value, config, indentationNext, depth, refs);
        current = iterator.next();
        if (!current.done) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return items (for example, of an array)
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, brackets)
   **/
  function printListItems(list, config, indentation, depth, refs, printer) {
    let result = '';
    if (list.length) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      for (let i = 0; i < list.length; i++) {
        result += indentationNext;
        if (i === config.maxWidth) {
          result += '';
          break;
        }
        if (i in list) {
          result += printer(list[i], config, indentationNext, depth, refs);
        }
        if (i < list.length - 1) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return properties of an object
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, braces)
   */
  function printObjectProperties(val, config, indentation, depth, refs, printer) {
    let result = '';
    const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
    if (keys.length) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const name = printer(key, config, indentationNext, depth, refs);
        const value = printer(val[key], config, indentationNext, depth, refs);
        result += `${indentationNext + name}: ${value}`;
        if (i < keys.length - 1) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }
},294,[],"node_modules\\pretty-format\\build\\collections.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  const asymmetricMatcher = typeof Symbol === 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 0x1357a5;
  const SPACE = ' ';
  const serialize = (val, config, indentation, depth, refs, printer) => {
    const stringedValue = val.toString();
    if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
      if (++depth > config.maxDepth) {
        return `[${stringedValue}]`;
      }
      return `${stringedValue + SPACE}[${(0, _collections.printListItems)(val.sample, config, indentation, depth, refs, printer)}]`;
    }
    if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
      if (++depth > config.maxDepth) {
        return `[${stringedValue}]`;
      }
      return `${stringedValue + SPACE}{${(0, _collections.printObjectProperties)(val.sample, config, indentation, depth, refs, printer)}}`;
    }
    if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
      return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
      return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (typeof val.toAsymmetricMatcher !== 'function') {
      throw new Error(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    }
    return val.toAsymmetricMatcher();
  };
  exports.serialize = serialize;
  const test = val => val && val.$$typeof === asymmetricMatcher;
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},295,[294],"node_modules\\pretty-format\\build\\plugins\\AsymmetricMatcher.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const SPACE = ' ';
  const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
  const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
  const testName = name => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
  const test = val => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
  exports.test = test;
  const isNamedNodeMap = collection => collection.constructor.name === 'NamedNodeMap';
  const serialize = (collection, config, indentation, depth, refs, printer) => {
    const name = collection.constructor.name;
    if (++depth > config.maxDepth) {
      return `[${name}]`;
    }
    return (config.min ? '' : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? `{${(0, _collections.printObjectProperties)(isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
      props[attribute.name] = attribute.value;
      return props;
    }, {}) : Object.assign({}, collection), config, indentation, depth, refs, printer)}}` : `[${(0, _collections.printListItems)(Array.from(collection), config, indentation, depth, refs, printer)}]`);
  };
  exports.serialize = serialize;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},296,[294],"node_modules\\pretty-format\\build\\plugins\\DOMCollection.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require(_dependencyMap[0], "./lib/markup");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const ELEMENT_NODE = 1;
  const TEXT_NODE = 3;
  const COMMENT_NODE = 8;
  const FRAGMENT_NODE = 11;
  const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
  const testHasAttribute = val => {
    try {
      return typeof val.hasAttribute === 'function' && val.hasAttribute('is');
    } catch {
      return false;
    }
  };
  const testNode = val => {
    const constructorName = val.constructor.name;
    const {
      nodeType,
      tagName
    } = val;
    const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === 'Text' || nodeType === COMMENT_NODE && constructorName === 'Comment' || nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment';
  };
  const test = val => val?.constructor?.name && testNode(val);
  exports.test = test;
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
  }
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
  }
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  const serialize = (node, config, indentation, depth, refs, printer) => {
    if (nodeIsText(node)) {
      return (0, _markup.printText)(node.data, config);
    }
    if (nodeIsComment(node)) {
      return (0, _markup.printComment)(node.data, config);
    }
    const type = nodeIsFragment(node) ? 'DocumentFragment' : node.tagName.toLowerCase();
    if (++depth > config.maxDepth) {
      return (0, _markup.printElementAsLeaf)(type, config);
    }
    return (0, _markup.printElement)(type, (0, _markup.printProps)(nodeIsFragment(node) ? [] : Array.from(node.attributes, attr => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
      props[attribute.name] = attribute.value;
      return props;
    }, {}), config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
  };
  exports.serialize = serialize;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},297,[298],"node_modules\\pretty-format\\build\\plugins\\DOMElement.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
  var _escapeHTML = _interopRequireDefault(require(_dependencyMap[0], "./escapeHTML"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Return empty string if keys is empty.
  const printProps = (keys, props, config, indentation, depth, refs, printer) => {
    const indentationNext = indentation + config.indent;
    const colors = config.colors;
    return keys.map(key => {
      const value = props[key];
      let printed = printer(value, config, indentationNext, depth, refs);
      if (typeof value !== 'string') {
        if (printed.indexOf('\n') !== -1) {
          printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
        }
        printed = `{${printed}}`;
      }
      return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
    }).join('');
  };

  // Return empty string if children is empty.
  exports.printProps = printProps;
  const printChildren = (children, config, indentation, depth, refs, printer) => children.map(child => config.spacingOuter + indentation + (typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs))).join('');
  exports.printChildren = printChildren;
  const printText = (text, config) => {
    const contentColor = config.colors.content;
    return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
  };
  exports.printText = printText;
  const printComment = (comment, config) => {
    const commentColor = config.colors.comment;
    return `${commentColor.open}<!--${(0, _escapeHTML.default)(comment)}-->${commentColor.close}`;
  };

  // Separate the functions to format props, children, and element,
  // so a plugin could override a particular function, if needed.
  // Too bad, so sad: the traditional (but unnecessary) space
  // in a self-closing tagColor requires a second test of printedProps.
  exports.printComment = printComment;
  const printElement = (type, printedProps, printedChildren, config, indentation) => {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? '' : ' '}/`}>${tagColor.close}`;
  };
  exports.printElement = printElement;
  const printElementAsLeaf = (type, config) => {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
  };
  exports.printElementAsLeaf = printElementAsLeaf;
},298,[299],"node_modules\\pretty-format\\build\\plugins\\lib\\markup.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.default = escapeHTML;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function escapeHTML(str) {
    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
},299,[],"node_modules\\pretty-format\\build\\plugins\\lib\\escapeHTML.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // SENTINEL constants are from https://github.com/facebook/immutable-js
  const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
  const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
  const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
  const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4
  const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
  const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
  const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
  const getImmutableName = name => `Immutable.${name}`;
  const printAsLeaf = name => `[${name}]`;
  const SPACE = ' ';
  const LAZY = ''; // Seq is lazy if it calls a method like filter

  const printImmutableEntries = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer)}}`;

  // Record has an entries method because it is a collection in immutable v3.
  // Return an iterator for Immutable Record from version v3 or v4.
  function getRecordEntries(val) {
    let i = 0;
    return {
      next() {
        if (i < val._keys.length) {
          const key = val._keys[i++];
          return {
            done: false,
            value: [key, val.get(key)]
          };
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
  const printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
    // _name property is defined only for an Immutable Record instance
    // which was constructed with a second optional descriptive name arg
    const name = getImmutableName(val._name || 'Record');
    return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${(0, _collections.printIteratorEntries)(getRecordEntries(val), config, indentation, depth, refs, printer)}}`;
  };
  const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
    const name = getImmutableName('Seq');
    if (++depth > config.maxDepth) {
      return printAsLeaf(name);
    }
    if (val[IS_KEYED_SENTINEL]) {
      return `${name + SPACE}{${
      // from Immutable collection of entries or from ECMAScript object
      val._iter || val._object ? (0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) : LAZY}}`;
    }
    return `${name + SPACE}[${val._iter ||
    // from Immutable collection of values
    val._array ||
    // from ECMAScript array
    val._collection ||
    // from ECMAScript collection in immutable v4
    val._iterable // from ECMAScript collection in immutable v3
    ? (0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) : LAZY}]`;
  };
  const printImmutableValues = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}]`;
  const serialize = (val, config, indentation, depth, refs, printer) => {
    if (val[IS_MAP_SENTINEL]) {
      return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
    }
    if (val[IS_LIST_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
    }
    if (val[IS_SET_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
    }
    if (val[IS_STACK_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
    }
    if (val[IS_SEQ_SENTINEL]) {
      return printImmutableSeq(val, config, indentation, depth, refs, printer);
    }

    // For compatibility with immutable v3 and v4, let record be the default.
    return printImmutableRecord(val, config, indentation, depth, refs, printer);
  };

  // Explicitly comparing sentinel properties to true avoids false positive
  // when mock identity-obj-proxy returns the key as the value for any key.
  exports.serialize = serialize;
  const test = val => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},300,[294],"node_modules\\pretty-format\\build\\plugins\\Immutable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var ReactIs = _interopRequireWildcard(require(_dependencyMap[0], "react-is"));
  var _markup = require(_dependencyMap[1], "./lib/markup");
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== 'function') return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Given element.props.children, or subtree during recursive traversal,
  // return flattened array of children.
  const getChildren = (arg, children = []) => {
    if (Array.isArray(arg)) {
      arg.forEach(item => {
        getChildren(item, children);
      });
    } else if (arg != null && arg !== false) {
      children.push(arg);
    }
    return children;
  };
  const getType = element => {
    const type = element.type;
    if (typeof type === 'string') {
      return type;
    }
    if (typeof type === 'function') {
      return type.displayName || type.name || 'Unknown';
    }
    if (ReactIs.isFragment(element)) {
      return 'React.Fragment';
    }
    if (ReactIs.isSuspense(element)) {
      return 'React.Suspense';
    }
    if (typeof type === 'object' && type !== null) {
      if (ReactIs.isContextProvider(element)) {
        return 'Context.Provider';
      }
      if (ReactIs.isContextConsumer(element)) {
        return 'Context.Consumer';
      }
      if (ReactIs.isForwardRef(element)) {
        if (type.displayName) {
          return type.displayName;
        }
        const functionName = type.render.displayName || type.render.name || '';
        return functionName !== '' ? `ForwardRef(${functionName})` : 'ForwardRef';
      }
      if (ReactIs.isMemo(element)) {
        const functionName = type.displayName || type.type.displayName || type.type.name || '';
        return functionName !== '' ? `Memo(${functionName})` : 'Memo';
      }
    }
    return 'UNDEFINED';
  };
  const getPropKeys = element => {
    const {
      props
    } = element;
    return Object.keys(props).filter(key => key !== 'children' && props[key] !== undefined).sort();
  };
  const serialize = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(getType(element), (0, _markup.printProps)(getPropKeys(element), element.props, config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
  exports.serialize = serialize;
  const test = val => val != null && ReactIs.isElement(val);
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},301,[302,298],"node_modules\\pretty-format\\build\\plugins\\ReactElement.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-is.production.min.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-is.development.js");
  }
},302,[4,303],"node_modules\\pretty-format\\node_modules\\react-is\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      // ATTENTION
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types.
      var REACT_ELEMENT_TYPE = Symbol.for('react.element');
      var REACT_PORTAL_TYPE = Symbol.for('react.portal');
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
      var REACT_CONTEXT_TYPE = Symbol.for('react.context');
      var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
      var REACT_MEMO_TYPE = Symbol.for('react.memo');
      var REACT_LAZY_TYPE = Symbol.for('react.lazy');
      var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

      // -----------------------------------------------------------------------------

      var enableScopeAPI = false; // Experimental Create Event Handle API.
      var enableCacheElement = false;
      var enableTransitionTracing = false; // No known bugs, but needs performance testing

      var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
      // stuff. Intended to enable React core members to more easily debug scheduling
      // issues in DEV builds.

      var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
      }
      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
          // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      exports.ContextConsumer = ContextConsumer;
      exports.ContextProvider = ContextProvider;
      exports.Element = Element;
      exports.ForwardRef = ForwardRef;
      exports.Fragment = Fragment;
      exports.Lazy = Lazy;
      exports.Memo = Memo;
      exports.Portal = Portal;
      exports.Profiler = Profiler;
      exports.StrictMode = StrictMode;
      exports.Suspense = Suspense;
      exports.SuspenseList = SuspenseList;
      exports.isAsyncMode = isAsyncMode;
      exports.isConcurrentMode = isConcurrentMode;
      exports.isContextConsumer = isContextConsumer;
      exports.isContextProvider = isContextProvider;
      exports.isElement = isElement;
      exports.isForwardRef = isForwardRef;
      exports.isFragment = isFragment;
      exports.isLazy = isLazy;
      exports.isMemo = isMemo;
      exports.isPortal = isPortal;
      exports.isProfiler = isProfiler;
      exports.isStrictMode = isStrictMode;
      exports.isSuspense = isSuspense;
      exports.isSuspenseList = isSuspenseList;
      exports.isValidElementType = isValidElementType;
      exports.typeOf = typeOf;
    })();
  }
},303,[],"node_modules\\pretty-format\\node_modules\\react-is\\cjs\\react-is.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require(_dependencyMap[0], "./lib/markup");
  var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  // Child can be `number` in Stack renderer but not in Fiber renderer.

  const testSymbol = typeof Symbol === 'function' && Symbol.for ? Symbol.for('react.test.json') : 0xea71357;
  const getPropKeys = object => {
    const {
      props
    } = object;
    return props ? Object.keys(props).filter(key => props[key] !== undefined).sort() : [];
  };
  const serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? (0, _markup.printChildren)(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
  exports.serialize = serialize;
  const test = val => val && val.$$typeof === testSymbol;
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},304,[298],"node_modules\\pretty-format\\build\\plugins\\ReactTestComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _DeviceEventEmitter = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/DeviceEventEmitter"));
  /**
   * Copyright  2023 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Ensure events are sent so custom Fast Refresh views are shown.
  function showMessage(message, _type) {
    _DeviceEventEmitter.default.emit('devLoadingView:showMessage', {
      message
    });
  }
  function hide() {
    _DeviceEventEmitter.default.emit('devLoadingView:hide', {});
  }
  var _default = exports.default = {
    showMessage,
    hide
  };
},305,[17,266],"node_modules\\@expo\\metro-runtime\\src\\LoadingView.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ExtendedExceptionData", {
    enumerable: true,
    get: function () {
      return _parseLogBoxLog.ExtendedExceptionData;
    }
  });
  Object.defineProperty(exports, "IgnorePattern", {
    enumerable: true,
    get: function () {
      return _LogBoxData.IgnorePattern;
    }
  });
  Object.defineProperty(exports, "LogData", {
    enumerable: true,
    get: function () {
      return _LogBoxData.LogData;
    }
  });
  exports.default = void 0;
  var _LogBoxData = require(_dependencyMap[0], "./Data/LogBoxData");
  var _parseLogBoxLog = require(_dependencyMap[1], "./Data/parseLogBoxLog");
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  let LogBox;
  /**
   * LogBox displays logs in the app.
   */
  if (__DEV__) {
    const LogBoxData = require(_dependencyMap[2], "./Data/LogBoxData");
    const {
      parseLogBoxLog,
      parseInterpolation
    } = require(_dependencyMap[3], "./Data/parseLogBoxLog");
    let originalConsoleError;
    let consoleErrorImpl;
    let isLogBoxInstalled = false;
    LogBox = {
      install() {
        if (isLogBoxInstalled) {
          return;
        }
        isLogBoxInstalled = true;

        // Trigger lazy initialization of module.
        // require("../NativeModules/specs/NativeLogBox");

        // IMPORTANT: we only overwrite `console.error` and `console.warn` once.
        // When we uninstall we keep the same reference and only change its
        // internal implementation
        const isFirstInstall = originalConsoleError == null;
        if (isFirstInstall) {
          originalConsoleError = console.error.bind(console);
          console.error = (...args) => {
            consoleErrorImpl?.(...args);
          };
        }
        consoleErrorImpl = registerError;
        if (process.env.NODE_ENV === 'test') {
          LogBoxData.setDisabled(true);
        }
      },
      uninstall() {
        if (!isLogBoxInstalled) {
          return;
        }
        isLogBoxInstalled = false;

        // IMPORTANT: we don't re-assign to `console` in case the method has been
        // decorated again after installing LogBox. E.g.:
        // Before uninstalling: original > LogBox > OtherErrorHandler
        // After uninstalling:  original > LogBox (noop) > OtherErrorHandler
        consoleErrorImpl = originalConsoleError;
        delete console.disableLogBox;
      },
      isInstalled() {
        return isLogBoxInstalled;
      },
      ignoreLogs(patterns) {
        LogBoxData.addIgnorePatterns(patterns);
      },
      ignoreAllLogs(value) {
        LogBoxData.setDisabled(value == null ? true : value);
      },
      clearAllLogs() {
        LogBoxData.clear();
      },
      addLog(log) {
        if (isLogBoxInstalled) {
          LogBoxData.addLog(log);
        }
      },
      addException(error) {
        if (isLogBoxInstalled) {
          LogBoxData.addException(error);
        }
      }
    };
    const isWarningModuleWarning = (...args) => {
      return typeof args[0] === 'string' && args[0].startsWith('Warning: ');
    };
    const registerError = (...args) => {
      // Let errors within LogBox itself fall through.
      if (LogBoxData.isLogBoxErrorMessage(args[0])) {
        originalConsoleError?.(...args);
        return;
      }
      try {
        if (!isWarningModuleWarning(...args)) {
          // Only show LogBox for the 'warning' module, otherwise pass through.
          // By passing through, this will get picked up by the React console override,
          // potentially adding the component stack. React then passes it back to the
          // React Native ExceptionsManager, which reports it to LogBox as an error.
          //
          // The 'warning' module needs to be handled here because React internally calls
          // `console.error('Warning: ')` with the component stack already included.
          originalConsoleError?.(...args);
          return;
        }
        const {
          category,
          message,
          componentStack
        } = parseLogBoxLog(args);
        if (!LogBoxData.isMessageIgnored(message.content)) {
          // Interpolate the message so they are formatted for adb and other CLIs.
          // This is different than the message.content above because it includes component stacks.
          const interpolated = parseInterpolation(args);
          originalConsoleError?.(interpolated.message.content);
          LogBoxData.addLog({
            // Always show the static rendering issues as full screen since they
            // are too confusing otherwise.
            level: /did not match\. Server:/.test(message.content) ? 'fatal' : 'error',
            category,
            message,
            componentStack
          });
        }
      } catch (err) {
        LogBoxData.reportUnexpectedLogBoxError(err);
      }
    };
  } else {
    LogBox = {
      install() {},
      uninstall() {},
      isInstalled() {
        return false;
      },
      ignoreLogs(_patterns) {},
      ignoreAllLogs(_value) {},
      clearAllLogs() {},
      addLog(_log) {},
      addException(_ex) {}
    };
  }
  var _default = exports.default = LogBox;
},306,[307,312,307,312],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\LogBox.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addException = addException;
  exports.addIgnorePatterns = addIgnorePatterns;
  exports.addLog = addLog;
  exports.clear = clear;
  exports.clearErrors = clearErrors;
  exports.clearWarnings = clearWarnings;
  exports.dismiss = dismiss;
  exports.getIgnorePatterns = getIgnorePatterns;
  exports.isDisabled = isDisabled;
  exports.isLogBoxErrorMessage = isLogBoxErrorMessage;
  exports.isMessageIgnored = isMessageIgnored;
  exports.observe = observe;
  exports.reportLogBoxError = reportLogBoxError;
  exports.reportUnexpectedLogBoxError = reportUnexpectedLogBoxError;
  exports.retrySymbolicateLogNow = retrySymbolicateLogNow;
  exports.setDisabled = setDisabled;
  exports.setSelectedLog = setSelectedLog;
  exports.symbolicateLogLazy = symbolicateLogLazy;
  exports.symbolicateLogNow = symbolicateLogNow;
  exports.withSubscription = withSubscription;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/NativeEventEmitter"));
  var _LogBoxLog = require(_dependencyMap[3], "./LogBoxLog");
  var _LogContext = require(_dependencyMap[4], "./LogContext");
  var _parseLogBoxLog = require(_dependencyMap[5], "./parseLogBoxLog");
  var _NativeLogBox = _interopRequireDefault(require(_dependencyMap[6], "../modules/NativeLogBox"));
  var _parseErrorStack = _interopRequireDefault(require(_dependencyMap[7], "../modules/parseErrorStack"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxData.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const observers = new Set();
  const ignorePatterns = new Set();
  let logs = new Set();
  let updateTimeout = null;
  let _isDisabled = false;
  let _selectedIndex = -1;
  const LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';
  function getNextState() {
    return {
      logs,
      isDisabled: _isDisabled,
      selectedLogIndex: _selectedIndex
    };
  }
  function reportLogBoxError(error, componentStack) {
    const ExceptionsManager = require(_dependencyMap[9], "../modules/ExceptionsManager").default;
    if (componentStack != null) {
      error.componentStack = componentStack;
    }
    ExceptionsManager.handleException(error);
  }
  function reportUnexpectedLogBoxError(error, componentStack) {
    error.message = `${LOGBOX_ERROR_MESSAGE}\n\n${error.message}`;
    return reportLogBoxError(error, componentStack);
  }
  function isLogBoxErrorMessage(message) {
    return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);
  }
  function isMessageIgnored(message) {
    for (const pattern of ignorePatterns) {
      if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {
        return true;
      }
    }
    return false;
  }
  function handleUpdate() {
    if (updateTimeout == null) {
      updateTimeout = setTimeout(() => {
        updateTimeout = null;
        const nextState = getNextState();
        observers.forEach(({
          observer
        }) => observer(nextState));
      }, 0);
    }
  }
  function appendNewLog(newLog) {
    // Don't want store these logs because they trigger a
    // state update when we add them to the store.
    if (isMessageIgnored(newLog.message.content)) {
      return;
    }

    // If the next log has the same category as the previous one
    // then roll it up into the last log in the list by incrementing
    // the count (similar to how Chrome does it).
    const lastLog = Array.from(logs).pop();
    if (lastLog && lastLog.category === newLog.category) {
      lastLog.incrementCount();
      handleUpdate();
      return;
    }
    if (newLog.level === 'fatal') {
      // If possible, to avoid jank, we don't want to open the error before
      // it's symbolicated. To do that, we optimistically wait for
      // symbolication for up to a second before adding the log.
      const OPTIMISTIC_WAIT_TIME = 1000;
      let addPendingLog = () => {
        logs.add(newLog);
        if (_selectedIndex < 0) {
          setSelectedLog(logs.size - 1);
        } else {
          handleUpdate();
        }
        addPendingLog = null;
      };
      const optimisticTimeout = setTimeout(() => {
        if (addPendingLog) {
          addPendingLog();
        }
      }, OPTIMISTIC_WAIT_TIME);

      // TODO: HANDLE THIS
      newLog.symbolicate('component');
      newLog.symbolicate('stack', status => {
        if (addPendingLog && status !== 'PENDING') {
          addPendingLog();
          clearTimeout(optimisticTimeout);
        } else if (status !== 'PENDING') {
          // The log has already been added but we need to trigger a render.
          handleUpdate();
        }
      });
    } else if (newLog.level === 'syntax') {
      logs.add(newLog);
      setSelectedLog(logs.size - 1);
    } else {
      logs.add(newLog);
      handleUpdate();
    }
  }
  function addLog(log) {
    const errorForStackTrace = new Error();

    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        const stack = (0, _parseErrorStack.default)(errorForStackTrace?.stack);
        appendNewLog(new _LogBoxLog.LogBoxLog({
          level: log.level,
          message: log.message,
          isComponentError: false,
          stack,
          category: log.category,
          componentStack: log.componentStack
        }));
      } catch (error) {
        reportUnexpectedLogBoxError(error);
      }
    }, 0);
  }
  function addException(error) {
    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        appendNewLog(new _LogBoxLog.LogBoxLog((0, _parseLogBoxLog.parseLogBoxException)(error)));
      } catch (loggingError) {
        reportUnexpectedLogBoxError(loggingError);
      }
    }, 0);
  }
  function symbolicateLogNow(type, log) {
    log.symbolicate(type, () => {
      handleUpdate();
    });
  }
  function retrySymbolicateLogNow(type, log) {
    log.retrySymbolicate(type, () => {
      handleUpdate();
    });
  }
  function symbolicateLogLazy(type, log) {
    log.symbolicate(type);
  }
  function clear() {
    if (logs.size > 0) {
      logs = new Set();
      setSelectedLog(-1);
    }
  }
  function setSelectedLog(proposedNewIndex) {
    const oldIndex = _selectedIndex;
    let newIndex = proposedNewIndex;
    const logArray = Array.from(logs);
    let index = logArray.length - 1;
    while (index >= 0) {
      // The latest syntax error is selected and displayed before all other logs.
      if (logArray[index].level === 'syntax') {
        newIndex = index;
        break;
      }
      index -= 1;
    }
    _selectedIndex = newIndex;
    handleUpdate();
    if (_NativeLogBox.default) {
      setTimeout(() => {
        if (oldIndex < 0 && newIndex >= 0) {
          _NativeLogBox.default.show();
        } else if (oldIndex >= 0 && newIndex < 0) {
          _NativeLogBox.default.hide();
        }
      }, 0);
    }
  }
  function clearWarnings() {
    const newLogs = Array.from(logs).filter(log => log.level !== 'warn');
    if (newLogs.length !== logs.size) {
      logs = new Set(newLogs);
      setSelectedLog(-1);
      handleUpdate();
    }
  }
  function clearErrors() {
    const newLogs = Array.from(logs).filter(log => log.level !== 'error' && log.level !== 'fatal');
    if (newLogs.length !== logs.size) {
      logs = new Set(newLogs);
      setSelectedLog(-1);
    }
  }
  function dismiss(log) {
    if (logs.has(log)) {
      logs.delete(log);
      handleUpdate();
    }
  }
  function getIgnorePatterns() {
    return Array.from(ignorePatterns);
  }
  function addIgnorePatterns(patterns) {
    const existingSize = ignorePatterns.size;
    // The same pattern may be added multiple times, but adding a new pattern
    // can be expensive so let's find only the ones that are new.
    patterns.forEach(pattern => {
      if (pattern instanceof RegExp) {
        for (const existingPattern of ignorePatterns) {
          if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {
            return;
          }
        }
        ignorePatterns.add(pattern);
      }
      ignorePatterns.add(pattern);
    });
    if (ignorePatterns.size === existingSize) {
      return;
    }
    // We need to recheck all of the existing logs.
    // This allows adding an ignore pattern anywhere in the codebase.
    // Without this, if you ignore a pattern after the a log is created,
    // then we would keep showing the log.
    logs = new Set(Array.from(logs).filter(log => !isMessageIgnored(log.message.content)));
    handleUpdate();
  }
  function setDisabled(value) {
    if (value === _isDisabled) {
      return;
    }
    _isDisabled = value;
    handleUpdate();
  }
  function isDisabled() {
    return _isDisabled;
  }
  function observe(observer) {
    const subscription = {
      observer
    };
    observers.add(subscription);
    observer(getNextState());
    return {
      unsubscribe() {
        observers.delete(subscription);
      }
    };
  }
  const emitter = new _NativeEventEmitter.default({
    addListener() {},
    removeListeners() {}
  });
  function withSubscription(WrappedComponent) {
    class LogBoxStateSubscription extends React.Component {
      static getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
      constructor(props) {
        super(props);
        if (process.env.NODE_ENV === 'development') {
          emitter.addListener('devLoadingView:hide', () => {
            if (this.state.hasError) {
              this.retry();
            }
          });
        }
      }
      componentDidCatch(err, errorInfo) {
        /* $FlowFixMe[class-object-subtyping] added when improving typing for
         * this parameters */
        reportLogBoxError(err, errorInfo.componentStack);
      }
      state = {
        logs: new Set(),
        isDisabled: false,
        hasError: false,
        selectedLogIndex: -1
      };
      retry = () => {
        return new Promise(resolve => {
          this.setState({
            hasError: false
          }, () => {
            resolve();
          });
        });
      };
      render() {
        return (0, _jsxRuntime.jsxs)(_LogContext.LogContext.Provider, {
          value: {
            selectedLogIndex: this.state.selectedLogIndex,
            isDisabled: this.state.isDisabled,
            logs: Array.from(this.state.logs)
          },
          children: [this.state.hasError ? null : this.props.children, (0, _jsxRuntime.jsx)(WrappedComponent, {})]
        });
      }
      componentDidMount() {
        this._subscription = observe(data => {
          // Ignore the initial empty log
          if (data.selectedLogIndex === -1) return;
          React.startTransition(() => {
            this.setState(data);
          });
        });
      }
      componentWillUnmount() {
        if (this._subscription != null) {
          this._subscription.unsubscribe();
        }
      }
      _handleDismiss = () => {
        // Here we handle the cases when the log is dismissed and it
        // was either the last log, or when the current index
        // is now outside the bounds of the log array.
        const {
          selectedLogIndex,
          logs: stateLogs
        } = this.state;
        const logsArray = Array.from(stateLogs);
        if (selectedLogIndex != null) {
          if (logsArray.length - 1 <= 0) {
            setSelectedLog(-1);
          } else if (selectedLogIndex >= logsArray.length - 1) {
            setSelectedLog(selectedLogIndex - 1);
          }
          dismiss(logsArray[selectedLogIndex]);
        }
      };
      _handleMinimize = () => {
        setSelectedLog(-1);
      };
      _handleSetSelectedLog = index => {
        setSelectedLog(index);
      };
    }

    // @ts-expect-error
    return LogBoxStateSubscription;
  }
},307,[17,3,223,308,311,312,316,313,2,338],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxData.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxLog = void 0;
  var LogBoxSymbolication = _interopRequireWildcard(require(_dependencyMap[0], "./LogBoxSymbolication"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function componentStackToStack(componentStack) {
    return componentStack.map(stack => ({
      file: stack.fileName,
      methodName: stack.content,
      lineNumber: stack.location?.row ?? 0,
      column: stack.location?.column ?? 0,
      arguments: []
    }));
  }
  class LogBoxLog {
    symbolicated = {
      stack: {
        error: null,
        stack: null,
        status: 'NONE'
      },
      component: {
        error: null,
        stack: null,
        status: 'NONE'
      }
    };
    callbacks = new Map();
    constructor(data) {
      this.level = data.level;
      this.type = data.type ?? 'error';
      this.message = data.message;
      this.stack = data.stack;
      this.category = data.category;
      this.componentStack = data.componentStack;
      this.codeFrame = data.codeFrame;
      this.isComponentError = data.isComponentError;
      this.count = 1;
      this.symbolicated = data.symbolicated ?? this.symbolicated;
    }
    incrementCount() {
      this.count += 1;
    }
    getAvailableStack(type) {
      if (this.symbolicated[type].status === 'COMPLETE') {
        return this.symbolicated[type].stack;
      }
      return this.getStack(type);
    }
    flushCallbacks(type) {
      const callbacks = this.callbacks.get(type);
      const status = this.symbolicated[type].status;
      if (callbacks) {
        for (const callback of callbacks) {
          callback(status);
        }
        callbacks.clear();
      }
    }
    pushCallback(type, callback) {
      let callbacks = this.callbacks.get(type);
      if (!callbacks) {
        callbacks = new Set();
        this.callbacks.set(type, callbacks);
      }
      callbacks.add(callback);
    }
    retrySymbolicate(type, callback) {
      this._symbolicate(type, true, callback);
    }
    symbolicate(type, callback) {
      this._symbolicate(type, false, callback);
    }
    _symbolicate(type, retry, callback) {
      if (callback) {
        this.pushCallback(type, callback);
      }
      const status = this.symbolicated[type].status;
      if (status === 'COMPLETE') {
        return this.flushCallbacks(type);
      }
      if (retry) {
        LogBoxSymbolication.deleteStack(this.getStack(type));
        this.handleSymbolicate(type);
      } else {
        if (status === 'NONE') {
          this.handleSymbolicate(type);
        }
      }
    }
    componentStackCache = null;
    getStack(type) {
      if (type === 'component') {
        if (this.componentStackCache == null) {
          this.componentStackCache = componentStackToStack(this.componentStack);
        }
        return this.componentStackCache;
      }
      return this.stack;
    }
    handleSymbolicate(type) {
      if (type === 'component' && !this.componentStack?.length) {
        return;
      }
      if (this.symbolicated[type].status !== 'PENDING') {
        this.updateStatus(type, null, null, null);
        LogBoxSymbolication.symbolicate(ensureStackFilesHaveParams(this.getStack(type))).then(data => {
          this.updateStatus(type, null, data?.stack, data?.codeFrame);
        }, error => {
          this.updateStatus(type, error, null, null);
        });
      }
    }
    updateStatus(type, error, stack, codeFrame) {
      const lastStatus = this.symbolicated[type].status;
      if (error != null) {
        this.symbolicated[type] = {
          error,
          stack: null,
          status: 'FAILED'
        };
      } else if (stack != null) {
        if (codeFrame) {
          this.codeFrame = codeFrame;
        }
        this.symbolicated[type] = {
          error: null,
          stack,
          status: 'COMPLETE'
        };
      } else {
        this.symbolicated[type] = {
          error: null,
          stack: null,
          status: 'PENDING'
        };
      }
      const status = this.symbolicated[type].status;
      if (lastStatus !== status) {
        if (['COMPLETE', 'FAILED'].includes(status)) {
          this.flushCallbacks(type);
        }
      }
    }
  }

  // Sometime the web stacks don't have correct query params, this can lead to Metro errors when it attempts to resolve without a platform.
  // This will attempt to reconcile the issue by adding the current query params to the stack frames if they exist, or fallback to some common defaults.
  exports.LogBoxLog = LogBoxLog;
  function ensureStackFilesHaveParams(stack) {
    const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;
    const currentParams = currentSrc ? new URLSearchParams(currentSrc) : new URLSearchParams({
      platform: 'web',
      dev: String(__DEV__)
    });
    return stack.map(frame => {
      if (!frame.file?.startsWith('http') ||
      // Account for Metro malformed URLs
      frame.file.includes('&platform=')) return frame;
      const url = new URL(frame.file);
      if (url.searchParams.has('platform')) {
        return frame;
      }
      currentParams.forEach((value, key) => {
        if (url.searchParams.has(key)) return;
        url.searchParams.set(key, value);
      });
      return Object.assign({}, frame, {
        file: url.toString()
      });
    });
  }
},308,[309],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxLog.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.deleteStack = deleteStack;
  exports.symbolicate = symbolicate;
  var _symbolicateStackTrace = _interopRequireDefault(require(_dependencyMap[1], "../modules/symbolicateStackTrace"));
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const cache = new Map();

  /**
   * Sanitize because sometimes, `symbolicateStackTrace` gives us invalid values.
   */
  const sanitize = ({
    stack: maybeStack,
    codeFrame
  }) => {
    if (!Array.isArray(maybeStack)) {
      throw new Error('Expected stack to be an array.');
    }
    const stack = [];
    for (const maybeFrame of maybeStack) {
      let collapse = false;
      if ('collapse' in maybeFrame) {
        if (typeof maybeFrame.collapse !== 'boolean') {
          throw new Error('Expected stack frame `collapse` to be a boolean.');
        }
        collapse = maybeFrame.collapse;
      }
      stack.push({
        arguments: [],
        column: maybeFrame.column,
        file: maybeFrame.file,
        lineNumber: maybeFrame.lineNumber,
        methodName: maybeFrame.methodName,
        collapse
      });
    }
    return {
      stack,
      codeFrame
    };
  };
  function deleteStack(stack) {
    cache.delete(stack);
  }
  function symbolicate(stack) {
    let promise = cache.get(stack);
    if (promise == null) {
      promise = (0, _symbolicateStackTrace.default)(stack).then(sanitize);
      cache.set(stack, promise);
    }
    return promise;
  }
},309,[17,310],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxSymbolication.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  async function symbolicateStackTrace(stack) {
    const baseUrl = typeof window === 'undefined' ? process.env.EXPO_DEV_SERVER_ORIGIN : window.location.protocol + '//' + window.location.host;
    const response = await fetch(baseUrl + '/symbolicate', {
      method: 'POST',
      body: JSON.stringify({
        stack
      })
    });
    return await response.json();
  }
  var _default = exports.default = symbolicateStackTrace;
},310,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\symbolicateStackTrace\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogContext = void 0;
  exports.useLogs = useLogs;
  exports.useSelectedLog = useSelectedLog;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _LogBoxLog = require(_dependencyMap[2], "./LogBoxLog");
  // Context provider for Array<LogBoxLog>

  const LogContext = exports.LogContext = /*#__PURE__*/_react.default.createContext(null);
  function useLogs() {
    const logs = _react.default.useContext(LogContext);
    if (!logs) {
      if (true && typeof window !== 'undefined') {
        // Logbox data that is pre-fetched on the dev server and rendered here.
        const expoCliStaticErrorElement = document.getElementById('_expo-static-error');
        if (expoCliStaticErrorElement?.textContent) {
          const raw = JSON.parse(expoCliStaticErrorElement.textContent);
          return Object.assign({}, raw, {
            logs: raw.logs.map(raw => new _LogBoxLog.LogBoxLog(raw))
          });
        }
      }
      throw new Error('useLogs must be used within a LogProvider');
    }
    return logs;
  }
  function useSelectedLog() {
    const {
      selectedLogIndex,
      logs
    } = useLogs();
    return logs[selectedLogIndex];
  }
},311,[17,3,308],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogContext.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseComponentStack = parseComponentStack;
  exports.parseInterpolation = parseInterpolation;
  exports.parseLogBoxException = parseLogBoxException;
  exports.parseLogBoxLog = parseLogBoxLog;
  var _parseErrorStack = _interopRequireDefault(require(_dependencyMap[1], "../modules/parseErrorStack"));
  var _stringifySafe = _interopRequireDefault(require(_dependencyMap[2], "../modules/stringifySafe"));
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/;
  const BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\].*): ([\s\S]+?)\n([ >]{2}[\d\s]+ \|[\s\S]+|\u{001b}[\s\S]+)/u;
  const METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/u;
  const SUBSTITUTION = '\ufeff%s';
  function parseInterpolation(args) {
    const categoryParts = [];
    const contentParts = [];
    const substitutionOffsets = [];
    const remaining = [...args];
    if (typeof remaining[0] === 'string') {
      const formatString = String(remaining.shift());
      const formatStringParts = formatString.split('%s');
      const substitutionCount = formatStringParts.length - 1;
      const substitutions = remaining.splice(0, substitutionCount);
      let categoryString = '';
      let contentString = '';
      let substitutionIndex = 0;
      for (const formatStringPart of formatStringParts) {
        categoryString += formatStringPart;
        contentString += formatStringPart;
        if (substitutionIndex < substitutionCount) {
          if (substitutionIndex < substitutions.length) {
            // Don't stringify a string type.
            // It adds quotation mark wrappers around the string,
            // which causes the LogBox to look odd.
            const substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : (0, _stringifySafe.default)(substitutions[substitutionIndex]);
            substitutionOffsets.push({
              length: substitution.length,
              offset: contentString.length
            });
            categoryString += SUBSTITUTION;
            contentString += substitution;
          } else {
            substitutionOffsets.push({
              length: 2,
              offset: contentString.length
            });
            categoryString += '%s';
            contentString += '%s';
          }
          substitutionIndex++;
        }
      }
      categoryParts.push(categoryString);
      contentParts.push(contentString);
    }
    const remainingArgs = remaining.map(arg => {
      // Don't stringify a string type.
      // It adds quotation mark wrappers around the string,
      // which causes the LogBox to look odd.
      return typeof arg === 'string' ? arg : (0, _stringifySafe.default)(arg);
    });
    categoryParts.push(...remainingArgs);
    contentParts.push(...remainingArgs);
    return {
      category: categoryParts.join(' '),
      message: {
        content: contentParts.join(' '),
        substitutions: substitutionOffsets
      }
    };
  }
  function isComponentStack(consoleArgument) {
    const isOldComponentStackFormat = / {4}in/.test(consoleArgument);
    const isNewComponentStackFormat = / {4}at/.test(consoleArgument);
    const isNewJSCComponentStackFormat = /@.*\n/.test(consoleArgument);
    return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;
  }
  function parseComponentStack(message) {
    // In newer versions of React, the component stack is formatted as a call stack frame.
    // First try to parse the component stack as a call stack frame, and if that doesn't
    // work then we'll fallback to the old custom component stack format parsing.
    const stack = (0, _parseErrorStack.default)(message);
    if (stack && stack.length > 0) {
      return stack.map(frame => ({
        content: frame.methodName,
        collapse: frame.collapse || false,
        fileName: frame.file == null ? 'unknown' : frame.file,
        location: {
          column: frame.column == null ? -1 : frame.column,
          row: frame.lineNumber == null ? -1 : frame.lineNumber
        }
      }));
    }
    return message.split(/\n {4}in /g).map(s => {
      if (!s) {
        return null;
      }
      const match = s.match(/(.*) \(at (.*\.js):([\d]+)\)/);
      if (!match) {
        return null;
      }
      const [content, fileName, row] = match.slice(1);
      return {
        content,
        fileName,
        location: {
          column: -1,
          row: parseInt(row, 10)
        }
      };
    }).filter(Boolean);
  }
  function parseLogBoxException(error) {
    const message = error.originalMessage != null ? error.originalMessage : 'Unknown';
    const metroInternalError = message.match(METRO_ERROR_FORMAT);
    if (metroInternalError) {
      const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);
      return {
        level: 'fatal',
        type: 'Metro Error',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: {
            row: parseInt(row, 10),
            column: parseInt(column, 10)
          },
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);
    if (babelTransformError) {
      // Transform errors are thrown from inside the Babel transformer.
      const [fileName, content, row, column, codeFrame] = babelTransformError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: {
            row: parseInt(row, 10),
            column: parseInt(column, 10)
          },
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);
    if (babelCodeFrameError) {
      // Codeframe errors are thrown from any use of buildCodeFrameError.
      const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: null,
          // We are not given the location.
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${1}-${1}`
      };
    }
    if (message.match(/^TransformError /)) {
      return {
        level: 'syntax',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: [],
        message: {
          content: message,
          substitutions: []
        },
        category: message
      };
    }
    const componentStack = error.componentStack;
    if (error.isFatal || error.isComponentError) {
      return Object.assign({
        level: 'fatal',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: componentStack != null ? parseComponentStack(componentStack) : []
      }, parseInterpolation([message]));
    }
    if (componentStack != null) {
      // It is possible that console errors have a componentStack.
      return Object.assign({
        level: 'error',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: parseComponentStack(componentStack)
      }, parseInterpolation([message]));
    }

    // Most `console.error` calls won't have a componentStack. We parse them like
    // regular logs which have the component stack burried in the message.
    return Object.assign({
      level: 'error',
      stack: error.stack,
      isComponentError: error.isComponentError
    }, parseLogBoxLog([message]));
  }
  function parseLogBoxLog(args) {
    const message = args[0];
    let argsWithoutComponentStack = [];
    let componentStack = [];

    // Extract component stack from warnings like "Some warning%s".
    if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {
      const lastArg = args[args.length - 1];
      if (typeof lastArg === 'string' && isComponentStack(lastArg)) {
        argsWithoutComponentStack = args.slice(0, -1);
        argsWithoutComponentStack[0] = message.slice(0, -2);
        componentStack = parseComponentStack(lastArg);
      }
    }
    if (componentStack.length === 0) {
      // Try finding the component stack elsewhere.
      for (const arg of args) {
        if (typeof arg === 'string' && isComponentStack(arg)) {
          // Strip out any messages before the component stack.
          let messageEndIndex = arg.search(/\n {4}(in|at) /);
          if (messageEndIndex < 0) {
            // Handle JSC component stacks.
            messageEndIndex = arg.search(/\n/);
          }
          if (messageEndIndex > 0) {
            argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));
          }
          componentStack = parseComponentStack(arg);
        } else {
          argsWithoutComponentStack.push(arg);
        }
      }
    }
    return Object.assign({}, parseInterpolation(argsWithoutComponentStack), {
      componentStack
    });
  }
},312,[17,313,315],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\parseLogBoxLog.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _stacktraceParser = require(_dependencyMap[0], "stacktrace-parser");
  function parseErrorStack(stack) {
    if (stack == null) {
      return [];
    }
    if (Array.isArray(stack)) {
      return stack;
    }
    return (0, _stacktraceParser.parse)(stack).map(frame => {
      // frame.file will mostly look like `http://localhost:8081/index.bundle?platform=web&dev=true&hot=false`
      return Object.assign({}, frame, {
        column: frame.column != null ? frame.column - 1 : null
      });
    });
  }
  var _default = exports.default = parseErrorStack;
},313,[867],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\parseErrorStack\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createStringifySafeWithLimits = createStringifySafeWithLimits;
  exports.default = void 0;
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Tries to stringify with JSON.stringify and toString, but catches exceptions
   * (e.g. from circular objects) and always returns a string and never throws.
   */
  function createStringifySafeWithLimits(limits) {
    const {
      maxDepth = Number.POSITIVE_INFINITY,
      maxStringLimit = Number.POSITIVE_INFINITY,
      maxArrayLimit = Number.POSITIVE_INFINITY,
      maxObjectKeysLimit = Number.POSITIVE_INFINITY
    } = limits;
    const stack = [];
    function replacer(_key, value) {
      while (stack.length && this !== stack[0]) {
        stack.shift();
      }
      if (typeof value === 'string') {
        const truncatedString = '...(truncated)...';
        if (value.length > maxStringLimit + truncatedString.length) {
          return value.substring(0, maxStringLimit) + truncatedString;
        }
        return value;
      }
      if (typeof value !== 'object' || value === null) {
        return value;
      }
      let retval = value;
      if (Array.isArray(value)) {
        if (stack.length >= maxDepth) {
          retval = `[ ... array with ${value.length} values ... ]`;
        } else if (value.length > maxArrayLimit) {
          retval = value.slice(0, maxArrayLimit).concat([`... extra ${value.length - maxArrayLimit} values truncated ...`]);
        }
      } else {
        // Add refinement after Array.isArray call.
        if (typeof value !== 'object') {
          throw new Error('This was already found earlier');
        }
        const keys = Object.keys(value);
        if (stack.length >= maxDepth) {
          retval = `{ ... object with ${keys.length} keys ... }`;
        } else if (keys.length > maxObjectKeysLimit) {
          // Return a sample of the keys.
          retval = {};
          for (const k of keys.slice(0, maxObjectKeysLimit)) {
            retval[k] = value[k];
          }
          const truncatedKey = '...(truncated keys)...';
          retval[truncatedKey] = keys.length - maxObjectKeysLimit;
        }
      }
      stack.unshift(retval);
      return retval;
    }
    return function stringifySafe(arg) {
      if (arg === undefined) {
        return 'undefined';
      } else if (arg === null) {
        return 'null';
      } else if (typeof arg === 'function') {
        try {
          return arg.toString();
        } catch {
          return '[function unknown]';
        }
      } else if (arg instanceof Error) {
        return arg.name + ': ' + arg.message;
      } else {
        // Perform a try catch, just in case the object has a circular
        // reference or stringify throws for some other reason.
        try {
          const ret = JSON.stringify(arg, replacer);
          if (ret === undefined) {
            return '["' + typeof arg + '" failed to stringify]';
          }
          return ret;
        } catch {
          if (typeof arg.toString === 'function') {
            try {
              // $FlowFixMe[incompatible-use] : toString shouldn't take any arguments in general.
              return arg.toString();
            } catch {}
          }
        }
      }
      return '["' + typeof arg + '" failed to stringify]';
    };
  }
  const stringifySafe = createStringifySafeWithLimits({
    maxDepth: 10,
    maxStringLimit: 100,
    maxArrayLimit: 50,
    maxObjectKeysLimit: 50
  });
  var _default = exports.default = stringifySafe;
},315,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\stringifySafe\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _client = _interopRequireDefault(require(_dependencyMap[2], "react-dom/client"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\NativeLogBox\\index.tsx";
  let currentRoot = null;
  var _default = exports.default = {
    show() {
      if (currentRoot) {
        return;
      }
      const ErrorOverlay = require(_dependencyMap[4], "../../ErrorOverlay").default;
      // Create a new div with ID `error-overlay` element and render LogBoxInspector into it.
      const div = document.createElement('div');
      div.id = 'error-overlay';
      document.body.appendChild(div);
      currentRoot = _client.default.createRoot(div);
      currentRoot.render((0, _jsxRuntime.jsx)(ErrorOverlay, {}));
    },
    hide() {
      // Remove div with ID `error-overlay`
      if (currentRoot) {
        currentRoot.unmount();
        currentRoot = null;
      }
      const div = document.getElementById('error-overlay');
      div?.remove();
    }
  };
},316,[17,3,89,2,317],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\NativeLogBox\\index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorOverlayBody = ErrorOverlayBody;
  exports.ErrorOverlayBodyContents = ErrorOverlayBodyContents;
  exports.LogBoxInspector = LogBoxInspector;
  exports.LogBoxInspectorContainer = LogBoxInspectorContainer;
  exports.default = void 0;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/ScrollView"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var LogBoxData = _interopRequireWildcard(require(_dependencyMap[5], "./Data/LogBoxData"));
  var _LogContext = require(_dependencyMap[6], "./Data/LogContext");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[7], "./UI/LogBoxStyle"));
  var _LogBoxInspectorCodeFrame = require(_dependencyMap[8], "./overlay/LogBoxInspectorCodeFrame");
  var _LogBoxInspectorFooter = require(_dependencyMap[9], "./overlay/LogBoxInspectorFooter");
  var _LogBoxInspectorHeader = require(_dependencyMap[10], "./overlay/LogBoxInspectorHeader");
  var _LogBoxInspectorMessageHeader = require(_dependencyMap[11], "./overlay/LogBoxInspectorMessageHeader");
  var _LogBoxInspectorStackFrames = require(_dependencyMap[12], "./overlay/LogBoxInspectorStackFrames");
  var _jsxRuntime = require(_dependencyMap[13], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\ErrorOverlay.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const HEADER_TITLE_MAP = {
    warn: 'Console Warning',
    error: 'Console Error',
    fatal: 'Uncaught Error',
    syntax: 'Syntax Error',
    static: 'Server Error',
    component: 'Render Error'
  };
  function LogBoxInspectorContainer() {
    const {
      selectedLogIndex,
      logs
    } = (0, _LogContext.useLogs)();
    const log = logs[selectedLogIndex];
    if (log == null) {
      return null;
    }
    return (0, _jsxRuntime.jsx)(LogBoxInspector, {
      log: log,
      selectedLogIndex: selectedLogIndex,
      logs: logs
    });
  }
  function LogBoxInspector({
    log,
    selectedLogIndex,
    logs
  }) {
    const onDismiss = (0, _react.useCallback)(() => {
      // Here we handle the cases when the log is dismissed and it
      // was either the last log, or when the current index
      // is now outside the bounds of the log array.
      const logsArray = Array.from(logs);
      if (selectedLogIndex != null) {
        if (logsArray.length - 1 <= 0) {
          LogBoxData.setSelectedLog(-1);
        } else if (selectedLogIndex >= logsArray.length - 1) {
          LogBoxData.setSelectedLog(selectedLogIndex - 1);
        }
        LogBoxData.dismiss(logsArray[selectedLogIndex]);
      }
    }, [selectedLogIndex]);
    const onMinimize = (0, _react.useCallback)(() => {
      LogBoxData.setSelectedLog(-1);
    }, []);
    const onChangeSelectedIndex = (0, _react.useCallback)(index => {
      LogBoxData.setSelectedLog(index);
    }, []);
    (0, _react.useEffect)(() => {
      if (log) {
        LogBoxData.symbolicateLogNow('stack', log);
        LogBoxData.symbolicateLogNow('component', log);
      }
    }, [log]);
    (0, _react.useEffect)(() => {
      // Optimistically symbolicate the last and next logs.
      if (logs.length > 1) {
        const selected = selectedLogIndex;
        const lastIndex = logs.length - 1;
        const prevIndex = selected - 1 < 0 ? lastIndex : selected - 1;
        const nextIndex = selected + 1 > lastIndex ? 0 : selected + 1;
        for (const type of ['component', 'stack']) {
          LogBoxData.symbolicateLogLazy(type, logs[prevIndex]);
          LogBoxData.symbolicateLogLazy(type, logs[nextIndex]);
        }
      }
    }, [logs, selectedLogIndex]);
    const _handleRetry = (0, _react.useCallback)(type => {
      LogBoxData.retrySymbolicateLogNow(type, log);
    }, [log]);
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.container,
      children: [(0, _jsxRuntime.jsx)(_LogBoxInspectorHeader.LogBoxInspectorHeader, {
        onSelectIndex: onChangeSelectedIndex,
        level: log.level
      }), (0, _jsxRuntime.jsx)(ErrorOverlayBody, {
        onRetry: _handleRetry
      }), (0, _jsxRuntime.jsx)(_LogBoxInspectorFooter.LogBoxInspectorFooter, {
        onDismiss: onDismiss,
        onMinimize: onMinimize
      })]
    });
  }
  function ErrorOverlayBody({
    onRetry
  }) {
    const log = (0, _LogContext.useSelectedLog)();
    return (0, _jsxRuntime.jsx)(ErrorOverlayBodyContents, {
      log: log,
      onRetry: onRetry
    });
  }
  function ErrorOverlayBodyContents({
    log,
    onRetry
  }) {
    const [collapsed, setCollapsed] = (0, _react.useState)(true);
    (0, _react.useEffect)(() => {
      setCollapsed(true);
    }, [log]);
    const headerTitle = HEADER_TITLE_MAP[log.isComponentError ? 'component' : log.level] ?? log.type;
    const header = (0, _jsxRuntime.jsx)(_LogBoxInspectorMessageHeader.LogBoxInspectorMessageHeader, {
      collapsed: collapsed,
      onPress: () => setCollapsed(!collapsed),
      message: log.message,
      level: log.level,
      title: headerTitle
    });

    // Hide useless React stack.
    const needsStack = !log.message.content.match(/(Expected server HTML to contain a matching|Text content did not match\.)/);
    return (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [collapsed && header, (0, _jsxRuntime.jsxs)(_ScrollView.default, {
        style: styles.scrollBody,
        children: [!collapsed && header, (0, _jsxRuntime.jsx)(_LogBoxInspectorCodeFrame.LogBoxInspectorCodeFrame, {
          codeFrame: log.codeFrame
        }), needsStack && (0, _jsxRuntime.jsx)(_LogBoxInspectorStackFrames.LogBoxInspectorStackFrames, {
          type: "stack"
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onRetry: onRetry.bind(onRetry, 'stack')
        }), !!log?.componentStack?.length && (0, _jsxRuntime.jsx)(_LogBoxInspectorStackFrames.LogBoxInspectorStackFrames, {
          type: "component"
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onRetry: onRetry.bind(onRetry, 'component')
        })]
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    scrollBody: {
      backgroundColor: LogBoxStyle.getBackgroundColor(1),
      flex: 1
    },
    container: {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      zIndex: 999,
      flex: 1,
      // @ts-expect-error: fixed is not in the RN types but it works on web
      position: 'fixed'
    }
  });
  var _default = exports.default = LogBoxData.withSubscription(LogBoxInspectorContainer);
},317,[17,3,135,111,30,307,311,318,319,327,328,331,333,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\ErrorOverlay.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getBackgroundColor = getBackgroundColor;
  exports.getBackgroundDarkColor = getBackgroundDarkColor;
  exports.getBackgroundLightColor = getBackgroundLightColor;
  exports.getDividerColor = getDividerColor;
  exports.getErrorColor = getErrorColor;
  exports.getErrorDarkColor = getErrorDarkColor;
  exports.getFatalColor = getFatalColor;
  exports.getFatalDarkColor = getFatalDarkColor;
  exports.getHighlightColor = getHighlightColor;
  exports.getLogColor = getLogColor;
  exports.getTextColor = getTextColor;
  exports.getWarningColor = getWarningColor;
  exports.getWarningDarkColor = getWarningDarkColor;
  exports.getWarningHighlightColor = getWarningHighlightColor;
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function getBackgroundColor(opacity) {
    return `rgba(0, 0, 0, ${opacity == null ? 1 : opacity})`;
    // return `rgba(51, 51, 51, ${opacity == null ? 1 : opacity})`;
  }
  function getBackgroundLightColor(opacity) {
    return `rgba(69, 69, 69, ${opacity == null ? 1 : opacity})`;
  }
  function getBackgroundDarkColor(opacity) {
    return `rgba(34, 34, 34, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningColor(opacity) {
    return `rgba(250, 186, 48, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningDarkColor(opacity) {
    return `rgba(224, 167, 8, ${opacity == null ? 1 : opacity})`;
  }
  function getFatalColor(opacity) {
    return `rgba(243, 83, 105, ${opacity == null ? 1 : opacity})`;
  }
  function getFatalDarkColor(opacity) {
    return `rgba(208, 75, 95, ${opacity == null ? 1 : opacity})`;
  }
  function getErrorColor(opacity) {
    return `rgba(243, 83, 105, ${opacity == null ? 1 : opacity})`;
  }
  function getErrorDarkColor(opacity) {
    return `rgba(208, 75, 95, ${opacity == null ? 1 : opacity})`;
  }
  function getLogColor(opacity) {
    return `rgba(119, 119, 119, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningHighlightColor(opacity) {
    return `rgba(252, 176, 29, ${opacity == null ? 1 : opacity})`;
  }
  function getDividerColor(opacity) {
    return `rgba(255, 255, 255, ${opacity == null ? 1 : opacity})`;
  }
  function getHighlightColor(opacity) {
    return `rgba(252, 176, 29, ${opacity == null ? 1 : opacity})`;
  }
  function getTextColor(opacity) {
    return `rgba(255, 255, 255, ${opacity == null ? 1 : opacity})`;
  }
},318,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxStyle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorCodeFrame = LogBoxInspectorCodeFrame;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/ScrollView"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _LogBoxInspectorSection = require(_dependencyMap[6], "./LogBoxInspectorSection");
  var _AnsiHighlight = require(_dependencyMap[7], "../UI/AnsiHighlight");
  var _LogBoxButton = require(_dependencyMap[8], "../UI/LogBoxButton");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[9], "../UI/LogBoxStyle"));
  var _constants = require(_dependencyMap[10], "../UI/constants");
  var _formatProjectFilePath = require(_dependencyMap[11], "../formatProjectFilePath");
  var _openFileInEditor = _interopRequireDefault(require(_dependencyMap[12], "../modules/openFileInEditor"));
  var _jsxRuntime = require(_dependencyMap[13], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorCodeFrame.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorCodeFrame({
    codeFrame
  }) {
    if (codeFrame == null) {
      return null;
    }
    function getFileName() {
      return (0, _formatProjectFilePath.formatProjectFilePath)("C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend", codeFrame?.fileName);
    }
    function getLocation() {
      const location = codeFrame?.location;
      if (location != null) {
        return ` (${location.row}:${location.column + 1 /* Code frame columns are zero indexed */})`;
      }
      return null;
    }
    return (0, _jsxRuntime.jsx)(_LogBoxInspectorSection.LogBoxInspectorSection, {
      heading: "Source",
      children: (0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.box,
        children: [(0, _jsxRuntime.jsx)(_View.default, {
          style: styles.frame,
          children: (0, _jsxRuntime.jsx)(_ScrollView.default, {
            horizontal: true,
            contentContainerStyle: {
              flexDirection: 'column'
            },
            children: (0, _jsxRuntime.jsx)(_AnsiHighlight.Ansi, {
              style: styles.content,
              text: codeFrame.content
            })
          })
        }), (0, _jsxRuntime.jsx)(_LogBoxButton.LogBoxButton, {
          backgroundColor: {
            default: 'transparent',
            pressed: LogBoxStyle.getBackgroundDarkColor(1)
          },
          style: styles.button,
          onPress: () => {
            (0, _openFileInEditor.default)(codeFrame.fileName, codeFrame.location?.row ?? 0);
          },
          children: (0, _jsxRuntime.jsxs)(_Text.default, {
            style: styles.fileText,
            children: [getFileName(), getLocation()]
          })
        })]
      })
    });
  }
  const styles = _StyleSheet.default.create({
    box: {
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      borderWidth: 1,
      borderColor: '#323232',
      marginLeft: 10,
      marginRight: 10,
      marginTop: 5,
      borderRadius: 3
    },
    frame: {
      padding: 10,
      borderBottomColor: LogBoxStyle.getTextColor(0.1),
      borderBottomWidth: 1
    },
    button: {
      paddingTop: 10,
      paddingBottom: 10
    },
    content: {
      flexDirection: 'column',
      color: LogBoxStyle.getTextColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 20,
      fontFamily: _constants.CODE_FONT
    },
    fileText: {
      userSelect: 'none',
      color: LogBoxStyle.getTextColor(0.5),
      textAlign: 'center',
      flex: 1,
      fontSize: 16,
      includeFontPadding: false,
      fontFamily: _constants.CODE_FONT
    }
  });
},319,[17,3,135,30,190,111,320,321,323,318,324,325,326,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorCodeFrame.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorSection = LogBoxInspectorSection;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[5], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSection.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorSection(props) {
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.section,
      children: [(0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.heading,
        children: [(0, _jsxRuntime.jsx)(_Text.default, {
          style: styles.headingText,
          children: props.heading
        }), props.action]
      }), (0, _jsxRuntime.jsx)(_View.default, {
        style: styles.body,
        children: props.children
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    section: {
      marginTop: 15
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginBottom: 10
    },
    headingText: {
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 18,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    body: {
      paddingBottom: 10
    }
  });
},320,[17,3,30,190,111,318,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSection.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Ansi = Ansi;
  var _anser = _interopRequireDefault(require(_dependencyMap[1], "anser"));
  var _react = _interopRequireDefault(require(_dependencyMap[2], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\AnsiHighlight.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  // Afterglow theme from https://iterm2colorschemes.com/
  const COLORS = {
    'ansi-black': 'rgb(27, 27, 27)',
    'ansi-red': 'rgb(187, 86, 83)',
    'ansi-green': 'rgb(144, 157, 98)',
    'ansi-yellow': 'rgb(234, 193, 121)',
    'ansi-blue': 'rgb(125, 169, 199)',
    'ansi-magenta': 'rgb(176, 101, 151)',
    'ansi-cyan': 'rgb(140, 220, 216)',
    // Instead of white, use the default color provided to the component
    // 'ansi-white': 'rgb(216, 216, 216)',
    'ansi-bright-black': 'rgb(98, 98, 98)',
    'ansi-bright-red': 'rgb(187, 86, 83)',
    'ansi-bright-green': 'rgb(144, 157, 98)',
    'ansi-bright-yellow': 'rgb(234, 193, 121)',
    'ansi-bright-blue': 'rgb(125, 169, 199)',
    'ansi-bright-magenta': 'rgb(176, 101, 151)',
    'ansi-bright-cyan': 'rgb(140, 220, 216)',
    'ansi-bright-white': 'rgb(247, 247, 247)'
  };
  function Ansi({
    text,
    style
  }) {
    let commonWhitespaceLength = Infinity;
    const parsedLines = text.split(/\n/).map(line => _anser.default.ansiToJson(line, {
      json: true,
      remove_empty: true,
      use_classes: true
    }));
    parsedLines.map(lines => {
      // The third item on each line includes the whitespace of the source code.
      // We are looking for the least amount of common whitespace to trim all lines.
      // Example: Array [" ", " 96 |", "     text", ...]
      const match = lines[2] && lines[2]?.content?.match(/^ +/);
      const whitespaceLength = match && match[0]?.length || 0;
      if (whitespaceLength < commonWhitespaceLength) {
        commonWhitespaceLength = whitespaceLength;
      }
    });
    const getText = (content, key) => {
      if (key === 1) {
        // Remove the vertical bar after line numbers
        return content.replace(/\| $/, ' ');
      } else if (key === 2 && commonWhitespaceLength < Infinity) {
        // Remove common whitespace at the beginning of the line
        return content.substr(commonWhitespaceLength);
      } else {
        return content;
      }
    };
    return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: parsedLines.map((items, i) => (0, _jsxRuntime.jsx)(_View.default, {
        style: styles.line,
        children: items.map((bundle, key) => {
          const textStyle = bundle.fg && COLORS[bundle.fg] ? {
            backgroundColor: bundle.bg && COLORS[bundle.bg],
            color: bundle.fg && COLORS[bundle.fg]
          } : {
            backgroundColor: bundle.bg && COLORS[bundle.bg]
          };
          return (0, _jsxRuntime.jsx)(_Text.default, {
            style: [style, textStyle],
            children: getText(bundle.content, key)
          }, key);
        })
      }, i))
    });
  }
  const styles = _StyleSheet.default.create({
    line: {
      flexDirection: 'row'
    }
  });
},321,[17,322,3,30,190,111,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\AnsiHighlight.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ANSI_COLORS = [[{
    color: "0, 0, 0",
    "class": "ansi-black"
  }, {
    color: "187, 0, 0",
    "class": "ansi-red"
  }, {
    color: "0, 187, 0",
    "class": "ansi-green"
  }, {
    color: "187, 187, 0",
    "class": "ansi-yellow"
  }, {
    color: "0, 0, 187",
    "class": "ansi-blue"
  }, {
    color: "187, 0, 187",
    "class": "ansi-magenta"
  }, {
    color: "0, 187, 187",
    "class": "ansi-cyan"
  }, {
    color: "255,255,255",
    "class": "ansi-white"
  }], [{
    color: "85, 85, 85",
    "class": "ansi-bright-black"
  }, {
    color: "255, 85, 85",
    "class": "ansi-bright-red"
  }, {
    color: "0, 255, 0",
    "class": "ansi-bright-green"
  }, {
    color: "255, 255, 85",
    "class": "ansi-bright-yellow"
  }, {
    color: "85, 85, 255",
    "class": "ansi-bright-blue"
  }, {
    color: "255, 85, 255",
    "class": "ansi-bright-magenta"
  }, {
    color: "85, 255, 255",
    "class": "ansi-bright-cyan"
  }, {
    color: "255, 255, 255",
    "class": "ansi-bright-white"
  }]];
  var Anser = function () {
    _createClass(Anser, null, [{
      key: "escapeForHtml",
      /**
       * Anser.escapeForHtml
       * Escape the input HTML.
       *
       * This does the minimum escaping of text to make it compliant with HTML.
       * In particular, the '&','<', and '>' characters are escaped. This should
       * be run prior to `ansiToHtml`.
       *
       * @name Anser.escapeForHtml
       * @function
       * @param {String} txt The input text (containing the ANSI snippets).
       * @returns {String} The escaped html.
       */
      value: function escapeForHtml(txt) {
        return new Anser().escapeForHtml(txt);
      }

      /**
       * Anser.linkify
       * Adds the links in the HTML.
       *
       * This replaces any links in the text with anchor tags that display the
       * link. The links should have at least one whitespace character
       * surrounding it. Also, you should apply this after you have run
       * `ansiToHtml` on the text.
       *
       * @name Anser.linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML containing the <a> tags (unescaped).
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return new Anser().linkify(txt);
      }

      /**
       * Anser.ansiToHtml
       * This replaces ANSI terminal escape codes with SPAN tags that wrap the
       * content.
       *
       * This function only interprets ANSI SGR (Select Graphic Rendition) codes
       * that can be represented in HTML.
       * For example, cursor movement codes are ignored and hidden from output.
       * The default style uses colors that are very close to the prescribed
       * standard. The standard assumes that the text will have a black
       * background. These colors are set as inline styles on the SPAN tags.
       *
       * Another option is to set `use_classes: true` in the options argument.
       * This will instead set classes on the spans so the colors can be set via
       * CSS. The class names used are of the format `ansi-*-fg/bg` and
       * `ansi-bright-*-fg/bg` where `*` is the color name,
       * i.e black/red/green/yellow/blue/magenta/cyan/white.
       *
       * @name Anser.ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return new Anser().ansiToHtml(txt, options);
      }

      /**
       * Anser.ansiToJson
       * Converts ANSI input into JSON output.
       *
       * @name Anser.ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        return new Anser().ansiToJson(txt, options);
      }

      /**
       * Anser.ansiToText
       * Converts ANSI input into text output.
       *
       * @name Anser.ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return new Anser().ansiToText(txt);
      }

      /**
       * Anser
       * The `Anser` class.
       *
       * @name Anser
       * @function
       * @returns {Anser}
       */
    }]);
    function Anser() {
      _classCallCheck(this, Anser);
      this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
      this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */

    _createClass(Anser, [{
      key: "setupPalette",
      value: function setupPalette() {
        this.PALETTE_COLORS = [];

        // Index 0..15 : System color
        for (var i = 0; i < 2; ++i) {
          for (var j = 0; j < 8; ++j) {
            this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
          }
        }

        // Index 16..231 : RGB 6x6x6
        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
        var levels = [0, 95, 135, 175, 215, 255];
        var format = function format(r, g, b) {
          return levels[r] + ", " + levels[g] + ", " + levels[b];
        };
        var r = void 0,
          g = void 0,
          b = void 0;
        for (var _r = 0; _r < 6; ++_r) {
          for (var _g = 0; _g < 6; ++_g) {
            for (var _b = 0; _b < 6; ++_b) {
              this.PALETTE_COLORS.push(format(_r, _g, _b));
            }
          }
        }

        // Index 232..255 : Grayscale
        var level = 8;
        for (var _i = 0; _i < 24; ++_i, level += 10) {
          this.PALETTE_COLORS.push(format(level, level, level));
        }
      }

      /**
       * escapeForHtml
       * Escapes the input text.
       *
       * @name escapeForHtml
       * @function
       * @param {String} txt The input text.
       * @returns {String} The escpaed HTML output.
       */
    }, {
      key: "escapeForHtml",
      value: function escapeForHtml(txt) {
        return txt.replace(/[&<>]/gm, function (str) {
          return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
        });
      }

      /**
       * linkify
       * Adds HTML link elements.
       *
       * @name linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML output containing link elements.
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
          return "<a href=\"" + str + "\">" + str + "</a>";
        });
      }

      /**
       * ansiToHtml
       * Converts ANSI input into HTML output.
       *
       * @name ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return this.process(txt, options, true);
      }

      /**
       * ansiToJson
       * Converts ANSI input into HTML output.
       *
       * @name ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The JSON output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        options = options || {};
        options.json = true;
        options.clearLine = false;
        return this.process(txt, options, true);
      }

      /**
       * ansiToText
       * Converts ANSI input into HTML output.
       *
       * @name ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return this.process(txt, {}, false);
      }

      /**
       * process
       * Processes the input.
       *
       * @name process
       * @function
       * @param {String} txt The input text.
       * @param {Object} options An object passed to `processChunk` method, extended with:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup
       */
    }, {
      key: "process",
      value: function process(txt, options, markup) {
        var _this = this;
        var self = this;
        var raw_text_chunks = txt.split(/\033\[/);
        var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

        if (options === undefined || options === null) {
          options = {};
        }
        options.clearLine = /\r/.test(txt); // check for Carriage Return
        var color_chunks = raw_text_chunks.map(function (chunk) {
          return _this.processChunk(chunk, options, markup);
        });
        if (options && options.json) {
          var first = self.processChunkJson("");
          first.content = first_chunk;
          first.clearLine = options.clearLine;
          color_chunks.unshift(first);
          if (options.remove_empty) {
            color_chunks = color_chunks.filter(function (c) {
              return !c.isEmpty();
            });
          }
          return color_chunks;
        } else {
          color_chunks.unshift(first_chunk);
        }
        return color_chunks.join("");
      }

      /**
       * processChunkJson
       * Processes the current chunk into json output.
       *
       * @name processChunkJson
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object} The result object:
       *
       *  - `content` (String): The text.
       *  - `fg` (String|null): The foreground color.
       *  - `bg` (String|null): The background color.
       *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
       *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
       *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
       *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
       *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
       *
       */
    }, {
      key: "processChunkJson",
      value: function processChunkJson(text, options, markup) {
        // Are we using classes or styles?
        options = typeof options == "undefined" ? {} : options;
        var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
        var key = options.key = use_classes ? "class" : "color";
        var result = {
          content: text,
          fg: null,
          bg: null,
          fg_truecolor: null,
          bg_truecolor: null,
          clearLine: options.clearLine,
          decoration: null,
          was_processed: false,
          isEmpty: function isEmpty() {
            return !result.content;
          }
        };

        // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
        //
        // This regex matches four groups within a chunk.
        //
        // The first and third groups match code type.
        // We supported only SGR command. It has empty first group and "m" in third.
        //
        // The second group matches all of the number+semicolon command sequences
        // before the "m" (or other trailing) character.
        // These are the graphics or SGR commands.
        //
        // The last group is the text (including newlines) that is colored by
        // the other group"s commands.
        var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
        if (!matches) return result;
        var orig_txt = result.content = matches[4];
        var nums = matches[2].split(";");

        // We currently support only "SGR" (Select Graphic Rendition)
        // Simply ignore if not a SGR command.
        if (matches[1] !== "" || matches[3] !== "m") {
          return result;
        }
        if (!markup) {
          return result;
        }
        var self = this;
        self.decoration = null;
        while (nums.length > 0) {
          var num_str = nums.shift();
          var num = parseInt(num_str);
          if (isNaN(num) || num === 0) {
            self.fg = self.bg = self.decoration = null;
          } else if (num === 1) {
            self.decoration = "bold";
          } else if (num === 2) {
            self.decoration = "dim";
            // Enable code 2 to get string
          } else if (num == 3) {
            self.decoration = "italic";
          } else if (num == 4) {
            self.decoration = "underline";
          } else if (num == 5) {
            self.decoration = "blink";
          } else if (num === 7) {
            self.decoration = "reverse";
          } else if (num === 8) {
            self.decoration = "hidden";
            // Enable code 9 to get strikethrough
          } else if (num === 9) {
            self.decoration = "strikethrough";
          } else if (num == 39) {
            self.fg = null;
          } else if (num == 49) {
            self.bg = null;
            // Foreground color
          } else if (num >= 30 && num < 38) {
            self.fg = ANSI_COLORS[0][num % 10][key];
            // Foreground bright color
          } else if (num >= 90 && num < 98) {
            self.fg = ANSI_COLORS[1][num % 10][key];
            // Background color
          } else if (num >= 40 && num < 48) {
            self.bg = ANSI_COLORS[0][num % 10][key];
            // Background bright color
          } else if (num >= 100 && num < 108) {
            self.bg = ANSI_COLORS[1][num % 10][key];
          } else if (num === 38 || num === 48) {
            // extend color (38=fg, 48=bg)
            var is_foreground = num === 38;
            if (nums.length >= 1) {
              var mode = nums.shift();
              if (mode === "5" && nums.length >= 1) {
                // palette color
                var palette_index = parseInt(nums.shift());
                if (palette_index >= 0 && palette_index <= 255) {
                  if (!use_classes) {
                    if (!this.PALETTE_COLORS) {
                      self.setupPalette();
                    }
                    if (is_foreground) {
                      self.fg = this.PALETTE_COLORS[palette_index];
                    } else {
                      self.bg = this.PALETTE_COLORS[palette_index];
                    }
                  } else {
                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                    if (is_foreground) {
                      self.fg = klass;
                    } else {
                      self.bg = klass;
                    }
                  }
                }
              } else if (mode === "2" && nums.length >= 3) {
                // true color
                var r = parseInt(nums.shift());
                var g = parseInt(nums.shift());
                var b = parseInt(nums.shift());
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                  var color = r + ", " + g + ", " + b;
                  if (!use_classes) {
                    if (is_foreground) {
                      self.fg = color;
                    } else {
                      self.bg = color;
                    }
                  } else {
                    if (is_foreground) {
                      self.fg = "ansi-truecolor";
                      self.fg_truecolor = color;
                    } else {
                      self.bg = "ansi-truecolor";
                      self.bg_truecolor = color;
                    }
                  }
                }
              }
            }
          }
        }
        if (self.fg === null && self.bg === null && self.decoration === null) {
          return result;
        } else {
          var styles = [];
          var classes = [];
          var data = {};
          result.fg = self.fg;
          result.bg = self.bg;
          result.fg_truecolor = self.fg_truecolor;
          result.bg_truecolor = self.bg_truecolor;
          result.decoration = self.decoration;
          result.was_processed = true;
          return result;
        }
      }

      /**
       * processChunk
       * Processes the current chunk of text.
       *
       * @name processChunk
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
       */
    }, {
      key: "processChunk",
      value: function processChunk(text, options, markup) {
        var _this2 = this;
        var self = this;
        options = options || {};
        var jsonChunk = this.processChunkJson(text, options, markup);
        if (options.json) {
          return jsonChunk;
        }
        if (jsonChunk.isEmpty()) {
          return "";
        }
        if (!jsonChunk.was_processed) {
          return jsonChunk.content;
        }
        var use_classes = options.use_classes;
        var styles = [];
        var classes = [];
        var data = {};
        var render_data = function render_data(data) {
          var fragments = [];
          var key = void 0;
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
            }
          }
          return fragments.length > 0 ? " " + fragments.join(" ") : "";
        };
        if (jsonChunk.fg) {
          if (use_classes) {
            classes.push(jsonChunk.fg + "-fg");
            if (jsonChunk.fg_truecolor !== null) {
              data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = null;
            }
          } else {
            styles.push("color:rgb(" + jsonChunk.fg + ")");
          }
        }
        if (jsonChunk.bg) {
          if (use_classes) {
            classes.push(jsonChunk.bg + "-bg");
            if (jsonChunk.bg_truecolor !== null) {
              data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = null;
            }
          } else {
            styles.push("background-color:rgb(" + jsonChunk.bg + ")");
          }
        }
        if (jsonChunk.decoration) {
          if (use_classes) {
            classes.push("ansi-" + jsonChunk.decoration);
          } else if (jsonChunk.decoration === "bold") {
            styles.push("font-weight:bold");
          } else if (jsonChunk.decoration === "dim") {
            styles.push("opacity:0.5");
          } else if (jsonChunk.decoration === "italic") {
            styles.push("font-style:italic");
            // underline and blink are treated bellow
          } else if (jsonChunk.decoration === "reverse") {
            styles.push("filter:invert(100%)");
          } else if (jsonChunk.decoration === "hidden") {
            styles.push("visibility:hidden");
          } else if (jsonChunk.decoration === "strikethrough") {
            styles.push("text-decoration:line-through");
          } else {
            styles.push("text-decoration:" + jsonChunk.decoration);
          }
        }
        if (use_classes) {
          return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        } else {
          return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        }
      }
    }]);
    return Anser;
  }();
  ;
  module.exports = Anser;
},322,[],"node_modules\\anser\\lib\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxButton = LogBoxButton;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Pressable"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[5], "./LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxButton.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxButton(props) {
    const [pressed, setPressed] = (0, _react.useState)(false);
    let backgroundColor = props.backgroundColor;
    if (!backgroundColor) {
      backgroundColor = {
        default: LogBoxStyle.getBackgroundColor(0.95),
        pressed: LogBoxStyle.getBackgroundColor(0.6)
      };
    }
    const content = (0, _jsxRuntime.jsx)(_View.default, {
      style: [Object.assign({
        backgroundColor: pressed ? backgroundColor.pressed : backgroundColor.default
      }, _Platform.default.select({
        web: {
          cursor: 'pointer'
        }
      })), props.style],
      children: props.children
    });
    return props.onPress == null ? content : (0, _jsxRuntime.jsx)(_Pressable.default, {
      hitSlop: props.hitSlop,
      onPress: props.onPress,
      onPressIn: () => setPressed(true),
      onPressOut: () => setPressed(false),
      children: content
    });
  }
},323,[17,3,106,244,111,318,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxButton.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CODE_FONT = void 0;
  const CODE_FONT = exports.CODE_FONT = false ?
  // iOS
  'Courier New' : false ?
  // Android
  'monospace' :
  // Default
  'Courier';
},324,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\constants.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.formatProjectFilePath = formatProjectFilePath;
  exports.getStackFormattedLocation = getStackFormattedLocation;
  function formatProjectFilePath(projectRoot, file) {
    if (file == null) {
      return '<unknown>';
    }
    return pathRelativeToPath(file.replace(/\\/g, '/'), projectRoot.replace(/\\/g, '/')).replace(/\?.*$/, '');
  }
  function pathRelativeToPath(path, relativeTo, sep = '/') {
    const relativeToParts = relativeTo.split(sep);
    const pathParts = path.split(sep);
    let i = 0;
    while (i < relativeToParts.length && i < pathParts.length) {
      if (relativeToParts[i] !== pathParts[i]) {
        break;
      }
      i++;
    }
    return pathParts.slice(i).join(sep);
  }
  function getStackFormattedLocation(projectRoot, frame) {
    const column = frame.column != null && parseInt(String(frame.column), 10);
    const location = formatProjectFilePath(projectRoot, frame.file) + (frame.lineNumber != null ? ':' + frame.lineNumber + (column && !isNaN(column) ? ':' + (column + 1) : '') : '');
    return location;
  }
},325,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\formatProjectFilePath.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function openFileInEditor(file, lineNumber) {
    if (process.env.NODE_ENV !== 'production') {
      // TODO: This is not a great URL since it now blocks users from accessing the `/open-stack-frame` url in their router
      // ideally it would be something like `/_devtools/open-stack-frame`.
      const baseUrl = window.location.protocol + '//' + window.location.host;
      fetch(baseUrl + '/open-stack-frame', {
        method: 'POST',
        body: JSON.stringify({
          file,
          lineNumber
        })
      });
    }
  }
  var _default = exports.default = openFileInEditor;
},326,[],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\openFileInEditor\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorFooter = LogBoxInspectorFooter;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Pressable"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/View"));
  var _LogContext = require(_dependencyMap[7], "../Data/LogContext");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[8], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[9], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorFooter.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorFooter(props) {
    const log = (0, _LogContext.useSelectedLog)();
    if (['static', 'syntax'].includes(log.level)) {
      return (0, _jsxRuntime.jsx)(_View.default, {
        style: styles.root,
        children: (0, _jsxRuntime.jsx)(_View.default, {
          style: styles.button,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            style: styles.syntaxErrorText,
            children: "This error cannot be dismissed."
          })
        })
      });
    }
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.root,
      children: [(0, _jsxRuntime.jsx)(FooterButton, {
        text: "Dismiss",
        onPress: props.onDismiss
      }), (0, _jsxRuntime.jsx)(FooterButton, {
        text: "Minimize",
        onPress: props.onMinimize
      })]
    });
  }
  function FooterButton({
    text,
    onPress
  }) {
    return (0, _jsxRuntime.jsx)(_Pressable.default, {
      onPress: onPress,
      style: {
        flex: 1
      },
      children: ({
        /** @ts-expect-error: react-native types are broken. */
        hovered,
        pressed
      }) => (0, _jsxRuntime.jsx)(_View.default, {
        style: [buttonStyles.safeArea, {
          // @ts-expect-error: web-only type
          transitionDuration: '150ms',
          backgroundColor: pressed ? '#323232' : hovered ? '#111111' : LogBoxStyle.getBackgroundColor()
        }],
        children: (0, _jsxRuntime.jsx)(_View.default, {
          style: buttonStyles.content,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            style: buttonStyles.label,
            children: text
          })
        })
      })
    });
  }
  const buttonStyles = _StyleSheet.default.create({
    safeArea: {
      flex: 1,
      borderTopWidth: 1,
      borderColor: '#323232'
      // paddingBottom: DeviceInfo.getConstants().isIPhoneX_deprecated ? 30 : 0,
    },
    content: {
      alignItems: 'center',
      height: 48,
      justifyContent: 'center'
    },
    label: {
      userSelect: 'none',
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 20
    }
  });
  const styles = _StyleSheet.default.create({
    root: Object.assign({
      backgroundColor: LogBoxStyle.getBackgroundColor(1)
    }, _Platform.default.select({
      web: {
        boxShadow: `0 -2px 0 2px #000`
      }
    }), {
      flexDirection: 'row'
    }),
    button: {
      flex: 1
    },
    syntaxErrorText: {
      textAlign: 'center',
      width: '100%',
      height: 48,
      fontSize: 14,
      lineHeight: 20,
      paddingTop: 20,
      paddingBottom: 50,
      fontStyle: 'italic',
      color: LogBoxStyle.getTextColor(0.6)
    }
  });
},327,[17,3,106,244,30,190,111,311,318,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorFooter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorHeader = LogBoxInspectorHeader;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _Image = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Image"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _StatusBar = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StatusBar"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/View"));
  var _LogContext = require(_dependencyMap[8], "../Data/LogContext");
  var _LogBoxButton = require(_dependencyMap[9], "../UI/LogBoxButton");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[10], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[11], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorHeader.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorHeader(props) {
    const {
      selectedLogIndex: selectedIndex,
      logs
    } = (0, _LogContext.useLogs)();
    const total = logs.length;
    if (props.level === 'syntax') {
      return (0, _jsxRuntime.jsx)(_View.default, {
        style: [styles.safeArea, styles[props.level]],
        children: (0, _jsxRuntime.jsx)(_View.default, {
          style: styles.header,
          children: (0, _jsxRuntime.jsx)(_View.default, {
            style: styles.title,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.titleText,
              children: "Failed to compile"
            })
          })
        })
      });
    }
    const prevIndex = selectedIndex - 1 < 0 ? total - 1 : selectedIndex - 1;
    const nextIndex = selectedIndex + 1 > total - 1 ? 0 : selectedIndex + 1;
    const titleText = `Log ${selectedIndex + 1} of ${total}`;
    return (0, _jsxRuntime.jsx)(_View.default, {
      style: [styles.safeArea, styles[props.level]],
      children: (0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.header,
        children: [(0, _jsxRuntime.jsx)(LogBoxInspectorHeaderButton, {
          disabled: total <= 1,
          level: props.level,
          image: require(_dependencyMap[12], "@expo/metro-runtime/assets/chevron-left.png"),
          onPress: () => props.onSelectIndex(prevIndex)
        }), (0, _jsxRuntime.jsx)(_View.default, {
          style: styles.title,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            style: styles.titleText,
            children: titleText
          })
        }), (0, _jsxRuntime.jsx)(LogBoxInspectorHeaderButton, {
          disabled: total <= 1,
          level: props.level,
          image: require(_dependencyMap[13], "@expo/metro-runtime/assets/chevron-right.png"),
          onPress: () => props.onSelectIndex(nextIndex)
        })]
      })
    });
  }
  const backgroundForLevel = level => ({
    warn: {
      default: 'transparent',
      pressed: LogBoxStyle.getWarningDarkColor()
    },
    error: {
      default: 'transparent',
      pressed: LogBoxStyle.getErrorDarkColor()
    },
    fatal: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    },
    syntax: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    },
    static: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    }
  })[level];
  function LogBoxInspectorHeaderButton(props) {
    return (0, _jsxRuntime.jsx)(_LogBoxButton.LogBoxButton, {
      backgroundColor: backgroundForLevel(props.level),
      onPress: props.disabled ? undefined : props.onPress,
      style: headerStyles.button,
      children: props.disabled ? null : (0, _jsxRuntime.jsx)(_Image.default, {
        source: props.image,
        tintColor: LogBoxStyle.getTextColor(),
        style: headerStyles.buttonImage
      })
    });
  }
  const headerStyles = _StyleSheet.default.create({
    button: {
      alignItems: 'center',
      justifyContent: 'center',
      aspectRatio: 1,
      marginRight: 6,
      marginLeft: 6,
      borderRadius: 3
    },
    buttonImage: {
      height: 14,
      width: 8
    }
  });
  const styles = _StyleSheet.default.create({
    syntax: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    static: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    fatal: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    warn: {
      backgroundColor: LogBoxStyle.getWarningColor()
    },
    error: {
      backgroundColor: LogBoxStyle.getErrorColor()
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      height: _Platform.default.select({
        default: 48,
        ios: 44
      })
    },
    title: {
      alignItems: 'center',
      flex: 1,
      justifyContent: 'center'
    },
    titleText: {
      color: LogBoxStyle.getTextColor(),
      fontSize: 16,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    safeArea: {
      paddingTop: true ? _StatusBar.default.currentHeight : 40
    }
  });
},328,[17,3,180,106,251,30,190,111,311,323,318,2,329,330],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorHeader.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/chevron-left.png",
    width: 16,
    height: 28
  };
},329,[],"node_modules\\@expo\\metro-runtime\\assets\\chevron-left.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/chevron-right.png",
    width: 16,
    height: 28
  };
},330,[],"node_modules\\@expo\\metro-runtime\\assets\\chevron-right.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorMessageHeader = LogBoxInspectorMessageHeader;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _LogBoxMessage = require(_dependencyMap[6], "../UI/LogBoxMessage");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[7], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorMessageHeader.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const SHOW_MORE_MESSAGE_LENGTH = 300;
  function ShowMoreButton({
    message,
    collapsed,
    onPress
  }) {
    if (message.content.length < SHOW_MORE_MESSAGE_LENGTH || !collapsed) {
      return null;
    }
    return (0, _jsxRuntime.jsx)(_Text.default, {
      style: styles.collapse,
      onPress: onPress,
      children: "... See More"
    });
  }
  function LogBoxInspectorMessageHeader(props) {
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.body,
      children: [(0, _jsxRuntime.jsx)(_View.default, {
        style: styles.heading,
        children: (0, _jsxRuntime.jsx)(_Text.default, {
          testID: "logbox_title",
          style: [styles.headingText, styles[props.level]],
          children: props.title
        })
      }), (0, _jsxRuntime.jsxs)(_Text.default, {
        style: styles.bodyText,
        children: [(0, _jsxRuntime.jsx)(_LogBoxMessage.LogBoxMessage, {
          maxLength: props.collapsed ? SHOW_MORE_MESSAGE_LENGTH : Infinity,
          message: props.message,
          style: styles.messageText
        }), (0, _jsxRuntime.jsx)(ShowMoreButton, Object.assign({}, props))]
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    body: Object.assign({
      backgroundColor: LogBoxStyle.getBackgroundColor(1)
    }, _Platform.default.select({
      web: {
        boxShadow: `0 2px 0 2px #00000080`
      }
    })),
    bodyText: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 20,
      fontWeight: '500',
      paddingHorizontal: 12,
      paddingBottom: 10
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginTop: 10,
      marginBottom: 5
    },
    headingText: {
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 28
    },
    warn: {
      color: LogBoxStyle.getWarningColor(1)
    },
    error: {
      color: LogBoxStyle.getErrorColor(1)
    },
    fatal: {
      color: LogBoxStyle.getFatalColor(1)
    },
    syntax: {
      color: LogBoxStyle.getFatalColor(1)
    },
    static: {
      color: LogBoxStyle.getFatalColor(1)
    },
    messageText: {
      color: LogBoxStyle.getTextColor(0.6)
    },
    collapse: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 14,
      fontWeight: '300',
      lineHeight: 12
    },
    button: {
      paddingVertical: 5,
      paddingHorizontal: 10,
      borderRadius: 3
    }
  });
},331,[17,3,106,30,190,111,332,318,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorMessageHeader.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxMessage = LogBoxMessage;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _Text = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Text"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxMessage.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  const cleanContent = content => content.replace(/^(TransformError |Warning: (Warning: )?|Error: )/g, '');
  function LogBoxMessage(props) {
    const {
      content,
      substitutions
    } = props.message;
    if (props.plaintext === true) {
      return (0, _jsxRuntime.jsx)(_Text.default, {
        children: cleanContent(content)
      });
    }
    const maxLength = props.maxLength != null ? props.maxLength : Infinity;
    const substitutionStyle = props.style;
    const elements = [];
    let length = 0;
    const createUnderLength = (key, message, style) => {
      let cleanMessage = cleanContent(message);
      if (props.maxLength != null) {
        cleanMessage = cleanMessage.slice(0, props.maxLength - length);
      }
      if (length < maxLength) {
        elements.push((0, _jsxRuntime.jsx)(_Text.default, {
          style: style,
          children: cleanMessage
        }, key));
      }
      length += cleanMessage.length;
    };
    const lastOffset = substitutions.reduce((prevOffset, substitution, index) => {
      const key = String(index);
      if (substitution.offset > prevOffset) {
        const prevPart = content.substr(prevOffset, substitution.offset - prevOffset);
        createUnderLength(key, prevPart);
      }
      const substititionPart = content.substr(substitution.offset, substitution.length);
      createUnderLength(key + '.5', substititionPart, substitutionStyle);
      return substitution.offset + substitution.length;
    }, 0);
    if (lastOffset < content.length) {
      const lastPart = content.substr(lastOffset);
      createUnderLength('-1', lastPart);
    }
    return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: elements
    });
  }
},332,[17,3,190,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxMessage.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorStackFrames = LogBoxInspectorStackFrames;
  exports.getCollapseMessage = getCollapseMessage;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var _LogBoxInspectorSection = require(_dependencyMap[5], "./LogBoxInspectorSection");
  var _LogBoxInspectorSourceMapStatus = require(_dependencyMap[6], "./LogBoxInspectorSourceMapStatus");
  var _LogBoxInspectorStackFrame = require(_dependencyMap[7], "./LogBoxInspectorStackFrame");
  var _LogContext = require(_dependencyMap[8], "../Data/LogContext");
  var _LogBoxButton = require(_dependencyMap[9], "../UI/LogBoxButton");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[10], "../UI/LogBoxStyle"));
  var _openFileInEditor = _interopRequireDefault(require(_dependencyMap[11], "../modules/openFileInEditor"));
  var _jsxRuntime = require(_dependencyMap[12], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrames.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function getCollapseMessage(stackFrames, collapsed) {
    if (stackFrames.length === 0) {
      return 'No frames to show';
    }
    const collapsedCount = stackFrames.reduce((count, {
      collapse
    }) => {
      if (collapse === true) {
        return count + 1;
      }
      return count;
    }, 0);
    if (collapsedCount === 0) {
      return 'Showing all frames';
    }
    const framePlural = `frame${collapsedCount > 1 ? 's' : ''}`;
    if (collapsedCount === stackFrames.length) {
      return collapsed ? `See${collapsedCount > 1 ? ' all ' : ' '}${collapsedCount} collapsed ${framePlural}` : `Collapse${collapsedCount > 1 ? ' all ' : ' '}${collapsedCount} ${framePlural}`;
    } else {
      return collapsed ? `See ${collapsedCount} more ${framePlural}` : `Collapse ${collapsedCount} ${framePlural}`;
    }
  }
  function LogBoxInspectorStackFrames({
    onRetry,
    type
  }) {
    const log = (0, _LogContext.useSelectedLog)();
    const [collapsed, setCollapsed] = (0, _react.useState)(() => {
      // Only collapse frames initially if some frames are not collapsed.
      return log.getAvailableStack(type)?.some(({
        collapse
      }) => !collapse);
    });
    function getStackList() {
      if (collapsed === true) {
        return log.getAvailableStack(type)?.filter(({
          collapse
        }) => !collapse);
      } else {
        return log.getAvailableStack(type);
      }
    }
    if (log.getAvailableStack(type)?.length === 0) {
      return null;
    }
    return (0, _jsxRuntime.jsxs)(_LogBoxInspectorSection.LogBoxInspectorSection, {
      heading: type === 'component' ? 'Component Stack' : 'Call Stack',
      action: (0, _jsxRuntime.jsx)(_LogBoxInspectorSourceMapStatus.LogBoxInspectorSourceMapStatus, {
        onPress: log.symbolicated[type].status === 'FAILED' ? onRetry : null,
        status: log.symbolicated[type].status
      }),
      children: [log.symbolicated[type].status !== 'COMPLETE' && (0, _jsxRuntime.jsx)(_View.default, {
        style: stackStyles.hintBox,
        children: (0, _jsxRuntime.jsx)(_Text.default, {
          style: stackStyles.hintText,
          children: "This call stack is not symbolicated. Some features are unavailable such as viewing the function name or tapping to open files."
        })
      }), (0, _jsxRuntime.jsx)(StackFrameList, {
        list: getStackList(),
        status: log.symbolicated[type].status
      }), (0, _jsxRuntime.jsx)(StackFrameFooter, {
        onPress: () => setCollapsed(!collapsed),
        message: getCollapseMessage(log.getAvailableStack(type), !!collapsed)
      })]
    });
  }
  function StackFrameList({
    list,
    status
  }) {
    return list.map((frame, index) => {
      const {
        file,
        lineNumber
      } = frame;
      return (0, _jsxRuntime.jsx)(_LogBoxInspectorStackFrame.LogBoxInspectorStackFrame, {
        frame: frame,
        onPress: status === 'COMPLETE' && file != null && lineNumber != null ? () => (0, _openFileInEditor.default)(file, lineNumber) : undefined
      }, index);
    });
  }
  function StackFrameFooter({
    message,
    onPress
  }) {
    return (0, _jsxRuntime.jsx)(_View.default, {
      style: stackStyles.collapseContainer,
      children: (0, _jsxRuntime.jsx)(_LogBoxButton.LogBoxButton, {
        backgroundColor: {
          default: 'transparent',
          pressed: LogBoxStyle.getBackgroundColor(1)
        },
        onPress: onPress,
        style: stackStyles.collapseButton,
        children: (0, _jsxRuntime.jsx)(_Text.default, {
          style: stackStyles.collapse,
          children: message
        })
      })
    });
  }
  const stackStyles = _StyleSheet.default.create({
    section: {
      marginTop: 15
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginBottom: 10
    },
    headingText: {
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    body: {
      paddingBottom: 10
    },
    bodyText: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '500',
      paddingHorizontal: 27
    },
    hintText: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 13,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '400',
      marginHorizontal: 10
    },
    hintBox: {
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      marginHorizontal: 10,
      paddingHorizontal: 5,
      paddingVertical: 10,
      borderRadius: 5,
      marginBottom: 5
    },
    collapseContainer: {
      marginLeft: 15,
      flexDirection: 'row'
    },
    collapseButton: {
      borderRadius: 5
    },
    collapse: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 12,
      fontWeight: '300',
      lineHeight: 20,
      marginTop: 0,
      paddingHorizontal: 10,
      paddingVertical: 5
    }
  });
},333,[17,3,30,190,111,320,334,337,311,323,318,326,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrames.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorSourceMapStatus = LogBoxInspectorSourceMapStatus;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Animated"));
  var _Easing = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Easing"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Text"));
  var _LogBoxButton = require(_dependencyMap[6], "../UI/LogBoxButton");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[7], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSourceMapStatus.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorSourceMapStatus(props) {
    const [state, setState] = (0, _react.useState)({
      animation: null,
      rotate: null
    });
    (0, _react.useEffect)(() => {
      if (props.status === 'PENDING') {
        if (state.animation == null) {
          const animated = new _Animated.default.Value(0);
          const animation = _Animated.default.loop(_Animated.default.timing(animated, {
            duration: 2000,
            easing: _Easing.default.linear,
            toValue: 1,
            useNativeDriver: true
          }));
          setState({
            animation,
            rotate: animated.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '360deg']
            })
          });
          animation.start();
        }
      } else {
        if (state.animation != null) {
          state.animation.stop();
          setState({
            animation: null,
            rotate: null
          });
        }
      }
      return () => {
        if (state.animation != null) {
          state.animation.stop();
        }
      };
    }, [props.status, state.animation]);
    let image;
    let color;
    switch (props.status) {
      case 'FAILED':
        image = require(_dependencyMap[9], "@expo/metro-runtime/assets/alert-triangle.png");
        color = LogBoxStyle.getErrorColor(1);
        break;
      case 'PENDING':
        image = require(_dependencyMap[10], "@expo/metro-runtime/assets/loader.png");
        color = LogBoxStyle.getWarningColor(1);
        break;
    }
    if (props.status === 'COMPLETE' || image == null) {
      return null;
    }
    return (0, _jsxRuntime.jsxs)(_LogBoxButton.LogBoxButton, {
      backgroundColor: {
        default: 'transparent',
        pressed: LogBoxStyle.getBackgroundColor(1)
      },
      hitSlop: {
        bottom: 8,
        left: 8,
        right: 8,
        top: 8
      },
      onPress: props.onPress,
      style: styles.root,
      children: [(0, _jsxRuntime.jsx)(_Animated.default.Image, {
        source: image,
        tintColor: color ?? LogBoxStyle.getTextColor(0.4),
        style: [styles.image, state.rotate == null || props.status !== 'PENDING' ? null : {
          transform: [{
            rotate: state.rotate
          }]
        }]
      }), (0, _jsxRuntime.jsx)(_Text.default, {
        style: [styles.text, {
          color
        }],
        children: "Source Map"
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    root: {
      alignItems: 'center',
      borderRadius: 12,
      flexDirection: 'row',
      height: 24,
      paddingHorizontal: 8
    },
    image: {
      height: 14,
      width: 16,
      marginEnd: 4
    },
    text: {
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
},334,[17,3,104,208,30,190,323,318,2,335,336],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSourceMapStatus.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/alert-triangle.png",
    width: 48,
    height: 42
  };
},335,[],"node_modules\\@expo\\metro-runtime\\assets\\alert-triangle.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/loader.png",
    width: 44,
    height: 44
  };
},336,[],"node_modules\\@expo\\metro-runtime\\assets\\loader.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogBoxInspectorStackFrame = LogBoxInspectorStackFrame;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var _LogBoxButton = require(_dependencyMap[5], "../UI/LogBoxButton");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[6], "../UI/LogBoxStyle"));
  var _constants = require(_dependencyMap[7], "../UI/constants");
  var _formatProjectFilePath = require(_dependencyMap[8], "../formatProjectFilePath");
  var _jsxRuntime = require(_dependencyMap[9], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrame.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LogBoxInspectorStackFrame(props) {
    const {
      frame,
      onPress
    } = props;
    const location = (0, _formatProjectFilePath.getStackFormattedLocation)("C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend", frame);
    return (0, _jsxRuntime.jsx)(_View.default, {
      style: styles.frameContainer,
      children: (0, _jsxRuntime.jsxs)(_LogBoxButton.LogBoxButton, {
        backgroundColor: {
          default: 'transparent',
          pressed: onPress ? LogBoxStyle.getBackgroundColor(1) : 'transparent'
        },
        onPress: onPress,
        style: styles.frame,
        children: [(0, _jsxRuntime.jsx)(_Text.default, {
          style: [styles.name, frame.collapse === true && styles.dim],
          children: frame.methodName
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          ellipsizeMode: "middle",
          numberOfLines: 1,
          style: [styles.location, frame.collapse === true && styles.dim],
          children: location
        })]
      })
    });
  }
  const styles = _StyleSheet.default.create({
    frameContainer: {
      flexDirection: 'row',
      paddingHorizontal: 15
    },
    frame: {
      flex: 1,
      paddingVertical: 4,
      paddingHorizontal: 10,
      borderRadius: 5
    },
    lineLocation: {
      flexDirection: 'row'
    },
    name: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '400',
      fontFamily: _constants.CODE_FONT
    },
    location: {
      color: LogBoxStyle.getTextColor(0.8),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16,
      paddingLeft: 10
    },
    dim: {
      color: LogBoxStyle.getTextColor(0.4),
      fontWeight: '300'
    },
    line: {
      color: LogBoxStyle.getTextColor(0.8),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16
    }
  });
},337,[17,3,30,190,111,323,318,324,325,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrame.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _parseErrorStack = _interopRequireDefault(require(_dependencyMap[1], "../parseErrorStack"));
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  class SyntheticError extends Error {
    name = '';
  }

  /**
   * Handles the developer-visible aspect of errors and exceptions
   */
  let exceptionID = 0;
  function parseException(e, isFatal) {
    const stack = (0, _parseErrorStack.default)(e?.stack);
    const currentExceptionID = ++exceptionID;
    const originalMessage = e.message || '';
    let message = originalMessage;
    if (e.componentStack != null) {
      message += `\n\nThis error is located at:${e.componentStack}`;
    }
    const namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;
    if (!message.startsWith(namePrefix)) {
      message = namePrefix + message;
    }
    message = e.jsEngine == null ? message : `${message}, js engine: ${e.jsEngine}`;
    const data = {
      message,
      originalMessage: message === originalMessage ? null : originalMessage,
      name: e.name == null || e.name === '' ? null : e.name,
      componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,
      stack,
      id: currentExceptionID,
      isFatal,
      extraData: {
        jsEngine: e.jsEngine,
        rawStack: e.stack
      }
    };
    return Object.assign({}, data, {
      isComponentError: !!e.isComponentError
    });
  }

  /**
   * Logs exceptions to the (native) console and displays them
   */
  function handleException(e) {
    let error;
    if (e instanceof Error) {
      error = e;
    } else {
      // Workaround for reporting errors caused by `throw 'some string'`
      // Unfortunately there is no way to figure out the stacktrace in this
      // case, so if you ended up here trying to trace an error, look for
      // `throw '<error message>'` somewhere in your codebase.
      error = new SyntheticError(e);
    }
    require(_dependencyMap[2], "../../LogBox").default.addException(parseException(error, true));
  }
  const ErrorUtils = {
    parseException,
    handleException,
    SyntheticError
  };
  var _default = exports.default = ErrorUtils;
},338,[17,313,306],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\ExceptionsManager\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  const getDevServer = () => {
    // Disable for SSR
    if (typeof window === 'undefined') {
      return {
        bundleLoadedFromServer: true,
        fullBundleUrl: '',
        url: ''
      };
    }
    return {
      // The bundle is always loaded from a server in the browser.
      bundleLoadedFromServer: true,
      /** URL but ensures that platform query param is added. */
      get fullBundleUrl() {
        if (document?.currentScript && 'src' in document.currentScript) {
          return document.currentScript.src;
        }
        const bundleUrl = new URL(location.href);
        bundleUrl.searchParams.set('platform', 'web');
        return bundleUrl.toString();
      },
      url: location.origin + location.pathname
    };
  };
  var _default = exports.default = getDevServer;
},339,[],"node_modules\\@expo\\metro-runtime\\src\\getDevServer.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* eslint-env browser */

  // Setup websocket messages for reloading the page from the command line.
  // This is normally setup on the native client.

  const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
  const messageSocket = new WebSocket(`${protocol}://${window.location.host}/message`);
  messageSocket.onmessage = message => {
    const data = JSON.parse(String(message.data));
    switch (data.method) {
      case 'sendDevCommand':
        switch (data.params.name) {
          case 'reload':
            window.location.reload();
            break;
          case 'rsc-reload':
            if (data.params.platform && data.params.platform !== "web") {
              return;
            }
            globalThis.__EXPO_RSC_RELOAD_LISTENERS__?.forEach(l => l());
            break;
          // Inject CSS modules from server components into the root client bundle in development.
          case 'module-import':
            {
              const {
                data: moduleData
              } = data.params;
              // remove element with the same 'expo-module-id'
              const id = `expo-module-id="${moduleData.id}"`;
              const style = document.querySelector(`style[${id}]`);
              document.querySelector(`script[${id}]`)?.remove();
              const code = moduleData.code;
              const script = document.createElement('script');
              script.type = 'module';
              script.text = code;
              script.setAttribute('expo-module-id', moduleData.id);
              document.head.appendChild(script);
              if (style) {
                // remove the previous block after the new one is loaded to mitigate FOUC.
                queueMicrotask(() => style.parentElement?.removeChild(style));
              }
            }
            break;
        }
        break;
      case 'reload':
        window.location.reload();
        break;
      case 'devMenu':
        // no-op
        break;
    }
  };
},340,[],"node_modules\\@expo\\metro-runtime\\src\\messageSocket.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _buildAsyncRequire = require(_dependencyMap[0], "./buildAsyncRequire");
  /**
   * Copyright  2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  global[`${global.__METRO_GLOBAL_PREFIX__ ?? ''}__loadBundleAsync`] = (0, _buildAsyncRequire.buildAsyncRequire)();
},341,[342],"node_modules\\@expo\\metro-runtime\\src\\async-require\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildAsyncRequire = buildAsyncRequire;
  var _loadBundle = require(_dependencyMap[0], "./loadBundle");
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Must satisfy the requirements of the Metro bundler.
   * https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0605-lazy-bundling.md#__loadbundleasync-in-metro
   */

  /** Create an `loadBundleAsync` function in the expected shape for Metro bundler. */
  function buildAsyncRequire() {
    const cache = new Map();
    return async function universal_loadBundleAsync(path) {
      if (cache.has(path)) {
        return cache.get(path);
      }
      const promise = (0, _loadBundle.loadBundleAsync)(path).catch(error => {
        cache.delete(path);
        throw error;
      });
      cache.set(path, promise);
      return promise;
    };
  }
},342,[343],"node_modules\\@expo\\metro-runtime\\src\\async-require\\buildAsyncRequire.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.loadBundleAsync = loadBundleAsync;
  var _buildUrlForBundle = require(_dependencyMap[0], "./buildUrlForBundle");
  var _fetchThenEval = require(_dependencyMap[1], "./fetchThenEval");
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param bundlePath Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon.bundle?params=from-metro`.
   */
  async function loadBundleAsync(bundlePath) {
    const requestUrl = (0, _buildUrlForBundle.buildUrlForBundle)(bundlePath);
    if (process.env.NODE_ENV === 'production') {
      return (0, _fetchThenEval.fetchThenEvalAsync)(requestUrl);
    } else {
      return (0, _fetchThenEval.fetchThenEvalAsync)(requestUrl).then(() => {
        const HMRClient = require(_dependencyMap[2], "../HMRClient").default;
        HMRClient.registerBundle(requestUrl);
      });
    }
  }
},343,[344,345,289],"node_modules\\@expo\\metro-runtime\\src\\async-require\\loadBundle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildUrlForBundle = buildUrlForBundle;
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Given a path and some optional additional query parameters, create the dev server bundle URL.
   * @param bundlePath like `/foobar`
   * @param params like `{ platform: "web" }`
   * @returns a URL like "/foobar.bundle?platform=android&modulesOnly=true&runModule=false&runtimeBytecodeVersion=null"
   */
  function buildUrlForBundle(bundlePath) {
    if (bundlePath.match(/^https?:\/\//)) {
      return bundlePath;
    }
    if (
    // @ts-expect-error
    typeof window.ReactNativeWebView !== 'undefined') {
      // In a webview, you cannot read from an absolute path.
      return bundlePath;
    }
    // NOTE(EvanBacon): This must come from the window origin (at least in dev mode).
    // Otherwise Metro will crash from attempting to load a bundle that doesn't exist.
    return '/' + bundlePath.replace(/^\/+/, '');
  }
},344,[],"node_modules\\@expo\\metro-runtime\\src\\async-require\\buildUrlForBundle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;

  // Basically `__webpack_require__.l`.
  function fetchThenEvalAsync(url, {
    scriptType,
    nonce,
    crossOrigin
  } = {}) {
    if (typeof window === 'undefined' ||
    // In development, use the fetch/eval method to detect the server error codes and parse bundler errors for the error overlay.
    __DEV__) {
      return require(_dependencyMap[0], "./fetchThenEvalJs").fetchThenEvalAsync(url);
    }
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      if (scriptType) script.type = scriptType;
      if (nonce) script.setAttribute('nonce', nonce);
      // script.setAttribute('data-expo-metro', ...);
      script.src = url;
      if (crossOrigin && script.src.indexOf(window.location.origin + '/') !== 0) {
        script.crossOrigin = crossOrigin;
      }
      script.onload = () => {
        script.parentNode && script.parentNode.removeChild(script);
        resolve();
      };
      // Create a new error object to preserve the original stack trace.
      const error = new AsyncRequireError();

      // Server error or network error.
      script.onerror = ev => {
        let event;
        if (typeof ev === 'string') {
          event = {
            type: 'error',
            target: {
              // @ts-expect-error
              src: event
            }
          };
        } else {
          event = ev;
        }
        const errorType = event && (event.type === 'load' ? 'missing' : event.type);
        // @ts-expect-error
        const realSrc = event?.target?.src;
        error.message = 'Loading module ' + url + ' failed.\n(' + errorType + ': ' + realSrc + ')';
        error.type = errorType;
        error.request = realSrc;
        script.parentNode && script.parentNode.removeChild(script);
        reject(error);
      };
      if (script.src === currentSrc) {
        // NOTE(kitten): We always prevent `fetchThenEval` from loading the "current script".
        // This points at our entrypoint bundle, and we should never reload and reevaluate the
        // entrypoint bundle
        resolve();
      } else {
        document.head.appendChild(script);
      }
    });
  }
  class AsyncRequireError extends Error {
    name = 'AsyncRequireError';
  }
},345,[346],"node_modules\\@expo\\metro-runtime\\src\\async-require\\fetchThenEval.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  var _errors = require(_dependencyMap[0], "./errors");
  var _fetchAsync = require(_dependencyMap[1], "./fetchAsync");
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param url Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon`.
   */
  function fetchThenEvalAsync(url) {
    return (0, _fetchAsync.fetchAsync)(url).then(({
      body,
      status,
      headers
    }) => {
      if (headers?.has?.('Content-Type') != null && headers.get('Content-Type').includes('application/json')) {
        // Errors are returned as JSON.
        throw new Error(JSON.parse(body).message || `Unknown error fetching '${url}'`);
      }
      if (status === 200) {
        // eslint-disable-next-line no-eval
        return eval(body);
      } else {
        // Format Metro errors if possible.
        if (process.env.NODE_ENV === 'development') {
          // body can be an error from Metro if a module is missing.
          // {"originModulePath":"/Users/evanbacon/Documents/GitHub/expo/.","targetModuleName":"./http://localhost:8081/node_modules/react-native/index.js","message":"..."}
          const error = jsonParseOptional(body);
          if (error) {
            // TODO: This is essentially like the Metro native red box errors. We should do a better job formatting them so
            // the user experience doesn't feel bad. This can be tested by loading a split bundle that results in a missing module error from Metro.
            throw new _errors.MetroServerError(error, url);
          }
        }
        throw new Error(`Failed to load split bundle from URL: ${url}\n${body}`);
      }
    });
  }
  function jsonParseOptional(json) {
    try {
      return JSON.parse(json);
    } catch {
      return null;
    }
  }
},346,[347,348],"node_modules\\@expo\\metro-runtime\\src\\async-require\\fetchThenEvalJs.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MetroServerError = void 0;
  class MetroServerError extends Error {
    code = 'METRO_SERVER_ERROR';
    constructor(errorObject, url) {
      super(errorObject.message);
      this.url = url;
      this.name = 'MetroServerError';
      for (const key in errorObject) {
        this[key] = errorObject[key];
      }
    }
  }
  exports.MetroServerError = MetroServerError;
},347,[],"node_modules\\@expo\\metro-runtime\\src\\async-require\\errors.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fetchAsync = fetchAsync;
  /**
   * Copyright  2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  async function fetchAsync(url) {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        // No real reason for this but we try to use this format for everything.
        'expo-platform': 'web'
      }
    });
    return {
      body: await response.text(),
      status: response.status,
      headers: response.headers
    };
  }
},348,[],"node_modules\\@expo\\metro-runtime\\src\\async-require\\fetchAsync.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright  2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // React Native's error handling is full of bugs which cause the app to crash in production.
  // We'll disable their handling in production native builds to ensure missing modules are shown to the user.
  const disableReactNativeMissingModuleHandling = !__DEV__ && (false || typeof window === 'undefined');
  globalThis.__webpack_chunk_load__ = id => {
    return global[`${__METRO_GLOBAL_PREFIX__}__loadBundleAsync`](id);
  };
  globalThis.__webpack_require__ = id => {
    // This logic can be tested by running a production iOS build without virtual client boundaries. This will result in all split chunks being missing and
    // errors being thrown on RSC load.

    const original = ErrorUtils.reportFatalError;
    if (disableReactNativeMissingModuleHandling) {
      ErrorUtils.reportFatalError = err => {
        // Throw the error so the __r function exits as expected. The error will then be caught by the nearest error boundary.
        throw err;
      };
    }
    try {
      return global[`${__METRO_GLOBAL_PREFIX__}__r`](id);
    } finally {
      // Restore the original error handling.
      if (disableReactNativeMissingModuleHandling) {
        ErrorUtils.reportFatalError = original;
      }
    }
  };
},349,[],"node_modules\\@expo\\metro-runtime\\rsc\\runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    createStaticNavigation: true,
    Link: true,
    LinkingContext: true,
    LocaleDirContext: true,
    NavigationContainer: true,
    ServerContainer: true,
    DarkTheme: true,
    DefaultTheme: true,
    UNSTABLE_UnhandledLinkingContext: true,
    useLinkBuilder: true,
    useLinkProps: true,
    useLinkTo: true,
    useLocale: true,
    useScrollToTop: true
  };
  Object.defineProperty(exports, "DarkTheme", {
    enumerable: true,
    get: function () {
      return _DarkTheme.DarkTheme;
    }
  });
  Object.defineProperty(exports, "DefaultTheme", {
    enumerable: true,
    get: function () {
      return _DefaultTheme.DefaultTheme;
    }
  });
  Object.defineProperty(exports, "Link", {
    enumerable: true,
    get: function () {
      return _Link.Link;
    }
  });
  Object.defineProperty(exports, "LinkingContext", {
    enumerable: true,
    get: function () {
      return _LinkingContext.LinkingContext;
    }
  });
  Object.defineProperty(exports, "LocaleDirContext", {
    enumerable: true,
    get: function () {
      return _LocaleDirContext.LocaleDirContext;
    }
  });
  Object.defineProperty(exports, "NavigationContainer", {
    enumerable: true,
    get: function () {
      return _NavigationContainer.NavigationContainer;
    }
  });
  Object.defineProperty(exports, "ServerContainer", {
    enumerable: true,
    get: function () {
      return _ServerContainer.ServerContainer;
    }
  });
  Object.defineProperty(exports, "UNSTABLE_UnhandledLinkingContext", {
    enumerable: true,
    get: function () {
      return _UnhandledLinkingContext.UnhandledLinkingContext;
    }
  });
  Object.defineProperty(exports, "createStaticNavigation", {
    enumerable: true,
    get: function () {
      return _createStaticNavigation.createStaticNavigation;
    }
  });
  Object.defineProperty(exports, "useLinkBuilder", {
    enumerable: true,
    get: function () {
      return _useLinkBuilder.useLinkBuilder;
    }
  });
  Object.defineProperty(exports, "useLinkProps", {
    enumerable: true,
    get: function () {
      return _useLinkProps.useLinkProps;
    }
  });
  Object.defineProperty(exports, "useLinkTo", {
    enumerable: true,
    get: function () {
      return _useLinkTo.useLinkTo;
    }
  });
  Object.defineProperty(exports, "useLocale", {
    enumerable: true,
    get: function () {
      return _useLocale.useLocale;
    }
  });
  Object.defineProperty(exports, "useScrollToTop", {
    enumerable: true,
    get: function () {
      return _useScrollToTop.useScrollToTop;
    }
  });
  var _createStaticNavigation = require(_dependencyMap[0], "./createStaticNavigation.js");
  var _Link = require(_dependencyMap[1], "./Link.js");
  var _LinkingContext = require(_dependencyMap[2], "./LinkingContext.js");
  var _LocaleDirContext = require(_dependencyMap[3], "./LocaleDirContext.js");
  var _NavigationContainer = require(_dependencyMap[4], "./NavigationContainer.js");
  var _ServerContainer = require(_dependencyMap[5], "./ServerContainer.js");
  var _DarkTheme = require(_dependencyMap[6], "./theming/DarkTheme.js");
  var _DefaultTheme = require(_dependencyMap[7], "./theming/DefaultTheme.js");
  var _types = require(_dependencyMap[8], "./types.js");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  var _UnhandledLinkingContext = require(_dependencyMap[9], "./UnhandledLinkingContext.js");
  var _useLinkBuilder = require(_dependencyMap[10], "./useLinkBuilder.js");
  var _useLinkProps = require(_dependencyMap[11], "./useLinkProps.js");
  var _useLinkTo = require(_dependencyMap[12], "./useLinkTo.js");
  var _useLocale = require(_dependencyMap[13], "./useLocale.js");
  var _useScrollToTop = require(_dependencyMap[14], "./useScrollToTop.js");
  var _core = require(_dependencyMap[15], "@react-navigation/core");
  Object.keys(_core).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _core[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _core[key];
      }
    });
  });
},350,[351,463,451,452,450,465,466,453,467,455,468,464,469,470,471,352],"node_modules\\@react-navigation\\native\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createStaticNavigation = createStaticNavigation;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _core = require(_dependencyMap[2], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _NavigationContainer = require(_dependencyMap[4], "./NavigationContainer.js");
  var _jsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  const _excluded = ["linking"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Create a navigation component from a static navigation config.
   * The returned component is a wrapper around `NavigationContainer`.
   *
   * @param tree Static navigation config.
   * @returns Navigation component to use in your app.
   */
  function createStaticNavigation(tree) {
    const Component = (0, _core.createComponentForStaticNavigation)(tree, 'RootNavigator');
    function Navigation(_ref, ref) {
      let {
          linking
        } = _ref,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
      const linkingConfig = React.useMemo(() => {
        const screens = (0, _core.createPathConfigForStaticNavigation)(tree, {
          initialRouteName: linking?.config?.initialRouteName
        }, linking?.enabled === 'auto');
        if (!screens) return;
        return {
          path: linking?.config?.path,
          initialRouteName: linking?.config?.initialRouteName,
          screens
        };
      }, [linking?.enabled, linking?.config?.path, linking?.config?.initialRouteName]);
      const memoizedLinking = React.useMemo(() => {
        if (!linking) {
          return undefined;
        }
        const enabled = typeof linking.enabled === 'boolean' ? linking.enabled : linkingConfig?.screens != null;
        return Object.assign({}, linking, {
          enabled,
          config: linkingConfig
        });
      }, [linking, linkingConfig]);
      if (linking?.enabled === true && linkingConfig?.screens == null) {
        throw new Error('Linking is enabled but no linking configuration was found for the screens.\n\n' + 'To solve this:\n' + "- Specify a 'linking' property for the screens you want to link to.\n" + "- Or set 'linking.enabled' to 'auto' to generate paths automatically.\n\n" + 'See usage guide: https://reactnavigation.org/docs/static-configuration#linking');
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationContainer.NavigationContainer, Object.assign({}, rest, {
        ref: ref,
        linking: memoizedLinking,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {})
      }));
    }
    return /*#__PURE__*/React.forwardRef(Navigation);
  }
},351,[17,29,352,3,450,6],"node_modules\\@react-navigation\\native\\lib\\module\\createStaticNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    BaseNavigationContainer: true,
    createNavigationContainerRef: true,
    createNavigatorFactory: true,
    CurrentRenderContext: true,
    findFocusedRoute: true,
    getActionFromState: true,
    getFocusedRouteNameFromRoute: true,
    getPathFromState: true,
    getStateFromPath: true,
    NavigationContainerRefContext: true,
    NavigationContext: true,
    NavigationHelpersContext: true,
    NavigationIndependentTree: true,
    NavigationRouteContext: true,
    PreventRemoveContext: true,
    PreventRemoveProvider: true,
    createComponentForStaticNavigation: true,
    createPathConfigForStaticNavigation: true,
    ThemeContext: true,
    ThemeProvider: true,
    useTheme: true,
    useFocusEffect: true,
    useIsFocused: true,
    useNavigation: true,
    useNavigationBuilder: true,
    useNavigationContainerRef: true,
    useNavigationIndependentTree: true,
    useNavigationState: true,
    usePreventRemove: true,
    usePreventRemoveContext: true,
    useRoute: true,
    useStateForPath: true,
    validatePathConfig: true
  };
  Object.defineProperty(exports, "BaseNavigationContainer", {
    enumerable: true,
    get: function () {
      return _BaseNavigationContainer.BaseNavigationContainer;
    }
  });
  Object.defineProperty(exports, "CurrentRenderContext", {
    enumerable: true,
    get: function () {
      return _CurrentRenderContext.CurrentRenderContext;
    }
  });
  Object.defineProperty(exports, "NavigationContainerRefContext", {
    enumerable: true,
    get: function () {
      return _NavigationContainerRefContext.NavigationContainerRefContext;
    }
  });
  Object.defineProperty(exports, "NavigationContext", {
    enumerable: true,
    get: function () {
      return _NavigationContext.NavigationContext;
    }
  });
  Object.defineProperty(exports, "NavigationHelpersContext", {
    enumerable: true,
    get: function () {
      return _NavigationHelpersContext.NavigationHelpersContext;
    }
  });
  Object.defineProperty(exports, "NavigationIndependentTree", {
    enumerable: true,
    get: function () {
      return _NavigationIndependentTree.NavigationIndependentTree;
    }
  });
  Object.defineProperty(exports, "NavigationRouteContext", {
    enumerable: true,
    get: function () {
      return _NavigationRouteContext.NavigationRouteContext;
    }
  });
  Object.defineProperty(exports, "PreventRemoveContext", {
    enumerable: true,
    get: function () {
      return _PreventRemoveContext.PreventRemoveContext;
    }
  });
  Object.defineProperty(exports, "PreventRemoveProvider", {
    enumerable: true,
    get: function () {
      return _PreventRemoveProvider.PreventRemoveProvider;
    }
  });
  Object.defineProperty(exports, "ThemeContext", {
    enumerable: true,
    get: function () {
      return _ThemeContext.ThemeContext;
    }
  });
  Object.defineProperty(exports, "ThemeProvider", {
    enumerable: true,
    get: function () {
      return _ThemeProvider.ThemeProvider;
    }
  });
  Object.defineProperty(exports, "createComponentForStaticNavigation", {
    enumerable: true,
    get: function () {
      return _StaticNavigation.createComponentForStaticNavigation;
    }
  });
  Object.defineProperty(exports, "createNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return _createNavigationContainerRef.createNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "createNavigatorFactory", {
    enumerable: true,
    get: function () {
      return _createNavigatorFactory.createNavigatorFactory;
    }
  });
  Object.defineProperty(exports, "createPathConfigForStaticNavigation", {
    enumerable: true,
    get: function () {
      return _StaticNavigation.createPathConfigForStaticNavigation;
    }
  });
  Object.defineProperty(exports, "findFocusedRoute", {
    enumerable: true,
    get: function () {
      return _findFocusedRoute.findFocusedRoute;
    }
  });
  Object.defineProperty(exports, "getActionFromState", {
    enumerable: true,
    get: function () {
      return _getActionFromState.getActionFromState;
    }
  });
  Object.defineProperty(exports, "getFocusedRouteNameFromRoute", {
    enumerable: true,
    get: function () {
      return _getFocusedRouteNameFromRoute.getFocusedRouteNameFromRoute;
    }
  });
  Object.defineProperty(exports, "getPathFromState", {
    enumerable: true,
    get: function () {
      return _getPathFromState.getPathFromState;
    }
  });
  Object.defineProperty(exports, "getStateFromPath", {
    enumerable: true,
    get: function () {
      return _getStateFromPath.getStateFromPath;
    }
  });
  Object.defineProperty(exports, "useFocusEffect", {
    enumerable: true,
    get: function () {
      return _useFocusEffect.useFocusEffect;
    }
  });
  Object.defineProperty(exports, "useIsFocused", {
    enumerable: true,
    get: function () {
      return _useIsFocused.useIsFocused;
    }
  });
  Object.defineProperty(exports, "useNavigation", {
    enumerable: true,
    get: function () {
      return _useNavigation.useNavigation;
    }
  });
  Object.defineProperty(exports, "useNavigationBuilder", {
    enumerable: true,
    get: function () {
      return _useNavigationBuilder.useNavigationBuilder;
    }
  });
  Object.defineProperty(exports, "useNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return _useNavigationContainerRef.useNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "useNavigationIndependentTree", {
    enumerable: true,
    get: function () {
      return _useNavigationIndependentTree.useNavigationIndependentTree;
    }
  });
  Object.defineProperty(exports, "useNavigationState", {
    enumerable: true,
    get: function () {
      return _useNavigationState.useNavigationState;
    }
  });
  Object.defineProperty(exports, "usePreventRemove", {
    enumerable: true,
    get: function () {
      return _usePreventRemove.usePreventRemove;
    }
  });
  Object.defineProperty(exports, "usePreventRemoveContext", {
    enumerable: true,
    get: function () {
      return _usePreventRemoveContext.usePreventRemoveContext;
    }
  });
  Object.defineProperty(exports, "useRoute", {
    enumerable: true,
    get: function () {
      return _useRoute.useRoute;
    }
  });
  Object.defineProperty(exports, "useStateForPath", {
    enumerable: true,
    get: function () {
      return _useStateForPath.useStateForPath;
    }
  });
  Object.defineProperty(exports, "useTheme", {
    enumerable: true,
    get: function () {
      return _useTheme.useTheme;
    }
  });
  Object.defineProperty(exports, "validatePathConfig", {
    enumerable: true,
    get: function () {
      return _validatePathConfig.validatePathConfig;
    }
  });
  var _BaseNavigationContainer = require(_dependencyMap[0], "./BaseNavigationContainer.js");
  var _createNavigationContainerRef = require(_dependencyMap[1], "./createNavigationContainerRef.js");
  var _createNavigatorFactory = require(_dependencyMap[2], "./createNavigatorFactory.js");
  var _CurrentRenderContext = require(_dependencyMap[3], "./CurrentRenderContext.js");
  var _findFocusedRoute = require(_dependencyMap[4], "./findFocusedRoute.js");
  var _getActionFromState = require(_dependencyMap[5], "./getActionFromState.js");
  var _getFocusedRouteNameFromRoute = require(_dependencyMap[6], "./getFocusedRouteNameFromRoute.js");
  var _getPathFromState = require(_dependencyMap[7], "./getPathFromState.js");
  var _getStateFromPath = require(_dependencyMap[8], "./getStateFromPath.js");
  var _NavigationContainerRefContext = require(_dependencyMap[9], "./NavigationContainerRefContext.js");
  var _NavigationContext = require(_dependencyMap[10], "./NavigationContext.js");
  var _NavigationHelpersContext = require(_dependencyMap[11], "./NavigationHelpersContext.js");
  var _NavigationIndependentTree = require(_dependencyMap[12], "./NavigationIndependentTree.js");
  var _NavigationRouteContext = require(_dependencyMap[13], "./NavigationRouteContext.js");
  var _PreventRemoveContext = require(_dependencyMap[14], "./PreventRemoveContext.js");
  var _PreventRemoveProvider = require(_dependencyMap[15], "./PreventRemoveProvider.js");
  var _StaticNavigation = require(_dependencyMap[16], "./StaticNavigation.js");
  var _ThemeContext = require(_dependencyMap[17], "./theming/ThemeContext.js");
  var _ThemeProvider = require(_dependencyMap[18], "./theming/ThemeProvider.js");
  var _useTheme = require(_dependencyMap[19], "./theming/useTheme.js");
  var _types = require(_dependencyMap[20], "./types.js");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  var _useFocusEffect = require(_dependencyMap[21], "./useFocusEffect.js");
  var _useIsFocused = require(_dependencyMap[22], "./useIsFocused.js");
  var _useNavigation = require(_dependencyMap[23], "./useNavigation.js");
  var _useNavigationBuilder = require(_dependencyMap[24], "./useNavigationBuilder.js");
  var _useNavigationContainerRef = require(_dependencyMap[25], "./useNavigationContainerRef.js");
  var _useNavigationIndependentTree = require(_dependencyMap[26], "./useNavigationIndependentTree.js");
  var _useNavigationState = require(_dependencyMap[27], "./useNavigationState.js");
  var _usePreventRemove = require(_dependencyMap[28], "./usePreventRemove.js");
  var _usePreventRemoveContext = require(_dependencyMap[29], "./usePreventRemoveContext.js");
  var _useRoute = require(_dependencyMap[30], "./useRoute.js");
  var _useStateForPath = require(_dependencyMap[31], "./useStateForPath.js");
  var _validatePathConfig = require(_dependencyMap[32], "./validatePathConfig.js");
  var _routers = require(_dependencyMap[33], "@react-navigation/routers");
  Object.keys(_routers).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _routers[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _routers[key];
      }
    });
  });
},352,[353,367,385,388,370,389,390,393,401,372,405,406,407,408,409,410,411,376,375,418,419,420,422,421,423,442,381,443,447,448,417,449,400,354],"node_modules\\@react-navigation\\core\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BaseNavigationContainer = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _routers = require(_dependencyMap[2], "@react-navigation/routers");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[4], "use-latest-callback"));
  var _checkDuplicateRouteNames = require(_dependencyMap[5], "./checkDuplicateRouteNames.js");
  var _checkSerializable = require(_dependencyMap[6], "./checkSerializable.js");
  var _createNavigationContainerRef = require(_dependencyMap[7], "./createNavigationContainerRef.js");
  var _DeprecatedNavigationInChildContext = require(_dependencyMap[8], "./DeprecatedNavigationInChildContext.js");
  var _EnsureSingleNavigator = require(_dependencyMap[9], "./EnsureSingleNavigator.js");
  var _findFocusedRoute = require(_dependencyMap[10], "./findFocusedRoute.js");
  var _NavigationBuilderContext = require(_dependencyMap[11], "./NavigationBuilderContext.js");
  var _NavigationContainerRefContext = require(_dependencyMap[12], "./NavigationContainerRefContext.js");
  var _NavigationIndependentTreeContext = require(_dependencyMap[13], "./NavigationIndependentTreeContext.js");
  var _NavigationStateContext = require(_dependencyMap[14], "./NavigationStateContext.js");
  var _ThemeProvider = require(_dependencyMap[15], "./theming/ThemeProvider.js");
  var _UnhandledActionContext = require(_dependencyMap[16], "./UnhandledActionContext.js");
  var _useChildListeners = require(_dependencyMap[17], "./useChildListeners.js");
  var _useEventEmitter = require(_dependencyMap[18], "./useEventEmitter.js");
  var _useKeyedChildListeners = require(_dependencyMap[19], "./useKeyedChildListeners.js");
  var _useNavigationIndependentTree = require(_dependencyMap[20], "./useNavigationIndependentTree.js");
  var _useOptionsGetters = require(_dependencyMap[21], "./useOptionsGetters.js");
  var _useSyncState = require(_dependencyMap[22], "./useSyncState.js");
  var _jsxRuntime = require(_dependencyMap[23], "react/jsx-runtime");
  const _excluded = ["key", "routeNames"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const serializableWarnings = [];
  const duplicateNameWarnings = [];

  /**
   * Remove `key` and `routeNames` from the state objects recursively to get partial state.
   *
   * @param state Initial state object.
   */
  const getPartialState = state => {
    if (state === undefined) {
      return;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const partialState = (0, _objectWithoutPropertiesLoose2.default)(state, _excluded);
    return Object.assign({}, partialState, {
      stale: true,
      routes: state.routes.map(route => {
        if (route.state === undefined) {
          return route;
        }
        return Object.assign({}, route, {
          state: getPartialState(route.state)
        });
      })
    });
  };

  /**
   * Container component which holds the navigation state.
   * This should be rendered at the root wrapping the whole app.
   *
   * @param props.initialState Initial state object for the navigation tree.
   * @param props.onReady Callback which is called after the navigation tree mounts.
   * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
   * @param props.onUnhandledAction Callback which is called when an action is not handled.
   * @param props.theme Theme object for the UI elements.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which refers to the navigation object containing helper methods.
   */
  const BaseNavigationContainer = exports.BaseNavigationContainer = /*#__PURE__*/React.forwardRef(function BaseNavigationContainer({
    initialState,
    onStateChange,
    onReady,
    onUnhandledAction,
    navigationInChildEnabled = false,
    theme,
    children
  }, ref) {
    const parent = React.useContext(_NavigationStateContext.NavigationStateContext);
    const independent = (0, _useNavigationIndependentTree.useNavigationIndependentTree)();
    if (!parent.isDefault && !independent) {
      throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, wrap the container in 'NavigationIndependentTree' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }
    const {
      state,
      getState,
      setState,
      scheduleUpdate,
      flushUpdates
    } = (0, _useSyncState.useSyncState)(() => getPartialState(initialState == null ? undefined : initialState));
    const isFirstMountRef = React.useRef(true);
    const navigatorKeyRef = React.useRef(undefined);
    const getKey = React.useCallback(() => navigatorKeyRef.current, []);
    const setKey = React.useCallback(key => {
      navigatorKeyRef.current = key;
    }, []);
    const {
      listeners,
      addListener
    } = (0, _useChildListeners.useChildListeners)();
    const {
      keyedListeners,
      addKeyedListener
    } = (0, _useKeyedChildListeners.useKeyedChildListeners)();
    const dispatch = (0, _useLatestCallback.default)(action => {
      if (listeners.focus[0] == null) {
        console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](navigation => navigation.dispatch(action));
      }
    });
    const canGoBack = (0, _useLatestCallback.default)(() => {
      if (listeners.focus[0] == null) {
        return false;
      }
      const {
        result,
        handled
      } = listeners.focus[0](navigation => navigation.canGoBack());
      if (handled) {
        return result;
      } else {
        return false;
      }
    });
    const resetRoot = (0, _useLatestCallback.default)(state => {
      const target = state?.key ?? keyedListeners.getState.root?.().key;
      if (target == null) {
        console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](navigation => navigation.dispatch(Object.assign({}, _routers.CommonActions.reset(state), {
          target
        })));
      }
    });
    const getRootState = (0, _useLatestCallback.default)(() => {
      return keyedListeners.getState.root?.();
    });
    const getCurrentRoute = (0, _useLatestCallback.default)(() => {
      const state = getRootState();
      if (state == null) {
        return undefined;
      }
      const route = (0, _findFocusedRoute.findFocusedRoute)(state);
      return route;
    });
    const isReady = (0, _useLatestCallback.default)(() => listeners.focus[0] != null);
    const emitter = (0, _useEventEmitter.useEventEmitter)();
    const {
      addOptionsGetter,
      getCurrentOptions
    } = (0, _useOptionsGetters.useOptionsGetters)({});
    const navigation = React.useMemo(() => Object.assign({}, Object.keys(_routers.CommonActions).reduce((acc, name) => {
      acc[name] = (...args) =>
      // @ts-expect-error: this is ok
      dispatch(_routers.CommonActions[name](...args));
      return acc;
    }, {}), emitter.create('root'), {
      dispatch,
      resetRoot,
      isFocused: () => true,
      canGoBack,
      getParent: () => undefined,
      getState,
      getRootState,
      getCurrentRoute,
      getCurrentOptions,
      isReady,
      setOptions: () => {
        throw new Error('Cannot call setOptions outside a screen');
      }
    }), [canGoBack, dispatch, emitter, getCurrentOptions, getCurrentRoute, getRootState, getState, isReady, resetRoot]);
    React.useImperativeHandle(ref, () => navigation, [navigation]);
    const onDispatchAction = (0, _useLatestCallback.default)((action, noop) => {
      emitter.emit({
        type: '__unsafe_action__',
        data: {
          action,
          noop,
          stack: stackRef.current
        }
      });
    });
    const lastEmittedOptionsRef = React.useRef(undefined);
    const onOptionsChange = (0, _useLatestCallback.default)(options => {
      if (lastEmittedOptionsRef.current === options) {
        return;
      }
      lastEmittedOptionsRef.current = options;
      emitter.emit({
        type: 'options',
        data: {
          options
        }
      });
    });
    const stackRef = React.useRef(undefined);
    const builderContext = React.useMemo(() => ({
      addListener,
      addKeyedListener,
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    }), [addListener, addKeyedListener, onDispatchAction, onOptionsChange, scheduleUpdate, flushUpdates]);
    const isInitialRef = React.useRef(true);
    const getIsInitial = React.useCallback(() => isInitialRef.current, []);
    const context = React.useMemo(() => ({
      state,
      getState,
      setState,
      getKey,
      setKey,
      getIsInitial,
      addOptionsGetter
    }), [state, getState, setState, getKey, setKey, getIsInitial, addOptionsGetter]);
    const onReadyRef = React.useRef(onReady);
    const onStateChangeRef = React.useRef(onStateChange);
    React.useEffect(() => {
      isInitialRef.current = false;
      onStateChangeRef.current = onStateChange;
      onReadyRef.current = onReady;
    });
    const onReadyCalledRef = React.useRef(false);
    React.useEffect(() => {
      if (!onReadyCalledRef.current && isReady()) {
        onReadyCalledRef.current = true;
        onReadyRef.current?.();
        emitter.emit({
          type: 'ready'
        });
      }
    }, [state, isReady, emitter]);
    React.useEffect(() => {
      const hydratedState = getRootState();
      if (process.env.NODE_ENV !== 'production') {
        if (hydratedState !== undefined) {
          const serializableResult = (0, _checkSerializable.checkSerializable)(hydratedState);
          if (!serializableResult.serializable) {
            const {
              location,
              reason
            } = serializableResult;
            let path = '';
            let pointer = hydratedState;
            let params = false;
            for (let i = 0; i < location.length; i++) {
              const curr = location[i];
              const prev = location[i - 1];
              pointer = pointer[curr];
              if (!params && curr === 'state') {
                continue;
              } else if (!params && curr === 'routes') {
                if (path) {
                  path += ' > ';
                }
              } else if (!params && typeof curr === 'number' && prev === 'routes') {
                path += pointer?.name;
              } else if (!params) {
                path += ` > ${curr}`;
                params = true;
              } else {
                if (typeof curr === 'number' || /^[0-9]+$/.test(curr)) {
                  path += `[${curr}]`;
                } else if (/^[a-z$_]+$/i.test(curr)) {
                  path += `.${curr}`;
                } else {
                  path += `[${JSON.stringify(curr)}]`;
                }
              }
            }
            const message = `Non-serializable values were found in the navigation state. Check:\n\n${path} (${reason})\n\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.`;
            if (!serializableWarnings.includes(message)) {
              serializableWarnings.push(message);
              console.warn(message);
            }
          }
          const duplicateRouteNamesResult = (0, _checkDuplicateRouteNames.checkDuplicateRouteNames)(hydratedState);
          if (duplicateRouteNamesResult.length) {
            const message = `Found screens with the same name nested inside one another. Check:\n${duplicateRouteNamesResult.map(locations => `\n${locations.join(', ')}`)}\n\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.`;
            if (!duplicateNameWarnings.includes(message)) {
              duplicateNameWarnings.push(message);
              console.warn(message);
            }
          }
        }
      }
      emitter.emit({
        type: 'state',
        data: {
          state
        }
      });
      if (!isFirstMountRef.current && onStateChangeRef.current) {
        onStateChangeRef.current(hydratedState);
      }
      isFirstMountRef.current = false;
    }, [getRootState, emitter, state]);
    const defaultOnUnhandledAction = (0, _useLatestCallback.default)(action => {
      if (process.env.NODE_ENV === 'production') {
        return;
      }
      const payload = action.payload;
      let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
      switch (action.type) {
        case 'PRELOAD':
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'POP_TO':
        case 'JUMP_TO':
          if (payload?.name) {
            message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.\n\nIf you're using conditional rendering, navigation will happen automatically and you shouldn't navigate manually, see.`;
          } else {
            message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
          }
          break;
        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
          message += `\n\nIs there any screen to go back to?`;
          break;
        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
          message += `\n\nIs your screen inside a Drawer navigator?`;
          break;
      }
      message += `\n\nThis is a development-only warning and won't be shown in production.`;
      console.error(message);
    });
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
      value: false,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationContainerRefContext.NavigationContainerRefContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
          value: builderContext,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
            value: context,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_UnhandledActionContext.UnhandledActionContext.Provider, {
              value: onUnhandledAction ?? defaultOnUnhandledAction,
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext.Provider, {
                value: navigationInChildEnabled,
                children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
                  children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_ThemeProvider.ThemeProvider, {
                    value: theme,
                    children: children
                  })
                })
              })
            })
          })
        })
      })
    });
  });
},353,[17,29,354,3,362,365,366,367,368,369,370,371,372,373,374,375,377,378,379,380,381,382,383,6],"node_modules\\@react-navigation\\core\\lib\\module\\BaseNavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    CommonActions: true,
    BaseRouter: true,
    DrawerActions: true,
    DrawerRouter: true,
    StackActions: true,
    StackRouter: true,
    TabActions: true,
    TabRouter: true
  };
  Object.defineProperty(exports, "BaseRouter", {
    enumerable: true,
    get: function () {
      return _BaseRouter.BaseRouter;
    }
  });
  exports.CommonActions = void 0;
  Object.defineProperty(exports, "DrawerActions", {
    enumerable: true,
    get: function () {
      return _DrawerRouter.DrawerActions;
    }
  });
  Object.defineProperty(exports, "DrawerRouter", {
    enumerable: true,
    get: function () {
      return _DrawerRouter.DrawerRouter;
    }
  });
  Object.defineProperty(exports, "StackActions", {
    enumerable: true,
    get: function () {
      return _StackRouter.StackActions;
    }
  });
  Object.defineProperty(exports, "StackRouter", {
    enumerable: true,
    get: function () {
      return _StackRouter.StackRouter;
    }
  });
  Object.defineProperty(exports, "TabActions", {
    enumerable: true,
    get: function () {
      return _TabRouter.TabActions;
    }
  });
  Object.defineProperty(exports, "TabRouter", {
    enumerable: true,
    get: function () {
      return _TabRouter.TabRouter;
    }
  });
  var CommonActions = _interopRequireWildcard(require(_dependencyMap[0], "./CommonActions.js"));
  exports.CommonActions = CommonActions;
  var _BaseRouter = require(_dependencyMap[1], "./BaseRouter.js");
  var _DrawerRouter = require(_dependencyMap[2], "./DrawerRouter.js");
  var _StackRouter = require(_dependencyMap[3], "./StackRouter.js");
  var _TabRouter = require(_dependencyMap[4], "./TabRouter.js");
  var _types = require(_dependencyMap[5], "./types.js");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
},354,[355,356,358,360,359,361],"node_modules\\@react-navigation\\routers\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.goBack = goBack;
  exports.navigate = navigate;
  exports.navigateDeprecated = navigateDeprecated;
  exports.preload = preload;
  exports.replaceParams = replaceParams;
  exports.reset = reset;
  exports.setParams = setParams;
  function goBack() {
    return {
      type: 'GO_BACK'
    };
  }
  function navigate(...args) {
    if (typeof args[0] === 'string') {
      const [name, params, options] = args;
      if (typeof options === 'boolean') {
        console.warn(`Passing a boolean as the third argument to 'navigate' is deprecated. Pass '{ merge: true }' instead.`);
      }
      return {
        type: 'NAVIGATE',
        payload: {
          name,
          params,
          merge: typeof options === 'boolean' ? options : options?.merge,
          pop: options?.pop
        }
      };
    } else {
      const payload = args[0] || {};
      if (!('name' in payload)) {
        throw new Error('You need to specify a name when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
      }
      return {
        type: 'NAVIGATE',
        payload
      };
    }
  }
  function navigateDeprecated(...args) {
    if (typeof args[0] === 'string') {
      return {
        type: 'NAVIGATE_DEPRECATED',
        payload: {
          name: args[0],
          params: args[1]
        }
      };
    } else {
      const payload = args[0] || {};
      if (!('name' in payload)) {
        throw new Error('You need to specify a name when calling navigateDeprecated with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigatelegacy for usage.');
      }
      return {
        type: 'NAVIGATE_DEPRECATED',
        payload
      };
    }
  }
  function reset(state) {
    return {
      type: 'RESET',
      payload: state
    };
  }
  function setParams(params) {
    return {
      type: 'SET_PARAMS',
      payload: {
        params
      }
    };
  }
  function replaceParams(params) {
    return {
      type: 'REPLACE_PARAMS',
      payload: {
        params
      }
    };
  }
  function preload(name, params) {
    return {
      type: 'PRELOAD',
      payload: {
        name,
        params
      }
    };
  }
},355,[],"node_modules\\@react-navigation\\routers\\lib\\module\\CommonActions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BaseRouter = void 0;
  var _nonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  /**
   * Base router object that can be used when writing custom routers.
   * This provides few helper methods to handle common actions such as `RESET`.
   */
  const BaseRouter = exports.BaseRouter = {
    getStateForAction(state, action) {
      switch (action.type) {
        case 'SET_PARAMS':
        case 'REPLACE_PARAMS':
          {
            const index = action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
            if (index === -1) {
              return null;
            }
            return Object.assign({}, state, {
              routes: state.routes.map((r, i) => i === index ? Object.assign({}, r, {
                params: action.type === 'REPLACE_PARAMS' ? action.payload.params : Object.assign({}, r.params, action.payload.params)
              }) : r)
            });
          }
        case 'RESET':
          {
            const nextState = action.payload;
            if (nextState.routes.length === 0 || nextState.routes.some(route => !state.routeNames.includes(route.name))) {
              return null;
            }
            if (nextState.stale === false) {
              if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some(name => !state.routeNames.includes(name))) {
                return null;
              }
              return Object.assign({}, nextState, {
                routes: nextState.routes.map(route => route.key ? route : Object.assign({}, route, {
                  key: `${route.name}-${(0, _nonSecure.nanoid)()}`
                }))
              });
            }
            return nextState;
          }
        default:
          return null;
      }
    },
    shouldActionChangeFocus(action) {
      return action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED';
    }
  };
},356,[900],"node_modules\\@react-navigation\\routers\\lib\\module\\BaseRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DrawerActions = void 0;
  exports.DrawerRouter = DrawerRouter;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _nonSecure = require(_dependencyMap[2], "nanoid/non-secure");
  var _TabRouter = require(_dependencyMap[3], "./TabRouter.js");
  const _excluded = ["defaultStatus"];
  const DrawerActions = exports.DrawerActions = Object.assign({}, _TabRouter.TabActions, {
    openDrawer() {
      return {
        type: 'OPEN_DRAWER'
      };
    },
    closeDrawer() {
      return {
        type: 'CLOSE_DRAWER'
      };
    },
    toggleDrawer() {
      return {
        type: 'TOGGLE_DRAWER'
      };
    }
  });
  function DrawerRouter(_ref) {
    let {
        defaultStatus = 'closed'
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const router = (0, _TabRouter.TabRouter)(rest);
    const isDrawerInHistory = state => Boolean(state.history?.some(it => it.type === 'drawer'));
    const addDrawerToHistory = state => {
      if (isDrawerInHistory(state)) {
        return state;
      }
      return Object.assign({}, state, {
        history: [...state.history, {
          type: 'drawer',
          status: defaultStatus === 'open' ? 'closed' : 'open'
        }]
      });
    };
    const removeDrawerFromHistory = state => {
      if (!isDrawerInHistory(state)) {
        return state;
      }
      return Object.assign({}, state, {
        history: state.history.filter(it => it.type !== 'drawer')
      });
    };
    const openDrawer = state => {
      if (defaultStatus === 'open') {
        return removeDrawerFromHistory(state);
      }
      return addDrawerToHistory(state);
    };
    const closeDrawer = state => {
      if (defaultStatus === 'open') {
        return addDrawerToHistory(state);
      }
      return removeDrawerFromHistory(state);
    };
    return Object.assign({}, router, {
      type: 'drawer',
      getInitialState({
        routeNames,
        routeParamList,
        routeGetIdList
      }) {
        const state = router.getInitialState({
          routeNames,
          routeParamList,
          routeGetIdList
        });
        return Object.assign({}, state, {
          default: defaultStatus,
          stale: false,
          type: 'drawer',
          key: `drawer-${(0, _nonSecure.nanoid)()}`
        });
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) {
        if (partialState.stale === false) {
          return partialState;
        }
        let state = router.getRehydratedState(partialState, {
          routeNames,
          routeParamList,
          routeGetIdList
        });
        if (isDrawerInHistory(partialState)) {
          // Re-sync the drawer entry in history to correct it if it was wrong
          state = removeDrawerFromHistory(state);
          state = addDrawerToHistory(state);
        }
        return Object.assign({}, state, {
          default: defaultStatus,
          type: 'drawer',
          key: `drawer-${(0, _nonSecure.nanoid)()}`
        });
      },
      getStateForRouteFocus(state, key) {
        const result = router.getStateForRouteFocus(state, key);
        return closeDrawer(result);
      },
      getStateForAction(state, action, options) {
        switch (action.type) {
          case 'OPEN_DRAWER':
            return openDrawer(state);
          case 'CLOSE_DRAWER':
            return closeDrawer(state);
          case 'TOGGLE_DRAWER':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }
            return addDrawerToHistory(state);
          case 'JUMP_TO':
          case 'NAVIGATE':
          case 'NAVIGATE_DEPRECATED':
            {
              const result = router.getStateForAction(state, action, options);
              if (result != null && result.index !== state.index) {
                return closeDrawer(result);
              }
              return result;
            }
          case 'GO_BACK':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }
            return router.getStateForAction(state, action, options);
          default:
            return router.getStateForAction(state, action, options);
        }
      },
      actionCreators: DrawerActions
    });
  }
},358,[17,29,900,359],"node_modules\\@react-navigation\\routers\\lib\\module\\DrawerRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TabActions = void 0;
  exports.TabRouter = TabRouter;
  var _nonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _BaseRouter = require(_dependencyMap[1], "./BaseRouter.js");
  const TYPE_ROUTE = 'route';
  const TabActions = exports.TabActions = {
    jumpTo(name, params) {
      return {
        type: 'JUMP_TO',
        payload: {
          name,
          params
        }
      };
    }
  };
  const getRouteHistory = (routes, index, backBehavior, initialRouteName) => {
    const history = [{
      type: TYPE_ROUTE,
      key: routes[index].key
    }];
    let initialRouteIndex;
    switch (backBehavior) {
      case 'order':
        for (let i = index; i > 0; i--) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[i - 1].key
          });
        }
        break;
      case 'firstRoute':
        if (index !== 0) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[0].key
          });
        }
        break;
      case 'initialRoute':
        initialRouteIndex = routes.findIndex(route => route.name === initialRouteName);
        initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
        if (index !== initialRouteIndex) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[initialRouteIndex].key
          });
        }
        break;
      case 'history':
      case 'fullHistory':
        // The history will fill up on navigation
        break;
    }
    return history;
  };
  const changeIndex = (state, index, backBehavior, initialRouteName) => {
    let history = state.history;
    if (backBehavior === 'history' || backBehavior === 'fullHistory') {
      const currentRouteKey = state.routes[index].key;
      if (backBehavior === 'history') {
        // Remove the existing key from the history to de-duplicate it
        history = history.filter(it => it.type === 'route' ? it.key !== currentRouteKey : false);
      } else if (backBehavior === 'fullHistory') {
        const lastHistoryRouteItemIndex = history.findLastIndex(item => item.type === 'route');
        if (currentRouteKey === history[lastHistoryRouteItemIndex]?.key) {
          // For full-history, only remove if it matches the last route
          // Useful for drawer, if current route was in history, then drawer state changed
          // Then we only need to move the route to the front
          history = [...history.slice(0, lastHistoryRouteItemIndex), ...history.slice(lastHistoryRouteItemIndex + 1)];
        }
      }
      history = history.concat({
        type: TYPE_ROUTE,
        key: currentRouteKey
      });
    } else {
      history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }
    return Object.assign({}, state, {
      index,
      history
    });
  };
  function TabRouter({
    initialRouteName,
    backBehavior = 'firstRoute'
  }) {
    const router = Object.assign({}, _BaseRouter.BaseRouter, {
      type: 'tab',
      getInitialState({
        routeNames,
        routeParamList
      }) {
        const index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
        const routes = routeNames.map(name => ({
          name,
          key: `${name}-${(0, _nonSecure.nanoid)()}`,
          params: routeParamList[name]
        }));
        const history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        return {
          stale: false,
          type: 'tab',
          key: `tab-${(0, _nonSecure.nanoid)()}`,
          index,
          routeNames,
          history,
          routes,
          preloadedRouteKeys: []
        };
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList
      }) {
        const state = partialState;
        if (state.stale === false) {
          return state;
        }
        const routes = routeNames.map(name => {
          const route = state.routes.find(r => r.name === name);
          return Object.assign({}, route, {
            name,
            key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nonSecure.nanoid)()}`,
            params: routeParamList[name] !== undefined ? Object.assign({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
          });
        });
        const index = Math.min(Math.max(routeNames.indexOf(state.routes[state?.index ?? 0]?.name), 0), routes.length - 1);
        const routeKeys = routes.map(route => route.key);
        const history = state.history?.filter(it => routeKeys.includes(it.key)) ?? [];
        return changeIndex({
          stale: false,
          type: 'tab',
          key: `tab-${(0, _nonSecure.nanoid)()}`,
          index,
          routeNames,
          history,
          routes,
          preloadedRouteKeys: state.preloadedRouteKeys?.filter(key => routeKeys.includes(key)) ?? []
        }, index, backBehavior, initialRouteName);
      },
      getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeKeyChanges
      }) {
        const routes = routeNames.map(name => state.routes.find(r => r.name === name && !routeKeyChanges.includes(r.name)) || {
          name,
          key: `${name}-${(0, _nonSecure.nanoid)()}`,
          params: routeParamList[name]
        });
        const index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
        let history = state.history.filter(
        // Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
        it => it.type !== 'route' || routes.find(r => r.key === it.key));
        if (!history.length) {
          history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        }
        return Object.assign({}, state, {
          history,
          routeNames,
          routes,
          index
        });
      },
      getStateForRouteFocus(state, key) {
        const index = state.routes.findIndex(r => r.key === key);
        if (index === -1 || index === state.index) {
          return state;
        }
        return changeIndex(state, index, backBehavior, initialRouteName);
      },
      getStateForAction(state, action, {
        routeParamList,
        routeGetIdList
      }) {
        switch (action.type) {
          case 'JUMP_TO':
          case 'NAVIGATE':
          case 'NAVIGATE_DEPRECATED':
            {
              const index = state.routes.findIndex(route => route.name === action.payload.name);
              if (index === -1) {
                return null;
              }
              const updatedState = changeIndex(Object.assign({}, state, {
                routes: state.routes.map(route => {
                  if (route.name !== action.payload.name) {
                    return route;
                  }
                  const getId = routeGetIdList[route.name];
                  const currentId = getId?.({
                    params: route.params
                  });
                  const nextId = getId?.({
                    params: action.payload.params
                  });
                  const key = currentId === nextId ? route.key : `${route.name}-${(0, _nonSecure.nanoid)()}`;
                  let params;
                  if ((action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED') && action.payload.merge && currentId === nextId) {
                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                  } else {
                    params = routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], action.payload.params) : action.payload.params;
                  }
                  const path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                  return params !== route.params || path !== route.path ? Object.assign({}, route, {
                    key,
                    path,
                    params
                  }) : route;
                })
              }), index, backBehavior, initialRouteName);
              return Object.assign({}, updatedState, {
                preloadedRouteKeys: updatedState.preloadedRouteKeys.filter(key => key !== state.routes[updatedState.index].key)
              });
            }
          case 'GO_BACK':
            {
              if (state.history.length === 1) {
                return null;
              }
              const previousKey = state.history[state.history.length - 2]?.key;
              const index = state.routes.findLastIndex(route => route.key === previousKey);
              if (index === -1) {
                return null;
              }
              return Object.assign({}, state, {
                preloadedRouteKeys: state.preloadedRouteKeys.filter(key => key !== state.routes[index].key),
                history: state.history.slice(0, -1),
                index
              });
            }
          case 'PRELOAD':
            {
              const routeIndex = state.routes.findIndex(route => route.name === action.payload.name);
              if (routeIndex === -1) {
                return null;
              }
              const route = state.routes[routeIndex];
              const getId = routeGetIdList[route.name];
              const currentId = getId?.({
                params: route.params
              });
              const nextId = getId?.({
                params: action.payload.params
              });
              const key = currentId === nextId ? route.key : `${route.name}-${(0, _nonSecure.nanoid)()}`;
              const params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], action.payload.params) : undefined;
              const newRoute = params !== route.params ? Object.assign({}, route, {
                key,
                params
              }) : route;
              return Object.assign({}, state, {
                preloadedRouteKeys: state.preloadedRouteKeys.filter(key => key !== route.key).concat(newRoute.key),
                routes: state.routes.map((route, index) => index === routeIndex ? newRoute : route),
                history: key === route.key ? state.history : state.history.filter(record => record.key !== route.key)
              });
            }
          default:
            return _BaseRouter.BaseRouter.getStateForAction(state, action);
        }
      },
      actionCreators: TabActions
    });
    return router;
  }
},359,[900,356],"node_modules\\@react-navigation\\routers\\lib\\module\\TabRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StackActions = void 0;
  exports.StackRouter = StackRouter;
  var _nonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _BaseRouter = require(_dependencyMap[1], "./BaseRouter.js");
  const StackActions = exports.StackActions = {
    replace(name, params) {
      return {
        type: 'REPLACE',
        payload: {
          name,
          params
        }
      };
    },
    push(name, params) {
      return {
        type: 'PUSH',
        payload: {
          name,
          params
        }
      };
    },
    pop(count = 1) {
      return {
        type: 'POP',
        payload: {
          count
        }
      };
    },
    popToTop() {
      return {
        type: 'POP_TO_TOP'
      };
    },
    popTo(name, params, options) {
      if (typeof options === 'boolean') {
        console.warn(`Passing a boolean as the third argument to 'popTo' is deprecated. Pass '{ merge: true }' instead.`);
      }
      return {
        type: 'POP_TO',
        payload: {
          name,
          params,
          merge: typeof options === 'boolean' ? options : options?.merge
        }
      };
    }
  };
  function StackRouter(options) {
    const router = Object.assign({}, _BaseRouter.BaseRouter, {
      type: 'stack',
      getInitialState({
        routeNames,
        routeParamList
      }) {
        const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
        return {
          stale: false,
          type: 'stack',
          key: `stack-${(0, _nonSecure.nanoid)()}`,
          index: 0,
          routeNames,
          preloadedRoutes: [],
          routes: [{
            key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          }]
        };
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList
      }) {
        const state = partialState;
        if (state.stale === false) {
          return state;
        }
        const routes = state.routes.filter(route => routeNames.includes(route.name)).map(route => Object.assign({}, route, {
          key: route.key || `${route.name}-${(0, _nonSecure.nanoid)()}`,
          params: routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params) : route.params
        }));
        const preloadedRoutes = state.preloadedRoutes?.filter(route => routeNames.includes(route.name)).map(route => Object.assign({}, route, {
          key: route.key || `${route.name}-${(0, _nonSecure.nanoid)()}`,
          params: routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params) : route.params
        })) ?? [];
        if (routes.length === 0) {
          const initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
          routes.push({
            key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }
        return {
          stale: false,
          type: 'stack',
          key: `stack-${(0, _nonSecure.nanoid)()}`,
          index: routes.length - 1,
          routeNames,
          routes,
          preloadedRoutes
        };
      },
      getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeKeyChanges
      }) {
        const routes = state.routes.filter(route => routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
        if (routes.length === 0) {
          const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
          routes.push({
            key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }
        return Object.assign({}, state, {
          routeNames,
          routes,
          index: Math.min(state.index, routes.length - 1)
        });
      },
      getStateForRouteFocus(state, key) {
        const index = state.routes.findIndex(r => r.key === key);
        if (index === -1 || index === state.index) {
          return state;
        }
        return Object.assign({}, state, {
          index,
          routes: state.routes.slice(0, index + 1)
        });
      },
      getStateForAction(state, action, options) {
        const {
          routeParamList
        } = options;
        switch (action.type) {
          case 'REPLACE':
            {
              const index = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
              if (index === -1) {
                return null;
              }
              const {
                name,
                params
              } = action.payload;
              if (!state.routeNames.includes(name)) {
                return null;
              }
              return Object.assign({}, state, {
                routes: state.routes.map((route, i) => i === index ? {
                  key: `${name}-${(0, _nonSecure.nanoid)()}`,
                  name,
                  params: routeParamList[name] !== undefined ? Object.assign({}, routeParamList[name], params) : params
                } : route)
              });
            }
          case 'PUSH':
          case 'NAVIGATE':
            {
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.findLast(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (action.type === 'NAVIGATE') {
                const currentRoute = state.routes[state.index];

                // If the route matches the current one, then navigate to it
                if (action.payload.name === currentRoute.name) {
                  route = currentRoute;
                } else if (action.payload.pop) {
                  route = state.routes.findLast(route => route.name === action.payload.name);
                }
              }
              if (!route) {
                route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              let params;
              if (action.type === 'NAVIGATE' && action.payload.merge && route) {
                params = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;
              } else {
                params = routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params;
              }
              let routes;
              if (route) {
                if (action.type === 'NAVIGATE' && action.payload.pop) {
                  routes = [];

                  // Get all routes until the matching one
                  for (const r of state.routes) {
                    if (r.key === route.key) {
                      routes.push(Object.assign({}, route, {
                        path: action.payload.path !== undefined ? action.payload.path : route.path,
                        params
                      }));
                      break;
                    }
                    routes.push(r);
                  }
                } else {
                  routes = state.routes.filter(r => r.key !== route.key);
                  routes.push(Object.assign({}, route, {
                    path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,
                    params
                  }));
                }
              } else {
                routes = [...state.routes, {
                  key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                  name: action.payload.name,
                  path: action.type === 'NAVIGATE' ? action.payload.path : undefined,
                  params
                }];
              }
              return Object.assign({}, state, {
                index: routes.length - 1,
                preloadedRoutes: state.preloadedRoutes.filter(route => routes[routes.length - 1].key !== route.key),
                routes
              });
            }
          case 'NAVIGATE_DEPRECATED':
            {
              if (state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                params: route.params
              }))) {
                return null;
              }
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }

              // If the route already exists, navigate to that
              let index = -1;
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              if (id) {
                index = state.routes.findIndex(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (state.routes[state.index].name === action.payload.name) {
                index = state.index;
              } else {
                for (let i = state.routes.length - 1; i >= 0; i--) {
                  if (state.routes[i].name === action.payload.name) {
                    index = i;
                    break;
                  }
                }
              }
              if (index === -1) {
                const routes = [...state.routes, {
                  key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                  name: action.payload.name,
                  params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                }];
                return Object.assign({}, state, {
                  routes,
                  index: routes.length - 1
                });
              }
              const route = state.routes[index];
              let params;
              if (action.payload.merge) {
                params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
              } else {
                params = routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], action.payload.params) : action.payload.params;
              }
              return Object.assign({}, state, {
                index,
                routes: [...state.routes.slice(0, index), params !== route.params ? Object.assign({}, route, {
                  params
                }) : state.routes[index]]
              });
            }
          case 'POP':
            {
              const index = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
              if (index > 0) {
                const count = Math.max(index - action.payload.count + 1, 1);
                const routes = state.routes.slice(0, count).concat(state.routes.slice(index + 1));
                return Object.assign({}, state, {
                  index: routes.length - 1,
                  routes
                });
              }
              return null;
            }
          case 'POP_TO_TOP':
            return router.getStateForAction(state, {
              type: 'POP',
              payload: {
                count: state.routes.length - 1
              }
            }, options);
          case 'POP_TO':
            {
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }

              // If the route already exists, navigate to that
              let index = -1;
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              if (id) {
                index = state.routes.findIndex(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (state.routes[state.index].name === action.payload.name) {
                index = state.index;
              } else {
                for (let i = state.routes.length - 1; i >= 0; i--) {
                  if (state.routes[i].name === action.payload.name) {
                    index = i;
                    break;
                  }
                }
              }

              // If the route doesn't exist, remove the current route and add the new one
              if (index === -1) {
                const routes = [...state.routes.slice(0, -1), {
                  key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                  name: action.payload.name,
                  params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                }];
                return Object.assign({}, state, {
                  routes,
                  index: routes.length - 1
                });
              }
              const route = state.routes[index];
              let params;
              if (action.payload.merge) {
                params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
              } else {
                params = routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], action.payload.params) : action.payload.params;
              }
              return Object.assign({}, state, {
                index,
                routes: [...state.routes.slice(0, index), params !== route.params ? Object.assign({}, route, {
                  params
                }) : state.routes[index]]
              });
            }
          case 'GO_BACK':
            if (state.index > 0) {
              return router.getStateForAction(state, {
                type: 'POP',
                payload: {
                  count: 1
                },
                target: action.target,
                source: action.source
              }, options);
            }
            return null;
          case 'PRELOAD':
            {
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              if (route) {
                return Object.assign({}, state, {
                  routes: state.routes.map(r => {
                    if (r.key !== route?.key) {
                      return r;
                    }
                    return Object.assign({}, r, {
                      params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                    });
                  })
                });
              } else {
                return Object.assign({}, state, {
                  preloadedRoutes: state.preloadedRoutes.filter(r => r.name !== action.payload.name || id !== getId?.({
                    params: r.params
                  })).concat({
                    key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                    name: action.payload.name,
                    params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                  })
                });
              }
            }
          default:
            return _BaseRouter.BaseRouter.getStateForAction(state, action);
        }
      },
      actionCreators: StackActions
    });
    return router;
  }
},360,[900,356],"node_modules\\@react-navigation\\routers\\lib\\module\\StackRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},361,[],"node_modules\\@react-navigation\\routers\\lib\\module\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _index = _interopRequireDefault(require(_dependencyMap[1], "./lib/src/index.js"));
  // eslint-disable-next-line import/extensions
  var _default = exports.default = _index.default;
},362,[17,363],"node_modules\\use-latest-callback\\esm.mjs");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var React = require(_dependencyMap[0], "react");
  var useIsomorphicLayoutEffect_1 = require(_dependencyMap[1], "./useIsomorphicLayoutEffect");
  /**
   * React hook which returns the latest callback without changing the reference.
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  function useLatestCallback(callback) {
    var ref = React.useRef(callback);
    var latestCallback = React.useRef(function latestCallback() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return ref.current.apply(this, args);
    }).current;
    (0, useIsomorphicLayoutEffect_1.default)(function () {
      ref.current = callback;
    });
    return latestCallback;
  }
  module.exports = useLatestCallback;
},363,[3,364],"node_modules\\use-latest-callback\\lib\\src\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var react_1 = require(_dependencyMap[0], "react");
  /**
   * Use `useEffect` during SSR and `useLayoutEffect` in the browser to avoid warnings.
   */
  var useIsomorphicLayoutEffect = typeof document !== 'undefined' ? react_1.useLayoutEffect : react_1.useEffect;
  exports.default = useIsomorphicLayoutEffect;
},364,[3],"node_modules\\use-latest-callback\\lib\\src\\useIsomorphicLayoutEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.checkDuplicateRouteNames = checkDuplicateRouteNames;
  function checkDuplicateRouteNames(state) {
    const duplicates = [];
    const getRouteNames = (location, state) => {
      state.routes.forEach(route => {
        const currentLocation = location ? `${location} > ${route.name}` : route.name;
        route.state?.routeNames?.forEach(routeName => {
          if (routeName === route.name) {
            duplicates.push([currentLocation, `${currentLocation} > ${route.name}`]);
          }
        });
        if (route.state) {
          getRouteNames(currentLocation, route.state);
        }
      });
    };
    getRouteNames('', state);
    return duplicates;
  }
},365,[],"node_modules\\@react-navigation\\core\\lib\\module\\checkDuplicateRouteNames.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.checkSerializable = checkSerializable;
  const checkSerializableWithoutCircularReference = (o, seen, location) => {
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
      return {
        serializable: true
      };
    }
    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
      return {
        serializable: false,
        location,
        reason: typeof o === 'function' ? 'Function' : String(o)
      };
    }
    if (seen.has(o)) {
      return {
        serializable: false,
        reason: 'Circular reference',
        location
      };
    }
    seen.add(o);
    if (Array.isArray(o)) {
      for (let i = 0; i < o.length; i++) {
        const childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), [...location, i]);
        if (!childResult.serializable) {
          return childResult;
        }
      }
    } else {
      for (const key in o) {
        const childResult = checkSerializableWithoutCircularReference(o[key], new Set(seen), [...location, key]);
        if (!childResult.serializable) {
          return childResult;
        }
      }
    }
    return {
      serializable: true
    };
  };
  function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
  }
},366,[],"node_modules\\@react-navigation\\core\\lib\\module\\checkSerializable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NOT_INITIALIZED_ERROR = void 0;
  exports.createNavigationContainerRef = createNavigationContainerRef;
  var _routers = require(_dependencyMap[0], "@react-navigation/routers");
  const NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
  function createNavigationContainerRef() {
    const methods = [...Object.keys(_routers.CommonActions), 'addListener', 'removeListener', 'resetRoot', 'dispatch', 'isFocused', 'canGoBack', 'getRootState', 'getState', 'getParent', 'getCurrentRoute', 'getCurrentOptions'];
    const listeners = {};
    const removeListener = (event, callback) => {
      if (listeners[event]) {
        listeners[event] = listeners[event].filter(cb => cb !== callback);
      }
    };
    let current = null;
    const ref = Object.assign({
      get current() {
        return current;
      },
      set current(value) {
        current = value;
        if (value != null) {
          Object.entries(listeners).forEach(([event, callbacks]) => {
            callbacks.forEach(callback => {
              value.addListener(event, callback);
            });
          });
        }
      },
      isReady: () => {
        if (current == null) {
          return false;
        }
        return current.isReady();
      }
    }, methods.reduce((acc, name) => {
      acc[name] = (...args) => {
        if (current == null) {
          switch (name) {
            case 'addListener':
              {
                const [event, callback] = args;
                listeners[event] = listeners[event] || [];
                listeners[event].push(callback);
                return () => removeListener(event, callback);
              }
            case 'removeListener':
              {
                const [event, callback] = args;
                removeListener(event, callback);
                break;
              }
            default:
              console.error(NOT_INITIALIZED_ERROR);
          }
        } else {
          // @ts-expect-error: this is ok
          return current[name](...args);
        }
      };
      return acc;
    }, {}));
    return ref;
  }
},367,[354],"node_modules\\@react-navigation\\core\\lib\\module\\createNavigationContainerRef.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DeprecatedNavigationInChildContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which enables deprecated bubbling to child navigators.
   */
  const DeprecatedNavigationInChildContext = exports.DeprecatedNavigationInChildContext = /*#__PURE__*/React.createContext(false);
},368,[3],"node_modules\\@react-navigation\\core\\lib\\module\\DeprecatedNavigationInChildContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EnsureSingleNavigator = EnsureSingleNavigator;
  exports.SingleNavigatorContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _jsxRuntime = require(_dependencyMap[1], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
  const SingleNavigatorContext = exports.SingleNavigatorContext = /*#__PURE__*/React.createContext(undefined);

  /**
   * Component which ensures that there's only one navigator nested under it.
   */
  function EnsureSingleNavigator({
    children
  }) {
    const navigatorKeyRef = React.useRef(undefined);
    const value = React.useMemo(() => ({
      register(key) {
        const currentKey = navigatorKeyRef.current;
        if (currentKey !== undefined && key !== currentKey) {
          throw new Error(MULTIPLE_NAVIGATOR_ERROR);
        }
        navigatorKeyRef.current = key;
      },
      unregister(key) {
        const currentKey = navigatorKeyRef.current;
        if (key !== currentKey) {
          return;
        }
        navigatorKeyRef.current = undefined;
      }
    }), []);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(SingleNavigatorContext.Provider, {
      value: value,
      children: children
    });
  }
},369,[3,6],"node_modules\\@react-navigation\\core\\lib\\module\\EnsureSingleNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findFocusedRoute = findFocusedRoute;
  function findFocusedRoute(state) {
    let current = state;
    while (current?.routes[current.index ?? 0].state != null) {
      current = current.routes[current.index ?? 0].state;
    }
    const route = current?.routes[current?.index ?? 0];
    return route;
  }
},370,[],"node_modules\\@react-navigation\\core\\lib\\module\\findFocusedRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationBuilderContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the required helpers needed to build nested navigators.
   */
  const NavigationBuilderContext = exports.NavigationBuilderContext = /*#__PURE__*/React.createContext({
    onDispatchAction: () => undefined,
    onOptionsChange: () => undefined,
    scheduleUpdate: () => {
      throw new Error("Couldn't find a context for scheduling updates.");
    },
    flushUpdates: () => {
      throw new Error("Couldn't find a context for flushing updates.");
    }
  });
},371,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationBuilderContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationContainerRefContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the route prop for a screen.
   */
  const NavigationContainerRefContext = exports.NavigationContainerRefContext = /*#__PURE__*/React.createContext(undefined);
},372,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationContainerRefContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationIndependentTreeContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which marks the navigation tree as independent.
   */
  const NavigationIndependentTreeContext = exports.NavigationIndependentTreeContext = /*#__PURE__*/React.createContext(false);
},373,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationIndependentTreeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationStateContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
  const NavigationStateContext = exports.NavigationStateContext = /*#__PURE__*/React.createContext({
    isDefault: true,
    get getKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getIsInitial() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
},374,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationStateContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ThemeProvider = ThemeProvider;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _ThemeContext = require(_dependencyMap[1], "./ThemeContext.js");
  var _jsxRuntime = require(_dependencyMap[2], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function ThemeProvider({
    value,
    children
  }) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_ThemeContext.ThemeContext.Provider, {
      value: value,
      children: children
    });
  }
},375,[3,376,6],"node_modules\\@react-navigation\\core\\lib\\module\\theming\\ThemeProvider.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ThemeContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const ThemeContext = exports.ThemeContext = /*#__PURE__*/React.createContext(undefined);
  ThemeContext.displayName = 'ThemeContext';
},376,[3],"node_modules\\@react-navigation\\core\\lib\\module\\theming\\ThemeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UnhandledActionContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const UnhandledActionContext = exports.UnhandledActionContext = /*#__PURE__*/React.createContext(undefined);
},377,[3],"node_modules\\@react-navigation\\core\\lib\\module\\UnhandledActionContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useChildListeners = useChildListeners;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook which lets child navigators add action listeners.
   */
  function useChildListeners() {
    const {
      current: listeners
    } = React.useRef({
      action: [],
      focus: []
    });
    const addListener = React.useCallback((type, listener) => {
      listeners[type].push(listener);
      let removed = false;
      return () => {
        const index = listeners[type].indexOf(listener);
        if (!removed && index > -1) {
          removed = true;
          listeners[type].splice(index, 1);
        }
      };
    }, [listeners]);
    return {
      listeners,
      addListener
    };
  }
},378,[3],"node_modules\\@react-navigation\\core\\lib\\module\\useChildListeners.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useEventEmitter = useEventEmitter;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to manage the event system used by the navigator to notify screens of various events.
   */
  function useEventEmitter(listen) {
    const listenRef = React.useRef(listen);
    React.useEffect(() => {
      listenRef.current = listen;
    });
    const listeners = React.useRef(Object.create(null));
    const create = React.useCallback(target => {
      const removeListener = (type, callback) => {
        const callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
        if (!callbacks) {
          return;
        }
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      };
      const addListener = (type, callback) => {
        listeners.current[type] = listeners.current[type] || {};
        listeners.current[type][target] = listeners.current[type][target] || [];
        listeners.current[type][target].push(callback);
        let removed = false;
        return () => {
          // Prevent removing other listeners when unsubscribing same listener multiple times
          if (!removed) {
            removed = true;
            removeListener(type, callback);
          }
        };
      };
      return {
        addListener,
        removeListener
      };
    }, []);
    const emit = React.useCallback(({
      type,
      data,
      target,
      canPreventDefault
    }) => {
      const items = listeners.current[type] || {};

      // Copy the current list of callbacks in case they are mutated during execution
      const callbacks = target !== undefined ? items[target]?.slice() : [].concat(...Object.keys(items).map(t => items[t])).filter((cb, i, self) => self.lastIndexOf(cb) === i);
      const event = {
        get type() {
          return type;
        }
      };
      if (target !== undefined) {
        Object.defineProperty(event, 'target', {
          enumerable: true,
          get() {
            return target;
          }
        });
      }
      if (data !== undefined) {
        Object.defineProperty(event, 'data', {
          enumerable: true,
          get() {
            return data;
          }
        });
      }
      if (canPreventDefault) {
        let defaultPrevented = false;
        Object.defineProperties(event, {
          defaultPrevented: {
            enumerable: true,
            get() {
              return defaultPrevented;
            }
          },
          preventDefault: {
            enumerable: true,
            value() {
              defaultPrevented = true;
            }
          }
        });
      }
      listenRef.current?.(event);
      callbacks?.forEach(cb => cb(event));
      return event;
    }, []);
    return React.useMemo(() => ({
      create,
      emit
    }), [create, emit]);
  }
},379,[3],"node_modules\\@react-navigation\\core\\lib\\module\\useEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useKeyedChildListeners = useKeyedChildListeners;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook which lets child navigators add getters to be called for obtaining rehydrated state.
   */
  function useKeyedChildListeners() {
    const {
      current: keyedListeners
    } = React.useRef(Object.assign(Object.create(null), {
      getState: {},
      beforeRemove: {}
    }));
    const addKeyedListener = React.useCallback((type, key, listener) => {
      // @ts-expect-error: according to ref stated above you can use `key` to index type
      keyedListeners[type][key] = listener;
      return () => {
        // @ts-expect-error: according to ref stated above you can use `key` to index type
        keyedListeners[type][key] = undefined;
      };
    }, [keyedListeners]);
    return {
      keyedListeners,
      addKeyedListener
    };
  }
},380,[3],"node_modules\\@react-navigation\\core\\lib\\module\\useKeyedChildListeners.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationIndependentTree = useNavigationIndependentTree;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationIndependentTreeContext = require(_dependencyMap[1], "./NavigationIndependentTreeContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useNavigationIndependentTree() {
    return React.useContext(_NavigationIndependentTreeContext.NavigationIndependentTreeContext);
  }
},381,[3,373],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationIndependentTree.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useOptionsGetters = useOptionsGetters;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _NavigationStateContext = require(_dependencyMap[2], "./NavigationStateContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useOptionsGetters({
    key,
    options,
    navigation
  }) {
    const optionsRef = React.useRef(options);
    const optionsGettersFromChildRef = React.useRef({});
    const {
      onOptionsChange
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const {
      addOptionsGetter: parentAddOptionsGetter
    } = React.useContext(_NavigationStateContext.NavigationStateContext);
    const optionsChangeListener = React.useCallback(() => {
      const isFocused = navigation?.isFocused() ?? true;
      const hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
      if (isFocused && !hasChildren) {
        onOptionsChange(optionsRef.current ?? {});
      }
    }, [navigation, onOptionsChange]);
    React.useEffect(() => {
      optionsRef.current = options;
      optionsChangeListener();
      return navigation?.addListener('focus', optionsChangeListener);
    }, [navigation, options, optionsChangeListener]);
    const getOptionsFromListener = React.useCallback(() => {
      for (const key in optionsGettersFromChildRef.current) {
        if (key in optionsGettersFromChildRef.current) {
          const result = optionsGettersFromChildRef.current[key]?.();

          // null means unfocused route
          if (result !== null) {
            return result;
          }
        }
      }
      return null;
    }, []);
    const getCurrentOptions = React.useCallback(() => {
      const isFocused = navigation?.isFocused() ?? true;
      if (!isFocused) {
        return null;
      }
      const optionsFromListener = getOptionsFromListener();
      if (optionsFromListener !== null) {
        return optionsFromListener;
      }
      return optionsRef.current;
    }, [navigation, getOptionsFromListener]);
    React.useEffect(() => {
      return parentAddOptionsGetter?.(key, getCurrentOptions);
    }, [getCurrentOptions, parentAddOptionsGetter, key]);
    const addOptionsGetter = React.useCallback((key, getter) => {
      optionsGettersFromChildRef.current[key] = getter;
      optionsChangeListener();
      return () => {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete optionsGettersFromChildRef.current[key];
        optionsChangeListener();
      };
    }, [optionsChangeListener]);
    return {
      addOptionsGetter,
      getCurrentOptions
    };
  }
},382,[3,371,374],"node_modules\\@react-navigation\\core\\lib\\module\\useOptionsGetters.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSyncState = useSyncState;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[2], "use-latest-callback"));
  var _deepFreeze = require(_dependencyMap[3], "./deepFreeze.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const createStore = getInitialState => {
    const listeners = [];
    let initialized = false;
    let state;
    const getState = () => {
      if (initialized) {
        return state;
      }
      initialized = true;
      state = (0, _deepFreeze.deepFreeze)(getInitialState());
      return state;
    };
    let isBatching = false;
    let didUpdate = false;
    const setState = newState => {
      state = (0, _deepFreeze.deepFreeze)(newState);
      didUpdate = true;
      if (!isBatching) {
        listeners.forEach(listener => listener());
      }
    };
    const subscribe = callback => {
      listeners.push(callback);
      return () => {
        const index = listeners.indexOf(callback);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    };
    const batchUpdates = callback => {
      isBatching = true;
      callback();
      isBatching = false;
      if (didUpdate) {
        didUpdate = false;
        listeners.forEach(listener => listener());
      }
    };
    return {
      getState,
      setState,
      batchUpdates,
      subscribe
    };
  };
  function useSyncState(getInitialState) {
    const store = React.useRef(createStore(getInitialState)).current;
    const state = React.useSyncExternalStore(store.subscribe, store.getState, store.getState);
    React.useDebugValue(state);
    const pendingUpdatesRef = React.useRef([]);
    const scheduleUpdate = (0, _useLatestCallback.default)(callback => {
      pendingUpdatesRef.current.push(callback);
    });
    const flushUpdates = (0, _useLatestCallback.default)(() => {
      const pendingUpdates = pendingUpdatesRef.current;
      pendingUpdatesRef.current = [];
      if (pendingUpdates.length !== 0) {
        store.batchUpdates(() => {
          // Flush all the pending updates
          for (const update of pendingUpdates) {
            update();
          }
        });
      }
    });
    return {
      state,
      getState: store.getState,
      setState: store.setState,
      scheduleUpdate,
      flushUpdates
    };
  }
},383,[17,3,362,384],"node_modules\\@react-navigation\\core\\lib\\module\\useSyncState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isPlainObject = exports.deepFreeze = void 0;
  const isPlainObject = value => {
    if (typeof value === 'object' && value !== null) {
      return Object.getPrototypeOf(value) === Object.prototype;
    }
    return false;
  };
  exports.isPlainObject = isPlainObject;
  const deepFreeze = object => {
    // We only freeze in development to catch issues early
    // Don't freeze in production to avoid unnecessary performance overhead
    if (process.env.NODE_ENV === 'production') {
      return object;
    }
    if (Object.isFrozen(object)) {
      return object;
    }
    if (!isPlainObject(object) && !Array.isArray(object)) {
      return object;
    }

    // Freeze properties before freezing self
    for (const key in object) {
      // Don't freeze objects in params since they are passed by the user
      if (key !== 'params') {
        if (Object.getOwnPropertyDescriptor(object, key)?.configurable) {
          const value = object[key];
          deepFreeze(value);
        }
      }
    }
    return Object.freeze(object);
  };
  exports.deepFreeze = deepFreeze;
},384,[],"node_modules\\@react-navigation\\core\\lib\\module\\deepFreeze.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createNavigatorFactory = createNavigatorFactory;
  var _Group = require(_dependencyMap[0], "./Group.js");
  var _Screen = require(_dependencyMap[1], "./Screen.js");
  /**
   * Higher order component to create a `Navigator` and `Screen` pair.
   * Custom navigators should wrap the navigator component in `createNavigator` before exporting.
   *
   * @param Navigator The navigator component to wrap.
   * @returns Factory method to create a `Navigator` and `Screen` pair.
   */
  function createNavigatorFactory(Navigator) {
    function createNavigator(config) {
      if (config != null) {
        return {
          Navigator,
          Screen: _Screen.Screen,
          Group: _Group.Group,
          config
        };
      }
      return {
        Navigator,
        Screen: _Screen.Screen,
        Group: _Group.Group
      };
    }
    return createNavigator;
  }
},385,[386,387],"node_modules\\@react-navigation\\core\\lib\\module\\createNavigatorFactory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Empty component used for grouping screen configs.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Group = Group;
  function Group(_) {
    /* istanbul ignore next */
    return null;
  }
},386,[],"node_modules\\@react-navigation\\core\\lib\\module\\Group.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Empty component used for specifying route configuration.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Screen = Screen;
  function Screen(_) {
    /* istanbul ignore next */
    return null;
  }
},387,[],"node_modules\\@react-navigation\\core\\lib\\module\\Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CurrentRenderContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the values for the current navigation tree.
   * Intended for use in SSR. This is not safe to use on the client.
   */
  const CurrentRenderContext = exports.CurrentRenderContext = /*#__PURE__*/React.createContext(undefined);
},388,[3],"node_modules\\@react-navigation\\core\\lib\\module\\CurrentRenderContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getActionFromState = getActionFromState;
  function getActionFromState(state, options) {
    // Create a normalized configs object which will be easier to use
    const normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    const routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
    if (routes.length === 0) {
      return undefined;
    }
    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === normalizedConfig?.initialRouteName && routes[1].key === undefined)) {
      return {
        type: 'RESET',
        payload: state
      };
    }
    const route = state.routes[state.index ?? state.routes.length - 1];
    let current = route?.state;
    let config = normalizedConfig?.screens?.[route?.name];
    let params = Object.assign({}, route.params);
    const payload = route ? {
      name: route.name,
      path: route.path,
      params
    } : undefined;

    // If the screen contains a navigator, pop other screens to navigate to it
    // This avoid pushing multiple instances of navigators onto a stack
    //
    // For example:
    // - RootStack
    //   - BottomTabs
    //   - SomeScreen
    //
    // In this case, if deep linking to `BottomTabs`, we should pop `SomeScreen`
    // Otherwise, we'll end up with 2 instances of `BottomTabs` in the stack
    //
    // There are 2 ways we can detect if a screen contains a navigator:
    // - The route contains nested state in `route.state`
    // - Nested screens are defined in the config
    if (payload && config?.screens && Object.keys(config.screens).length) {
      payload.pop = true;
    }
    while (current) {
      if (current.routes.length === 0) {
        return undefined;
      }
      const routes = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
      const route = routes[routes.length - 1];

      // Explicitly set to override existing value when merging params
      Object.assign(params, {
        initial: undefined,
        screen: undefined,
        params: undefined,
        state: undefined
      });
      if (routes.length === 1 && routes[0].key === undefined) {
        params.initial = true;
        params.screen = route.name;
      } else if (routes.length === 2 && routes[0].key === undefined && routes[0].name === config?.initialRouteName && routes[1].key === undefined) {
        params.initial = false;
        params.screen = route.name;
      } else {
        params.state = current;
        break;
      }
      if (route.state) {
        params.params = Object.assign({}, route.params);
        params.pop = true;
        params = params.params;
      } else {
        params.path = route.path;
        params.params = route.params;
      }
      current = route.state;
      config = config?.screens?.[route.name];
      if (config?.screens && Object.keys(config.screens).length) {
        params.pop = true;
      }
    }
    if (payload?.params.screen || payload?.params.state) {
      payload.pop = true;
    }
    if (!payload) {
      return;
    }

    // Try to construct payload for a `NAVIGATE` action from the state
    // This lets us preserve the navigation state and not lose it
    return {
      type: 'NAVIGATE',
      payload
    };
  }
  const createNormalizedConfigItem = config => typeof config === 'object' && config != null ? {
    initialRouteName: config.initialRouteName,
    screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
  } : {};
  const createNormalizedConfigs = options => Object.entries(options).reduce((acc, [k, v]) => {
    acc[k] = createNormalizedConfigItem(v);
    return acc;
  }, {});
},389,[],"node_modules\\@react-navigation\\core\\lib\\module\\getActionFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getFocusedRouteNameFromRoute = getFocusedRouteNameFromRoute;
  var _useRouteCache = require(_dependencyMap[0], "./useRouteCache.js");
  function getFocusedRouteNameFromRoute(route) {
    // @ts-expect-error: this isn't in type definitions coz we want this private
    const state = route[_useRouteCache.CHILD_STATE] ?? route.state;
    const params = route.params;
    const routeName = state ?
    // Get the currently active route name in the nested navigator
    state.routes[
    // If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
    // The type property will only exist for rehydrated state and not for state from deep link
    state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name :
    // If state doesn't exist, we need to default to `screen` param if available
    typeof params?.screen === 'string' ? params.screen : undefined;
    return routeName;
  }
},390,[391],"node_modules\\@react-navigation\\core\\lib\\module\\getFocusedRouteNameFromRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CHILD_STATE = void 0;
  exports.useRouteCache = useRouteCache;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _isRecordEqual = require(_dependencyMap[3], "./isRecordEqual.js");
  const _excluded = ["state"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Utilities such as `getFocusedRouteNameFromRoute` need to access state.
   * So we need a way to suppress the warning for those use cases.
   * This is fine since they are internal utilities and this is not public API.
   */
  const CHILD_STATE = exports.CHILD_STATE = Symbol('CHILD_STATE');

  /**
   * Hook to cache route props for each screen in the navigator.
   * This lets add warnings and modifications to the route object but keep references between renders.
   */
  function useRouteCache(routes) {
    // Cache object which holds route objects for each screen
    const cache = React.useMemo(() => ({
      current: new Map()
    }), []);
    if (process.env.NODE_ENV === 'production') {
      // We don't want the overhead of creating extra maps every render in prod
      return routes;
    }
    cache.current = routes.reduce((acc, route) => {
      const previous = cache.current.get(route.key);
      const {
          state
        } = route,
        routeWithoutState = (0, _objectWithoutPropertiesLoose2.default)(route, _excluded);
      let proxy;
      if (previous && (0, _isRecordEqual.isRecordEqual)(previous, routeWithoutState)) {
        // If a cached route object already exists, reuse it
        proxy = previous;
      } else {
        proxy = routeWithoutState;
      }
      if (process.env.NODE_ENV !== 'production') {
        // FIXME: since the state is updated with mutation, the route object cannot be frozen
        // As a workaround, loop through the object and make the properties readonly
        for (const key in proxy) {
          // @ts-expect-error: this is fine since we are looping through the object
          const value = proxy[key];
          Object.defineProperty(proxy, key, {
            enumerable: true,
            configurable: true,
            writable: false,
            value
          });
        }
      }
      Object.defineProperty(proxy, CHILD_STATE, {
        enumerable: false,
        configurable: true,
        value: state
      });
      acc.set(route.key, proxy);
      return acc;
    }, new Map());
    return Array.from(cache.current.values());
  }
},391,[17,29,3,392],"node_modules\\@react-navigation\\core\\lib\\module\\useRouteCache.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two records with primitive values as the content.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isRecordEqual = isRecordEqual;
  function isRecordEqual(a, b) {
    if (a === b) {
      return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(key => a[key] === b[key]);
  }
},392,[],"node_modules\\@react-navigation\\core\\lib\\module\\isRecordEqual.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPathFromState = getPathFromState;
  var queryString = _interopRequireWildcard(require(_dependencyMap[0], "query-string"));
  var _getPatternParts = require(_dependencyMap[1], "./getPatternParts.js");
  var _validatePathConfig = require(_dependencyMap[2], "./validatePathConfig.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const getActiveRoute = state => {
    const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
      return getActiveRoute(route.state);
    }
    return route;
  };
  const cachedNormalizedConfigs = new WeakMap();
  const getNormalizedConfigs = options => {
    if (!options?.screens) return {};
    const cached = cachedNormalizedConfigs.get(options?.screens);
    if (cached) return cached;
    const normalizedConfigs = createNormalizedConfigs(options.screens);
    cachedNormalizedConfigs.set(options.screens, normalizedConfigs);
    return normalizedConfigs;
  };

  /**
   * Utility to serialize a navigation state object to a path string.
   *
   * @example
   * ```js
   * getPathFromState(
   *   {
   *     routes: [
   *       {
   *         name: 'Chat',
   *         params: { author: 'Jane', id: 42 },
   *       },
   *     ],
   *   },
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         stringify: { author: author => author.toLowerCase() }
   *       }
   *     }
   *   }
   * )
   * ```
   *
   * @param state Navigation state to serialize.
   * @param options Extra options to fine-tune how to serialize the path.
   * @returns Path representing the state, e.g. /foo/bar?count=42.
   */
  function getPathFromState(state, options) {
    if (state == null) {
      throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);
    }
    if (options) {
      (0, _validatePathConfig.validatePathConfig)(options);
    }
    const configs = getNormalizedConfigs(options);
    let path = '/';
    let current = state;
    const allParams = {};
    while (current) {
      let index = typeof current.index === 'number' ? current.index : 0;
      let route = current.routes[index];
      let parts;
      let focusedParams;
      let currentOptions = configs;
      const focusedRoute = getActiveRoute(state);

      // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
      const nestedRouteNames = [];
      let hasNext = true;
      while (route.name in currentOptions && hasNext) {
        parts = currentOptions[route.name].parts;
        nestedRouteNames.push(route.name);
        if (route.params) {
          const options = currentOptions[route.name];
          const currentParams = Object.fromEntries(Object.entries(route.params).map(([key, value]) => {
            if (value === undefined) {
              if (options) {
                const optional = options.parts?.find(part => part.param === key)?.optional;
                if (optional) {
                  return null;
                }
              } else {
                return null;
              }
            }
            const stringify = options?.stringify?.[key] ?? String;
            return [key, stringify(value)];
          }).filter(entry => entry != null));
          if (parts?.length) {
            Object.assign(allParams, currentParams);
          }
          if (focusedRoute === route) {
            // If this is the focused route, keep the params for later use
            // We save it here since it's been stringified already
            focusedParams = Object.assign({}, currentParams);
            parts
            // eslint-disable-next-line no-loop-func
            ?.forEach(({
              param
            }) => {
              if (param) {
                // Remove the params present in the pattern since we'll only use the rest for query string
                if (focusedParams) {
                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                  delete focusedParams[param];
                }
              }
            });
          }
        }

        // If there is no `screens` property or no nested state, we return pattern
        if (!currentOptions[route.name].screens || route.state === undefined) {
          hasNext = false;
        } else {
          index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
          const nextRoute = route.state.routes[index];
          const nestedConfig = currentOptions[route.name].screens;

          // if there is config for next route name, we go deeper
          if (nestedConfig && nextRoute.name in nestedConfig) {
            route = nextRoute;
            currentOptions = nestedConfig;
          } else {
            // If not, there is no sense in going deeper in config
            hasNext = false;
          }
        }
      }
      if (currentOptions[route.name] !== undefined) {
        path += parts?.map(({
          segment,
          param,
          optional
        }) => {
          // We don't know what to show for wildcard patterns
          // Showing the route name seems ok, though whatever we show here will be incorrect
          // Since the page doesn't actually exist
          if (segment === '*') {
            return route.name;
          }

          // If the path has a pattern for a param, put the param in the path
          if (param) {
            const value = allParams[param];
            if (value === undefined && optional) {
              // Optional params without value assigned in route.params should be ignored
              return '';
            }

            // Valid characters according to
            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
            return String(value).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));
          }
          return encodeURIComponent(segment);
        }).join('/');
      } else {
        path += encodeURIComponent(route.name);
      }
      if (!focusedParams && focusedRoute.params) {
        focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(([key, value]) => [key, String(value)]));
      }
      if (route.state) {
        path += '/';
      } else if (focusedParams) {
        for (const param in focusedParams) {
          if (focusedParams[param] === 'undefined') {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete focusedParams[param];
          }
        }
        const query = queryString.stringify(focusedParams, {
          sort: false
        });
        if (query) {
          path += `?${query}`;
        }
      }
      current = route.state;
    }

    // Include the root path if specified
    if (options?.path) {
      path = `${options.path}/${path}`;
    }

    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;

    // If path doesn't start with a slash, add it
    // This makes sure that history.pushState will update the path correctly instead of appending
    if (!path.startsWith('/')) {
      path = `/${path}`;
    }
    return path;
  }
  const createConfigItem = (config, parentParts) => {
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const parts = (0, _getPatternParts.getPatternParts)(config);
      if (parentParts) {
        return {
          parts: [...parentParts, ...parts]
        };
      }
      return {
        parts
      };
    }
    if (config.exact && config.path === undefined) {
      throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }

    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    const parts = config.exact !== true ? [...(parentParts || []), ...(config.path ? (0, _getPatternParts.getPatternParts)(config.path) : [])] : config.path ? (0, _getPatternParts.getPatternParts)(config.path) : undefined;
    const screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;
    return {
      parts,
      stringify: config.stringify,
      screens
    };
  };
  const createNormalizedConfigs = (options, parts) => Object.fromEntries(Object.entries(options).map(([name, c]) => {
    const result = createConfigItem(c, parts);
    return [name, result];
  }));
},393,[394,399,400],"node_modules\\@react-navigation\\core\\lib\\module\\getPathFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  const strictUriEncode = require(_dependencyMap[0], "strict-uri-encode");
  const decodeComponent = require(_dependencyMap[1], "decode-uri-component");
  const splitOnFirst = require(_dependencyMap[2], "split-on-first");
  const filterObject = require(_dependencyMap[3], "filter-obj");
  const isNullOrUndefined = value => value === null || value === undefined;
  const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return key => (result, value) => {
          const index = result.length;
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), '[', index, ']'].join('')];
          }
          return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];
        };
      case 'bracket':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), '[]'].join('')];
          }
          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
        };
      case 'colon-list-separator':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), ':list='].join('')];
          }
          return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
        };
      case 'comma':
      case 'separator':
      case 'bracket-separator':
        {
          const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
          return key => (result, value) => {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            // Translate null to an empty string so that it doesn't serialize as 'null'
            value = value === null ? '' : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
      default:
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, encode(key, options)];
          }
          return [...result, [encode(key, options), '=', encode(value, options)].join('')];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case 'index':
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case 'bracket':
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case 'colon-list-separator':
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case 'comma':
      case 'separator':
        return (key, value, accumulator) => {
          const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };
      case 'bracket-separator':
        return (key, value, accumulator) => {
          const isArray = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, '');
          if (!isArray) {
            accumulator[key] = value ? decode(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));
          if (accumulator[key] === undefined) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === 'object') {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf('#');
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
    return hash;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');
    if (queryStart === -1) {
      return '';
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }
    return value;
  }
  function parse(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);

    // Create an object with no prototype
    const ret = Object.create(null);
    if (typeof query !== 'string') {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
      return ret;
    }
    for (const param of query.split('&')) {
      if (param === '') {
        continue;
      }
      let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

      // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === 'object' && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        // Sort object keys, not values
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse;
  exports.stringify = (object, options) => {
    if (!object) {
      return '';
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map(key => {
      const value = object[key];
      if (value === undefined) {
        return '';
      }
      if (value === null) {
        return encode(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
          return encode(key, options) + '[]';
        }
        return value.reduce(formatter(key), []).join('&');
      }
      return encode(key, options) + '=' + encode(value, options);
    }).filter(x => x.length > 0).join('&');
  };
  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash] = splitOnFirst(url, '#');
    return Object.assign({
      url: url_.split('?')[0] || '',
      query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
      fragmentIdentifier: decode(hash, options)
    } : {});
  };
  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, {
      sort: false
    });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString = exports.stringify(query, options);
    if (queryString) {
      queryString = `?${queryString}`;
    }
    let hash = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
  };
  exports.pick = (input, filter, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const {
      url,
      query,
      fragmentIdentifier
    } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options);
  };
  exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
},394,[395,396,397,398],"node_modules\\query-string\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
},395,[],"node_modules\\strict-uri-encode\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');
  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return [decodeURIComponent(components.join(''))];
    } catch (err) {
      // Do nothing
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;

    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': '\uFFFD\uFFFD',
      '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }

    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
  }
  module.exports = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, ' ');

      // Try the built in decoder first
      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };
},396,[],"node_modules\\decode-uri-component\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = (string, separator) => {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
      return [string];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [string];
    }
    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };
},397,[],"node_modules\\split-on-first\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];
      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }
    return ret;
  };
},398,[],"node_modules\\filter-obj\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Parse a path into an array of parts with information about each segment.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPatternParts = getPatternParts;
  function getPatternParts(path) {
    const parts = [];
    let current = {
      segment: ''
    };
    let isRegex = false;
    let isParam = false;
    let regexInnerParens = 0;

    // One extra iteration to add the last character
    for (let i = 0; i <= path.length; i++) {
      const char = path[i];
      if (char != null) {
        current.segment += char;
      }
      if (char === ':') {
        // The segment must start with a colon if it's a param
        if (current.segment === ':') {
          isParam = true;
        } else if (!isRegex) {
          throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);
        }
      } else if (char === '(') {
        if (isParam) {
          if (isRegex) {
            // The '(' is part of the regex if we're already inside one
            regexInnerParens++;
          } else {
            isRegex = true;
          }
        } else {
          throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);
        }
      } else if (char === ')') {
        if (isParam && isRegex) {
          if (regexInnerParens) {
            // The ')' is part of the regex if we're already inside one
            regexInnerParens--;
            current.regex += char;
          } else {
            isRegex = false;
            isParam = false;
          }
        } else {
          throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);
        }
      } else if (char === '?') {
        if (current.param) {
          isParam = false;
          current.optional = true;
        } else {
          throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);
        }
      } else if (char == null || char === '/' && !isRegex) {
        isParam = false;

        // Remove trailing slash from segment
        current.segment = current.segment.replace(/\/$/, '');
        if (current.segment === '') {
          continue;
        }
        if (current.param) {
          current.param = current.param.replace(/^:/, '');
        }
        if (current.regex) {
          current.regex = current.regex.replace(/^\(/, '').replace(/\)$/, '');
        }
        parts.push(current);
        if (char == null) {
          break;
        }
        current = {
          segment: ''
        };
      }
      if (isRegex) {
        current.regex = current.regex || '';
        current.regex += char;
      }
      if (isParam && !isRegex) {
        current.param = current.param || '';
        current.param += char;
      }
    }
    if (isRegex) {
      throw new Error(`Could not find closing ')' in path: ${path}`);
    }
    const params = parts.map(part => part.param).filter(Boolean);
    for (const [index, param] of params.entries()) {
      if (params.indexOf(param) !== index) {
        throw new Error(`Duplicate param name '${param}' found in path: ${path}`);
      }
    }
    return parts;
  }
},399,[],"node_modules\\@react-navigation\\core\\lib\\module\\getPatternParts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validatePathConfig = validatePathConfig;
  const formatToList = items => Object.entries(items).map(([key, value]) => `- ${key} (${value})`).join('\n');
  function validatePathConfig(config, root = true) {
    const validation = Object.assign({
      path: 'string',
      initialRouteName: 'string',
      screens: 'object'
    }, root ? null : {
      alias: 'array',
      exact: 'boolean',
      stringify: 'object',
      parse: 'object'
    });
    if (typeof config !== 'object' || config === null) {
      throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);
    }
    const validationErrors = Object.fromEntries(Object.keys(config).map(key => {
      if (key in validation) {
        const type = validation[key];
        // @ts-expect-error: we know the key exists
        const value = config[key];
        if (value !== undefined) {
          if (type === 'array') {
            if (!Array.isArray(value)) {
              return [key, `expected 'Array', got '${typeof value}'`];
            }
          } else if (typeof value !== type) {
            return [key, `expected '${type}', got '${typeof value}'`];
          }
        }
      } else {
        return [key, 'extraneous'];
      }
      return null;
    }).filter(Boolean));
    if (Object.keys(validationErrors).length) {
      throw new Error(`Found invalid properties in the configuration:\n${formatToList(validationErrors)}\n\nYou can only specify the following properties:\n${formatToList(validation)}\n\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
    }
    if (root && 'path' in config && typeof config.path === 'string' && config.path.includes(':')) {
      throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);
    }
    if ('screens' in config && config.screens) {
      Object.entries(config.screens).forEach(([_, value]) => {
        if (typeof value !== 'string') {
          validatePathConfig(value, false);
        }
      });
    }
  }
},400,[],"node_modules\\@react-navigation\\core\\lib\\module\\validatePathConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getStateFromPath = getStateFromPath;
  var _escapeStringRegexp = _interopRequireDefault(require(_dependencyMap[1], "escape-string-regexp"));
  var queryString = _interopRequireWildcard(require(_dependencyMap[2], "query-string"));
  var _arrayStartsWith = require(_dependencyMap[3], "./arrayStartsWith.js");
  var _findFocusedRoute = require(_dependencyMap[4], "./findFocusedRoute.js");
  var _getPatternParts = require(_dependencyMap[5], "./getPatternParts.js");
  var _isArrayEqual = require(_dependencyMap[6], "./isArrayEqual.js");
  var _validatePathConfig = require(_dependencyMap[7], "./validatePathConfig.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Utility to parse a path string to initial state object accepted by the container.
   * This is useful for deep linking when we need to handle the incoming URL.
   *
   * @example
   * ```js
   * getStateFromPath(
   *   '/chat/jane/42',
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         parse: { id: Number }
   *       }
   *     }
   *   }
   * )
   * ```
   * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
   * @param options Extra options to fine-tune how to parse the path.
   */
  function getStateFromPath(path, options) {
    const {
      initialRoutes,
      configs
    } = getConfigResources(options);
    const screens = options?.screens;
    let remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later

    // Make sure there is a trailing slash
    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    const prefix = options?.path?.replace(/^\//, ''); // Remove extra leading slash

    if (prefix) {
      // Make sure there is a trailing slash
      const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;

      // If the path doesn't start with the prefix, it's not a match
      if (!remaining.startsWith(normalizedPrefix)) {
        return undefined;
      }

      // Remove the prefix from the path
      remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
      // When no config is specified, use the path segments as route names
      const routes = remaining.split('/').filter(Boolean).map(segment => {
        const name = decodeURIComponent(segment);
        return {
          name
        };
      });
      if (routes.length) {
        return createNestedStateObject(path, routes, initialRoutes);
      }
      return undefined;
    }
    if (remaining === '/') {
      // We need to add special handling of empty path so navigation to empty path also works
      // When handling empty path, we should only look at the root level config
      const match = configs.find(config => config.segments.join('/') === '');
      if (match) {
        return createNestedStateObject(path, match.routeNames.map(name => ({
          name
        })), initialRoutes, configs);
      }
      return undefined;
    }
    let result;
    let current;

    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    const {
      routes,
      remainingPath
    } = matchAgainstConfigs(remaining, configs);
    if (routes !== undefined) {
      // This will always be empty if full path matched
      current = createNestedStateObject(path, routes, initialRoutes, configs);
      remaining = remainingPath;
      result = current;
    }
    if (current == null || result == null) {
      return undefined;
    }
    return result;
  }

  /**
   * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
   */
  const cachedConfigResources = new WeakMap();
  function getConfigResources(options) {
    if (!options) return prepareConfigResources();
    const cached = cachedConfigResources.get(options);
    if (cached) return cached;
    const resources = prepareConfigResources(options);
    cachedConfigResources.set(options, resources);
    return resources;
  }
  function prepareConfigResources(options) {
    if (options) {
      (0, _validatePathConfig.validatePathConfig)(options);
    }
    const initialRoutes = getInitialRoutes(options);
    const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);
    checkForDuplicatedConfigs(configs);
    const configWithRegexes = getConfigsWithRegexes(configs);
    return {
      initialRoutes,
      configs,
      configWithRegexes
    };
  }
  function getInitialRoutes(options) {
    const initialRoutes = [];
    if (options?.initialRouteName) {
      initialRoutes.push({
        initialRouteName: options.initialRouteName,
        parentScreens: []
      });
    }
    return initialRoutes;
  }
  function getSortedNormalizedConfigs(initialRoutes, screens = {}) {
    // Create a normalized configs array which will be easier to use
    return [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, initialRoutes, [], [], []))).sort((a, b) => {
      // Sort config from most specific to least specific:
      // - more segments
      // - static segments
      // - params with regex
      // - regular params
      // - wildcard

      // If 2 patterns are same, move the one with less route names up
      // This is an error state, so it's only useful for consistent error messages
      if ((0, _isArrayEqual.isArrayEqual)(a.segments, b.segments)) {
        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
      }

      // If one of the patterns starts with the other, it's more exhaustive
      // So move it up
      if ((0, _arrayStartsWith.arrayStartsWith)(a.segments, b.segments)) {
        return -1;
      }
      if ((0, _arrayStartsWith.arrayStartsWith)(b.segments, a.segments)) {
        return 1;
      }
      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {
        // if b is longer, b gets higher priority
        if (a.segments[i] == null) {
          return 1;
        }

        // if a is longer, a gets higher priority
        if (b.segments[i] == null) {
          return -1;
        }
        const aWildCard = a.segments[i] === '*';
        const bWildCard = b.segments[i] === '*';
        const aParam = a.segments[i].startsWith(':');
        const bParam = b.segments[i].startsWith(':');
        const aRegex = aParam && a.segments[i].includes('(');
        const bRegex = bParam && b.segments[i].includes('(');

        // if both are wildcard or regex, we compare next component
        if (aWildCard && bWildCard || aRegex && bRegex) {
          continue;
        }

        // if only a is wildcard, b gets higher priority
        if (aWildCard && !bWildCard) {
          return 1;
        }

        // if only b is wildcard, a gets higher priority
        if (bWildCard && !aWildCard) {
          return -1;
        }

        // If only a has a param, b gets higher priority
        if (aParam && !bParam) {
          return 1;
        }

        // If only b has a param, a gets higher priority
        if (bParam && !aParam) {
          return -1;
        }

        // if only a has regex, a gets higher priority
        if (aRegex && !bRegex) {
          return -1;
        }

        // if only b has regex, b gets higher priority
        if (bRegex && !aRegex) {
          return 1;
        }
      }
      return a.segments.length - b.segments.length;
    });
  }
  function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config) => {
      const pattern = config.segments.join('/');
      if (acc[pattern]) {
        const a = acc[pattern].routeNames;
        const b = config.routeNames;

        // It's not a problem if the path string omitted from a inner most screen
        // For example, it's ok if a path resolves to `A > B > C` or `A > B`
        const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);
        if (!intersects) {
          throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
        }
      }
      return Object.assign(acc, {
        [pattern]: config
      });
    }, {});
  }
  function getConfigsWithRegexes(configs) {
    return configs.map(c => Object.assign({}, c, {
      // Add `$` to the regex to make sure it matches till end of the path and not just beginning
      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
    }));
  }
  const matchAgainstConfigs = (remaining, configs) => {
    let routes;
    let remainingPath = remaining;

    // Go through all configs, and see if the next path segment matches our regex
    for (const config of configs) {
      if (!config.regex) {
        continue;
      }
      const match = remainingPath.match(config.regex);

      // If our regex matches, we need to extract params from the path
      if (match) {
        routes = config.routeNames.map(routeName => {
          const routeConfig = configs.find(c => {
            // Check matching name AND pattern in case same screen is used at different levels in config
            return c.screen === routeName && (0, _arrayStartsWith.arrayStartsWith)(config.segments, c.segments);
          });
          const params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map(([key, value]) => {
            const index = Number(key.replace('param_', ''));
            const param = routeConfig.params.find(it => it.index === index);
            if (param?.screen === routeName && param?.name) {
              return [param.name, value];
            }
            return null;
          }).filter(it => it != null).map(([key, value]) => {
            if (value == null) {
              return [key, undefined];
            }
            const decoded = decodeURIComponent(value);
            const parsed = routeConfig.parse?.[key] ? routeConfig.parse[key](decoded) : decoded;
            return [key, parsed];
          })) : undefined;
          if (params && Object.keys(params).length) {
            return {
              name: routeName,
              params
            };
          }
          return {
            name: routeName
          };
        });
        remainingPath = remainingPath.replace(match[0], '');
        break;
      }
    }
    return {
      routes,
      remainingPath
    };
  };
  const createNormalizedConfigs = (screen, routeConfig, initials, paths, parentScreens, routeNames) => {
    const configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    const config = routeConfig[screen];
    if (typeof config === 'string') {
      paths.push({
        screen,
        path: config
      });
      configs.push(createConfigItem(screen, [...routeNames], [...paths]));
    } else if (typeof config === 'object') {
      // if an object is specified as the value (e.g. Foo: { ... }),
      // it can have `path` property and
      // it could have `screens` prop which has nested configs
      if (typeof config.path === 'string') {
        if (config.exact && config.path == null) {
          throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \`path: ''\`.`);
        }

        // We should add alias configs after the main config
        // So unless they are more specific, main config will be matched first
        const aliasConfigs = [];
        if (config.alias) {
          for (const alias of config.alias) {
            if (typeof alias === 'string') {
              aliasConfigs.push(createConfigItem(screen, [...routeNames], [...paths, {
                screen,
                path: alias
              }], config.parse));
            } else if (typeof alias === 'object') {
              aliasConfigs.push(createConfigItem(screen, [...routeNames], alias.exact ? [{
                screen,
                path: alias.path
              }] : [...paths, {
                screen,
                path: alias.path
              }], alias.parse));
            }
          }
        }
        if (config.exact) {
          // If it's an exact path, we don't need to keep track of the parent screens
          // So we can clear it
          paths.length = 0;
        }
        paths.push({
          screen,
          path: config.path
        });
        configs.push(createConfigItem(screen, [...routeNames], [...paths], config.parse));
        configs.push(...aliasConfigs);
      }
      if (typeof config !== 'string' && typeof config.path !== 'string' && config.alias?.length) {
        throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);
      }
      if (config.screens) {
        // property `initialRouteName` without `screens` has no purpose
        if (config.initialRouteName) {
          initials.push({
            initialRouteName: config.initialRouteName,
            parentScreens
          });
        }
        Object.keys(config.screens).forEach(nestedConfig => {
          const result = createNormalizedConfigs(nestedConfig, config.screens, initials, [...paths], [...parentScreens], routeNames);
          configs.push(...result);
        });
      }
    }
    routeNames.pop();
    return configs;
  };
  const createConfigItem = (screen, routeNames, paths, parse) => {
    const parts = [];

    // Parse the path string into parts for easier matching
    for (const {
      screen,
      path
    } of paths) {
      parts.push(...(0, _getPatternParts.getPatternParts)(path).map(part => Object.assign({}, part, {
        screen
      })));
    }
    const regex = parts.length ? new RegExp(`^(${parts.map((it, i) => {
      if (it.param) {
        const reg = it.regex || '[^/]+';
        return `(((?<param_${i}>${reg})\\/)${it.optional ? '?' : ''})`;
      }
      return `${it.segment === '*' ? '.*' : (0, _escapeStringRegexp.default)(it.segment)}\\/`;
    }).join('')})$`) : undefined;
    const segments = parts.map(it => it.segment);
    const params = parts.map((it, i) => it.param ? {
      index: i,
      screen: it.screen,
      name: it.param
    } : null).filter(it => it != null);
    return {
      screen,
      regex,
      segments,
      params,
      routeNames,
      parse
    };
  };
  const findParseConfigForRoute = (routeName, flatConfig) => {
    for (const config of flatConfig) {
      if (routeName === config.routeNames[config.routeNames.length - 1]) {
        return config.parse;
      }
    }
    return undefined;
  };

  // Try to find an initial route connected with the one passed
  const findInitialRoute = (routeName, parentScreens, initialRoutes) => {
    for (const config of initialRoutes) {
      if (parentScreens.length === config.parentScreens.length) {
        let sameParents = true;
        for (let i = 0; i < parentScreens.length; i++) {
          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
            sameParents = false;
            break;
          }
        }
        if (sameParents) {
          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
        }
      }
    }
    return undefined;
  };

  // returns state object with values depending on whether
  // it is the end of state and if there is initialRoute for this level
  const createStateObject = (initialRoute, route, isEmpty) => {
    if (isEmpty) {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, route]
        };
      } else {
        return {
          routes: [route]
        };
      }
    } else {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      } else {
        return {
          routes: [Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      }
    }
  };
  const createNestedStateObject = (path, routes, initialRoutes, flatConfig) => {
    let route = routes.shift();
    const parentScreens = [];
    let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    const state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
      let nestedState = state;
      while (route = routes.shift()) {
        initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
        const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
        nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
        if (routes.length > 0) {
          nestedState = nestedState.routes[nestedStateIndex].state;
        }
        parentScreens.push(route.name);
      }
    }
    route = (0, _findFocusedRoute.findFocusedRoute)(state);
    route.path = path.replace(/\/$/, '');
    const params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
    if (params) {
      route.params = Object.assign({}, route.params, params);
    }
    return state;
  };
  const parseQueryParams = (path, parseConfig) => {
    const query = path.split('?')[1];
    const params = queryString.parse(query);
    if (parseConfig) {
      Object.keys(params).forEach(name => {
        if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
          params[name] = parseConfig[name](params[name]);
        }
      });
    }
    return Object.keys(params).length ? params : undefined;
  };
},401,[17,402,394,403,370,399,404,400],"node_modules\\@react-navigation\\core\\lib\\module\\getStateFromPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = string => {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string');
    }

    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
  };
},402,[],"node_modules\\escape-string-regexp\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two arrays to check if the first array starts with the second array.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.arrayStartsWith = arrayStartsWith;
  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }
    return start.every((it, index) => it === array[index]);
  }
},403,[],"node_modules\\@react-navigation\\core\\lib\\module\\arrayStartsWith.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two arrays with primitive values as the content.
   * We need to make sure that both values and order match.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isArrayEqual = isArrayEqual;
  function isArrayEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every((it, index) => it === b[index]);
  }
},404,[],"node_modules\\@react-navigation\\core\\lib\\module\\isArrayEqual.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the navigation prop for a screen.
   */
  const NavigationContext = exports.NavigationContext = /*#__PURE__*/React.createContext(undefined);
},405,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationHelpersContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the navigation helpers of the parent navigator.
   * Navigators should use this context in their view component.
   */
  const NavigationHelpersContext = exports.NavigationHelpersContext = /*#__PURE__*/React.createContext(undefined);
},406,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationHelpersContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationIndependentTree = NavigationIndependentTree;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationContext = require(_dependencyMap[1], "./NavigationContext.js");
  var _NavigationIndependentTreeContext = require(_dependencyMap[2], "./NavigationIndependentTreeContext.js");
  var _NavigationRouteContext = require(_dependencyMap[3], "./NavigationRouteContext.js");
  var _jsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Component to make the child navigation container independent of parent containers.
   */

  function NavigationIndependentTree({
    children
  }) {
    return (/*#__PURE__*/
      // We need to clear any existing contexts for nested independent container to work correctly
      (0, _jsxRuntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
        value: undefined,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationContext.NavigationContext.Provider, {
          value: undefined,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
            value: true,
            children: children
          })
        })
      })
    );
  }
},407,[3,405,373,408,6],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationIndependentTree.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationRouteContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context which holds the route prop for a screen.
   */
  const NavigationRouteContext = exports.NavigationRouteContext = /*#__PURE__*/React.createContext(undefined);
},408,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationRouteContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PreventRemoveContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * A type of an object that have a route key as an object key
   * and a value whether to prevent that route.
   */

  const PreventRemoveContext = exports.PreventRemoveContext = /*#__PURE__*/React.createContext(undefined);
},409,[3],"node_modules\\@react-navigation\\core\\lib\\module\\PreventRemoveContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PreventRemoveProvider = PreventRemoveProvider;
  var _nonSecure = require(_dependencyMap[1], "nanoid/non-secure");
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[3], "use-latest-callback"));
  var _NavigationHelpersContext = require(_dependencyMap[4], "./NavigationHelpersContext.js");
  var _NavigationRouteContext = require(_dependencyMap[5], "./NavigationRouteContext.js");
  var _PreventRemoveContext = require(_dependencyMap[6], "./PreventRemoveContext.js");
  var _jsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Util function to transform map of prevented routes to a simpler object.
   */
  const transformPreventedRoutes = preventedRoutesMap => {
    const preventedRoutesToTransform = [...preventedRoutesMap.values()];
    const preventedRoutes = preventedRoutesToTransform.reduce((acc, {
      routeKey,
      preventRemove
    }) => {
      acc[routeKey] = {
        preventRemove: acc[routeKey]?.preventRemove || preventRemove
      };
      return acc;
    }, {});
    return preventedRoutes;
  };

  /**
   * Component used for managing which routes have to be prevented from removal in native-stack.
   */
  function PreventRemoveProvider({
    children
  }) {
    const [parentId] = React.useState(() => (0, _nonSecure.nanoid)());
    const [preventedRoutesMap, setPreventedRoutesMap] = React.useState(() => new Map());
    const navigation = React.useContext(_NavigationHelpersContext.NavigationHelpersContext);
    const route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    const preventRemoveContextValue = React.useContext(_PreventRemoveContext.PreventRemoveContext);
    // take `setPreventRemove` from parent context - if exist it means we're in a nested context
    const setParentPrevented = preventRemoveContextValue?.setPreventRemove;
    const setPreventRemove = (0, _useLatestCallback.default)((id, routeKey, preventRemove) => {
      if (preventRemove && (navigation == null || navigation?.getState().routes.every(route => route.key !== routeKey))) {
        throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
      }
      setPreventedRoutesMap(prevPrevented => {
        // values haven't changed - do nothing
        if (routeKey === prevPrevented.get(id)?.routeKey && preventRemove === prevPrevented.get(id)?.preventRemove) {
          return prevPrevented;
        }
        const nextPrevented = new Map(prevPrevented);
        if (preventRemove) {
          nextPrevented.set(id, {
            routeKey,
            preventRemove
          });
        } else {
          nextPrevented.delete(id);
        }
        return nextPrevented;
      });
    });
    const isPrevented = [...preventedRoutesMap.values()].some(({
      preventRemove
    }) => preventRemove);
    React.useEffect(() => {
      if (route?.key !== undefined && setParentPrevented !== undefined) {
        // when route is defined (and setParentPrevented) it means we're in a nested stack
        // route.key then will be the route key of parent
        setParentPrevented(parentId, route.key, isPrevented);
        return () => {
          setParentPrevented(parentId, route.key, false);
        };
      }
      return;
    }, [parentId, isPrevented, route?.key, setParentPrevented]);
    const value = React.useMemo(() => ({
      setPreventRemove,
      preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
    }), [setPreventRemove, preventedRoutesMap]);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_PreventRemoveContext.PreventRemoveContext.Provider, {
      value: value,
      children: children
    });
  }
},410,[17,900,3,362,406,408,409,6],"node_modules\\@react-navigation\\core\\lib\\module\\PreventRemoveProvider.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createComponentForStaticNavigation = createComponentForStaticNavigation;
  exports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _reactIs = require(_dependencyMap[4], "react-is");
  var _useRoute = require(_dependencyMap[5], "./useRoute.js");
  var _jsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  const _excluded = ["screen", "if"],
    _excluded2 = ["screens", "groups"],
    _excluded3 = ["if"];
  /**
   * Flatten a type to remove all type alias names, unions etc.
   * This will show a plain object when hovering over the type.
   */
  /**
   * keyof T doesn't work for union types. We can use distributive conditional types instead.
   * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
   */
  /**
   * We get a union type when using keyof, but we want an intersection instead.
   * https://stackoverflow.com/a/50375286/1665026
   */
  /**
   * Props for a screen component which is rendered by a static navigator.
   * Takes the route params as a generic argument.
   */
  /**
   * Infer the param list from the static navigation config.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MemoizedScreen = /*#__PURE__*/React.memo(({
    component
  }) => {
    const route = (0, _useRoute.useRoute)();
    const children = /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(component, {
      route
    });
    return children;
  });
  MemoizedScreen.displayName = 'Memo(Screen)';
  const getItemsFromScreens = (Screen, screens) => {
    return Object.entries(screens).map(([name, item]) => {
      let component;
      let props = {};
      let useIf;
      let isNavigator = false;
      if ('screen' in item) {
        const {
            screen,
            if: _if
          } = item,
          rest = (0, _objectWithoutPropertiesLoose2.default)(item, _excluded);
        useIf = _if;
        props = rest;
        if ((0, _reactIs.isValidElementType)(screen)) {
          component = screen;
        } else if ('config' in screen) {
          isNavigator = true;
          component = createComponentForStaticNavigation(screen, `${name}Navigator`);
        }
      } else if ((0, _reactIs.isValidElementType)(item)) {
        component = item;
      } else if ('config' in item) {
        isNavigator = true;
        component = createComponentForStaticNavigation(item, `${name}Navigator`);
      }
      if (component == null) {
        throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
      }
      const element = isNavigator ? (/*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(component, {})) : /*#__PURE__*/(0, _jsxRuntime.jsx)(MemoizedScreen, {
        component: component
      });
      return () => {
        const shouldRender = useIf == null || useIf();
        if (!shouldRender) {
          return null;
        }
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(Screen, Object.assign({
          name: name
        }, props, {
          children: () => element
        }), name);
      };
    });
  };

  /**
   * Create a component that renders a navigator based on the static configuration.
   *
   * @param tree Static navigation config.
   * @param displayName Name of the component to be displayed in React DevTools.
   * @returns A component which renders the navigator.
   */
  function createComponentForStaticNavigation(tree, displayName) {
    const {
      Navigator,
      Group,
      Screen,
      config
    } = tree;
    const {
        screens,
        groups
      } = config,
      rest = (0, _objectWithoutPropertiesLoose2.default)(config, _excluded2);
    if (screens == null && groups == null) {
      throw new Error("Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.");
    }
    const items = [];

    // Loop through the config to find screens and groups
    // So we add the screens and groups in the same order as they are defined
    for (const key in config) {
      if (key === 'screens' && screens) {
        items.push(...getItemsFromScreens(Screen, screens));
      }
      if (key === 'groups' && groups) {
        items.push(...Object.entries(groups).map(([key, _ref]) => {
          let {
              if: useIf
            } = _ref,
            group = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded3);
          const groupItems = getItemsFromScreens(Screen, group.screens);
          return () => {
            // Call unconditionally since screen configs may contain `useIf` hooks
            const children = groupItems.map(item => item());
            const shouldRender = useIf == null || useIf();
            if (!shouldRender) {
              return null;
            }
            return /*#__PURE__*/(0, _jsxRuntime.jsx)(Group, Object.assign({
              navigationKey: key
            }, group, {
              children: children
            }), key);
          };
        }));
      }
    }
    const NavigatorComponent = () => {
      const children = items.map(item => item());
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(Navigator, Object.assign({}, rest, {
        children: children
      }));
    };
    NavigatorComponent.displayName = displayName;
    return NavigatorComponent;
  }
  /**
   * Create a path config object from a static navigation config for deep linking.
   *
   * @param tree Static navigation config.
   * @param options Additional options from `linking.config`.
   * @param auto Whether to automatically generate paths for leaf screens.
   * @returns Path config object to use in linking config.
   *
   * @example
   * ```js
   * const config = {
   *   screens: {
   *     Home: {
   *       screens: createPathConfigForStaticNavigation(HomeTabs),
   *     },
   *   },
   * };
   * ```
   */
  function createPathConfigForStaticNavigation(tree, options, auto) {
    let initialScreenConfig;
    const createPathConfigForTree = (t, o, skipInitialDetection) => {
      const createPathConfigForScreens = (screens, initialRouteName) => {
        return Object.fromEntries(Object.entries(screens)
        // Re-order to move the initial route to the front
        // This way we can detect the initial route correctly
        .sort(([a], [b]) => {
          if (a === initialRouteName) {
            return -1;
          }
          if (b === initialRouteName) {
            return 1;
          }
          return 0;
        }).map(([key, item]) => {
          const screenConfig = {};
          if ('linking' in item) {
            if (typeof item.linking === 'string') {
              screenConfig.path = item.linking;
            } else {
              Object.assign(screenConfig, item.linking);
            }
            if (typeof screenConfig.path === 'string') {
              screenConfig.path = screenConfig.path.replace(/^\//, '') // Remove extra leading slash
              .replace(/\/$/, ''); // Remove extra trailing slash
            }
          }
          let screens;
          const skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';
          if ('config' in item) {
            screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);
          } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {
            screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);
          }
          if (screens) {
            screenConfig.screens = screens;
          }
          if (auto && !screenConfig.screens &&
          // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly
          !('linking' in item && item.linking == null)) {
            if (screenConfig.path != null) {
              if (!skipInitialDetection && screenConfig.path === '') {
                // We encounter a leaf screen with empty path,
                // Clear the initial screen config as it's not needed anymore
                initialScreenConfig = undefined;
              }
            } else {
              if (!skipInitialDetection && initialScreenConfig == null) {
                initialScreenConfig = screenConfig;
              }
              screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();
            }
          }
          return [key, screenConfig];
        }).filter(([, screen]) => Object.keys(screen).length > 0));
      };
      const screens = {};

      // Loop through the config to find screens and groups
      // So we add the screens and groups in the same order as they are defined
      for (const key in t.config) {
        if (key === 'screens' && t.config.screens) {
          Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));
        }
        if (key === 'groups' && t.config.groups) {
          Object.entries(t.config.groups).forEach(([, group]) => {
            Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));
          });
        }
      }
      if (Object.keys(screens).length === 0) {
        return undefined;
      }
      return screens;
    };
    const screens = createPathConfigForTree(tree, options, false);
    if (auto && initialScreenConfig) {
      initialScreenConfig.path = '';
    }
    return screens;
  }
},411,[17,29,412,3,415,417,6],"node_modules\\@react-navigation\\core\\lib\\module\\StaticNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.vars = exports.useUnstableNativeVariable = exports.useSafeAreaEnv = exports.useColorScheme = exports.remapProps = exports.rem = exports.cssInterop = exports.createInteropElement = exports.colorScheme = exports.StyleSheet = exports.wrapJSX = exports.createElement = void 0;
  var react_1 = require(_dependencyMap[0], "react");
  Object.defineProperty(exports, "createElement", {
    enumerable: true,
    get: function () {
      return react_1.createElement;
    }
  });
  var wrap_jsx_1 = require(_dependencyMap[1], "./runtime/wrap-jsx");
  Object.defineProperty(exports, "wrapJSX", {
    enumerable: true,
    get: function () {
      return __importDefault(wrap_jsx_1).default;
    }
  });
  __exportStar(require(_dependencyMap[2], "./doctor"), exports);
  var runtime_1 = require(_dependencyMap[3], "./runtime");
  Object.defineProperty(exports, "StyleSheet", {
    enumerable: true,
    get: function () {
      return runtime_1.StyleSheet;
    }
  });
  Object.defineProperty(exports, "colorScheme", {
    enumerable: true,
    get: function () {
      return runtime_1.colorScheme;
    }
  });
  Object.defineProperty(exports, "createInteropElement", {
    enumerable: true,
    get: function () {
      return runtime_1.createInteropElement;
    }
  });
  Object.defineProperty(exports, "cssInterop", {
    enumerable: true,
    get: function () {
      return runtime_1.cssInterop;
    }
  });
  Object.defineProperty(exports, "rem", {
    enumerable: true,
    get: function () {
      return runtime_1.rem;
    }
  });
  Object.defineProperty(exports, "remapProps", {
    enumerable: true,
    get: function () {
      return runtime_1.remapProps;
    }
  });
  Object.defineProperty(exports, "useColorScheme", {
    enumerable: true,
    get: function () {
      return runtime_1.useColorScheme;
    }
  });
  Object.defineProperty(exports, "useSafeAreaEnv", {
    enumerable: true,
    get: function () {
      return runtime_1.useSafeAreaEnv;
    }
  });
  Object.defineProperty(exports, "useUnstableNativeVariable", {
    enumerable: true,
    get: function () {
      return runtime_1.useUnstableNativeVariable;
    }
  });
  Object.defineProperty(exports, "vars", {
    enumerable: true,
    get: function () {
      return runtime_1.vars;
    }
  });
},412,[3,8,413,414],"node_modules\\react-native-css-interop\\dist\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\react-native-css-interop\\dist\\doctor.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.verifyJSX = verifyJSX;
  exports.verifyFlag = verifyFlag;
  exports.verifyData = verifyData;
  const computedStyles = globalThis.window ? globalThis.window.getComputedStyle(globalThis.window.document.documentElement) : {
    getPropertyValue: () => "asdf"
  };
  function verifyJSX() {
    return _reactNativeCssInteropJsxRuntime.jsx("react-native-css-interop-jsx-pragma-check", {}) === true;
  }
  function verifyFlag(name, value = "true") {
    return globalThis.window ? computedStyles.getPropertyValue(name ? `--css-interop-${name}` : "--css-interop") === value : true;
  }
  function verifyData() {
    return globalThis.window ? computedStyles.getPropertyValue("--css-interop") !== "" : true;
  }
},413,[2],"node_modules\\react-native-css-interop\\dist\\doctor.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createInteropElement = void 0;
  __exportStar(require(_dependencyMap[0], "./web/api"), exports);
  var jsx_runtime_1 = require(_dependencyMap[1], "./jsx-runtime");
  Object.defineProperty(exports, "createInteropElement", {
    enumerable: true,
    get: function () {
      return jsx_runtime_1.createInteropElement;
    }
  });
},414,[10,2],"node_modules\\react-native-css-interop\\dist\\runtime\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-is.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-is.development.js");
  }
},415,[4,416],"node_modules\\react-is\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function typeOf(object) {
      if ("object" === typeof object && null !== object) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object = object.type, object) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object;
              default:
                switch (object = object && object.$$typeof, object) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object;
                  case REACT_CONSUMER_TYPE:
                    return object;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    exports.ContextConsumer = REACT_CONSUMER_TYPE;
    exports.ContextProvider = REACT_CONTEXT_TYPE;
    exports.Element = REACT_ELEMENT_TYPE;
    exports.ForwardRef = REACT_FORWARD_REF_TYPE;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Lazy = REACT_LAZY_TYPE;
    exports.Memo = REACT_MEMO_TYPE;
    exports.Portal = REACT_PORTAL_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    exports.isContextConsumer = function (object) {
      return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    exports.isContextProvider = function (object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    exports.isElement = function (object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    exports.isForwardRef = function (object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    exports.isFragment = function (object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    exports.isLazy = function (object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    };
    exports.isMemo = function (object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    };
    exports.isPortal = function (object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    };
    exports.isProfiler = function (object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    };
    exports.isStrictMode = function (object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    exports.isSuspense = function (object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    exports.isSuspenseList = function (object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    exports.isValidElementType = function (type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
    };
    exports.typeOf = typeOf;
  }();
},416,[],"node_modules\\react-is\\cjs\\react-is.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useRoute = useRoute;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationRouteContext = require(_dependencyMap[1], "./NavigationRouteContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to access the route prop of the parent screen anywhere.
   *
   * @returns Route prop of the parent screen.
   */
  function useRoute() {
    const route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    if (route === undefined) {
      throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }
    return route;
  }
},417,[3,408],"node_modules\\@react-navigation\\core\\lib\\module\\useRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useTheme = useTheme;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _ThemeContext = require(_dependencyMap[1], "./ThemeContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useTheme() {
    const theme = React.useContext(_ThemeContext.ThemeContext);
    if (theme == null) {
      throw new Error("Couldn't find a theme. Is your component inside NavigationContainer or does it have a theme?");
    }
    return theme;
  }
},418,[3,376],"node_modules\\@react-navigation\\core\\lib\\module\\theming\\useTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PrivateValueStore = void 0;
  class PrivateValueStore {}
  exports.PrivateValueStore = PrivateValueStore;
},419,[],"node_modules\\@react-navigation\\core\\lib\\module\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEffect = useFocusEffect;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _useNavigation = require(_dependencyMap[1], "./useNavigation.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to run an effect in a focused screen, similar to `React.useEffect`.
   * This can be used to perform side-effects such as fetching data or subscribing to events.
   * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.
   *
   * @param callback Memoized callback containing the effect, should optionally return a cleanup function.
   */
  function useFocusEffect(effect) {
    const navigation = (0, _useNavigation.useNavigation)();

    // eslint-disable-next-line prefer-rest-params
    if (arguments[1] !== undefined) {
      const message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
      console.error(message);
    }
    React.useEffect(() => {
      let isFocused = false;
      let cleanup;
      const callback = () => {
        const destroy = effect();
        if (destroy === undefined || typeof destroy === 'function') {
          return destroy;
        }
        if (process.env.NODE_ENV !== 'production') {
          let message = 'An effect function must not return anything besides a function, which is used for clean-up.';
          if (destroy === null) {
            message += " You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).";
          } else if (typeof destroy.then === 'function') {
            message += "\n\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. " + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    async function fetchData() {\n' + '      // You can await here\n' + '      const response = await MyAPI.getData(someId);\n' + '      // ...\n' + '    }\n\n' + '    fetchData();\n' + '  }, [someId])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
          } else {
            message += ` You returned '${JSON.stringify(destroy)}'.`;
          }
          console.error(message);
        }
      };

      // We need to run the effect on initial render/dep changes if the screen is focused
      if (navigation.isFocused()) {
        cleanup = callback();
        isFocused = true;
      }
      const unsubscribeFocus = navigation.addListener('focus', () => {
        // If callback was already called for focus, avoid calling it again
        // The focus event may also fire on initial render, so we guard against running the effect twice
        if (isFocused) {
          return;
        }
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = callback();
        isFocused = true;
      });
      const unsubscribeBlur = navigation.addListener('blur', () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = undefined;
        isFocused = false;
      });
      return () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [effect, navigation]);
  }
},420,[3,421],"node_modules\\@react-navigation\\core\\lib\\module\\useFocusEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigation = useNavigation;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationContainerRefContext = require(_dependencyMap[1], "./NavigationContainerRefContext.js");
  var _NavigationContext = require(_dependencyMap[2], "./NavigationContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to access the navigation prop of the parent screen anywhere.
   *
   * @returns Navigation prop of the parent screen.
   */
  function useNavigation() {
    const root = React.useContext(_NavigationContainerRefContext.NavigationContainerRefContext);
    const navigation = React.useContext(_NavigationContext.NavigationContext);
    if (navigation === undefined && root === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }

    // FIXME: Figure out a better way to do this
    return navigation ?? root;
  }
},421,[3,372,405],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useIsFocused = useIsFocused;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _useNavigation = require(_dependencyMap[1], "./useNavigation.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.
   * This can be used if a component needs to render something based on the focus state.
   */
  function useIsFocused() {
    const navigation = (0, _useNavigation.useNavigation)();
    const subscribe = React.useCallback(callback => {
      const unsubscribeFocus = navigation.addListener('focus', callback);
      const unsubscribeBlur = navigation.addListener('blur', callback);
      return () => {
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [navigation]);
    const value = React.useSyncExternalStore(subscribe, navigation.isFocused, navigation.isFocused);
    return value;
  }
},422,[3,421],"node_modules\\@react-navigation\\core\\lib\\module\\useIsFocused.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationBuilder = useNavigationBuilder;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _routers = require(_dependencyMap[2], "@react-navigation/routers");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _reactIs = require(_dependencyMap[4], "react-is");
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[5], "use-latest-callback"));
  var _deepFreeze = require(_dependencyMap[6], "./deepFreeze.js");
  var _Group = require(_dependencyMap[7], "./Group.js");
  var _isArrayEqual = require(_dependencyMap[8], "./isArrayEqual.js");
  var _isRecordEqual = require(_dependencyMap[9], "./isRecordEqual.js");
  var _NavigationHelpersContext = require(_dependencyMap[10], "./NavigationHelpersContext.js");
  var _NavigationRouteContext = require(_dependencyMap[11], "./NavigationRouteContext.js");
  var _NavigationStateContext = require(_dependencyMap[12], "./NavigationStateContext.js");
  var _PreventRemoveProvider = require(_dependencyMap[13], "./PreventRemoveProvider.js");
  var _Screen = require(_dependencyMap[14], "./Screen.js");
  var _types = require(_dependencyMap[15], "./types.js");
  var _useChildListeners = require(_dependencyMap[16], "./useChildListeners.js");
  var _useComponent = require(_dependencyMap[17], "./useComponent.js");
  var _useCurrentRender = require(_dependencyMap[18], "./useCurrentRender.js");
  var _useDescriptors = require(_dependencyMap[19], "./useDescriptors.js");
  var _useEventEmitter = require(_dependencyMap[20], "./useEventEmitter.js");
  var _useFocusedListenersChildrenAdapter = require(_dependencyMap[21], "./useFocusedListenersChildrenAdapter.js");
  var _useFocusEvents = require(_dependencyMap[22], "./useFocusEvents.js");
  var _useIsomorphicLayoutEffect = require(_dependencyMap[23], "./useIsomorphicLayoutEffect");
  var _useKeyedChildListeners = require(_dependencyMap[24], "./useKeyedChildListeners.js");
  var _useLazyValue = require(_dependencyMap[25], "./useLazyValue.js");
  var _useNavigationHelpers = require(_dependencyMap[26], "./useNavigationHelpers.js");
  var _useOnAction = require(_dependencyMap[27], "./useOnAction.js");
  var _useOnGetState = require(_dependencyMap[28], "./useOnGetState.js");
  var _useOnRouteFocus = require(_dependencyMap[29], "./useOnRouteFocus.js");
  var _useRegisterNavigator = require(_dependencyMap[30], "./useRegisterNavigator.js");
  var _useScheduleUpdate = require(_dependencyMap[31], "./useScheduleUpdate.js");
  var _jsxRuntime = require(_dependencyMap[32], "react/jsx-runtime");
  const _excluded = ["children", "layout", "screenOptions", "screenLayout", "screenListeners", "UNSTABLE_router"]; // This is to make TypeScript compiler happy
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  _types.PrivateValueStore;
  const isScreen = child => {
    return child.type === _Screen.Screen;
  };
  const isGroup = child => {
    return child.type === React.Fragment || child.type === _Group.Group;
  };
  const isValidKey = key => key === undefined || typeof key === 'string' && key !== '';

  /**
   * Extract route config object from React children elements.
   *
   * @param children React Elements to extract the config from.
   */
  const getRouteConfigsFromChildren = (children, groupKey, groupOptions, groupLayout) => {
    const configs = React.Children.toArray(children).reduce((acc, child) => {
      if (/*#__PURE__*/React.isValidElement(child)) {
        if (isScreen(child)) {
          // We can only extract the config from `Screen` elements
          // If something else was rendered, it's probably a bug

          if (typeof child.props !== 'object' || child.props === null) {
            throw new Error(`Got an invalid element for screen.`);
          }
          if (typeof child.props.name !== 'string' || child.props.name === '') {
            throw new Error(`Got an invalid name (${JSON.stringify(child.props.name)}) for the screen. It must be a non-empty string.`);
          }
          if (child.props.navigationKey !== undefined && (typeof child.props.navigationKey !== 'string' || child.props.navigationKey === '')) {
            throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
          }
          acc.push({
            keys: [groupKey, child.props.navigationKey],
            options: groupOptions,
            layout: groupLayout,
            props: child.props
          });
          return acc;
        }
        if (isGroup(child)) {
          if (!isValidKey(child.props.navigationKey)) {
            throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
          }

          // When we encounter a fragment or group, we need to dive into its children to extract the configs
          // This is handy to conditionally define a group of screens
          acc.push(...getRouteConfigsFromChildren(child.props.children, child.props.navigationKey,
          // FIXME
          // @ts-expect-error: add validation
          child.type !== _Group.Group ? groupOptions : groupOptions != null ? [...groupOptions, child.props.screenOptions] : [child.props.screenOptions], typeof child.props.screenLayout === 'function' ? child.props.screenLayout : groupLayout));
          return acc;
        }
      }
      throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${/*#__PURE__*/ /*#__PURE__*/React.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : child.type?.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && child.props?.name ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
    }, []);
    if (process.env.NODE_ENV !== 'production') {
      configs.forEach(config => {
        const {
          name,
          children,
          component,
          getComponent
        } = config.props;
        if (children != null || component !== undefined || getComponent !== undefined) {
          if (children != null && component !== undefined) {
            throw new Error(`Got both 'component' and 'children' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (children != null && getComponent !== undefined) {
            throw new Error(`Got both 'getComponent' and 'children' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (component !== undefined && getComponent !== undefined) {
            throw new Error(`Got both 'component' and 'getComponent' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (children != null && typeof children !== 'function') {
            throw new Error(`Got an invalid value for 'children' prop for the screen '${name}'. It must be a function returning a React Element.`);
          }
          if (component !== undefined && !(0, _reactIs.isValidElementType)(component)) {
            throw new Error(`Got an invalid value for 'component' prop for the screen '${name}'. It must be a valid React Component.`);
          }
          if (getComponent !== undefined && typeof getComponent !== 'function') {
            throw new Error(`Got an invalid value for 'getComponent' prop for the screen '${name}'. It must be a function returning a React Component.`);
          }
          if (typeof component === 'function') {
            if (component.name === 'component') {
              // Inline anonymous functions passed in the `component` prop will have the name of the prop
              // It's relatively safe to assume that it's not a component since it should also have PascalCase name
              // We won't catch all scenarios here, but this should catch a good chunk of incorrect use.
              console.warn(`Looks like you're passing an inline function for 'component' prop for the screen '${name}' (e.g. component={() => <SomeComponent />}). Passing an inline function will cause the component state to be lost on re-render and cause perf issues since it's re-created every render. You can pass the function as children to 'Screen' instead to achieve the desired behaviour.`);
            } else if (/^[a-z]/.test(component.name)) {
              console.warn(`Got a component with the name '${component.name}' for the screen '${name}'. React Components must start with an uppercase letter. If you're passing a regular function and not a component, pass it as children to 'Screen' instead. Otherwise capitalize your component's name.`);
            }
          }
        } else {
          throw new Error(`Couldn't find a 'component', 'getComponent' or 'children' prop for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
        }
      });
    }
    return configs;
  };

  /**
   * Hook for building navigators.
   *
   * @param createRouter Factory method which returns router object.
   * @param options Options object containing `children` and additional options for the router.
   * @returns An object containing `state`, `navigation`, `descriptors` objects.
   */
  function useNavigationBuilder(createRouter, options) {
    const navigatorKey = (0, _useRegisterNavigator.useRegisterNavigator)();
    const route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    const {
        children,
        layout,
        screenOptions,
        screenLayout,
        screenListeners,
        UNSTABLE_router
      } = options,
      rest = (0, _objectWithoutPropertiesLoose2.default)(options, _excluded);
    const routeConfigs = getRouteConfigsFromChildren(children);
    const router = (0, _useLazyValue.useLazyValue)(() => {
      if (rest.initialRouteName != null && routeConfigs.every(config => config.props.name !== rest.initialRouteName)) {
        throw new Error(`Couldn't find a screen named '${rest.initialRouteName}' to use as 'initialRouteName'.`);
      }
      const original = createRouter(rest);
      if (UNSTABLE_router != null) {
        const overrides = UNSTABLE_router(original);
        return Object.assign({}, original, overrides);
      }
      return original;
    });
    const screens = routeConfigs.reduce((acc, config) => {
      if (config.props.name in acc) {
        throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
      }
      acc[config.props.name] = config;
      return acc;
    }, {});
    const routeNames = routeConfigs.map(config => config.props.name);
    const routeKeyList = routeNames.reduce((acc, curr) => {
      acc[curr] = screens[curr].keys.map(key => key ?? '').join(':');
      return acc;
    }, {});
    const routeParamList = routeNames.reduce((acc, curr) => {
      const {
        initialParams
      } = screens[curr].props;
      acc[curr] = initialParams;
      return acc;
    }, {});
    const routeGetIdList = routeNames.reduce((acc, curr) => Object.assign(acc, {
      [curr]: screens[curr].props.getId
    }), {});
    if (!routeNames.length) {
      throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }
    const isStateValid = React.useCallback(state => state.type === undefined || state.type === router.type, [router.type]);
    const isStateInitialized = React.useCallback(state => state !== undefined && state.stale === false && isStateValid(state), [isStateValid]);
    const {
      state: currentState,
      getState: getCurrentState,
      setState: setCurrentState,
      setKey,
      getKey,
      getIsInitial
    } = React.useContext(_NavigationStateContext.NavigationStateContext);
    const stateCleanedUp = React.useRef(false);
    const setState = (0, _useLatestCallback.default)(state => {
      if (stateCleanedUp.current) {
        // State might have been already cleaned up due to unmount
        // We do not want to expose API allowing to override this
        // This would lead to old data preservation on main navigator unmount
        return;
      }
      setCurrentState(state);
    });
    const [initializedState, isFirstStateInitialization] = React.useMemo(() => {
      const initialRouteParamList = routeNames.reduce((acc, curr) => {
        const {
          initialParams
        } = screens[curr].props;
        const initialParamsFromParams = route?.params?.state == null && route?.params?.initial !== false && route?.params?.screen === curr ? route.params.params : undefined;
        acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? Object.assign({}, initialParams, initialParamsFromParams) : undefined;
        return acc;
      }, {});

      // If the current state isn't initialized on first render, we initialize it
      // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
      // Otherwise assume that the state was provided as initial state
      // So we need to rehydrate it to make it usable
      if ((currentState === undefined || !isStateValid(currentState)) && route?.params?.state == null && !(typeof route?.params?.screen === 'string' && route?.params?.initial !== false)) {
        return [router.getInitialState({
          routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList
        }), true];
      } else {
        let stateFromParams;
        if (route?.params?.state != null) {
          stateFromParams = route.params.state;
        } else if (typeof route?.params?.screen === 'string' && route?.params?.initial !== false) {
          stateFromParams = {
            index: 0,
            routes: [{
              name: route.params.screen,
              params: route.params.params,
              path: route.params.path
            }]
          };
        }
        return [router.getRehydratedState(stateFromParams ?? currentState, {
          routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList
        }), false];
      }
      // We explicitly don't include routeNames, route.params etc. in the dep list
      // below. We want to avoid forcing a new state to be calculated in those cases
      // Instead, we handle changes to these in the nextState code below. Note
      // that some changes to routeConfigs are explicitly ignored, such as changes
      // to initialParams
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [currentState, router, isStateValid]);
    const previousRouteKeyListRef = React.useRef(routeKeyList);
    React.useEffect(() => {
      previousRouteKeyListRef.current = routeKeyList;
    });
    const previousRouteKeyList = previousRouteKeyListRef.current;
    let state =
    // If the state isn't initialized, or stale, use the state we initialized instead
    // The state won't update until there's a change needed in the state we have initialized locally
    // So it'll be `undefined` or stale until the first navigation event happens
    isStateInitialized(currentState) ? currentState : initializedState;
    let nextState = state;
    if (!(0, _isArrayEqual.isArrayEqual)(state.routeNames, routeNames) || !(0, _isRecordEqual.isRecordEqual)(routeKeyList, previousRouteKeyList)) {
      // When the list of route names change, the router should handle it to remove invalid routes
      nextState = router.getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeGetIdList,
        routeKeyChanges: Object.keys(routeKeyList).filter(name => name in previousRouteKeyList && routeKeyList[name] !== previousRouteKeyList[name])
      });
    }
    const previousNestedParamsRef = React.useRef(route?.params);
    React.useEffect(() => {
      previousNestedParamsRef.current = route?.params;
    }, [route?.params]);
    if (route?.params) {
      const previousParams = previousNestedParamsRef.current;
      let action;
      if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
        // If the route was updated with new state, we should reset to it
        action = _routers.CommonActions.reset(route.params.state);
      } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
        // If the route was updated with new screen name and/or params, we should navigate there
        action = _routers.CommonActions.navigate({
          name: route.params.screen,
          params: route.params.params,
          path: route.params.path,
          pop: route.params.pop
        });
      }

      // The update should be limited to current navigator only, so we call the router manually
      const updatedState = action ? router.getStateForAction(nextState, action, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) : null;
      nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) : nextState;
    }
    const shouldUpdate = state !== nextState;
    (0, _useScheduleUpdate.useScheduleUpdate)(() => {
      if (shouldUpdate) {
        // If the state needs to be updated, we'll schedule an update
        setState(nextState);
      }
    });

    // The up-to-date state will come in next render, but we don't need to wait for it
    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
    // So we override the state object we return to use the latest state as soon as possible
    state = nextState;
    React.useEffect(() => {
      // In strict mode, React will double-invoke effects.
      // So we need to reset the flag if component was not unmounted
      stateCleanedUp.current = false;
      setKey(navigatorKey);
      if (!getIsInitial()) {
        // If it's not initial render, we need to update the state
        // This will make sure that our container gets notifier of state changes due to new mounts
        // This is necessary for proper screen tracking, URL updates etc.
        setState(nextState);
      }
      return () => {
        // We need to clean up state for this navigator on unmount
        if (getCurrentState() !== undefined && getKey() === navigatorKey) {
          setCurrentState(undefined);
          stateCleanedUp.current = true;
        }
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // In some cases (e.g. route names change), internal state might have changed
    // But it hasn't been committed yet, so hasn't propagated to the sync external store
    // During this time, we need to return the internal state in `getState`
    // Otherwise it can result in inconsistent state during render in children
    // To avoid this, we use a ref for render phase, and immediately clear it on commit
    const stateRef = React.useRef(state);
    stateRef.current = state;
    (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(() => {
      stateRef.current = null;
    });
    const getState = (0, _useLatestCallback.default)(() => {
      const currentState = getCurrentState();
      return (0, _deepFreeze.deepFreeze)(isStateInitialized(currentState) ? currentState : initializedState);
    });
    const emitter = (0, _useEventEmitter.useEventEmitter)(e => {
      const routeNames = [];
      let route;
      if (e.target) {
        route = state.routes.find(route => route.key === e.target);
        if (route?.name) {
          routeNames.push(route.name);
        }
      } else {
        route = state.routes[state.index];
        routeNames.push(...Object.keys(screens).filter(name => route?.name === name));
      }
      if (route == null) {
        return;
      }
      const navigation = descriptors[route.key].navigation;
      const listeners = [].concat(
      // Get an array of listeners for all screens + common listeners on navigator
      ...[screenListeners, ...routeNames.map(name => {
        const {
          listeners
        } = screens[name].props;
        return listeners;
      })].map(listeners => {
        const map = typeof listeners === 'function' ? listeners({
          route: route,
          navigation
        }) : listeners;
        return map ? Object.keys(map).filter(type => type === e.type).map(type => map?.[type]) : undefined;
      }))
      // We don't want same listener to be called multiple times for same event
      // So we remove any duplicate functions from the array
      .filter((cb, i, self) => cb && self.lastIndexOf(cb) === i);
      listeners.forEach(listener => listener?.(e));
    });
    (0, _useFocusEvents.useFocusEvents)({
      state,
      emitter
    });
    React.useEffect(() => {
      emitter.emit({
        type: 'state',
        data: {
          state
        }
      });
    }, [emitter, state]);
    const {
      listeners: childListeners,
      addListener
    } = (0, _useChildListeners.useChildListeners)();
    const {
      keyedListeners,
      addKeyedListener
    } = (0, _useKeyedChildListeners.useKeyedChildListeners)();
    const onAction = (0, _useOnAction.useOnAction)({
      router,
      getState,
      setState,
      key: route?.key,
      actionListeners: childListeners.action,
      beforeRemoveListeners: keyedListeners.beforeRemove,
      routerConfigOptions: {
        routeNames,
        routeParamList,
        routeGetIdList
      },
      emitter
    });
    const onRouteFocus = (0, _useOnRouteFocus.useOnRouteFocus)({
      router,
      key: route?.key,
      getState,
      setState
    });
    const navigation = (0, _useNavigationHelpers.useNavigationHelpers)({
      id: options.id,
      onAction,
      getState,
      emitter,
      router,
      stateRef
    });
    (0, _useFocusedListenersChildrenAdapter.useFocusedListenersChildrenAdapter)({
      navigation,
      focusedListeners: childListeners.focus
    });
    (0, _useOnGetState.useOnGetState)({
      getState,
      getStateListeners: keyedListeners.getState
    });
    const {
      describe,
      descriptors
    } = (0, _useDescriptors.useDescriptors)({
      state,
      screens,
      navigation,
      screenOptions,
      screenLayout,
      onAction,
      getState,
      setState,
      onRouteFocus,
      addListener,
      addKeyedListener,
      router,
      // @ts-expect-error: this should have both core and custom events, but too much work right now
      emitter
    });
    (0, _useCurrentRender.useCurrentRender)({
      state,
      navigation,
      descriptors
    });
    const NavigationContent = (0, _useComponent.useComponent)(children => {
      const element = layout != null ? layout({
        state,
        descriptors,
        navigation,
        children
      }) : children;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationHelpersContext.NavigationHelpersContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_PreventRemoveProvider.PreventRemoveProvider, {
          children: element
        })
      });
    });
    return {
      state,
      navigation,
      describe,
      descriptors,
      NavigationContent
    };
  }
},423,[17,29,354,3,415,362,384,386,404,392,406,408,374,410,387,419,378,424,425,426,379,431,432,433,380,434,435,436,438,439,440,441,6],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationBuilder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useComponent = useComponent;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _jsxRuntime = require(_dependencyMap[1], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const NavigationContent = ({
    render,
    children
  }) => {
    return render(children);
  };
  function useComponent(render) {
    const renderRef = React.useRef(render);

    // Normally refs shouldn't be mutated in render
    // But we return a component which will be rendered
    // So it's just for immediate consumption
    renderRef.current = render;
    React.useEffect(() => {
      renderRef.current = null;
    });
    return React.useRef(({
      children
    }) => {
      const render = renderRef.current;
      if (render === null) {
        throw new Error('The returned component must be rendered in the same render phase as the hook.');
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(NavigationContent, {
        render: render,
        children: children
      });
    }).current;
  }
},424,[3,6],"node_modules\\@react-navigation\\core\\lib\\module\\useComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useCurrentRender = useCurrentRender;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _CurrentRenderContext = require(_dependencyMap[1], "./CurrentRenderContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Write the current options, so that server renderer can get current values
   * Mutating values like this is not safe in async mode, but it doesn't apply to SSR
   */
  function useCurrentRender({
    state,
    navigation,
    descriptors
  }) {
    const current = React.useContext(_CurrentRenderContext.CurrentRenderContext);
    if (current && navigation.isFocused()) {
      current.options = descriptors[state.routes[state.index].key].options;
    }
  }
},425,[3,388],"node_modules\\@react-navigation\\core\\lib\\module\\useCurrentRender.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDescriptors = useDescriptors;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[3], "./NavigationBuilderContext.js");
  var _NavigationContext = require(_dependencyMap[4], "./NavigationContext.js");
  var _NavigationRouteContext = require(_dependencyMap[5], "./NavigationRouteContext.js");
  var _SceneView = require(_dependencyMap[6], "./SceneView.js");
  var _ThemeContext = require(_dependencyMap[7], "./theming/ThemeContext.js");
  var _useNavigationCache = require(_dependencyMap[8], "./useNavigationCache.js");
  var _useRouteCache = require(_dependencyMap[9], "./useRouteCache.js");
  var _jsxRuntime = require(_dependencyMap[10], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  /**
   * Hook to create descriptor objects for the child routes.
   *
   * A descriptor object provides 3 things:
   * - Helper method to render a screen
   * - Options specified by the screen for the navigator
   * - Navigation object intended for the route
   */
  function useDescriptors({
    state,
    screens,
    navigation,
    screenOptions,
    screenLayout,
    onAction,
    getState,
    setState,
    addListener,
    addKeyedListener,
    onRouteFocus,
    router,
    emitter
  }) {
    const theme = React.useContext(_ThemeContext.ThemeContext);
    const [options, setOptions] = React.useState({});
    const {
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const context = React.useMemo(() => ({
      navigation,
      onAction,
      addListener,
      addKeyedListener,
      onRouteFocus,
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    }), [navigation, onAction, addListener, addKeyedListener, onRouteFocus, onDispatchAction, onOptionsChange, scheduleUpdate, flushUpdates, stackRef]);
    const {
      base,
      navigations
    } = (0, _useNavigationCache.useNavigationCache)({
      state,
      getState,
      navigation,
      setOptions,
      router,
      emitter
    });
    const routes = (0, _useRouteCache.useRouteCache)(state.routes);
    const getOptions = (route, navigation, overrides) => {
      const config = screens[route.name];
      const screen = config.props;
      const optionsList = [
      // The default `screenOptions` passed to the navigator
      screenOptions,
      // The `screenOptions` props passed to `Group` elements
      ...(config.options ? config.options.filter(Boolean) : []),
      // The `options` prop passed to `Screen` elements,
      screen.options,
      // The options set via `navigation.setOptions`
      overrides];
      return optionsList.reduce((acc, curr) => Object.assign(acc,
      // @ts-expect-error: we check for function but TS still complains
      typeof curr !== 'function' ? curr : curr({
        route,
        navigation,
        theme
      })), {});
    };
    const render = (route, navigation, customOptions, routeState) => {
      const config = screens[route.name];
      const screen = config.props;
      const clearOptions = () => setOptions(o => {
        if (route.key in o) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const _route$key = route.key,
            rest = (0, _objectWithoutPropertiesLoose2.default)(o, [_route$key].map(_toPropertyKey));
          return rest;
        }
        return o;
      });
      const layout =
      // The `layout` prop passed to `Screen` elements,
      screen.layout ??
      // The `screenLayout` props passed to `Group` elements
      config.layout ??
      // The default `screenLayout` passed to the navigator
      screenLayout;
      let element = /*#__PURE__*/(0, _jsxRuntime.jsx)(_SceneView.SceneView, {
        navigation: navigation,
        route: route,
        screen: screen,
        routeState: routeState,
        getState: getState,
        setState: setState,
        options: customOptions,
        clearOptions: clearOptions
      });
      if (layout != null) {
        element = layout({
          route,
          navigation,
          options: customOptions,
          // @ts-expect-error: in practice `theme` will be defined
          theme,
          children: element
        });
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
        value: context,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationContext.NavigationContext.Provider, {
          value: navigation,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
            value: route,
            children: element
          })
        })
      }, route.key);
    };
    const descriptors = routes.reduce((acc, route, i) => {
      const navigation = navigations[route.key];
      const customOptions = getOptions(route, navigation, options[route.key]);
      const element = render(route, navigation, customOptions, state.routes[i].state);
      acc[route.key] = {
        route,
        // @ts-expect-error: it's missing action helpers, fix later
        navigation,
        render() {
          return element;
        },
        options: customOptions
      };
      return acc;
    }, {});

    /**
     * Create a descriptor object for a route.
     *
     * @param route Route object for which the descriptor should be created
     * @param placeholder Whether the descriptor should be a placeholder, e.g. for a route not yet in the state
     * @returns Descriptor object
     */
    const describe = (route, placeholder) => {
      if (!placeholder) {
        if (!(route.key in descriptors)) {
          throw new Error(`Couldn't find a route with the key ${route.key}.`);
        }
        return descriptors[route.key];
      }
      const navigation = base;
      const customOptions = getOptions(route, navigation, {});
      const element = render(route, navigation, customOptions, undefined);
      return {
        route,
        navigation,
        render() {
          return element;
        },
        options: customOptions
      };
    };
    return {
      describe,
      descriptors
    };
  }
},426,[17,29,3,371,405,408,427,376,430,391,6],"node_modules\\@react-navigation\\core\\lib\\module\\useDescriptors.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SceneView = SceneView;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _EnsureSingleNavigator = require(_dependencyMap[3], "./EnsureSingleNavigator.js");
  var _NavigationFocusedRouteStateContext = require(_dependencyMap[4], "./NavigationFocusedRouteStateContext.js");
  var _NavigationStateContext = require(_dependencyMap[5], "./NavigationStateContext.js");
  var _StaticContainer = require(_dependencyMap[6], "./StaticContainer.js");
  var _useOptionsGetters = require(_dependencyMap[7], "./useOptionsGetters.js");
  var _jsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  const _excluded = ["state", "screen", "params", "initial"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Component which takes care of rendering the screen for a route.
   * It provides all required contexts and applies optimizations when applicable.
   */
  function SceneView({
    screen,
    route,
    navigation,
    routeState,
    getState,
    setState,
    options,
    clearOptions
  }) {
    const navigatorKeyRef = React.useRef(undefined);
    const getKey = React.useCallback(() => navigatorKeyRef.current, []);
    const {
      addOptionsGetter
    } = (0, _useOptionsGetters.useOptionsGetters)({
      key: route.key,
      options,
      navigation
    });
    const setKey = React.useCallback(key => {
      navigatorKeyRef.current = key;
    }, []);
    const getCurrentState = React.useCallback(() => {
      const state = getState();
      const currentRoute = state.routes.find(r => r.key === route.key);
      return currentRoute ? currentRoute.state : undefined;
    }, [getState, route.key]);
    const setCurrentState = React.useCallback(child => {
      const state = getState();
      setState(Object.assign({}, state, {
        routes: state.routes.map(r => {
          if (r.key !== route.key) {
            return r;
          }
          const nextRoute = Object.assign({}, r, {
            state: child
          });

          // Before updating the state, cleanup any nested screen and state
          // This will avoid the navigator trying to handle them again
          if (nextRoute.params && ('state' in nextRoute.params && typeof nextRoute.params.state === 'object' && nextRoute.params.state !== null || 'screen' in nextRoute.params && typeof nextRoute.params.screen === 'string')) {
            // @ts-expect-error: we don't have correct type for params
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const _nextRoute$params = nextRoute.params,
              rest = (0, _objectWithoutPropertiesLoose2.default)(_nextRoute$params, _excluded);
            if (Object.keys(rest).length) {
              nextRoute.params = rest;
            } else {
              delete nextRoute.params;
            }
          }
          return nextRoute;
        })
      }));
    }, [getState, route.key, setState]);
    const isInitialRef = React.useRef(true);
    React.useEffect(() => {
      isInitialRef.current = false;
    });

    // Clear options set by this screen when it is unmounted
    React.useEffect(() => {
      return clearOptions;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const getIsInitial = React.useCallback(() => isInitialRef.current, []);
    const parentFocusedRouteState = React.useContext(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext);
    const focusedRouteState = React.useMemo(() => {
      const state = {
        routes: [{
          key: route.key,
          name: route.name,
          params: route.params,
          path: route.path
        }]
      };

      // Add our state to the innermost route of the parent state
      const addState = parent => {
        const parentRoute = parent?.routes[0];
        if (parentRoute) {
          return {
            routes: [Object.assign({}, parentRoute, {
              state: addState(parentRoute.state)
            })]
          };
        }
        return state;
      };
      return addState(parentFocusedRouteState);
    }, [parentFocusedRouteState, route.key, route.name, route.params, route.path]);
    const context = React.useMemo(() => ({
      state: routeState,
      getState: getCurrentState,
      setState: setCurrentState,
      getKey,
      setKey,
      getIsInitial,
      addOptionsGetter
    }), [routeState, getCurrentState, setCurrentState, getKey, setKey, getIsInitial, addOptionsGetter]);
    const ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
      value: context,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext.Provider, {
        value: focusedRouteState,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_StaticContainer.StaticContainer, {
            name: screen.name,
            render: ScreenComponent || screen.children,
            navigation: navigation,
            route: route,
            children: ScreenComponent !== undefined ? /*#__PURE__*/(0, _jsxRuntime.jsx)(ScreenComponent, {
              navigation: navigation,
              route: route
            }) : screen.children !== undefined ? screen.children({
              navigation,
              route
            }) : null
          })
        })
      })
    });
  }
},427,[17,29,3,369,428,374,429,382,6],"node_modules\\@react-navigation\\core\\lib\\module\\SceneView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationFocusedRouteStateContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Context for the parent route of a navigator.
   */
  const NavigationFocusedRouteStateContext = exports.NavigationFocusedRouteStateContext = /*#__PURE__*/React.createContext(undefined);
},428,[3],"node_modules\\@react-navigation\\core\\lib\\module\\NavigationFocusedRouteStateContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StaticContainer = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Component which prevents updates for children if no props changed
   */
  const StaticContainer = exports.StaticContainer = /*#__PURE__*/React.memo(function StaticContainer(props) {
    return props.children;
  }, (prevProps, nextProps) => {
    const prevPropKeys = Object.keys(prevProps);
    const nextPropKeys = Object.keys(nextProps);
    if (prevPropKeys.length !== nextPropKeys.length) {
      return false;
    }
    for (const key of prevPropKeys) {
      if (key === 'children') {
        continue;
      }
      if (prevProps[key] !== nextProps[key]) {
        return false;
      }
    }
    return true;
  });
},429,[3],"node_modules\\@react-navigation\\core\\lib\\module\\StaticContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationCache = useNavigationCache;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _routers = require(_dependencyMap[2], "@react-navigation/routers");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[4], "./NavigationBuilderContext.js");
  const _excluded = ["emit"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to cache navigation objects for each screen in the navigator.
   * It's important to cache them to make sure navigation objects don't change between renders.
   * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.
   */
  function useNavigationCache({
    state,
    getState,
    navigation,
    setOptions,
    router,
    emitter
  }) {
    const {
      stackRef
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const base = React.useMemo(() => {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const rest = (0, _objectWithoutPropertiesLoose2.default)(navigation, _excluded);
      const actions = Object.assign({}, router.actionCreators, _routers.CommonActions);
      const dispatch = () => {
        throw new Error('Actions cannot be dispatched from a placeholder screen.');
      };
      const helpers = Object.keys(actions).reduce((acc, name) => {
        acc[name] = dispatch;
        return acc;
      }, {});
      return Object.assign({}, rest, helpers, {
        addListener: () => {
          // Event listeners are not supported for placeholder screens

          return () => {
            // Empty function
          };
        },
        removeListener: () => {
          // Event listeners are not supported for placeholder screens
        },
        dispatch,
        getParent: id => {
          if (id !== undefined && id === rest.getId()) {
            return base;
          }
          return rest.getParent(id);
        },
        setOptions: () => {
          throw new Error('Options cannot be set from a placeholder screen.');
        },
        isFocused: () => false
      });
    }, [navigation, router.actionCreators]);

    // Cache object which holds navigation objects for each screen
    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
    // In reality, these deps will rarely change, if ever
    const cache = React.useMemo(() => ({
      current: {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [base, getState, navigation, setOptions, emitter]);
    cache.current = state.routes.reduce((acc, route) => {
      const previous = cache.current[route.key];
      if (previous) {
        // If a cached navigation object already exists, reuse it
        acc[route.key] = previous;
      } else {
        const dispatch = thunk => {
          const action = typeof thunk === 'function' ? thunk(getState()) : thunk;
          if (action != null) {
            navigation.dispatch(Object.assign({
              source: route.key
            }, action));
          }
        };
        const withStack = callback => {
          let isStackSet = false;
          try {
            if (process.env.NODE_ENV !== 'production' && stackRef && !stackRef.current) {
              // Capture the stack trace for devtools
              stackRef.current = new Error().stack;
              isStackSet = true;
            }
            callback();
          } finally {
            if (isStackSet && stackRef) {
              stackRef.current = undefined;
            }
          }
        };
        const actions = Object.assign({}, router.actionCreators, _routers.CommonActions);
        const helpers = Object.keys(actions).reduce((acc, name) => {
          acc[name] = (...args) => withStack(() =>
          // @ts-expect-error: name is a valid key, but TypeScript is dumb
          dispatch(actions[name](...args)));
          return acc;
        }, {});
        acc[route.key] = Object.assign({}, base, helpers, emitter.create(route.key), {
          dispatch: thunk => withStack(() => dispatch(thunk)),
          getParent: id => {
            if (id !== undefined && id === base.getId()) {
              // If the passed id is the same as the current navigation id,
              // we return the cached navigation object for the relevant route
              return acc[route.key];
            }
            return base.getParent(id);
          },
          setOptions: options => {
            setOptions(o => Object.assign({}, o, {
              [route.key]: Object.assign({}, o[route.key], options)
            }));
          },
          isFocused: () => {
            const state = base.getState();
            if (state.routes[state.index].key !== route.key) {
              return false;
            }

            // If the current screen is focused, we also need to check if parent navigator is focused
            // This makes sure that we return the focus state in the whole tree, not just this navigator
            return navigation ? navigation.isFocused() : true;
          }
        });
      }
      return acc;
    }, {});
    return {
      base,
      navigations: cache.current
    };
  }
},430,[17,29,354,3,371],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationCache.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusedListenersChildrenAdapter = useFocusedListenersChildrenAdapter;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook for passing focus callback to children
   */
  function useFocusedListenersChildrenAdapter({
    navigation,
    focusedListeners
  }) {
    const {
      addListener
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const listener = React.useCallback(callback => {
      if (navigation.isFocused()) {
        for (const listener of focusedListeners) {
          const {
            handled,
            result
          } = listener(callback);
          if (handled) {
            return {
              handled,
              result
            };
          }
        }
        return {
          handled: true,
          result: callback(navigation)
        };
      } else {
        return {
          handled: false,
          result: null
        };
      }
    }, [focusedListeners, navigation]);
    React.useEffect(() => addListener?.('focus', listener), [addListener, listener]);
  }
},431,[3,371],"node_modules\\@react-navigation\\core\\lib\\module\\useFocusedListenersChildrenAdapter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEvents = useFocusEvents;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationContext = require(_dependencyMap[1], "./NavigationContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to take care of emitting `focus` and `blur` events.
   */
  function useFocusEvents({
    state,
    emitter
  }) {
    const navigation = React.useContext(_NavigationContext.NavigationContext);
    const lastFocusedKeyRef = React.useRef(undefined);
    const currentFocusedKey = state.routes[state.index].key;

    // When the parent screen changes its focus state, we also need to change child's focus
    // Coz the child screen can't be focused if the parent screen is out of focus
    React.useEffect(() => navigation?.addListener('focus', () => {
      lastFocusedKeyRef.current = currentFocusedKey;
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }), [currentFocusedKey, emitter, navigation]);
    React.useEffect(() => navigation?.addListener('blur', () => {
      lastFocusedKeyRef.current = undefined;
      emitter.emit({
        type: 'blur',
        target: currentFocusedKey
      });
    }), [currentFocusedKey, emitter, navigation]);
    React.useEffect(() => {
      const lastFocusedKey = lastFocusedKeyRef.current;
      lastFocusedKeyRef.current = currentFocusedKey;

      // We wouldn't have `lastFocusedKey` on initial mount
      // Fire focus event for the current route on mount if there's no parent navigator
      if (lastFocusedKey === undefined && !navigation) {
        emitter.emit({
          type: 'focus',
          target: currentFocusedKey
        });
      }

      // We should only emit events when the focused key changed and navigator is focused
      // When navigator is not focused, screens inside shouldn't receive focused status either
      if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
        return;
      }
      if (lastFocusedKey === undefined) {
        // Only fire events after initial mount
        return;
      }
      emitter.emit({
        type: 'blur',
        target: lastFocusedKey
      });
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }, [currentFocusedKey, emitter, navigation]);
  }
},432,[3,405],"node_modules\\@react-navigation\\core\\lib\\module\\useFocusEvents.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useIsomorphicLayoutEffect = void 0;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Use `useEffect` during SSR and `useLayoutEffect` in the browser to avoid warnings.
   */
  const useIsomorphicLayoutEffect = exports.useIsomorphicLayoutEffect = typeof document !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;
},433,[3],"node_modules\\@react-navigation\\core\\lib\\module\\useIsomorphicLayoutEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLazyValue = useLazyValue;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useLazyValue(create) {
    const lazyRef = React.useRef(undefined);
    if (lazyRef.current === undefined) {
      lazyRef.current = create();
    }
    return lazyRef.current;
  }
},434,[3],"node_modules\\@react-navigation\\core\\lib\\module\\useLazyValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationHelpers = useNavigationHelpers;
  var _routers = require(_dependencyMap[0], "@react-navigation/routers");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _NavigationContext = require(_dependencyMap[2], "./NavigationContext.js");
  var _types = require(_dependencyMap[3], "./types.js");
  var _UnhandledActionContext = require(_dependencyMap[4], "./UnhandledActionContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  // This is to make TypeScript compiler happy
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  _types.PrivateValueStore;
  /**
   * Navigation object with helper methods to be used by a navigator.
   * This object includes methods for common actions as well as methods the parent screen's navigation object.
   */
  function useNavigationHelpers({
    id: navigatorId,
    onAction,
    getState,
    emitter,
    router,
    stateRef
  }) {
    const onUnhandledAction = React.useContext(_UnhandledActionContext.UnhandledActionContext);
    const parentNavigationHelpers = React.useContext(_NavigationContext.NavigationContext);
    return React.useMemo(() => {
      const dispatch = op => {
        const action = typeof op === 'function' ? op(getState()) : op;
        const handled = onAction(action);
        if (!handled) {
          onUnhandledAction?.(action);
        }
      };
      const actions = Object.assign({}, router.actionCreators, _routers.CommonActions);
      const helpers = Object.keys(actions).reduce((acc, name) => {
        // @ts-expect-error: name is a valid key, but TypeScript is dumb
        acc[name] = (...args) => dispatch(actions[name](...args));
        return acc;
      }, {});
      const navigationHelpers = Object.assign({}, parentNavigationHelpers, helpers, {
        dispatch,
        emit: emitter.emit,
        isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : () => true,
        canGoBack: () => {
          const state = getState();
          return router.getStateForAction(state, _routers.CommonActions.goBack(), {
            routeNames: state.routeNames,
            routeParamList: {},
            routeGetIdList: {}
          }) !== null || parentNavigationHelpers?.canGoBack() || false;
        },
        getId: () => navigatorId,
        getParent: id => {
          if (id !== undefined) {
            let current = navigationHelpers;
            while (current && id !== current.getId()) {
              current = current.getParent();
            }
            return current;
          }
          return parentNavigationHelpers;
        },
        getState: () => {
          // FIXME: Workaround for when the state is read during render
          // By this time, we haven't committed the new state yet
          // Without this `useSyncExternalStore` will keep reading the old state
          // This may result in `useNavigationState` or `useIsFocused` returning wrong values
          // Apart from `useSyncExternalStore`, `getState` should never be called during render
          if (stateRef.current != null) {
            return stateRef.current;
          }
          return getState();
        }
      });
      return navigationHelpers;
    }, [router, parentNavigationHelpers, emitter.emit, getState, onAction, onUnhandledAction, navigatorId, stateRef]);
  }
},435,[354,3,405,419,377],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationHelpers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useOnAction = useOnAction;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _DeprecatedNavigationInChildContext = require(_dependencyMap[1], "./DeprecatedNavigationInChildContext.js");
  var _NavigationBuilderContext = require(_dependencyMap[2], "./NavigationBuilderContext.js");
  var _useOnPreventRemove = require(_dependencyMap[3], "./useOnPreventRemove.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to handle actions for a navigator, including state updates and bubbling.
   *
   * Bubbling an action is achieved in 2 ways:
   * 1. To bubble action to parent, we expose the action handler in context and then access the parent context
   * 2. To bubble action to child, child adds event listeners subscribing to actions from parent
   *
   * When the action handler handles as action, it returns `true`, otherwise `false`.
   */
  function useOnAction({
    router,
    getState,
    setState,
    key,
    actionListeners,
    beforeRemoveListeners,
    routerConfigOptions,
    emitter
  }) {
    const {
      onAction: onActionParent,
      onRouteFocus: onRouteFocusParent,
      addListener: addListenerParent,
      onDispatchAction
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const navigationInChildEnabled = React.useContext(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext);
    const routerConfigOptionsRef = React.useRef(routerConfigOptions);
    React.useEffect(() => {
      routerConfigOptionsRef.current = routerConfigOptions;
    });
    const onAction = React.useCallback((action, visitedNavigators = new Set()) => {
      const state = getState();

      // Since actions can bubble both up and down, they could come to the same navigator again
      // We keep track of navigators which have already tried to handle the action and return if it's already visited
      if (visitedNavigators.has(state.key)) {
        return false;
      }
      visitedNavigators.add(state.key);
      if (typeof action.target !== 'string' || action.target === state.key) {
        let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);

        // If a target is specified and set to current navigator, the action shouldn't bubble
        // So instead of `null`, we use the state object for such cases to signal that action was handled
        result = result === null && action.target === state.key ? state : result;
        if (result !== null) {
          onDispatchAction(action, state === result);
          if (state !== result) {
            const isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
            if (isPrevented) {
              return true;
            }
            setState(result);
          }
          if (onRouteFocusParent !== undefined) {
            // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
            // This means we need to focus all of the parent navigators of this navigator as well
            const shouldFocus = router.shouldActionChangeFocus(action);
            if (shouldFocus && key !== undefined) {
              onRouteFocusParent(key);
            }
          }
          return true;
        }
      }
      if (onActionParent !== undefined) {
        // Bubble action to the parent if the current navigator didn't handle it
        if (onActionParent(action, visitedNavigators)) {
          return true;
        }
      }
      if (typeof action.target === 'string' ||
      // For backward compatibility
      action.type === 'NAVIGATE_DEPRECATED' || navigationInChildEnabled) {
        // If the action wasn't handled by current navigator or a parent navigator, let children handle it
        // Handling this when target isn't specified is deprecated and will be removed in the future
        for (let i = actionListeners.length - 1; i >= 0; i--) {
          const listener = actionListeners[i];
          if (listener(action, visitedNavigators)) {
            return true;
          }
        }
      }
      return false;
    }, [actionListeners, beforeRemoveListeners, emitter, getState, navigationInChildEnabled, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);
    (0, _useOnPreventRemove.useOnPreventRemove)({
      getState,
      emitter,
      beforeRemoveListeners
    });
    React.useEffect(() => addListenerParent?.('action', onAction), [addListenerParent, onAction]);
    return onAction;
  }
},436,[3,368,371,437],"node_modules\\@react-navigation\\core\\lib\\module\\useOnAction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shouldPreventRemove = void 0;
  exports.useOnPreventRemove = useOnPreventRemove;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _NavigationRouteContext = require(_dependencyMap[2], "./NavigationRouteContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
  const shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action) => {
    const nextRouteKeys = nextRoutes.map(route => route.key);

    // Call these in reverse order so last screens handle the event first
    const removedRoutes = currentRoutes.filter(route => !nextRouteKeys.includes(route.key)).reverse();
    const visitedRouteKeys =
    // @ts-expect-error: add this property to mark that we've already emitted this action
    action[VISITED_ROUTE_KEYS] ?? new Set();
    const beforeRemoveAction = Object.assign({}, action, {
      [VISITED_ROUTE_KEYS]: visitedRouteKeys
    });
    for (const route of removedRoutes) {
      if (visitedRouteKeys.has(route.key)) {
        // Skip if we've already emitted this action for this screen
        continue;
      }

      // First, we need to check if any child screens want to prevent it
      const isPrevented = beforeRemoveListeners[route.key]?.(beforeRemoveAction);
      if (isPrevented) {
        return true;
      }
      visitedRouteKeys.add(route.key);
      const event = emitter.emit({
        type: 'beforeRemove',
        target: route.key,
        data: {
          action: beforeRemoveAction
        },
        canPreventDefault: true
      });
      if (event.defaultPrevented) {
        return true;
      }
    }
    return false;
  };
  exports.shouldPreventRemove = shouldPreventRemove;
  function useOnPreventRemove({
    getState,
    emitter,
    beforeRemoveListeners
  }) {
    const {
      addKeyedListener
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    const routeKey = route?.key;
    React.useEffect(() => {
      if (routeKey) {
        return addKeyedListener?.('beforeRemove', routeKey, action => {
          const state = getState();
          return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
        });
      }
    }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);
  }
},437,[3,371,408],"node_modules\\@react-navigation\\core\\lib\\module\\useOnPreventRemove.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useOnGetState = useOnGetState;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _isArrayEqual = require(_dependencyMap[1], "./isArrayEqual.js");
  var _NavigationBuilderContext = require(_dependencyMap[2], "./NavigationBuilderContext.js");
  var _NavigationRouteContext = require(_dependencyMap[3], "./NavigationRouteContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useOnGetState({
    getState,
    getStateListeners
  }) {
    const {
      addKeyedListener
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    const route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    const key = route ? route.key : 'root';
    const getRehydratedState = React.useCallback(() => {
      const state = getState();

      // Avoid returning new route objects if we don't need to
      const routes = state.routes.map(route => {
        const childState = getStateListeners[route.key]?.();
        if (route.state === childState) {
          return route;
        }
        return Object.assign({}, route, {
          state: childState
        });
      });
      if ((0, _isArrayEqual.isArrayEqual)(state.routes, routes)) {
        return state;
      }
      return Object.assign({}, state, {
        routes
      });
    }, [getState, getStateListeners]);
    React.useEffect(() => {
      return addKeyedListener?.('getState', key, getRehydratedState);
    }, [addKeyedListener, getRehydratedState, key]);
  }
},438,[3,404,371,408],"node_modules\\@react-navigation\\core\\lib\\module\\useOnGetState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useOnRouteFocus = useOnRouteFocus;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to handle focus actions for a route.
   * Focus action needs to be treated specially, coz when a nested route is focused,
   * the parent navigators also needs to be focused.
   */
  function useOnRouteFocus({
    router,
    getState,
    key: sourceRouteKey,
    setState
  }) {
    const {
      onRouteFocus: onRouteFocusParent
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);
    return React.useCallback(key => {
      const state = getState();
      const result = router.getStateForRouteFocus(state, key);
      if (result !== state) {
        setState(result);
      }
      if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
        onRouteFocusParent(sourceRouteKey);
      }
    }, [getState, onRouteFocusParent, router, setState, sourceRouteKey]);
  }
},439,[3,371],"node_modules\\@react-navigation\\core\\lib\\module\\useOnRouteFocus.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useRegisterNavigator = useRegisterNavigator;
  var _nonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _EnsureSingleNavigator = require(_dependencyMap[2], "./EnsureSingleNavigator.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Register a navigator in the parent context (either a navigation container or a screen).
   * This is used to prevent multiple navigators under a single container or screen.
   */
  function useRegisterNavigator() {
    const [key] = React.useState(() => (0, _nonSecure.nanoid)());
    const container = React.useContext(_EnsureSingleNavigator.SingleNavigatorContext);
    if (container === undefined) {
      throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }
    React.useEffect(() => {
      const {
        register,
        unregister
      } = container;
      register(key);
      return () => unregister(key);
    }, [container, key]);
    return key;
  }
},440,[900,3,369],"node_modules\\@react-navigation\\core\\lib\\module\\useRegisterNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useScheduleUpdate = useScheduleUpdate;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationBuilderContext = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _useIsomorphicLayoutEffect = require(_dependencyMap[2], "./useIsomorphicLayoutEffect");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * When screen config changes, we want to update the navigator in the same update phase.
   * However, navigation state is in the root component and React won't let us update it from a child.
   * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.
   * It lets all subsequent updates access the latest state so it stays correct.
   * Then we call setState during after the component updates.
   */
  function useScheduleUpdate(callback) {
    const {
      scheduleUpdate,
      flushUpdates
    } = React.useContext(_NavigationBuilderContext.NavigationBuilderContext);

    // FIXME: This is potentially unsafe
    // However, since we are using sync store, it might be fine
    scheduleUpdate(callback);
    (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(flushUpdates);
  }
},441,[3,371,433],"node_modules\\@react-navigation\\core\\lib\\module\\useScheduleUpdate.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationContainerRef = useNavigationContainerRef;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _createNavigationContainerRef = require(_dependencyMap[1], "./createNavigationContainerRef.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useNavigationContainerRef() {
    const navigation = React.useRef(null);
    if (navigation.current == null) {
      navigation.current = (0, _createNavigationContainerRef.createNavigationContainerRef)();
    }
    return navigation.current;
  }
},442,[3,367],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationContainerRef.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigationState = useNavigationState;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _withSelector = require(_dependencyMap[1], "use-sync-external-store/with-selector");
  var _useNavigation = require(_dependencyMap[2], "./useNavigation.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to get a value from the current navigation state using a selector.
   *
   * @param selector Selector function to get a value from the state.
   */
  function useNavigationState(selector) {
    const navigation = (0, _useNavigation.useNavigation)();
    const subscribe = React.useCallback(callback => {
      const unsubscribe = navigation.addListener('state', callback);
      return unsubscribe;
    }, [navigation]);
    const value = (0, _withSelector.useSyncExternalStoreWithSelector)(subscribe, navigation.getState, navigation.getState, selector);
    return value;
  }
},443,[3,444,421],"node_modules\\@react-navigation\\core\\lib\\module\\useNavigationState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/use-sync-external-store-with-selector.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/use-sync-external-store-with-selector.development.js");
  }
},444,[445,446],"node_modules\\use-sync-external-store\\with-selector.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * use-sync-external-store-with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var React = require(_dependencyMap[0], "react");
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is,
    useSyncExternalStore = React.useSyncExternalStore,
    useRef = React.useRef,
    useEffect = React.useEffect,
    useMemo = React.useMemo,
    useDebugValue = React.useDebugValue;
  exports.useSyncExternalStoreWithSelector = function (subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = {
        hasValue: !1,
        value: null
      };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(function () {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = !0;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
          }
          return memoizedSelection = nextSnapshot;
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
        memoizedSnapshot = nextSnapshot;
        return memoizedSelection = nextSelection;
      }
      var hasMemo = !1,
        memoizedSnapshot,
        memoizedSelection,
        maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [function () {
        return memoizedSelector(getSnapshot());
      }, null === maybeGetServerSnapshot ? void 0 : function () {
        return memoizedSelector(maybeGetServerSnapshot());
      }];
    }, [getSnapshot, getServerSnapshot, selector, isEqual]);
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(function () {
      inst.hasValue = !0;
      inst.value = value;
    }, [value]);
    useDebugValue(value);
    return value;
  };
},445,[3],"node_modules\\use-sync-external-store\\cjs\\use-sync-external-store-with-selector.production.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require(_dependencyMap[0], "react"),
      objectIs = "function" === typeof Object.is ? Object.is : is,
      useSyncExternalStore = React.useSyncExternalStore,
      useRef = React.useRef,
      useEffect = React.useEffect,
      useMemo = React.useMemo,
      useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function (subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = {
          hasValue: !1,
          value: null
        };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(function () {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = !0;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = !1,
          memoizedSnapshot,
          memoizedSelection,
          maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [function () {
          return memoizedSelector(getSnapshot());
        }, null === maybeGetServerSnapshot ? void 0 : function () {
          return memoizedSelector(maybeGetServerSnapshot());
        }];
      }, [getSnapshot, getServerSnapshot, selector, isEqual]);
      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
      useEffect(function () {
        inst.hasValue = !0;
        inst.value = value;
      }, [value]);
      useDebugValue(value);
      return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},446,[3],"node_modules\\use-sync-external-store\\cjs\\use-sync-external-store-with-selector.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.usePreventRemove = usePreventRemove;
  var _nonSecure = require(_dependencyMap[1], "nanoid/non-secure");
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[3], "use-latest-callback"));
  var _useNavigation = require(_dependencyMap[4], "./useNavigation.js");
  var _usePreventRemoveContext = require(_dependencyMap[5], "./usePreventRemoveContext.js");
  var _useRoute = require(_dependencyMap[6], "./useRoute.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to prevent screen from being removed. Can be used to prevent users from leaving the screen.
   *
   * @param preventRemove Boolean indicating whether to prevent screen from being removed.
   * @param callback Function which is executed when screen was prevented from being removed.
   */
  function usePreventRemove(preventRemove, callback) {
    const [id] = React.useState(() => (0, _nonSecure.nanoid)());
    const navigation = (0, _useNavigation.useNavigation)();
    const {
      key: routeKey
    } = (0, _useRoute.useRoute)();
    const {
      setPreventRemove
    } = (0, _usePreventRemoveContext.usePreventRemoveContext)();
    React.useEffect(() => {
      setPreventRemove(id, routeKey, preventRemove);
      return () => {
        setPreventRemove(id, routeKey, false);
      };
    }, [setPreventRemove, id, routeKey, preventRemove]);
    const beforeRemoveListener = (0, _useLatestCallback.default)(e => {
      if (!preventRemove) {
        return;
      }
      e.preventDefault();
      callback({
        data: e.data
      });
    });
    React.useEffect(() => navigation?.addListener('beforeRemove', beforeRemoveListener), [navigation, beforeRemoveListener]);
  }
},447,[17,900,3,362,421,448,417],"node_modules\\@react-navigation\\core\\lib\\module\\usePreventRemove.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.usePreventRemoveContext = usePreventRemoveContext;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _PreventRemoveContext = require(_dependencyMap[1], "./PreventRemoveContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function usePreventRemoveContext() {
    const value = React.useContext(_PreventRemoveContext.PreventRemoveContext);
    if (value == null) {
      throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
    }
    return value;
  }
},448,[3,409],"node_modules\\@react-navigation\\core\\lib\\module\\usePreventRemoveContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useStateForPath = useStateForPath;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _NavigationFocusedRouteStateContext = require(_dependencyMap[1], "./NavigationFocusedRouteStateContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to get a minimal state representation for the current route.
   * The returned state can be used with `getPathFromState` to build a path.
   *
   * @returns Minimal state to build a path for the current route.
   */
  function useStateForPath() {
    const state = React.useContext(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext);
    return state;
  }
},449,[3,428],"node_modules\\@react-navigation\\core\\lib\\module\\useStateForPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationContainer = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _core = require(_dependencyMap[2], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _I18nManager = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/I18nManager"));
  var _useLatestCallback = _interopRequireDefault(require(_dependencyMap[5], "use-latest-callback"));
  var _LinkingContext = require(_dependencyMap[6], "./LinkingContext.js");
  var _LocaleDirContext = require(_dependencyMap[7], "./LocaleDirContext.js");
  var _DefaultTheme = require(_dependencyMap[8], "./theming/DefaultTheme.js");
  var _UnhandledLinkingContext = require(_dependencyMap[9], "./UnhandledLinkingContext.js");
  var _useBackButton = require(_dependencyMap[10], "./useBackButton");
  var _useDocumentTitle = require(_dependencyMap[11], "./useDocumentTitle");
  var _useLinking = require(_dependencyMap[12], "./useLinking");
  var _useThenable = require(_dependencyMap[13], "./useThenable.js");
  var _jsxRuntime = require(_dependencyMap[14], "react/jsx-runtime");
  const _excluded = ["direction", "theme", "linking", "fallback", "documentTitle", "onReady", "onStateChange"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
  /**
   * Container component which holds the navigation state designed for React Native apps.
   * This should be rendered at the root wrapping the whole app.
   *
   * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
   * @param props.onReady Callback which is called after the navigation tree mounts.
   * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
   * @param props.onUnhandledAction Callback which is called when an action is not handled.
   * @param props.direction Text direction of the components. Defaults to `'ltr'`.
   * @param props.theme Theme object for the UI elements.
   * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
   * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
   * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which refers to the navigation object containing helper methods.
   */
  function NavigationContainerInner(_ref, ref) {
    let {
        direction = _I18nManager.default.getConstants().isRTL ? 'rtl' : 'ltr',
        theme = _DefaultTheme.DefaultTheme,
        linking,
        fallback = null,
        documentTitle,
        onReady,
        onStateChange
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking?.config) {
      (0, _core.validatePathConfig)(linking.config);
    }
    const refContainer = React.useRef(null);
    (0, _useBackButton.useBackButton)(refContainer);
    (0, _useDocumentTitle.useDocumentTitle)(refContainer, documentTitle);
    const [lastUnhandledLink, setLastUnhandledLink] = React.useState();
    const {
      getInitialState
    } = (0, _useLinking.useLinking)(refContainer, Object.assign({
      enabled: isLinkingEnabled,
      prefixes: []
    }, linking), setLastUnhandledLink);
    const linkingContext = React.useMemo(() => ({
      options: linking
    }), [linking]);
    const unhandledLinkingContext = React.useMemo(() => ({
      lastUnhandledLink,
      setLastUnhandledLink
    }), [lastUnhandledLink, setLastUnhandledLink]);
    const onReadyForLinkingHandling = (0, _useLatestCallback.default)(() => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onReady?.();
    });
    const onStateChangeForLinkingHandling = (0, _useLatestCallback.default)(state => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onStateChange?.(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    React.useEffect(() => {
      if (refContainer.current) {
        REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
          get linking() {
            return Object.assign({}, linking, {
              enabled: isLinkingEnabled,
              prefixes: linking?.prefixes ?? [],
              getStateFromPath: linking?.getStateFromPath ?? _core.getStateFromPath,
              getPathFromState: linking?.getPathFromState ?? _core.getPathFromState,
              getActionFromState: linking?.getActionFromState ?? _core.getActionFromState
            });
          }
        });
      }
    });
    const [isResolved, initialState] = (0, _useThenable.useThenable)(getInitialState);

    // FIXME
    // @ts-expect-error not sure why this is not working
    React.useImperativeHandle(ref, () => refContainer.current);
    const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_LocaleDirContext.LocaleDirContext.Provider, {
        value: direction,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_core.ThemeProvider, {
          value: theme,
          children: fallback
        })
      });
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_LocaleDirContext.LocaleDirContext.Provider, {
      value: direction,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_UnhandledLinkingContext.UnhandledLinkingContext.Provider, {
        value: unhandledLinkingContext,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_LinkingContext.LinkingContext.Provider, {
          value: linkingContext,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_core.BaseNavigationContainer, Object.assign({}, rest, {
            theme: theme,
            onReady: onReadyForLinkingHandling,
            onStateChange: onStateChangeForLinkingHandling,
            initialState: rest.initialState == null ? initialState : rest.initialState,
            ref: refContainer
          }))
        })
      })
    });
  }
  const NavigationContainer = exports.NavigationContainer = /*#__PURE__*/React.forwardRef(NavigationContainerInner);
},450,[17,29,352,3,218,362,451,452,453,455,456,457,458,462,6],"node_modules\\@react-navigation\\native\\lib\\module\\NavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LinkingContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MISSING_CONTEXT_ERROR = "Couldn't find a LinkingContext context.";
  const LinkingContext = exports.LinkingContext = /*#__PURE__*/React.createContext({
    get options() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
  LinkingContext.displayName = 'LinkingContext';
},451,[3],"node_modules\\@react-navigation\\native\\lib\\module\\LinkingContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocaleDirContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const LocaleDirContext = exports.LocaleDirContext = /*#__PURE__*/React.createContext('ltr');
  LocaleDirContext.displayName = 'LocaleDirContext';
},452,[3],"node_modules\\@react-navigation\\native\\lib\\module\\LocaleDirContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DefaultTheme = void 0;
  var _fonts = require(_dependencyMap[0], "./fonts.js");
  const DefaultTheme = exports.DefaultTheme = {
    dark: false,
    colors: {
      primary: 'rgb(0, 122, 255)',
      background: 'rgb(242, 242, 242)',
      card: 'rgb(255, 255, 255)',
      text: 'rgb(28, 28, 30)',
      border: 'rgb(216, 216, 216)',
      notification: 'rgb(255, 59, 48)'
    },
    fonts: _fonts.fonts
  };
},453,[454],"node_modules\\@react-navigation\\native\\lib\\module\\theming\\DefaultTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fonts = void 0;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Platform"));
  const WEB_FONT_STACK = 'system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
  const fonts = exports.fonts = _Platform.default.select({
    web: {
      regular: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '400'
      },
      medium: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '500'
      },
      bold: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '600'
      },
      heavy: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '700'
      }
    },
    ios: {
      regular: {
        fontFamily: 'System',
        fontWeight: '400'
      },
      medium: {
        fontFamily: 'System',
        fontWeight: '500'
      },
      bold: {
        fontFamily: 'System',
        fontWeight: '600'
      },
      heavy: {
        fontFamily: 'System',
        fontWeight: '700'
      }
    },
    default: {
      regular: {
        fontFamily: 'sans-serif',
        fontWeight: 'normal'
      },
      medium: {
        fontFamily: 'sans-serif-medium',
        fontWeight: 'normal'
      },
      bold: {
        fontFamily: 'sans-serif',
        fontWeight: '600'
      },
      heavy: {
        fontFamily: 'sans-serif',
        fontWeight: '700'
      }
    }
  });
},454,[17,106],"node_modules\\@react-navigation\\native\\lib\\module\\theming\\fonts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UnhandledLinkingContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MISSING_CONTEXT_ERROR = "Couldn't find an UnhandledLinkingContext context.";
  const UnhandledLinkingContext = exports.UnhandledLinkingContext = /*#__PURE__*/React.createContext({
    get lastUnhandledLink() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setLastUnhandledLink() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
  UnhandledLinkingContext.displayName = 'UnhandledLinkingContext';
},455,[3],"node_modules\\@react-navigation\\native\\lib\\module\\UnhandledLinkingContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useBackButton = useBackButton;
  function useBackButton(_) {
    // No-op
    // BackHandler is not available on web
  }
},456,[],"node_modules\\@react-navigation\\native\\lib\\module\\useBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDocumentTitle = useDocumentTitle;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Set the document title for the active screen
   */
  function useDocumentTitle(ref, {
    enabled = true,
    formatter = (options, route) => options?.title ?? route?.name
  } = {}) {
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const navigation = ref.current;
      if (navigation) {
        const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());
        document.title = title;
      }
      return navigation?.addListener('options', e => {
        const title = formatter(e.data.options, navigation?.getCurrentRoute());
        document.title = title;
      });
    });
  }
},457,[3],"node_modules\\@react-navigation\\native\\lib\\module\\useDocumentTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.series = void 0;
  exports.useLinking = useLinking;
  var _core = require(_dependencyMap[1], "@react-navigation/core");
  var _fastDeepEqual = _interopRequireDefault(require(_dependencyMap[2], "fast-deep-equal"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _createMemoryHistory = require(_dependencyMap[4], "./createMemoryHistory.js");
  var _ServerContext = require(_dependencyMap[5], "./ServerContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Find the matching navigation state that changed between 2 navigation states
   * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state
   */
  const findMatchingState = (a, b) => {
    if (a === undefined || b === undefined || a.key !== b.key) {
      return [undefined, undefined];
    }

    // Tab and drawer will have `history` property, but stack will have history in `routes`
    const aHistoryLength = a.history ? a.history.length : a.routes.length;
    const bHistoryLength = b.history ? b.history.length : b.routes.length;
    const aRoute = a.routes[a.index];
    const bRoute = b.routes[b.index];
    const aChildState = aRoute.state;
    const bChildState = bRoute.state;

    // Stop here if this is the state object that changed:
    // - history length is different
    // - focused routes are different
    // - one of them doesn't have child state
    // - child state keys are different
    if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {
      return [a, b];
    }
    return findMatchingState(aChildState, bChildState);
  };

  /**
   * Run async function in series as it's called.
   */
  const series = cb => {
    let queue = Promise.resolve();
    const callback = () => {
      // eslint-disable-next-line promise/no-callback-in-promise
      queue = queue.then(cb);
    };
    return callback;
  };
  exports.series = series;
  const linkingHandlers = [];
  function useLinking(ref, {
    enabled = true,
    config,
    getStateFromPath = _core.getStateFromPath,
    getPathFromState = _core.getPathFromState,
    getActionFromState = _core.getActionFromState
  }, onUnhandledLinking) {
    const independent = (0, _core.useNavigationIndependentTree)();
    React.useEffect(() => {
      if (process.env.NODE_ENV === 'production') {
        return undefined;
      }
      if (independent) {
        return undefined;
      }
      if (enabled !== false && linkingHandlers.length) {
        console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered'].join('\n').trim());
      }
      const handler = Symbol();
      if (enabled !== false) {
        linkingHandlers.push(handler);
      }
      return () => {
        const index = linkingHandlers.indexOf(handler);
        if (index > -1) {
          linkingHandlers.splice(index, 1);
        }
      };
    }, [enabled, independent]);
    const [history] = React.useState(_createMemoryHistory.createMemoryHistory);

    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    const enabledRef = React.useRef(enabled);
    const configRef = React.useRef(config);
    const getStateFromPathRef = React.useRef(getStateFromPath);
    const getPathFromStateRef = React.useRef(getPathFromState);
    const getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(() => {
      enabledRef.current = enabled;
      configRef.current = config;
      getStateFromPathRef.current = getStateFromPath;
      getPathFromStateRef.current = getPathFromState;
      getActionFromStateRef.current = getActionFromState;
    });
    const validateRoutesNotExistInRootState = React.useCallback(state => {
      const navigation = ref.current;
      const rootState = navigation?.getRootState();
      // Make sure that the routes in the state exist in the root navigator
      // Otherwise there's an error in the linking configuration
      return state?.routes.some(r => !rootState?.routeNames.includes(r.name));
    }, [ref]);
    const server = React.useContext(_ServerContext.ServerContext);
    const getInitialState = React.useCallback(() => {
      let value;
      if (enabledRef.current) {
        const location = server?.location ?? (typeof window !== 'undefined' ? window.location : undefined);
        const path = location ? location.pathname + location.search : undefined;
        if (path) {
          value = getStateFromPathRef.current(path, configRef.current);
        }

        // If the link were handled, it gets cleared in NavigationContainer
        onUnhandledLinking(path);
      }
      const thenable = {
        then(onfulfilled) {
          return Promise.resolve(onfulfilled ? onfulfilled(value) : value);
        },
        catch() {
          return thenable;
        }
      };
      return thenable;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const previousIndexRef = React.useRef(undefined);
    const previousStateRef = React.useRef(undefined);
    const pendingPopStatePathRef = React.useRef(undefined);
    React.useEffect(() => {
      previousIndexRef.current = history.index;
      return history.listen(() => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const {
          location
        } = window;
        const path = location.pathname + location.search;
        const index = history.index;
        const previousIndex = previousIndexRef.current ?? 0;
        previousIndexRef.current = index;
        pendingPopStatePathRef.current = path;

        // When browser back/forward is clicked, we first need to check if state object for this index exists
        // If it does we'll reset to that state object
        // Otherwise, we'll handle it like a regular deep link
        const record = history.get(index);
        if (record?.path === path && record?.state) {
          navigation.resetRoot(record.state);
          return;
        }
        const state = getStateFromPathRef.current(path, configRef.current);

        // We should only dispatch an action when going forward
        // Otherwise the action will likely add items to history, which would mess things up
        if (state) {
          // If the link were handled, it gets cleared in NavigationContainer
          onUnhandledLinking(path);
          // Make sure that the routes in the state exist in the root navigator
          // Otherwise there's an error in the linking configuration
          if (validateRoutesNotExistInRootState(state)) {
            return;
          }
          if (index > previousIndex) {
            const action = getActionFromStateRef.current(state, configRef.current);
            if (action !== undefined) {
              try {
                navigation.dispatch(action);
              } catch (e) {
                // Ignore any errors from deep linking.
                // This could happen in case of malformed links, navigation object not being initialized etc.
                console.warn(`An error occurred when trying to handle the link '${path}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
              }
            } else {
              navigation.resetRoot(state);
            }
          } else {
            navigation.resetRoot(state);
          }
        } else {
          // if current path didn't return any state, we should revert to initial state
          navigation.resetRoot(state);
        }
      });
    }, [enabled, history, onUnhandledLinking, ref, validateRoutesNotExistInRootState]);
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const getPathForRoute = (route, state) => {
        let path;

        // If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match
        // This makes sure that we preserve the original URL for wildcard routes
        if (route?.path) {
          const stateForPath = getStateFromPathRef.current(route.path, configRef.current);
          if (stateForPath) {
            const focusedRoute = (0, _core.findFocusedRoute)(stateForPath);
            if (focusedRoute && focusedRoute.name === route.name && (0, _fastDeepEqual.default)(focusedRoute.params, route.params)) {
              path = route.path;
            }
          }
        }
        if (path == null) {
          path = getPathFromStateRef.current(state, configRef.current);
        }
        const previousRoute = previousStateRef.current ? (0, _core.findFocusedRoute)(previousStateRef.current) : undefined;

        // Preserve the hash if the route didn't change
        if (previousRoute && route && 'key' in previousRoute && 'key' in route && previousRoute.key === route.key) {
          path = path + location.hash;
        }
        return path;
      };
      if (ref.current) {
        // We need to record the current metadata on the first render if they aren't set
        // This will allow the initial state to be in the history entry
        const state = ref.current.getRootState();
        if (state) {
          const route = (0, _core.findFocusedRoute)(state);
          const path = getPathForRoute(route, state);
          if (previousStateRef.current === undefined) {
            previousStateRef.current = state;
          }
          history.replace({
            path,
            state
          });
        }
      }
      const onStateChange = async () => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const previousState = previousStateRef.current;
        const state = navigation.getRootState();

        // root state may not available, for example when root navigators switch inside the container
        if (!state) {
          return;
        }
        const pendingPath = pendingPopStatePathRef.current;
        const route = (0, _core.findFocusedRoute)(state);
        const path = getPathForRoute(route, state);
        previousStateRef.current = state;
        pendingPopStatePathRef.current = undefined;

        // To detect the kind of state change, we need to:
        // - Find the common focused navigation state in previous and current state
        // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace
        // - If no common focused navigation state found, it's a replace
        const [previousFocusedState, focusedState] = findMatchingState(previousState, state);
        if (previousFocusedState && focusedState &&
        // We should only handle push/pop if path changed from what was in last `popstate`
        // Otherwise it's likely a change triggered by `popstate`
        path !== pendingPath) {
          const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
          if (historyDelta > 0) {
            // If history length is increased, we should pushState
            // Note that path might not actually change here, for example, drawer open should pushState
            history.push({
              path,
              state
            });
          } else if (historyDelta < 0) {
            // If history length is decreased, i.e. entries were removed, we want to go back

            const nextIndex = history.backIndex({
              path
            });
            const currentIndex = history.index;
            try {
              if (nextIndex !== -1 && nextIndex < currentIndex &&
              // We should only go back if the entry exists and it's less than current index
              history.get(nextIndex)) {
                // An existing entry for this path exists and it's less than current index, go back to that
                await history.go(nextIndex - currentIndex);
              } else {
                // We couldn't find an existing entry to go back to, so we'll go back by the delta
                // This won't be correct if multiple routes were pushed in one go before
                // Usually this shouldn't happen and this is a fallback for that
                await history.go(historyDelta);
              }

              // Store the updated state as well as fix the path if incorrect
              history.replace({
                path,
                state
              });
            } catch (e) {
              // The navigation was interrupted
            }
          } else {
            // If history length is unchanged, we want to replaceState
            history.replace({
              path,
              state
            });
          }
        } else {
          // If no common navigation state was found, assume it's a replace
          // This would happen if the user did a reset/conditionally changed navigators
          history.replace({
            path,
            state
          });
        }
      };

      // We debounce onStateChange coz we don't want multiple state changes to be handled at one time
      // This could happen since `history.go(n)` is asynchronous
      // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up
      return ref.current?.addListener('state', series(onStateChange));
    }, [enabled, history, ref]);
    return {
      getInitialState
    };
  }
},458,[17,352,459,3,460,461],"node_modules\\@react-navigation\\native\\lib\\module\\useLinking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  // do not edit .js files directly - edit src/index.jst
  module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b;
  };
},459,[],"node_modules\\fast-deep-equal\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createMemoryHistory = createMemoryHistory;
  var _nonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  function createMemoryHistory() {
    let index = 0;
    let items = [];

    // Pending callbacks for `history.go(n)`
    // We might modify the callback stored if it was interrupted, so we have a ref to identify it
    const pending = [];
    const interrupt = () => {
      // If another history operation was performed we need to interrupt existing ones
      // This makes sure that calls such as `history.replace` after `history.go` don't happen
      // Since otherwise it won't be correct if something else has changed
      pending.forEach(it => {
        const cb = it.cb;
        it.cb = () => cb(true);
      });
    };
    const history = {
      get index() {
        // We store an id in the state instead of an index
        // Index could get out of sync with in-memory values if page reloads
        const id = window.history.state?.id;
        if (id) {
          const index = items.findIndex(item => item.id === id);
          return index > -1 ? index : 0;
        }
        return 0;
      },
      get(index) {
        return items[index];
      },
      backIndex({
        path
      }) {
        // We need to find the index from the element before current to get closest path to go back to
        for (let i = index - 1; i >= 0; i--) {
          const item = items[i];
          if (item.path === path) {
            return i;
          }
        }
        return -1;
      },
      push({
        path,
        state
      }) {
        interrupt();
        const id = (0, _nonSecure.nanoid)();

        // When a new entry is pushed, all the existing entries after index will be inaccessible
        // So we remove any existing entries after the current index to clean them up
        items = items.slice(0, index + 1);
        items.push({
          path,
          state,
          id
        });
        index = items.length - 1;

        // We pass empty string for title because it's ignored in all browsers except safari
        // We don't store state object in history.state because:
        // - browsers have limits on how big it can be, and we don't control the size
        // - while not recommended, there could be non-serializable data in state
        window.history.pushState({
          id
        }, '', path);
      },
      replace({
        path,
        state
      }) {
        interrupt();
        const id = window.history.state?.id ?? (0, _nonSecure.nanoid)();

        // Need to keep the hash part of the path if there was no previous history entry
        // or the previous history entry had the same path
        let pathWithHash = path;
        const hash = pathWithHash.includes('#') ? '' : location.hash;
        if (!items.length || items.findIndex(item => item.id === id) < 0) {
          // There are two scenarios for creating an array with only one history record:
          // - When loaded id not found in the items array, this function by default will replace
          //   the first item. We need to keep only the new updated object, otherwise it will break
          //   the page when navigating forward in history.
          // - This is the first time any state modifications are done
          //   So we need to push the entry as there's nothing to replace

          pathWithHash = pathWithHash + hash;
          items = [{
            path: pathWithHash,
            state,
            id
          }];
          index = 0;
        } else {
          if (items[index].path === path) {
            pathWithHash = pathWithHash + hash;
          }
          items[index] = {
            path,
            state,
            id
          };
        }
        window.history.replaceState({
          id
        }, '', pathWithHash);
      },
      // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
      // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
      // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.
      // - the `popstate` event fires before the next frame after calling `history.go(n)`.
      // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.
      go(n) {
        interrupt();

        // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory
        // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.
        const nextIndex = index + n;
        const lastItemIndex = items.length - 1;
        if (n < 0 && !items[nextIndex]) {
          // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.
          n = -index;
          index = 0;
        } else if (n > 0 && nextIndex > lastItemIndex) {
          // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.
          n = lastItemIndex - index;
          index = lastItemIndex;
        } else {
          index = nextIndex;
        }
        if (n === 0) {
          return;
        }

        // When we call `history.go`, `popstate` will fire when there's history to go back to
        // So we need to somehow handle following cases:
        // - There's history to go back, `history.go` is called, and `popstate` fires
        // - `history.go` is called multiple times, we need to resolve on respective `popstate`
        // - No history to go back, but `history.go` was called, browser has no API to detect it
        return new Promise((resolve, reject) => {
          const done = interrupted => {
            clearTimeout(timer);
            if (interrupted) {
              reject(new Error('History was changed during navigation.'));
              return;
            }

            // There seems to be a bug in Chrome regarding updating the title
            // If we set a title just before calling `history.go`, the title gets lost
            // However the value of `document.title` is still what we set it to
            // It's just not displayed in the tab bar
            // To update the tab bar, we need to reset the title to something else first (e.g. '')
            // And set the title to what it was before so it gets applied
            // It won't work without setting it to empty string coz otherwise title isn't changing
            // Which means that the browser won't do anything after setting the title
            const {
              title
            } = window.document;
            window.document.title = '';
            window.document.title = title;
            resolve();
          };
          pending.push({
            ref: done,
            cb: done
          });

          // If navigation didn't happen within 100ms, assume that it won't happen
          // This may not be accurate, but hopefully it won't take so much time
          // In Chrome, navigation seems to happen instantly in next microtask
          // But on Firefox, it seems to take much longer, around 50ms from our testing
          // We're using a hacky timeout since there doesn't seem to be way to know for sure
          const timer = setTimeout(() => {
            const foundIndex = pending.findIndex(it => it.ref === done);
            if (foundIndex > -1) {
              pending[foundIndex].cb();
              pending.splice(foundIndex, 1);
            }
            index = this.index;
          }, 100);
          const onPopState = () => {
            // Fix createMemoryHistory.index variable's value
            // as it may go out of sync when navigating in the browser.
            index = this.index;
            const last = pending.pop();
            window.removeEventListener('popstate', onPopState);
            last?.cb();
          };
          window.addEventListener('popstate', onPopState);
          window.history.go(n);
        });
      },
      // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`
      // If we call `history.go(n)` ourselves, we don't want it to trigger the listener
      // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener
      listen(listener) {
        const onPopState = () => {
          // Fix createMemoryHistory.index variable's value
          // as it may go out of sync when navigating in the browser.
          index = this.index;
          if (pending.length) {
            // This was triggered by `history.go(n)`, we shouldn't call the listener
            return;
          }
          listener();
        };
        window.addEventListener('popstate', onPopState);
        return () => window.removeEventListener('popstate', onPopState);
      }
    };
    return history;
  }
},460,[900],"node_modules\\@react-navigation\\native\\lib\\module\\createMemoryHistory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ServerContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const ServerContext = exports.ServerContext = /*#__PURE__*/React.createContext(undefined);
},461,[3],"node_modules\\@react-navigation\\native\\lib\\module\\ServerContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useThenable = useThenable;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useThenable(create) {
    const [promise] = React.useState(create);
    let initialState = [false, undefined];

    // Check if our thenable is synchronous
    // eslint-disable-next-line promise/catch-or-return, promise/always-return
    promise.then(result => {
      initialState = [true, result];
    });
    const [state, setState] = React.useState(initialState);
    const [resolved] = state;
    React.useEffect(() => {
      let cancelled = false;
      const resolve = async () => {
        let result;
        try {
          result = await promise;
        } finally {
          if (!cancelled) {
            setState([true, result]);
          }
        }
      };
      if (!resolved) {
        resolve();
      }
      return () => {
        cancelled = true;
      };
    }, [promise, resolved]);
    return state;
  }
},462,[3],"node_modules\\@react-navigation\\native\\lib\\module\\useThenable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Link = Link;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var _core = require(_dependencyMap[3], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _Text = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Text"));
  var _useLinkProps = require(_dependencyMap[7], "./useLinkProps.js");
  const _excluded = ["screen", "params", "action", "href", "style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Component to render link to another screen using a path.
   * Uses an anchor tag on the web.
   *
   * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
   * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
   * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
   * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
   * @param props.children Child elements to render the content.
   */
  function Link(_ref) {
    let {
        screen,
        params,
        action,
        href,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _core.useTheme)();
    // @ts-expect-error: This is already type-checked by the prop types
    const props = (0, _useLinkProps.useLinkProps)({
      screen,
      params,
      action,
      href
    });
    const onPress = e => {
      if ('onPress' in rest) {
        rest.onPress?.(e);
      }

      // Let user prevent default behavior
      if (!e.defaultPrevented) {
        props.onPress(e);
      }
    };
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_Text.default, Object.assign({}, props, rest, _Platform.default.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress
      }
    }), {
      style: [{
        color: colors.primary
      }, fonts.regular, style]
    }));
  }
},463,[17,29,412,352,3,106,190,464],"node_modules\\@react-navigation\\native\\lib\\module\\Link.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLinkProps = useLinkProps;
  var _core = require(_dependencyMap[1], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _LinkingContext = require(_dependencyMap[4], "./LinkingContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const getStateFromParams = params => {
    if (params?.state) {
      return params.state;
    }
    if (params?.screen) {
      return {
        routes: [{
          name: params.screen,
          params: params.params,
          // @ts-expect-error this is fine 
          state: params.screen ? getStateFromParams(params.params) : undefined
        }]
      };
    }
    return undefined;
  };

  /**
   * Hook to get props for an anchor tag so it can work with in page navigation.
   *
   * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
   * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
   * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
   * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
   */
  function useLinkProps({
    screen,
    params,
    href,
    action
  }) {
    const root = React.useContext(_core.NavigationContainerRefContext);
    const navigation = React.useContext(_core.NavigationHelpersContext);
    const {
      options
    } = React.useContext(_LinkingContext.LinkingContext);
    const onPress = e => {
      let shouldHandle = false;
      if (_Platform.default.OS !== 'web' || !e) {
        e?.preventDefault?.();
        shouldHandle = true;
      } else {
        // ignore clicks with modifier keys
        const hasModifierKey = 'metaKey' in e && e.metaKey || 'altKey' in e && e.altKey || 'ctrlKey' in e && e.ctrlKey || 'shiftKey' in e && e.shiftKey;

        // only handle left clicks
        const isLeftClick = 'button' in e ? e.button == null || e.button === 0 : true;

        // let browser handle "target=_blank" etc.
        const isSelfTarget = e.currentTarget && 'target' in e.currentTarget ? [undefined, null, '', 'self'].includes(e.currentTarget.target) : true;
        if (!hasModifierKey && isLeftClick && isSelfTarget) {
          e.preventDefault?.();
          shouldHandle = true;
        }
      }
      if (shouldHandle) {
        if (action) {
          if (navigation) {
            navigation.dispatch(action);
          } else if (root) {
            root.dispatch(action);
          } else {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
          }
        } else {
          // @ts-expect-error This is already type-checked by the prop types
          navigation?.navigate(screen, params);
        }
      }
    };
    const getPathFromStateHelper = options?.getPathFromState ?? _core.getPathFromState;
    return {
      href: href ?? (_Platform.default.OS === 'web' && screen != null ? getPathFromStateHelper({
        routes: [{
          // @ts-expect-error this is fine 
          name: screen,
          // @ts-expect-error this is fine 
          params: params,
          // @ts-expect-error this is fine 
          state: getStateFromParams(params)
        }]
      }, options?.config) : undefined),
      role: 'link',
      onPress
    };
  }
},464,[17,352,3,106,451],"node_modules\\@react-navigation\\native\\lib\\module\\useLinkProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ServerContainer = void 0;
  var _core = require(_dependencyMap[0], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _ServerContext = require(_dependencyMap[2], "./ServerContext.js");
  var _jsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Container component for server rendering.
   *
   * @param props.location Location object to base the initial URL for SSR.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which contains helper methods.
   */
  const ServerContainer = exports.ServerContainer = /*#__PURE__*/React.forwardRef(function ServerContainer({
    children,
    location
  }, ref) {
    React.useEffect(() => {
      console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);

    // eslint-disable-next-line @eslint-react/no-unstable-context-value
    const current = {};
    if (ref) {
      const value = {
        getCurrentOptions() {
          return current.options;
        }
      };

      // We write to the `ref` during render instead of `React.useImperativeHandle`
      // This is because `useImperativeHandle` will update the ref after 'commit',
      // and there's no 'commit' phase during SSR.
      // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
      if (typeof ref === 'function') {
        ref(value);
      } else {
        ref.current = value;
      }
    }
    return (/*#__PURE__*/
      // eslint-disable-next-line @eslint-react/no-unstable-context-value
      (0, _jsxRuntime.jsx)(_ServerContext.ServerContext.Provider, {
        value: {
          location
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_core.CurrentRenderContext.Provider, {
          value: current,
          children: children
        })
      })
    );
  });
},465,[352,3,461,6],"node_modules\\@react-navigation\\native\\lib\\module\\ServerContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DarkTheme = void 0;
  var _fonts = require(_dependencyMap[0], "./fonts.js");
  const DarkTheme = exports.DarkTheme = {
    dark: true,
    colors: {
      primary: 'rgb(10, 132, 255)',
      background: 'rgb(1, 1, 1)',
      card: 'rgb(18, 18, 18)',
      text: 'rgb(229, 229, 231)',
      border: 'rgb(39, 39, 41)',
      notification: 'rgb(255, 69, 58)'
    },
    fonts: _fonts.fonts
  };
},466,[454],"node_modules\\@react-navigation\\native\\lib\\module\\theming\\DarkTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},467,[],"node_modules\\@react-navigation\\native\\lib\\module\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLinkBuilder = useLinkBuilder;
  var _core = require(_dependencyMap[0], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _LinkingContext = require(_dependencyMap[2], "./LinkingContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Helpers to build href or action based on the linking options.
   *
   * @returns `buildHref` to build an `href` for screen and `buildAction` to build an action from an `href`.
   */
  function useLinkBuilder() {
    const navigation = React.useContext(_core.NavigationHelpersContext);
    const route = React.useContext(_core.NavigationRouteContext);
    const {
      options
    } = React.useContext(_LinkingContext.LinkingContext);
    const focusedRouteState = (0, _core.useStateForPath)();
    const getPathFromStateHelper = options?.getPathFromState ?? _core.getPathFromState;
    const getStateFromPathHelper = options?.getStateFromPath ?? _core.getStateFromPath;
    const getActionFromStateHelper = options?.getActionFromState ?? _core.getActionFromState;
    const buildHref = React.useCallback((name, params) => {
      if (options?.enabled === false) {
        return undefined;
      }

      // Check that we're inside:
      // - navigator's context
      // - route context of the navigator (could be a screen, tab, etc.)
      // - route matches the state for path (from the screen's context)
      // This ensures that we're inside a screen
      const isScreen = navigation && route?.key && focusedRouteState ? route.key === (0, _core.findFocusedRoute)(focusedRouteState)?.key && navigation.getState().routes.some(r => r.key === route.key) : false;
      const stateForRoute = {
        routes: [{
          name,
          params
        }]
      };
      const constructState = state => {
        if (state) {
          const route = state.routes[0];

          // If we're inside a screen and at the innermost route
          // We need to replace the state with the provided one
          // This assumes that we're navigating to a sibling route
          if (isScreen && !route.state) {
            return stateForRoute;
          }

          // Otherwise, dive into the nested state of the route
          return {
            routes: [Object.assign({}, route, {
              state: constructState(route.state)
            })]
          };
        }

        // Once there is no more nested state, we're at the innermost route
        // We can add a state based on provided parameters
        // This assumes that we're navigating to a child of this route
        // In this case, the helper is used in a navigator for its routes
        return stateForRoute;
      };
      const state = constructState(focusedRouteState);
      const path = getPathFromStateHelper(state, options?.config);
      return path;
    }, [options?.enabled, options?.config, route?.key, navigation, focusedRouteState, getPathFromStateHelper]);
    const buildAction = React.useCallback(href => {
      if (!href.startsWith('/')) {
        throw new Error(`The href must start with '/' (${href}).`);
      }
      const state = getStateFromPathHelper(href, options?.config);
      if (state) {
        const action = getActionFromStateHelper(state, options?.config);
        return action ?? _core.CommonActions.reset(state);
      } else {
        throw new Error('Failed to parse the href to a navigation state.');
      }
    }, [options?.config, getStateFromPathHelper, getActionFromStateHelper]);
    return {
      buildHref,
      buildAction
    };
  }
},468,[352,3,451],"node_modules\\@react-navigation\\native\\lib\\module\\useLinkBuilder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLinkTo = useLinkTo;
  var _core = require(_dependencyMap[0], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _useLinkBuilder = require(_dependencyMap[2], "./useLinkBuilder.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Helper to navigate to a screen using a href based on the linking options.
   *
   * @returns function that receives the href to navigate to.
   */
  function useLinkTo() {
    const navigation = React.useContext(_core.NavigationContainerRefContext);
    const {
      buildAction
    } = (0, _useLinkBuilder.useLinkBuilder)();
    const linkTo = React.useCallback(href => {
      if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
      }
      const action = buildAction(href);
      navigation.dispatch(action);
    }, [buildAction, navigation]);
    return linkTo;
  }
},469,[352,3,468],"node_modules\\@react-navigation\\native\\lib\\module\\useLinkTo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLocale = useLocale;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _LocaleDirContext = require(_dependencyMap[1], "./LocaleDirContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Hook to access the text direction specified in the `NavigationContainer`.
   */
  function useLocale() {
    const direction = React.useContext(_LocaleDirContext.LocaleDirContext);
    if (direction === undefined) {
      throw new Error("Couldn't determine the text direction. Is your component inside NavigationContainer?");
    }
    return {
      direction
    };
  }
},470,[3,452],"node_modules\\@react-navigation\\native\\lib\\module\\useLocale.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useScrollToTop = useScrollToTop;
  var _core = require(_dependencyMap[0], "@react-navigation/core");
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function getScrollableNode(ref) {
    if (ref.current == null) {
      return null;
    }
    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
      // This is already a scrollable node.
      return ref.current;
    } else if ('getScrollResponder' in ref.current) {
      // If the view is a wrapper like FlatList, SectionList etc.
      // We need to use `getScrollResponder` to get access to the scroll responder
      return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
      // When a `ScrollView` is wrapped in `Animated.createAnimatedComponent`
      // we need to use `getNode` to get the ref to the actual scrollview.
      // Note that `getNode` is deprecated in newer versions of react-native
      // this is why we check if we already have a scrollable node above.
      return ref.current.getNode();
    } else {
      return ref.current;
    }
  }
  function useScrollToTop(ref) {
    const navigation = React.useContext(_core.NavigationContext);
    const route = (0, _core.useRoute)();
    if (navigation === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    React.useEffect(() => {
      const tabNavigations = [];
      let currentNavigation = navigation;
      // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
      // So we need to find all the parent tab navigators and add the listeners there
      while (currentNavigation) {
        if (currentNavigation.getState().type === 'tab') {
          tabNavigations.push(currentNavigation);
        }
        currentNavigation = currentNavigation.getParent();
      }
      if (tabNavigations.length === 0) {
        return;
      }
      const unsubscribers = tabNavigations.map(tab => {
        return tab.addListener(
        // We don't wanna import tab types here to avoid extra deps
        // in addition, there are multiple tab implementations
        // @ts-expect-error the `tabPress` event is only available when navigation type is tab
        'tabPress', e => {
          // We should scroll to top only when the screen is focused
          const isFocused = navigation.isFocused();

          // In a nested stack navigator, tab press resets the stack to first screen
          // So we should scroll to top only when we are on first screen
          const isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;

          // Run the operation in the next frame so we're sure all listeners have been run
          // This is necessary to know if preventDefault() has been called
          requestAnimationFrame(() => {
            const scrollable = getScrollableNode(ref);
            if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
              if ('scrollToTop' in scrollable) {
                scrollable.scrollToTop();
              } else if ('scrollTo' in scrollable) {
                scrollable.scrollTo({
                  y: 0,
                  animated: true
                });
              } else if ('scrollToOffset' in scrollable) {
                scrollable.scrollToOffset({
                  offset: 0,
                  animated: true
                });
              } else if ('scrollResponderScrollTo' in scrollable) {
                scrollable.scrollResponderScrollTo({
                  y: 0,
                  animated: true
                });
              }
            }
          });
        });
      });
      return () => {
        unsubscribers.forEach(unsubscribe => unsubscribe());
      };
    }, [navigation, ref, route.key]);
  }
},471,[352,3],"node_modules\\@react-navigation\\native\\lib\\module\\useScrollToTop.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getServerResources = getServerResources;
  exports.registerStaticFont = registerStaticFont;
  exports.resetServerContext = resetServerContext;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ExpoFontLoader = _interopRequireDefault(require(_dependencyMap[2], "./ExpoFontLoader"));
  var _FontLoader = require(_dependencyMap[3], "./FontLoader");
  /**
   * @returns the server resources that should be statically extracted.
   * @private
   */
  function getServerResources() {
    return _ExpoFontLoader.default.getServerResources();
  }
  /**
   * @returns clear the server resources from the global scope.
   * @private
   */
  function resetServerContext() {
    return _ExpoFontLoader.default.resetServerContext();
  }
  function registerStaticFont(fontFamily, source) {
    // MUST BE A SYNC FUNCTION!
    if (!source) {
      throw new _expoModulesCore.CodedError(`ERR_FONT_SOURCE`, `Cannot load null or undefined font source: { "${fontFamily}": ${source} }. Expected asset of type \`FontSource\` for fontFamily of name: "${fontFamily}"`);
    }
    const asset = (0, _FontLoader.getAssetForSource)(source);
    (0, _FontLoader.loadSingleFontAsync)(fontFamily, asset);
  }
},472,[17,473,505,508],"node_modules\\expo-font\\build\\server.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    NativeModule: true,
    SharedObject: true,
    SharedRef: true,
    Platform: true,
    uuid: true,
    EventEmitter: true,
    requireNativeViewManager: true,
    CodedError: true,
    UnavailabilityError: true,
    LegacyEventEmitter: true,
    NativeModulesProxy: true
  };
  Object.defineProperty(exports, "CodedError", {
    enumerable: true,
    get: function () {
      return _CodedError.CodedError;
    }
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _EventEmitter.default;
    }
  });
  Object.defineProperty(exports, "LegacyEventEmitter", {
    enumerable: true,
    get: function () {
      return _LegacyEventEmitter.LegacyEventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _NativeModule.default;
    }
  });
  Object.defineProperty(exports, "NativeModulesProxy", {
    enumerable: true,
    get: function () {
      return _NativeModulesProxy.default;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _Platform.default;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _SharedObject.default;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _SharedRef.default;
    }
  });
  Object.defineProperty(exports, "UnavailabilityError", {
    enumerable: true,
    get: function () {
      return _UnavailabilityError.UnavailabilityError;
    }
  });
  Object.defineProperty(exports, "requireNativeViewManager", {
    enumerable: true,
    get: function () {
      return _NativeViewManagerAdapter.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "uuid", {
    enumerable: true,
    get: function () {
      return _uuid.default;
    }
  });
  require(_dependencyMap[1], "./sweet/setUpErrorManager.fx");
  require(_dependencyMap[2], "./web");
  var _NativeModule = _interopRequireDefault(require(_dependencyMap[3], "./NativeModule"));
  var _SharedObject = _interopRequireDefault(require(_dependencyMap[4], "./SharedObject"));
  var _SharedRef = _interopRequireDefault(require(_dependencyMap[5], "./SharedRef"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[6], "./Platform"));
  var _uuid = _interopRequireDefault(require(_dependencyMap[7], "./uuid"));
  var _EventEmitter = _interopRequireDefault(require(_dependencyMap[8], "./EventEmitter"));
  var _NativeViewManagerAdapter = require(_dependencyMap[9], "./NativeViewManagerAdapter");
  var _requireNativeModule = require(_dependencyMap[10], "./requireNativeModule");
  Object.keys(_requireNativeModule).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _requireNativeModule[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _requireNativeModule[key];
      }
    });
  });
  var _registerWebModule = require(_dependencyMap[11], "./registerWebModule");
  Object.keys(_registerWebModule).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _registerWebModule[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _registerWebModule[key];
      }
    });
  });
  var _TypedArrays = require(_dependencyMap[12], "./TypedArrays.types");
  Object.keys(_TypedArrays).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _TypedArrays[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _TypedArrays[key];
      }
    });
  });
  var _PermissionsInterface = require(_dependencyMap[13], "./PermissionsInterface");
  Object.keys(_PermissionsInterface).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _PermissionsInterface[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _PermissionsInterface[key];
      }
    });
  });
  var _PermissionsHook = require(_dependencyMap[14], "./PermissionsHook");
  Object.keys(_PermissionsHook).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _PermissionsHook[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _PermissionsHook[key];
      }
    });
  });
  var _Refs = require(_dependencyMap[15], "./Refs");
  Object.keys(_Refs).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Refs[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Refs[key];
      }
    });
  });
  var _useReleasingSharedObject = require(_dependencyMap[16], "./hooks/useReleasingSharedObject");
  Object.keys(_useReleasingSharedObject).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _useReleasingSharedObject[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _useReleasingSharedObject[key];
      }
    });
  });
  var _reload = require(_dependencyMap[17], "./reload");
  Object.keys(_reload).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _reload[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _reload[key];
      }
    });
  });
  var _CodedError = require(_dependencyMap[18], "./errors/CodedError");
  var _UnavailabilityError = require(_dependencyMap[19], "./errors/UnavailabilityError");
  var _LegacyEventEmitter = require(_dependencyMap[20], "./LegacyEventEmitter");
  var _NativeModulesProxy = _interopRequireDefault(require(_dependencyMap[21], "./NativeModulesProxy"));
},473,[17,474,475,484,486,487,488,477,490,491,494,495,496,497,498,499,500,501,493,492,502,504],"node_modules\\expo-modules-core\\src\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},474,[],"node_modules\\expo-modules-core\\src\\sweet\\setUpErrorManager.fx.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    registerWebGlobals: true
  };
  exports.registerWebGlobals = registerWebGlobals;
  var _CoreModule = require(_dependencyMap[1], "./CoreModule");
  var _uuid = _interopRequireDefault(require(_dependencyMap[2], "../uuid"));
  var _global = require(_dependencyMap[3], "../ts-declarations/global");
  Object.keys(_global).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _global[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _global[key];
      }
    });
  });
  // jest-expo imports to this file directly without going through the global types
  // Exporting the types to let jest-expo to know the globalThis types

  function registerWebGlobals() {
    if (globalThis.expo) return;
    globalThis.expo = {
      EventEmitter: _CoreModule.EventEmitter,
      NativeModule: _CoreModule.NativeModule,
      SharedObject: _CoreModule.SharedObject,
      SharedRef: _CoreModule.SharedRef,
      modules: globalThis.ExpoDomWebView?.expoModulesProxy ?? {},
      uuidv4: _uuid.default.v4,
      uuidv5: _uuid.default.v5,
      getViewConfig: () => {
        throw new Error('Method not implemented.');
      },
      reloadAppAsync: async () => {
        window.location.reload();
      }
    };
  }
  registerWebGlobals();
},475,[17,476,477,483],"node_modules\\expo-modules-core\\src\\web\\index.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SharedRef = exports.SharedObject = exports.NativeModule = exports.EventEmitter = void 0;
  class EventEmitter {
    addListener(eventName, listener) {
      if (!this.listeners) {
        this.listeners = new Map();
      }
      if (!this.listeners?.has(eventName)) {
        this.listeners?.set(eventName, new Set());
      }
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.add(listener);
      if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {
        this.startObserving(eventName);
      }
      return {
        remove: () => {
          this.removeListener(eventName, listener);
        }
      };
    }
    removeListener(eventName, listener) {
      const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);
      if (this.listenerCount(eventName) === 0 && hasRemovedListener) {
        this.stopObserving(eventName);
      }
    }
    removeAllListeners(eventName) {
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.clear();
      if (previousListenerCount > 0) {
        this.stopObserving(eventName);
      }
    }
    emit(eventName, ...args) {
      const listeners = new Set(this.listeners?.get(eventName));
      listeners.forEach(listener => {
        // When the listener throws an error, don't stop the execution of subsequent listeners and
        // don't propagate the error to the `emit` function. The motivation behind this is that
        // errors thrown from a module or user's code shouldn't affect other modules' behavior.
        try {
          listener(...args);
        } catch (error) {
          console.error(error);
        }
      });
    }
    listenerCount(eventName) {
      return this.listeners?.get(eventName)?.size ?? 0;
    }
    startObserving(eventName) {}
    stopObserving(eventName) {}
  }
  exports.EventEmitter = EventEmitter;
  class NativeModule extends EventEmitter {}
  exports.NativeModule = NativeModule;
  class SharedObject extends EventEmitter {
    release() {
      // no-op on Web, but subclasses can override it if needed.
    }
  }
  exports.SharedObject = SharedObject;
  class SharedRef extends SharedObject {
    nativeRefType = 'unknown';
  }
  exports.SharedRef = SharedRef;
},476,[],"node_modules\\expo-modules-core\\src\\web\\CoreModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _uuid.default;
    }
  });
  var _uuid = _interopRequireDefault(require(_dependencyMap[1], "./uuid"));
},477,[17,478],"node_modules\\expo-modules-core\\src\\uuid\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _sha = _interopRequireDefault(require(_dependencyMap[1], "./lib/sha1"));
  var _v = _interopRequireDefault(require(_dependencyMap[2], "./lib/v35"));
  var _uuid = require(_dependencyMap[3], "./uuid.types");
  function uuidv4() {
    if (
    // We use this code path in jest-expo.
    process.env.NODE_ENV === 'test' ||
    // Node.js has supported global crypto since v15.
    typeof crypto === 'undefined' &&
    // Only use abstract imports in server environments.
    typeof window === 'undefined') {
      // NOTE: Metro statically extracts all `require` statements to resolve them for environments
      // that don't support `require` natively. Here we check if we're running in a server environment
      // by using the standard `typeof window` check, then running `eval` to skip Metro's static
      // analysis and keep the `require` statement intact for runtime evaluation.
      // eslint-disable-next-line no-eval
      return eval('require')('node:crypto').randomUUID();
    }
    return crypto.randomUUID();
  }
  const uuid = {
    v4: uuidv4,
    v5: (0, _v.default)('v5', 0x50, _sha.default),
    namespace: _uuid.Uuidv5Namespace
  };
  var _default = exports.default = uuid;
},478,[17,479,480,482],"node_modules\\expo-modules-core\\src\\uuid\\uuid.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Adapted from Chris Veness' SHA1 code at
  // http://www.movable-type.co.uk/scripts/sha1.html
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
      default:
        return 0;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    if (typeof bytes == 'string') {
      const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
      bytes = new Array(msg.length);
      for (let i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
    }
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; i++) {
      M[i] = new Array(16);
      for (let j = 0; j < 16; j++) {
        M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
      }
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for (let i = 0; i < N; i++) {
      const W = new Array(80);
      for (let t = 0; t < 16; t++) W[t] = M[i][t];
      for (let t = 16; t < 80; t++) {
        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
      }
      let a = H[0];
      let b = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      for (let t = 0; t < 80; t++) {
        const s = Math.floor(t / 20);
        const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
  }
  var _default = exports.default = sha1;
},479,[],"node_modules\\expo-modules-core\\src\\uuid\\lib\\sha1.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _bytesToUuid = _interopRequireDefault(require(_dependencyMap[1], "./bytesToUuid"));
  function uuidToBytes(uuid) {
    // Note: We assume we're being passed a valid uuid string
    const bytes = [];
    uuid.replace(/[a-fA-F0-9]{2}/g, hex => {
      bytes.push(parseInt(hex, 16));
      return '';
    });
    return bytes;
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = new Array(str.length);
    for (let i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  }
  function _default(name, version, hashfunc) {
    const generateUUID = function (value, namespace, buf, offset) {
      const off = buf && offset || 0;
      if (typeof value == 'string') value = stringToBytes(value);
      if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
      if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
      if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values');

      // Per 4.3
      const bytes = hashfunc(namespace.concat(value));
      bytes[6] = bytes[6] & 0x0f | version;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      if (buf) {
        for (let idx = 0; idx < 16; ++idx) {
          buf[off + idx] = bytes[idx];
        }
      }
      return (0, _bytesToUuid.default)(bytes);
    };

    // Function#name is not settable on some platforms (#270)
    try {
      generateUUID.name = name;
    } catch {}

    // Pre-defined namespaces, per Appendix C
    generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    return generateUUID;
  }
},480,[17,481],"node_modules\\expo-modules-core\\src\\uuid\\lib\\v35.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    let i = offset || 0;
    const bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
  }
  var _default = exports.default = bytesToUuid;
},481,[],"node_modules\\expo-modules-core\\src\\uuid\\lib\\bytesToUuid.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Uuidv5Namespace = void 0;
  /**
   * Collection of utilities used for generating Universally Unique Identifiers.
   */
  /**
   * Default namespaces for UUID v5 defined in RFC 4122
   */
  let Uuidv5Namespace = exports.Uuidv5Namespace = /*#__PURE__*/function (Uuidv5Namespace) {
    // Source of the UUIDs: https://datatracker.ietf.org/doc/html/rfc4122
    Uuidv5Namespace["dns"] = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["url"] = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["oid"] = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["x500"] = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
    return Uuidv5Namespace;
  }({});
},482,[],"node_modules\\expo-modules-core\\src\\uuid\\uuid.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},483,[],"node_modules\\expo-modules-core\\src\\ts-declarations\\global.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  var _default = exports.default = globalThis.expo.NativeModule;
},484,[485],"node_modules\\expo-modules-core\\src\\NativeModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ensureNativeModulesAreInstalled = ensureNativeModulesAreInstalled;
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/NativeModules"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  var _web = require(_dependencyMap[3], "./web");
  /**
   * Ensures that the native modules are installed in the current runtime.
   * Otherwise, it synchronously calls a native function that installs them.
   */
  function ensureNativeModulesAreInstalled() {
    if (globalThis.expo) {
      return;
    }
    try {
      if (_Platform.default.OS === 'web') {
        // Requiring web folder sets up the `globalThis.expo` object.
        (0, _web.registerWebGlobals)();
      } else {
        // TODO: ExpoModulesCore shouldn't be optional here,
        // but to keep backwards compatibility let's just ignore it in SDK 50.
        // In most cases the modules were already installed from the native side.
        _NativeModules.default.ExpoModulesCore?.installModules();
      }
    } catch (error) {
      console.error(`Unable to install Expo modules: ${error}`);
    }
  }
},485,[17,96,106,475],"node_modules\\expo-modules-core\\src\\ensureNativeModulesAreInstalled.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedObject = globalThis.expo.SharedObject;
  var _default = exports.default = SharedObject;
},486,[485],"node_modules\\expo-modules-core\\src\\SharedObject.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedRef = globalThis.expo.SharedRef;
  var _default = exports.default = SharedRef;
},487,[485],"node_modules\\expo-modules-core\\src\\SharedRef.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Platform"));
  var _browser = require(_dependencyMap[2], "./environment/browser");
  if (__DEV__ && typeof "web" === 'undefined') {
    console.warn(`The global process.env.EXPO_OS is not defined. This should be inlined by babel-preset-expo during transformation.`);
  }
  const nativeSelect = typeof window !== 'undefined' ? _Platform.default.select :
  // process.env.EXPO_OS is injected by `babel-preset-expo` and available in both client and `react-server` environments.
  // Opt to use the env var when possible, and fallback to the React Native Platform module when it's not (arbitrary bundlers and transformers).
  function select(specifics) {
    if (!"web") return undefined;
    if (specifics.hasOwnProperty("web")) {
      return specifics["web"];
    } else if (false && specifics.hasOwnProperty('native')) {
      return specifics.native;
    } else if (specifics.hasOwnProperty('default')) {
      return specifics.default;
    }
    // do nothing...
    return undefined;
  };
  const Platform = {
    /**
     * Denotes the currently running platform.
     * Can be one of ios, android, web.
     */
    OS: "web" || _Platform.default.OS,
    /**
     * Returns the value with the matching platform.
     * Object keys can be any of ios, android, native, web, default.
     *
     * @ios ios, native, default
     * @android android, native, default
     * @web web, default
     */
    select: nativeSelect,
    /**
     * Denotes if the DOM API is available in the current environment.
     * The DOM is not available in native React runtimes and Node.js.
     */
    isDOMAvailable: _browser.isDOMAvailable,
    /**
     * Denotes if the current environment can attach event listeners
     * to the window. This will return false in native React
     * runtimes and Node.js.
     */
    canUseEventListeners: _browser.canUseEventListeners,
    /**
     * Denotes if the current environment can inspect properties of the
     * screen on which the current window is being rendered. This will
     * return false in native React runtimes and Node.js.
     */
    canUseViewport: _browser.canUseViewport,
    /**
     * If the JavaScript is being executed in a remote JavaScript environment.
     * When `true`, synchronous native invocations cannot be executed.
     */
    isAsyncDebugging: _browser.isAsyncDebugging
  };
  var _default = exports.default = Platform;
},488,[17,106,489],"node_modules\\expo-modules-core\\src\\Platform.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDOMAvailable = exports.isAsyncDebugging = exports.canUseViewport = exports.canUseEventListeners = void 0;
  // Used for delegating node actions when browser APIs aren't available
  // like in SSR websites.
  const isDOMAvailable = exports.isDOMAvailable = typeof window !== 'undefined' && !!window.document?.createElement;
  const canUseEventListeners = exports.canUseEventListeners = isDOMAvailable && !!(window.addEventListener || window.attachEvent);
  const canUseViewport = exports.canUseViewport = isDOMAvailable && !!window.screen;
  const isAsyncDebugging = exports.isAsyncDebugging = false;
},489,[],"node_modules\\expo-modules-core\\src\\environment\\browser.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();

  /**
   * A subscription object that allows to conveniently remove an event listener from the emitter.
   */
  var _default = exports.default = globalThis.expo.EventEmitter;
},490,[485],"node_modules\\expo-modules-core\\src\\EventEmitter.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.requireNativeViewManager = requireNativeViewManager;
  var _UnavailabilityError = require(_dependencyMap[0], "./errors/UnavailabilityError");
  /**
   * A drop-in replacement for `requireNativeComponent`.
   */
  function requireNativeViewManager(moduleName, viewName) {
    throw new _UnavailabilityError.UnavailabilityError('expo-modules-core', 'requireNativeViewManager');
  }
},491,[492],"node_modules\\expo-modules-core\\src\\NativeViewManagerAdapter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UnavailabilityError = void 0;
  var _CodedError = require(_dependencyMap[1], "./CodedError");
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "../Platform"));
  /**
   * A class for errors to be thrown when a property is accessed which is
   * unavailable, unsupported, or not currently implemented on the running
   * platform.
   */
  class UnavailabilityError extends _CodedError.CodedError {
    constructor(moduleName, propertyName) {
      super('ERR_UNAVAILABLE', `The method or property ${moduleName}.${propertyName} is not available on ${_Platform.default.OS}, are you sure you've linked all the native dependencies properly?`);
    }
  }
  exports.UnavailabilityError = UnavailabilityError;
},492,[17,493,488],"node_modules\\expo-modules-core\\src\\errors\\UnavailabilityError.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CodedError = void 0;
  /**
   * A general error class that should be used for all errors in Expo modules.
   * Guarantees a `code` field that can be used to differentiate between different
   * types of errors without further subclassing Error.
   */
  class CodedError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
  exports.CodedError = CodedError;
},493,[],"node_modules\\expo-modules-core\\src\\errors\\CodedError.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.requireNativeModule = requireNativeModule;
  exports.requireOptionalNativeModule = requireOptionalNativeModule;
  function requireNativeModule(moduleName) {
    const nativeModule = requireOptionalNativeModule(moduleName);
    if (nativeModule != null) {
      return nativeModule;
    }
    if (typeof window === 'undefined') {
      // For SSR, we expect not to have native modules available, but to avoid crashing from SSR resolutions, we return an empty object.
      return {};
    }
    throw new Error(`Cannot find native module '${moduleName}'`);
  }
  function requireOptionalNativeModule(moduleName) {
    if (typeof globalThis.ExpoDomWebView === 'object' && globalThis?.expo?.modules != null) {
      return globalThis.expo?.modules?.[moduleName] ?? null;
    }
    return null;
  }
},494,[],"node_modules\\expo-modules-core\\src\\requireNativeModule.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.registerWebModule = registerWebModule;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  /**
   * Registers a web module.
   * @param moduleImplementation A class that extends `NativeModule`. The class is registered under `globalThis.expo.modules[className]`.
   * @param moduleName  a name to register the module under `globalThis.expo.modules[className]`.
   * @returns A singleton instance of the class passed into arguments.
   */

  function registerWebModule(moduleImplementation, moduleName) {
    (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
    moduleName = moduleName ?? moduleImplementation.name;
    if (!moduleName) {
      throw new Error('Web module implementation is missing a name - it is either not a class or has been minified. Pass the name as a second argument to the `registerWebModule` function.');
    }
    if (!globalThis?.expo?.modules) {
      globalThis.expo.modules = {};
    }
    if (globalThis.expo.modules[moduleName]) {
      return globalThis.expo.modules[moduleName];
    }
    globalThis.expo.modules[moduleName] = new moduleImplementation();
    return globalThis.expo.modules[moduleName];
  }
},495,[485],"node_modules\\expo-modules-core\\src\\registerWebModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},496,[],"node_modules\\expo-modules-core\\src\\TypedArrays.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PermissionStatus = void 0;
  let PermissionStatus = exports.PermissionStatus = /*#__PURE__*/function (PermissionStatus) {
    /**
     * User has granted the permission.
     */
    PermissionStatus["GRANTED"] = "granted";
    /**
     * User hasn't granted or denied the permission yet.
     */
    PermissionStatus["UNDETERMINED"] = "undetermined";
    /**
     * User has denied the permission.
     */
    PermissionStatus["DENIED"] = "denied";
    return PermissionStatus;
  }({});
  /**
   * Permission expiration time. Currently, all permissions are granted permanently.
   */
  /**
   * An object obtained by permissions get and request functions.
   */
},497,[],"node_modules\\expo-modules-core\\src\\PermissionsInterface.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Copyright  2024 650 Industries.

  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createPermissionHook = createPermissionHook;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = require(_dependencyMap[2], "react");
  const _excluded = ["get", "request"];
  // These types are identical, but improves the readability for suggestions in editors

  /**
   * Get or request permission for protected functionality within the app.
   * It uses separate permission requesters to interact with a single permission.
   * By default, the hook will only retrieve the permission status.
   */
  function usePermission(methods, options) {
    const isMounted = (0, _react.useRef)(true);
    const [status, setStatus] = (0, _react.useState)(null);
    const _ref = options || {},
      {
        get = true,
        request = false
      } = _ref,
      permissionOptions = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const getPermission = (0, _react.useCallback)(async () => {
      const response = await methods.getMethod(Object.keys(permissionOptions).length > 0 ? permissionOptions : undefined);
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.getMethod]);
    const requestPermission = (0, _react.useCallback)(async () => {
      const response = await methods.requestMethod(Object.keys(permissionOptions).length > 0 ? permissionOptions : undefined);
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.requestMethod]);
    (0, _react.useEffect)(function runMethods() {
      if (request) requestPermission();
      if (!request && get) getPermission();
    }, [get, request, requestPermission, getPermission]);

    // Workaround for unmounting components receiving state updates
    (0, _react.useEffect)(function didMount() {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return [status, requestPermission, getPermission];
  }

  /**
   * Create a new permission hook with the permission methods built-in.
   * This can be used to quickly create specific permission hooks in every module.
   */
  function createPermissionHook(methods) {
    return options => usePermission(methods, options);
  }
},498,[17,29,3],"node_modules\\expo-modules-core\\src\\PermissionsHook.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSnapshotFriendlyRef = createSnapshotFriendlyRef;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Create a React ref object that is friendly for snapshots.
   * It will be represented as `[React.ref]` in snapshots.
   * @returns A React ref object.
   */
  function createSnapshotFriendlyRef() {
    return /*#__PURE__*/(0, _react.createRef)();
  }
},499,[3],"node_modules\\expo-modules-core\\src\\Refs.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useReleasingSharedObject = useReleasingSharedObject;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Returns a shared object, which is automatically cleaned up when the component is unmounted.
   */
  function useReleasingSharedObject(factory, dependencies) {
    const objectRef = (0, _react.useRef)(null);
    const isFastRefresh = (0, _react.useRef)(false);
    const previousDependencies = (0, _react.useRef)(dependencies);
    if (objectRef.current == null) {
      objectRef.current = factory();
    }
    const object = (0, _react.useMemo)(() => {
      let newObject = objectRef.current;
      const dependenciesAreEqual = previousDependencies.current?.length === dependencies.length && dependencies.every((value, index) => value === previousDependencies.current[index]);

      // If the dependencies have changed, release the previous object and create a new one, otherwise this has been called
      // because of a fast refresh, and we don't want to release the object.
      if (!newObject || !dependenciesAreEqual) {
        objectRef.current?.release();
        newObject = factory();
        objectRef.current = newObject;
        previousDependencies.current = dependencies;
      } else {
        isFastRefresh.current = true;
      }
      return newObject;
    }, dependencies);
    (0, _react.useEffect)(() => {
      isFastRefresh.current = false;
      return () => {
        // This will be called on every fast refresh and on unmount, but we only want to release the object on unmount.
        if (!isFastRefresh.current && objectRef.current) {
          objectRef.current.release();
        }
      };
    }, []);
    return object;
  }
},500,[3],"node_modules\\expo-modules-core\\src\\hooks\\useReleasingSharedObject.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.reloadAppAsync = reloadAppAsync;
  /**
   * Reloads the app. This method works for both release and debug builds.
   *
   * Unlike [`Updates.reloadAsync()`](/versions/latest/sdk/updates/#updatesreloadasync),
   * this function does not use a new update even if one is available. It only reloads the app using the same JavaScript bundle that is currently running.
   *
   * @param reason The reason for reloading the app. This is used only for some platforms.
   */
  async function reloadAppAsync(reason = 'Reloaded from JS call') {
    await globalThis.expo?.reloadAppAsync(reason);
  }
},501,[],"node_modules\\expo-modules-core\\src\\reload.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LegacyEventEmitter = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "invariant"));
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/NativeEventEmitter"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  const nativeEmitterSubscriptionKey = '@@nativeEmitterSubscription@@';
  /**
   * @deprecated Deprecated in favor of `EventEmitter`.
   */
  class LegacyEventEmitter {
    _listenerCount = 0;

    // @ts-expect-error

    // @ts-expect-error

    constructor(nativeModule) {
      // If the native module is a new module, just return it back as it's already an event emitter.
      // This is for backwards compatibility until we stop using this legacy class in other packages.
      if (nativeModule.__expo_module_name__) {
        // @ts-expect-error
        return nativeModule;
      }
      this._nativeModule = nativeModule;
      this._eventEmitter = new _NativeEventEmitter.default(nativeModule);
    }
    addListener(eventName, listener) {
      if (!this._listenerCount && _Platform.default.OS !== 'ios' && this._nativeModule.startObserving) {
        this._nativeModule.startObserving();
      }
      this._listenerCount++;
      const nativeEmitterSubscription = this._eventEmitter.addListener(eventName, listener);
      const subscription = {
        [nativeEmitterSubscriptionKey]: nativeEmitterSubscription,
        remove: () => {
          this.removeSubscription(subscription);
        }
      };
      return subscription;
    }
    removeAllListeners(eventName) {
      // @ts-ignore: the EventEmitter interface has been changed in react-native@0.64.0
      const removedListenerCount = this._eventEmitter.listenerCount ?
      // @ts-ignore: this is available since 0.64
      this._eventEmitter.listenerCount(eventName) :
      // @ts-ignore: this is available in older versions
      this._eventEmitter.listeners(eventName).length;
      this._eventEmitter.removeAllListeners(eventName);
      this._listenerCount -= removedListenerCount;
      (0, _invariant.default)(this._listenerCount >= 0, `EventEmitter must have a non-negative number of listeners`);
      if (!this._listenerCount && _Platform.default.OS !== 'ios' && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    removeSubscription(subscription) {
      const state = subscription;
      const nativeEmitterSubscription = state[nativeEmitterSubscriptionKey];
      if (!nativeEmitterSubscription) {
        return;
      }
      if ('remove' in nativeEmitterSubscription) {
        nativeEmitterSubscription.remove?.();
      }
      this._listenerCount--;

      // Ensure that the emitter's internal state remains correct even if `removeSubscription` is
      // called again with the same subscription
      delete state[nativeEmitterSubscriptionKey];

      // Release closed-over references to the emitter
      subscription.remove = () => {};
      if (!this._listenerCount && _Platform.default.OS !== 'ios' && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    emit(eventName, ...params) {
      this._eventEmitter.emit(eventName, ...params);
    }
  }
  exports.LegacyEventEmitter = LegacyEventEmitter;
},502,[17,919,223,106],"node_modules\\expo-modules-core\\src\\LegacyEventEmitter.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  // We default to an empty object shim wherever we don't have an environment-specific implementation
  /**
   * @deprecated `NativeModulesProxy` is deprecated and might be removed in the future releases.
   * Use `requireNativeModule` or `requireOptionalNativeModule` instead.
   */
  var _default = exports.default = {};
},504,[],"node_modules\\expo-modules-core\\src\\NativeModulesProxy.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._createWebFontTemplate = _createWebFontTemplate;
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _fontfaceobserver = _interopRequireDefault(require(_dependencyMap[2], "fontfaceobserver"));
  var _Font = require(_dependencyMap[3], "./Font.types");
  function getFontFaceStyleSheet() {
    if (!_expoModulesCore.Platform.isDOMAvailable) {
      return null;
    }
    const styleSheet = getStyleElement();
    return styleSheet.sheet ? styleSheet.sheet : null;
  }
  function getFontFaceRules() {
    const sheet = getFontFaceStyleSheet();
    if (sheet) {
      // @ts-ignore: rule iterator
      const rules = [...sheet.cssRules];
      const items = [];
      for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        if (rule instanceof CSSFontFaceRule) {
          items.push({
            rule,
            index: i
          });
        }
      }
      return items;
    }
    return [];
  }
  function getFontFaceRulesMatchingResource(fontFamilyName, options) {
    const rules = getFontFaceRules();
    return rules.filter(({
      rule
    }) => {
      return rule.style.fontFamily === fontFamilyName && (options && options.display ? options.display === rule.style.fontDisplay : true);
    });
  }
  const serverContext = new Set();
  function getHeadElements() {
    const entries = [...serverContext.entries()];
    if (!entries.length) {
      return [];
    }
    const css = entries.map(([{
      css
    }]) => css).join('\n');
    const links = entries.map(([{
      resourceId
    }]) => resourceId);
    // TODO: Maybe return nothing if no fonts were loaded.
    return [{
      $$type: 'style',
      children: css,
      id: ID,
      type: 'text/css'
    }, ...links.map(resourceId => ({
      $$type: 'link',
      rel: 'preload',
      href: resourceId,
      as: 'font',
      crossorigin: ''
    }))];
  }
  var _default = exports.default = {
    async unloadAllAsync() {
      if (!_expoModulesCore.Platform.isDOMAvailable) return;
      const element = document.getElementById(ID);
      if (element && element instanceof HTMLStyleElement) {
        document.removeChild(element);
      }
    },
    async unloadAsync(fontFamilyName, options) {
      const sheet = getFontFaceStyleSheet();
      if (!sheet) return;
      const items = getFontFaceRulesMatchingResource(fontFamilyName, options);
      for (const item of items) {
        sheet.deleteRule(item.index);
      }
    },
    getServerResources() {
      const elements = getHeadElements();
      return elements.map(element => {
        switch (element.$$type) {
          case 'style':
            return `<style id="${element.id}" type="${element.type}">${element.children}</style>`;
          case 'link':
            return `<link rel="${element.rel}" href="${element.href}" as="${element.as}" crossorigin="${element.crossorigin}" />`;
          default:
            return '';
        }
      }).filter(Boolean);
    },
    resetServerContext() {
      serverContext.clear();
    },
    getLoadedFonts() {
      if (typeof window === 'undefined') {
        return [...serverContext.values()].map(({
          name
        }) => name);
      }
      const rules = getFontFaceRules();
      return rules.map(({
        rule
      }) => rule.style.fontFamily);
    },
    isLoaded(fontFamilyName, resource = {}) {
      if (typeof window === 'undefined') {
        return !![...serverContext.values()].find(asset => {
          return asset.name === fontFamilyName;
        });
      }
      return getFontFaceRulesMatchingResource(fontFamilyName, resource)?.length > 0;
    },
    // NOTE(EvanBacon): No async keyword! This cannot return a promise in Node environments.
    loadAsync(fontFamilyName, resource) {
      if (typeof window === 'undefined') {
        serverContext.add({
          name: fontFamilyName,
          css: _createWebFontTemplate(fontFamilyName, resource),
          // @ts-expect-error: typeof string
          resourceId: resource.uri
        });
        return Promise.resolve();
      }
      const canInjectStyle = document.head && typeof document.head.appendChild === 'function';
      if (!canInjectStyle) {
        throw new _expoModulesCore.CodedError('ERR_WEB_ENVIRONMENT', `The browser's \`document.head\` element doesn't support injecting fonts.`);
      }
      const style = getStyleElement();
      document.head.appendChild(style);
      const res = getFontFaceRulesMatchingResource(fontFamilyName, resource);
      if (!res.length) {
        _createWebStyle(fontFamilyName, resource);
      }
      if (!isFontLoadingListenerSupported()) {
        return Promise.resolve();
      }
      return new _fontfaceobserver.default(fontFamilyName, {
        // @ts-expect-error: TODO(@kitten): Typings indicate that the polyfill may not support this?
        display: resource.display
      }).load(null, 6000);
    }
  };
  const ID = 'expo-generated-fonts';
  function getStyleElement() {
    const element = document.getElementById(ID);
    if (element && element instanceof HTMLStyleElement) {
      return element;
    }
    const styleElement = document.createElement('style');
    styleElement.id = ID;
    styleElement.type = 'text/css';
    return styleElement;
  }
  function _createWebFontTemplate(fontFamily, resource) {
    return `@font-face{font-family:${fontFamily};src:url(${resource.uri});font-display:${resource.display || _Font.FontDisplay.AUTO}}`;
  }
  function _createWebStyle(fontFamily, resource) {
    const fontStyle = _createWebFontTemplate(fontFamily, resource);
    const styleElement = getStyleElement();
    // @ts-ignore: TypeScript does not define HTMLStyleElement::styleSheet. This is just for IE and
    // possibly can be removed if it's unnecessary on IE 11.
    if (styleElement.styleSheet) {
      const styleElementIE = styleElement;
      styleElementIE.styleSheet.cssText = styleElementIE.styleSheet.cssText ? styleElementIE.styleSheet.cssText + fontStyle : fontStyle;
    } else {
      const textNode = document.createTextNode(fontStyle);
      styleElement.appendChild(textNode);
    }
    return styleElement;
  }
  function isFontLoadingListenerSupported() {
    const {
      userAgent
    } = window.navigator;
    // WebKit is broken https://github.com/bramstein/fontfaceobserver/issues/95
    const isIOS = !!userAgent.match(/iPad|iPhone/i);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    // Edge is broken https://github.com/bramstein/fontfaceobserver/issues/109#issuecomment-333356795
    const isEdge = userAgent.includes('Edge');
    // Internet Explorer
    const isIE = userAgent.includes('Trident');
    // Firefox
    const isFirefox = userAgent.includes('Firefox');
    return !isSafari && !isIOS && !isEdge && !isIE && !isFirefox;
  }
},505,[17,473,506,507],"node_modules\\expo-font\\build\\ExpoFontLoader.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* Font Face Observer v2.3.0 -  Bram Stein. License: BSD-3-Clause */(function () {
    function p(a, c) {
      document.addEventListener ? a.addEventListener("scroll", c, !1) : a.attachEvent("scroll", c);
    }
    function u(a) {
      document.body ? a() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function b() {
        document.removeEventListener("DOMContentLoaded", b);
        a();
      }) : document.attachEvent("onreadystatechange", function g() {
        if ("interactive" == document.readyState || "complete" == document.readyState) document.detachEvent("onreadystatechange", g), a();
      });
    }
    ;
    function w(a) {
      this.g = document.createElement("div");
      this.g.setAttribute("aria-hidden", "true");
      this.g.appendChild(document.createTextNode(a));
      this.h = document.createElement("span");
      this.i = document.createElement("span");
      this.m = document.createElement("span");
      this.j = document.createElement("span");
      this.l = -1;
      this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
      this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
      this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
      this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";
      this.h.appendChild(this.m);
      this.i.appendChild(this.j);
      this.g.appendChild(this.h);
      this.g.appendChild(this.i);
    }
    function x(a, c) {
      a.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + c + ";";
    }
    function B(a) {
      var c = a.g.offsetWidth,
        b = c + 100;
      a.j.style.width = b + "px";
      a.i.scrollLeft = b;
      a.h.scrollLeft = a.h.scrollWidth + 100;
      return a.l !== c ? (a.l = c, !0) : !1;
    }
    function C(a, c) {
      function b() {
        var e = g;
        B(e) && null !== e.g.parentNode && c(e.l);
      }
      var g = a;
      p(a.h, b);
      p(a.i, b);
      B(a);
    }
    ;
    function D(a, c, b) {
      c = c || {};
      b = b || window;
      this.family = a;
      this.style = c.style || "normal";
      this.weight = c.weight || "normal";
      this.stretch = c.stretch || "normal";
      this.context = b;
    }
    var E = null,
      F = null,
      G = null,
      H = null;
    function I(a) {
      null === F && (M(a) && /Apple/.test(window.navigator.vendor) ? (a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), F = !!a && 603 > parseInt(a[1], 10)) : F = !1);
      return F;
    }
    function M(a) {
      null === H && (H = !!a.document.fonts);
      return H;
    }
    function N(a, c) {
      var b = a.style,
        g = a.weight;
      if (null === G) {
        var e = document.createElement("div");
        try {
          e.style.font = "condensed 100px sans-serif";
        } catch (q) {}
        G = "" !== e.style.font;
      }
      return [b, g, G ? a.stretch : "", "100px", c].join(" ");
    }
    D.prototype.load = function (a, c) {
      var b = this,
        g = a || "BESbswy",
        e = 0,
        q = c || 3E3,
        J = new Date().getTime();
      return new Promise(function (K, L) {
        if (M(b.context) && !I(b.context)) {
          var O = new Promise(function (r, t) {
              function h() {
                new Date().getTime() - J >= q ? t(Error("" + q + "ms timeout exceeded")) : b.context.document.fonts.load(N(b, '"' + b.family + '"'), g).then(function (n) {
                  1 <= n.length ? r() : setTimeout(h, 25);
                }, t);
              }
              h();
            }),
            P = new Promise(function (r, t) {
              e = setTimeout(function () {
                t(Error("" + q + "ms timeout exceeded"));
              }, q);
            });
          Promise.race([P, O]).then(function () {
            clearTimeout(e);
            K(b);
          }, L);
        } else u(function () {
          function r() {
            var d;
            if (d = -1 != k && -1 != l || -1 != k && -1 != m || -1 != l && -1 != m) (d = k != l && k != m && l != m) || (null === E && (d = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), E = !!d && (536 > parseInt(d[1], 10) || 536 === parseInt(d[1], 10) && 11 >= parseInt(d[2], 10))), d = E && (k == y && l == y && m == y || k == z && l == z && m == z || k == A && l == A && m == A)), d = !d;
            d && (null !== f.parentNode && f.parentNode.removeChild(f), clearTimeout(e), K(b));
          }
          function t() {
            if (new Date().getTime() - J >= q) null !== f.parentNode && f.parentNode.removeChild(f), L(Error("" + q + "ms timeout exceeded"));else {
              var d = b.context.document.hidden;
              if (!0 === d || void 0 === d) k = h.g.offsetWidth, l = n.g.offsetWidth, m = v.g.offsetWidth, r();
              e = setTimeout(t, 50);
            }
          }
          var h = new w(g),
            n = new w(g),
            v = new w(g),
            k = -1,
            l = -1,
            m = -1,
            y = -1,
            z = -1,
            A = -1,
            f = document.createElement("div");
          f.dir = "ltr";
          x(h, N(b, "sans-serif"));
          x(n, N(b, "serif"));
          x(v, N(b, "monospace"));
          f.appendChild(h.g);
          f.appendChild(n.g);
          f.appendChild(v.g);
          b.context.document.body.appendChild(f);
          y = h.g.offsetWidth;
          z = n.g.offsetWidth;
          A = v.g.offsetWidth;
          t();
          C(h, function (d) {
            k = d;
            r();
          });
          x(h, N(b, '"' + b.family + '",sans-serif'));
          C(n, function (d) {
            l = d;
            r();
          });
          x(n, N(b, '"' + b.family + '",serif'));
          C(v, function (d) {
            m = d;
            r();
          });
          x(v, N(b, '"' + b.family + '",monospace'));
        });
      });
    };
    "object" === typeof module ? module.exports = D : (window.FontFaceObserver = D, window.FontFaceObserver.prototype.load = D.prototype.load);
  })();
},506,[],"node_modules\\fontfaceobserver\\fontfaceobserver.standalone.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FontDisplay = void 0;
  // @needsAudit
  /**
   * Sets the [font-display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display)
   * for a given typeface. The default font value on web is `FontDisplay.AUTO`.
   * Even though setting the `fontDisplay` does nothing on native platforms, the default behavior
   * emulates `FontDisplay.SWAP` on flagship devices like iOS, Samsung, Pixel, etc. Default
   * functionality varies on One Plus devices. In the browser this value is set in the generated
   * `@font-face` CSS block and not as a style property meaning you cannot dynamically change this
   * value based on the element it's used in.
   * @platform web
   */
  var FontDisplay;
  (function (FontDisplay) {
    /**
     * __(Default)__ The font display strategy is defined by the user agent or platform.
     * This generally defaults to the text being invisible until the font is loaded.
     * Good for buttons or banners that require a specific treatment.
     */
    FontDisplay["AUTO"] = "auto";
    /**
     * Fallback text is rendered immediately with a default font while the desired font is loaded.
     * This is good for making the content appear to load instantly and is usually preferred.
     */
    FontDisplay["SWAP"] = "swap";
    /**
     * The text will be invisible until the font has loaded. If the font fails to load then nothing
     * will appear - it's best to turn this off when debugging missing text.
     */
    FontDisplay["BLOCK"] = "block";
    /**
     * Splits the behavior between `SWAP` and `BLOCK`.
     * There will be a [100ms timeout](https://developers.google.com/web/updates/2016/02/font-display?hl=en)
     * where the text with a custom font is invisible, after that the text will either swap to the
     * styled text or it'll show the unstyled text and continue to load the custom font. This is good
     * for buttons that need a custom font but should also be quickly available to screen-readers.
     */
    FontDisplay["FALLBACK"] = "fallback";
    /**
     * This works almost identically to `FALLBACK`, the only difference is that the browser will
     * decide to load the font based on slow connection speed or critical resource demand.
     */
    FontDisplay["OPTIONAL"] = "optional";
  })(FontDisplay || (exports.FontDisplay = FontDisplay = {}));
},507,[],"node_modules\\expo-font\\build\\Font.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getAssetForSource = getAssetForSource;
  exports.loadSingleFontAsync = loadSingleFontAsync;
  var _expoAsset = require(_dependencyMap[1], "expo-asset");
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _ExpoFontLoader = _interopRequireDefault(require(_dependencyMap[3], "./ExpoFontLoader"));
  var _Font = require(_dependencyMap[4], "./Font.types");
  function uriFromFontSource(asset) {
    if (typeof asset === 'string') {
      return asset || null;
    } else if (typeof asset === 'number') {
      return uriFromFontSource(_expoAsset.Asset.fromModule(asset));
    } else if (typeof asset === 'object' && typeof asset.uri === 'number') {
      return uriFromFontSource(asset.uri);
    } else if (typeof asset === 'object') {
      return asset.uri || asset.localUri || asset.default || null;
    }
    return null;
  }
  function displayFromFontSource(asset) {
    if (typeof asset === 'object' && 'display' in asset) {
      return asset.display || _Font.FontDisplay.AUTO;
    }
    return _Font.FontDisplay.AUTO;
  }
  function getAssetForSource(source) {
    const uri = uriFromFontSource(source);
    const display = displayFromFontSource(source);
    if (!uri || typeof uri !== 'string') {
      throwInvalidSourceError(uri);
    }
    return {
      uri,
      display
    };
  }
  function throwInvalidSourceError(source) {
    let type = typeof source;
    if (type === 'object') type = JSON.stringify(source, null, 2);
    throw new _expoModulesCore.CodedError(`ERR_FONT_SOURCE`, `Expected font asset of type \`string | FontResource | Asset\` instead got: ${type}`);
  }
  // NOTE(EvanBacon): No async keyword!
  function loadSingleFontAsync(name, input) {
    if (typeof input !== 'object' || typeof input.uri !== 'string' || input.downloadAsync) {
      throwInvalidSourceError(input);
    }
    try {
      return _ExpoFontLoader.default.loadAsync(name, input);
    } catch {
      // No-op.
    }
    return Promise.resolve();
  }
},508,[17,509,473,505,507],"node_modules\\expo-font\\build\\FontLoader.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  require(_dependencyMap[0], "./Asset.fx");
  var _Asset2 = require(_dependencyMap[1], "./Asset");
  Object.keys(_Asset2).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _Asset2[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Asset2[key];
      }
    });
  });
  var _AssetHooks = require(_dependencyMap[2], "./AssetHooks");
  Object.keys(_AssetHooks).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _AssetHooks[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _AssetHooks[key];
      }
    });
  });
},509,[510,511,520],"node_modules\\expo-asset\\build\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _Asset = require(_dependencyMap[0], "./Asset");
  var _PlatformUtils = require(_dependencyMap[1], "./PlatformUtils");
  var _resolveAssetSource = _interopRequireWildcard(require(_dependencyMap[2], "./resolveAssetSource"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  // Override React Native's asset resolution for `Image` components in contexts where it matters
  if (_PlatformUtils.IS_ENV_WITH_LOCAL_ASSETS) {
    const setTransformer = _resolveAssetSource.default.setCustomSourceTransformer || _resolveAssetSource.setCustomSourceTransformer;
    setTransformer(resolver => {
      try {
        // Bundler is using the hashAssetFiles plugin if and only if the fileHashes property exists
        if ('fileHashes' in resolver.asset && resolver.asset.fileHashes) {
          const asset = _Asset.Asset.fromMetadata(resolver.asset);
          if (asset.uri.startsWith(_Asset.ANDROID_EMBEDDED_URL_BASE_RESOURCE)) {
            // TODO(@kitten): See https://github.com/expo/expo/commit/ec940b57a87d99ab4f1d06d87126e662c3f04f04#r155340943
            // It's unclear whether this is sound since this may be our own AssetSourceResolver, which doesn't have this method
            // Please compare `AssetSourceResolver` type from `react-native/Libraries/Image/AssetSourceResolver` against `./AssetSourceResolver`
            return resolver.resourceIdentifierWithoutScale();
          }
          return resolver.fromSource(asset.downloaded ? asset.localUri : asset.uri);
        } else {
          return resolver.defaultAsset();
        }
      } catch {
        return resolver.defaultAsset();
      }
    });
  }
},510,[511,514,519],"node_modules\\expo-asset\\build\\Asset.fx.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Asset = exports.ANDROID_EMBEDDED_URL_BASE_RESOURCE = void 0;
  var _registry = require(_dependencyMap[1], "@react-native/assets-registry/registry");
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _AssetSources = require(_dependencyMap[3], "./AssetSources");
  var AssetUris = _interopRequireWildcard(require(_dependencyMap[4], "./AssetUris"));
  var _ExpoAsset = require(_dependencyMap[5], "./ExpoAsset");
  var ImageAssets = _interopRequireWildcard(require(_dependencyMap[6], "./ImageAssets"));
  var _LocalAssets = require(_dependencyMap[7], "./LocalAssets");
  var _PlatformUtils = require(_dependencyMap[8], "./PlatformUtils");
  var _resolveAssetSource = _interopRequireDefault(require(_dependencyMap[9], "./resolveAssetSource"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /**
   * Android resource URL prefix.
   * @hidden
   */
  const ANDROID_EMBEDDED_URL_BASE_RESOURCE = exports.ANDROID_EMBEDDED_URL_BASE_RESOURCE = 'file:///android_res/';
  /**
   * The `Asset` class represents an asset in your app. It gives metadata about the asset (such as its
   * name and type) and provides facilities to load the asset data.
   */
  class Asset {
    static byHash = {};
    static byUri = {};
    /**
     * The name of the asset file without the extension. Also without the part from `@` onward in the
     * filename (used to specify scale factor for images).
     */

    /**
     * The extension of the asset filename.
     */

    /**
     * The MD5 hash of the asset's data.
     */
    hash = null;
    /**
     * A URI that points to the asset's data on the remote server. When running the published version
     * of your app, this refers to the location on Expo's asset server where Expo has stored your
     * asset. When running the app from Expo CLI during development, this URI points to Expo CLI's
     * server running on your computer and the asset is served directly from your computer. If you
     * are not using Classic Updates (legacy), this field should be ignored as we ensure your assets
     * are on device before running your application logic.
     */

    /**
     * If the asset has been downloaded (by calling [`downloadAsync()`](#downloadasync)), the
     * `file://` URI pointing to the local file on the device that contains the asset data.
     */
    localUri = null;
    /**
     * If the asset is an image, the width of the image data divided by the scale factor. The scale
     * factor is the number after `@` in the filename, or `1` if not present.
     */
    width = null;
    /**
     * If the asset is an image, the height of the image data divided by the scale factor. The scale factor is the number after `@` in the filename, or `1` if not present.
     */
    height = null;
    downloading = false;
    /**
     * Whether the asset has finished downloading from a call to [`downloadAsync()`](#downloadasync).
     */
    downloaded = false;
    _downloadCallbacks = [];
    constructor({
      name,
      type,
      hash = null,
      uri,
      width,
      height
    }) {
      this.name = name;
      this.type = type;
      this.hash = hash;
      this.uri = uri;
      if (typeof width === 'number') {
        this.width = width;
      }
      if (typeof height === 'number') {
        this.height = height;
      }
      if (hash) {
        this.localUri = (0, _LocalAssets.getLocalAssetUri)(hash, type);
        if (this.localUri?.startsWith(ANDROID_EMBEDDED_URL_BASE_RESOURCE)) {
          // Treat Android embedded resources as not downloaded state, because the uri is not direct accessible.
          this.uri = this.localUri;
          this.localUri = null;
        } else if (this.localUri) {
          this.downloaded = true;
        }
      }
      if (_expoModulesCore.Platform.OS === 'web') {
        if (!name) {
          this.name = AssetUris.getFilename(uri);
        }
        if (!type) {
          this.type = AssetUris.getFileExtension(uri);
        }
      }
    }
    // @needsAudit
    /**
     * A helper that wraps `Asset.fromModule(module).downloadAsync` for convenience.
     * @param moduleId An array of `require('path/to/file')` or external network URLs. Can also be
     * just one module or URL without an Array.
     * @return Returns a Promise that fulfills with an array of `Asset`s when the asset(s) has been
     * saved to disk.
     * @example
     * ```ts
     * const [{ localUri }] = await Asset.loadAsync(require('./assets/snack-icon.png'));
     * ```
     */
    static loadAsync(moduleId) {
      const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];
      return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));
    }
    // @needsAudit
    /**
     * Returns the [`Asset`](#asset) instance representing an asset given its module or URL.
     * @param virtualAssetModule The value of `require('path/to/file')` for the asset or external
     * network URL
     * @return The [`Asset`](#asset) instance for the asset.
     */
    static fromModule(virtualAssetModule) {
      if (typeof virtualAssetModule === 'string') {
        return Asset.fromURI(virtualAssetModule);
      }
      if (typeof virtualAssetModule === 'object' && 'uri' in virtualAssetModule && typeof virtualAssetModule.uri === 'string') {
        const extension = AssetUris.getFileExtension(virtualAssetModule.uri);
        return new Asset({
          name: '',
          type: extension.startsWith('.') ? extension.substring(1) : extension,
          hash: null,
          uri: virtualAssetModule.uri,
          width: virtualAssetModule.width,
          height: virtualAssetModule.height
        });
      }
      const meta = (0, _registry.getAssetByID)(virtualAssetModule);
      if (!meta) {
        throw new Error(`Module "${virtualAssetModule}" is missing from the asset registry`);
      }
      // Outside of the managed env we need the moduleId to initialize the asset
      // because resolveAssetSource depends on it
      if (!_PlatformUtils.IS_ENV_WITH_LOCAL_ASSETS) {
        // null-check is performed above with `getAssetByID`.
        const {
          uri
        } = (0, _resolveAssetSource.default)(virtualAssetModule);
        const asset = new Asset({
          name: meta.name,
          type: meta.type,
          hash: meta.hash,
          uri,
          width: meta.width,
          height: meta.height
        });
        // For images backward compatibility,
        // keeps localUri the same as uri for React Native's Image that
        // works fine with drawable resource names.
        if (_expoModulesCore.Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {
          asset.localUri = asset.uri;
          asset.downloaded = true;
        }
        Asset.byHash[meta.hash] = asset;
        return asset;
      }
      return Asset.fromMetadata(meta);
    }
    // @docsMissing
    static fromMetadata(meta) {
      // The hash of the whole asset, not to be confused with the hash of a specific file returned
      // from `selectAssetSource`
      const metaHash = meta.hash;
      if (Asset.byHash[metaHash]) {
        return Asset.byHash[metaHash];
      }
      const {
        uri,
        hash
      } = (0, _AssetSources.selectAssetSource)(meta);
      const asset = new Asset({
        name: meta.name,
        type: meta.type,
        hash,
        uri,
        width: meta.width,
        height: meta.height
      });
      Asset.byHash[metaHash] = asset;
      return asset;
    }
    // @docsMissing
    static fromURI(uri) {
      if (Asset.byUri[uri]) {
        return Asset.byUri[uri];
      }
      // Possibly a Base64-encoded URI
      let type = '';
      if (uri.indexOf(';base64') > -1) {
        type = uri.split(';')[0].split('/')[1];
      } else {
        const extension = AssetUris.getFileExtension(uri);
        type = extension.startsWith('.') ? extension.substring(1) : extension;
      }
      const asset = new Asset({
        name: '',
        type,
        hash: null,
        uri
      });
      Asset.byUri[uri] = asset;
      return asset;
    }
    // @needsAudit
    /**
     * Downloads the asset data to a local file in the device's cache directory. Once the returned
     * promise is fulfilled without error, the [`localUri`](#localuri) field of this asset points
     * to a local file containing the asset data. The asset is only downloaded if an up-to-date local
     * file for the asset isn't already present due to an earlier download. The downloaded `Asset`
     * will be returned when the promise is resolved.
     * @return Returns a Promise which fulfills with an `Asset` instance.
     */
    async downloadAsync() {
      if (this.downloaded) {
        return this;
      }
      if (this.downloading) {
        await new Promise((resolve, reject) => {
          this._downloadCallbacks.push({
            resolve,
            reject
          });
        });
        return this;
      }
      this.downloading = true;
      try {
        if (_expoModulesCore.Platform.OS === 'web') {
          if (ImageAssets.isImageType(this.type)) {
            const {
              width,
              height,
              name
            } = await ImageAssets.getImageInfoAsync(this.uri);
            this.width = width;
            this.height = height;
            this.name = name;
          } else {
            this.name = AssetUris.getFilename(this.uri);
          }
        }
        this.localUri = await (0, _ExpoAsset.downloadAsync)(this.uri, this.hash, this.type);
        this.downloaded = true;
        this._downloadCallbacks.forEach(({
          resolve
        }) => resolve());
      } catch (e) {
        this._downloadCallbacks.forEach(({
          reject
        }) => reject(e));
        throw e;
      } finally {
        this.downloading = false;
        this._downloadCallbacks = [];
      }
      return this;
    }
  }
  exports.Asset = Asset;
},511,[17,181,473,512,515,516,517,518,514,519],"node_modules\\expo-asset\\build\\Asset.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveUri = resolveUri;
  exports.selectAssetSource = selectAssetSource;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/PixelRatio"));
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/NativeModules"));
  var _AssetSourceResolver = _interopRequireDefault(require(_dependencyMap[4], "./AssetSourceResolver"));
  var _PlatformUtils = require(_dependencyMap[5], "./PlatformUtils");
  /**
   * Selects the best file for the given asset (ex: choosing the best scale for images) and returns
   * a { uri, hash } pair for the specific asset file.
   *
   * If the asset isn't an image with multiple scales, the first file is selected.
   */
  function selectAssetSource(meta) {
    // This logic is based on that of AssetSourceResolver, with additional support for file hashes and
    // explicitly provided URIs
    const scale = _AssetSourceResolver.default.pickScale(meta.scales, _PixelRatio.default.get());
    const index = meta.scales.findIndex(s => s === scale);
    const hash = meta.fileHashes ? meta.fileHashes[index] ?? meta.fileHashes[0] : meta.hash;
    // Allow asset processors to directly provide the URL to load
    const uri = meta.fileUris ? meta.fileUris[index] ?? meta.fileUris[0] : meta.uri;
    if (uri) {
      return {
        uri: resolveUri(uri),
        hash
      };
    }
    const fileScale = scale === 1 ? '' : `@${scale}x`;
    const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';
    const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}`;
    const params = new URLSearchParams({
      platform: _expoModulesCore.Platform.OS,
      hash: meta.hash
    });
    // For assets with a specified absolute URL, we use the existing origin instead of prepending the
    // development server or production CDN URL origin
    if (/^https?:\/\//.test(meta.httpServerLocation)) {
      const uri = meta.httpServerLocation + suffix + '?' + params;
      return {
        uri,
        hash
      };
    }
    // For assets during development using manifest2, we use the development server's URL origin
    const manifest2 = (0, _PlatformUtils.getManifest2)();
    const devServerUrl = manifest2?.extra?.expoGo?.developer ? 'http://' + manifest2.extra.expoGo.debuggerHost : null;
    if (devServerUrl) {
      const baseUrl = new URL(meta.httpServerLocation + suffix, devServerUrl);
      baseUrl.searchParams.set('platform', _expoModulesCore.Platform.OS);
      baseUrl.searchParams.set('hash', meta.hash);
      return {
        uri: baseUrl.href,
        hash
      };
    }
    // Temporary fallback for loading assets in Expo Go home
    if (_NativeModules.default['ExponentKernel']) {
      return {
        uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`,
        hash
      };
    }
    // In correctly configured apps, we arrive here if the asset is locally available on disk due to
    // being managed by expo-updates, and `getLocalAssetUri(hash)` must return a local URI for this
    // hash. Since the asset is local, we don't have a remote URL and specify an invalid URL (an empty
    // string) as a placeholder.
    return {
      uri: '',
      hash
    };
  }
  /**
   * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is
   * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's
   * base URI.
   */
  function resolveUri(uri) {
    // `manifestBaseUrl` is always an absolute URL or `null`.
    return _PlatformUtils.manifestBaseUrl ? new URL(uri, _PlatformUtils.manifestBaseUrl).href : uri;
  }
},512,[17,473,183,96,513,514],"node_modules\\expo-asset\\build\\AssetSources.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/PixelRatio"));
  // Returns the Metro dev server-specific asset location.
  function getScaledAssetPath(asset) {
    const scale = AssetSourceResolver.pickScale(asset.scales, _PixelRatio.default.get());
    const scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
    const type = !asset.type ? '' : `.${asset.type}`;
    if (__DEV__) {
      return asset.httpServerLocation + '/' + asset.name + scaleSuffix + type;
    } else {
      return asset.httpServerLocation.replace(/\.\.\//g, '_') + '/' + asset.name + scaleSuffix + type;
    }
  }
  class AssetSourceResolver {
    // where the jsbundle is being run from
    // NOTE(EvanBacon): Never defined on web.
    // @ts-expect-error: Never read locally

    // the asset to resolve

    constructor(serverUrl, jsbundleUrl, asset) {
      this.serverUrl = serverUrl || 'https://expo.dev';
      this.jsbundleUrl = null;
      this.asset = asset;
    }
    // Always true for web runtimes
    isLoadedFromServer() {
      return true;
    }
    // Always false for web runtimes
    isLoadedFromFileSystem() {
      return false;
    }
    defaultAsset() {
      return this.assetServerURL();
    }
    /**
     * @returns absolute remote URL for the hosted asset.
     */
    assetServerURL() {
      const fromUrl = new URL(getScaledAssetPath(this.asset), this.serverUrl);
      fromUrl.searchParams.set('platform', _expoModulesCore.Platform.OS);
      fromUrl.searchParams.set('hash', this.asset.hash);
      return this.fromSource(
      // Relative on web
      fromUrl.toString().replace(fromUrl.origin, ''));
    }
    fromSource(source) {
      return {
        __packager_asset: true,
        width: this.asset.width ?? undefined,
        height: this.asset.height ?? undefined,
        uri: source,
        scale: AssetSourceResolver.pickScale(this.asset.scales, _PixelRatio.default.get())
      };
    }
    static pickScale(scales, deviceScale) {
      for (let i = 0; i < scales.length; i++) {
        if (scales[i] >= deviceScale) {
          return scales[i];
        }
      }
      return scales[scales.length - 1] || 1;
    }
  }
  exports.default = AssetSourceResolver;
},513,[17,473,183],"node_modules\\expo-asset\\build\\AssetSourceResolver.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.IS_ENV_WITH_LOCAL_ASSETS = void 0;
  exports.getLocalAssets = getLocalAssets;
  exports.getManifest2 = getManifest2;
  exports.manifestBaseUrl = void 0;
  const IS_ENV_WITH_LOCAL_ASSETS = exports.IS_ENV_WITH_LOCAL_ASSETS = false;
  function getLocalAssets() {
    return {};
  }
  function getManifest2() {
    return {};
  }
  // Compute manifest base URL if available
  const manifestBaseUrl = exports.manifestBaseUrl = null;
},514,[],"node_modules\\expo-asset\\build\\PlatformUtils.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getFileExtension = getFileExtension;
  exports.getFilename = getFilename;
  exports.getManifestBaseUrl = getManifestBaseUrl;
  function getFilename(url) {
    const {
      pathname,
      searchParams
    } = new URL(url, 'https://e');
    // When attached to a dev server, we use `unstable_path` to represent the file path. This ensures
    // the file name is not canonicalized by the browser.
    // NOTE(EvanBacon): This is technically not tied to `__DEV__` as it's possible to use this while bundling in production
    // mode.
    if (__DEV__) {
      if (searchParams.has('unstable_path')) {
        const encodedFilePath = decodeURIComponent(searchParams.get('unstable_path'));
        return getBasename(encodedFilePath);
      }
    }
    return getBasename(pathname);
  }
  function getBasename(pathname) {
    return pathname.substring(pathname.lastIndexOf('/') + 1);
  }
  function getFileExtension(url) {
    const filename = getFilename(url);
    const dotIndex = filename.lastIndexOf('.');
    // Ignore leading dots for hidden files
    return dotIndex > 0 ? filename.substring(dotIndex) : '';
  }
  /**
   * Returns the base URL from a manifest's URL. For example, given a manifest hosted at
   * https://example.com/app/manifest.json, the base URL would be https://example.com/app/. Query
   * parameters and fragments also are removed.
   *
   * For an Expo-hosted project with a manifest hosted at https://exp.host/@user/project/index.exp, the
   * base URL would be https://exp.host/@user/project.
   *
   * We also normalize the "exp" protocol to "http" to handle internal URLs with the Expo schemes used
   * to tell the OS to open the URLs in the the Expo client.
   */
  function getManifestBaseUrl(manifestUrl) {
    const urlObject = new URL(manifestUrl);
    let nextProtocol = urlObject.protocol;
    // Change the scheme to http(s) if it is exp(s)
    if (nextProtocol === 'exp:') {
      nextProtocol = 'http:';
    } else if (nextProtocol === 'exps:') {
      nextProtocol = 'https:';
    }
    urlObject.protocol = nextProtocol;
    // Trim filename, query parameters, and fragment, if any
    const directory = urlObject.pathname.substring(0, urlObject.pathname.lastIndexOf('/') + 1);
    urlObject.pathname = directory;
    urlObject.search = '';
    urlObject.hash = '';
    // The URL spec doesn't allow for changing the protocol to `http` or `https`
    // without a port set so instead, we'll just swap the protocol manually.
    return urlObject.protocol !== nextProtocol ? urlObject.href.replace(urlObject.protocol, nextProtocol) : urlObject.href;
  }
},515,[],"node_modules\\expo-asset\\build\\AssetUris.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.downloadAsync = downloadAsync;
  async function downloadAsync(url, _hash, _type) {
    return url;
  }
},516,[],"node_modules\\expo-asset\\build\\ExpoAsset.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageInfoAsync = getImageInfoAsync;
  exports.isImageType = isImageType;
  var _AssetUris = require(_dependencyMap[0], "./AssetUris");
  /* eslint-env browser */

  function isImageType(type) {
    return /^(jpeg|jpg|gif|png|bmp|webp|heic)$/i.test(type);
  }
  function getImageInfoAsync(url) {
    if (typeof window === 'undefined') {
      return Promise.resolve({
        name: (0, _AssetUris.getFilename)(url),
        width: 0,
        height: 0
      });
    }
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onerror = reject;
      img.onload = () => {
        resolve({
          name: (0, _AssetUris.getFilename)(url),
          width: img.naturalWidth,
          height: img.naturalHeight
        });
      };
      img.src = url;
    });
  }
},517,[515],"node_modules\\expo-asset\\build\\ImageAssets.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLocalAssetUri = getLocalAssetUri;
  function getLocalAssetUri(hash, type) {
    // noop on web
    return null;
  }
},518,[],"node_modules\\expo-asset\\build\\LocalAssets.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.pickScale = exports.default = void 0;
  exports.setCustomSourceTransformer = setCustomSourceTransformer;
  var _registry = require(_dependencyMap[1], "@react-native/assets-registry/registry");
  var _AssetSourceResolver = _interopRequireDefault(require(_dependencyMap[2], "./AssetSourceResolver"));
  let _customSourceTransformer;
  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }
  /**
   * `source` is either a number (opaque type returned by require('./foo.png'))
   * or an `ImageSource` like { uri: '<http location || file path>' }
   */
  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }
    const asset = (0, _registry.getAssetByID)(source);
    if (!asset) {
      return null;
    }
    const resolver = new _AssetSourceResolver.default(
    // Doesn't matter since this is removed on web
    'https://expo.dev', null, asset);
    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }
    return resolver.defaultAsset();
  }
  Object.defineProperty(resolveAssetSource, 'setCustomSourceTransformer', {
    get() {
      return setCustomSourceTransformer;
    }
  });
  var _default = exports.default = resolveAssetSource;
  const {
    pickScale
  } = _AssetSourceResolver.default;
  exports.pickScale = pickScale;
},519,[17,181,513],"node_modules\\expo-asset\\build\\resolveAssetSource.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useAssets = useAssets;
  var _react = require(_dependencyMap[0], "react");
  var _Asset = require(_dependencyMap[1], "./Asset");
  // @needsAudit
  /**
   * Downloads and stores one or more assets locally.
   * After the assets are loaded, this hook returns a list of asset instances.
   * If something went wrong when loading the assets, an error is returned.
   *
   * > Note, the assets are not "reloaded" when you dynamically change the asset list.
   *
   * @return Returns an array containing:
   * - on the first position, a list of all loaded assets. If they aren't loaded yet, this value is
   *   `undefined`.
   * - on the second position, an error which encountered when loading the assets. If there was no
   *   error, this value is `undefined`.
   *
   * @example
   * ```tsx
   * const [assets, error] = useAssets([require('path/to/asset.jpg'), require('path/to/other.png')]);
   *
   * return assets ? <Image source={assets[0]} /> : null;
   * ```
   */
  function useAssets(moduleIds) {
    const [assets, setAssets] = (0, _react.useState)();
    const [error, setError] = (0, _react.useState)();
    (0, _react.useEffect)(() => {
      _Asset.Asset.loadAsync(moduleIds).then(setAssets).catch(setError);
    }, []);
    return [assets, error];
  }
},520,[3,511],"node_modules\\expo-asset\\build\\AssetHooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ctx = void 0;
  const ctx = exports.ctx = require(_dependencyMap[0], "..\\..\\app");
},532,[533],"node_modules\\expo-router\\_ctx.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // All of the requested modules are loaded behind enumerable getters.
  const map = Object.defineProperties({}, {
    "./_layout.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[0], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\_layout.tsx");
      }
    },
    "./account.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[1], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\account.tsx");
      }
    },
    "./feed.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[2], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\feed.tsx");
      }
    },
    "./home.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[3], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\home.tsx");
      }
    },
    "./index.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[4], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\index.tsx");
      }
    },
    "./login.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[5], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\login.tsx");
      }
    },
    "./maps.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[6], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\maps.tsx");
      }
    },
    "./profile.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[7], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\profile.tsx");
      }
    },
    "./scan-result.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[8], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\scan-result.tsx");
      }
    },
    "./scan.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[9], "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\scan.tsx");
      }
    }
  });
  function metroContext(request) {
    return map[request];
  }

  // Return the keys that can be resolved.
  metroContext.keys = function metroContextKeys() {
    return Object.keys(map);
  };

  // Return the module identifier for a user request.
  metroContext.resolve = function metroContextResolve(request) {
    throw new Error('Unimplemented Metro module context functionality');
  };
  module.exports = metroContext;
},533,[534,729,736,768,769,770,771,772,773,817],"app?ctx=e5807cc4e93b7ea02120ad0165264d893ac772db");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = RootLayout;
  var _expoRouter = require(_dependencyMap[0], "expo-router");
  require(_dependencyMap[1], "../global.css");
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\_layout.tsx";
  function RootLayout() {
    return (0, _jsxRuntime.jsx)(_expoRouter.Stack, {});
  }
  _c = RootLayout;
  var _c;
  $RefreshReg$(_c, "RootLayout");
},534,[535,728,2],"app\\_layout.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tabs = exports.Stack = void 0;
  var Stack_1 = require(_dependencyMap[0], "./layouts/Stack");
  Object.defineProperty(exports, "Stack", {
    enumerable: true,
    get: function () {
      return Stack_1.Stack;
    }
  });
  var Tabs_1 = require(_dependencyMap[1], "./layouts/Tabs");
  Object.defineProperty(exports, "Tabs", {
    enumerable: true,
    get: function () {
      return Tabs_1.Tabs;
    }
  });
  __exportStar(require(_dependencyMap[2], "./exports"), exports);
},535,[536,652,714],"node_modules\\expo-router\\build\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Stack = void 0;
  const StackClient_1 = __importDefault(require(_dependencyMap[0], "./StackClient"));
  exports.Stack = StackClient_1.default;
  const Screen_1 = require(_dependencyMap[1], "../views/Screen");
  StackClient_1.default.Screen = Screen_1.Screen;
  exports.default = StackClient_1.default;
},536,[537,648],"node_modules\\expo-router\\build\\layouts\\Stack.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\layouts\\StackClient.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StackRouter = exports.stackRouterOverride = void 0;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const native_stack_1 = require(_dependencyMap[2], "@react-navigation/native-stack");
  const withLayoutContext_1 = require(_dependencyMap[3], "./withLayoutContext");
  const useScreens_1 = require(_dependencyMap[4], "../useScreens");
  const Protected_1 = require(_dependencyMap[5], "../views/Protected");
  const NativeStackNavigator = (0, native_stack_1.createNativeStackNavigator)().Navigator;
  const RNStack = (0, withLayoutContext_1.withLayoutContext)(NativeStackNavigator);
  function isStackAction(action) {
    return action.type === 'PUSH' || action.type === 'NAVIGATE' || action.type === 'POP' || action.type === 'POP_TO_TOP' || action.type === 'REPLACE';
  }
  /**
   * React Navigation matches a screen by its name or a 'getID' function that uniquely identifies a screen.
   * When a screen has been uniquely identified, the Stack can only have one instance of that screen.
   *
   * Expo Router allows for a screen to be matched by name and path params, a 'getID' function or a singular id.
   *
   * Instead of reimplementing the entire StackRouter, we can override the getStateForAction method to handle the singular screen logic.
   *
   */
  const stackRouterOverride = original => {
    return {
      getStateForAction: (state, action, options) => {
        if (action.target && action.target !== state.key) {
          return null;
        }
        if (!isStackAction(action)) {
          return original.getStateForAction(state, action, options);
        }
        // The dynamic getId added to an action, `router.push('screen', { singular: true })`
        const actionSingularOptions = action.payload && 'singular' in action.payload ? action.payload.singular : undefined;
        // Handle if 'getID' or 'singular' is set.
        function getIdFunction(fn) {
          // Actions can be fired by the user, so we do need to validate their structure.
          if (!('payload' in action) || !action.payload || !('name' in action.payload) || typeof action.payload.name !== 'string') {
            return;
          }
          const name = action.payload.name;
          return (
            // The dynamic singular added to an action, `router.push('screen', { singular: () => 'id' })`
            getActionSingularIdFn(actionSingularOptions, name) ||
            // The static getId added as a prop to `<Screen singular />` or `<Screen getId={} />`
            options.routeGetIdList[name] ||
            // The custom singular added by Expo Router to support its concept of `navigate`
            fn
          );
        }
        switch (action.type) {
          case 'PUSH':
            {
              /**
               * PUSH should always push
               *
               * If 'getID' or 'singular' is set and a match is found, instead of pushing a new screen,
               * the existing screen will be moved to the HEAD of the stack. If there are multiple matches, the rest will be removed.
               */
              const nextState = original.getStateForAction(state, action, Object.assign({}, options, {
                routeGetIdList: Object.assign({}, options.routeGetIdList, {
                  [action.payload.name]: getIdFunction()
                })
              }));
              /**
               * React Navigation doesn't support dynamic getId function on the action. Because of this,
               * can you enter a state where the screen is pushed multiple times but the normal getStateForAction
               * doesn't remove the duplicates. We need to filter the state to only have singular screens.
               */
              return actionSingularOptions ? filterSingular(nextState, actionSingularOptions) : nextState;
            }
          case 'NAVIGATE':
            {
              /**
               * NAVIGATE should push unless the current name & route params of the current and target screen match.
               * Search params and hashes should be ignored.
               *
               * If the name, route params & search params match, no action is taken.
               * If both the name and route params match, the screen is replaced.
               * If the name / route params do not match, the screen is pushed.
               *
               * If 'getID' or 'singular' is set and a match is found, instead of pushing a new screen,
               * the existing screen will be moved to the HEAD of the stack. If there are multiple matches, the rest will be removed.
               */
              const nextState = original.getStateForAction(state, action, Object.assign({}, options, {
                routeGetIdList: Object.assign({}, options.routeGetIdList, {
                  [action.payload.name]: getIdFunction(options => {
                    return (0, useScreens_1.getSingularId)(action.payload.name, options);
                  })
                })
              }));
              /**
               * React Navigation doesn't support dynamic getId function on the action. Because of this,
               * can you enter a state where the screen is pushed multiple times but the normal getStateForAction
               * doesn't remove the duplicates. We need to filter the state to only have singular screens.
               */
              return actionSingularOptions ? filterSingular(nextState, actionSingularOptions) : nextState;
            }
          default:
            {
              return original.getStateForAction(state, action, options);
            }
        }
      }
    };
  };
  exports.stackRouterOverride = stackRouterOverride;
  function getActionSingularIdFn(actionGetId, name) {
    if (typeof actionGetId === 'function') {
      return options => actionGetId(name, options.params ?? {});
    } else if (actionGetId === true) {
      return options => (0, useScreens_1.getSingularId)(name, options);
    }
    return undefined;
  }
  /**
   * If there is a dynamic singular on an action, then we need to filter the state to only have singular screens.
   * As multiples may have been added before we did the singular navigation.
   */
  function filterSingular(state, singular) {
    if (!state || !singular) {
      return state;
    }
    if (!state.routes) {
      return state;
    }
    const currentIndex = state.index || state.routes.length - 1;
    const current = state.routes[currentIndex];
    const name = current.name;
    const getId = getActionSingularIdFn(singular, name);
    if (!getId) {
      return state;
    }
    const id = getId({
      params: current.params
    });
    if (!id) {
      return state;
    }
    // TypeScript needs a type assertion here for the filter to work.
    let routes = state.routes;
    routes = routes.filter((route, index) => {
      // If the route is the current route, keep it.
      if (index === currentIndex) {
        return true;
      }
      // Remove all other routes with the same name and id.
      return name !== route.name || id !== getId({
        params: route.params
      });
    });
    return Object.assign({}, state, {
      index: routes.length - 1,
      routes
    });
  }
  const Stack = Object.assign(props => {
    return _reactNativeCssInteropJsxRuntime.jsx(RNStack, Object.assign({}, props, {
      UNSTABLE_router: exports.stackRouterOverride
    }));
  }, {
    Screen: RNStack.Screen,
    Protected: Protected_1.Protected
  });
  exports.default = Stack;
  const StackRouter = options => {
    const router = (0, native_1.StackRouter)(options);
    return Object.assign({}, router, (0, exports.stackRouterOverride)(router));
  };
  exports.StackRouter = StackRouter;
},537,[2,350,538,583,587,647],"node_modules\\expo-router\\build\\layouts\\StackClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Navigators
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NativeStackView", {
    enumerable: true,
    get: function () {
      return _NativeStackView.NativeStackView;
    }
  });
  Object.defineProperty(exports, "createNativeStackNavigator", {
    enumerable: true,
    get: function () {
      return _createNativeStackNavigator.createNativeStackNavigator;
    }
  });
  Object.defineProperty(exports, "useAnimatedHeaderHeight", {
    enumerable: true,
    get: function () {
      return _useAnimatedHeaderHeight.useAnimatedHeaderHeight;
    }
  });
  var _createNativeStackNavigator = require(_dependencyMap[0], "./navigators/createNativeStackNavigator.js");
  var _NativeStackView = require(_dependencyMap[1], "./views/NativeStackView");
  var _useAnimatedHeaderHeight = require(_dependencyMap[2], "./utils/useAnimatedHeaderHeight.js");
},538,[539,540,582],"node_modules\\@react-navigation\\native-stack\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createNativeStackNavigator = createNativeStackNavigator;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _NativeStackView = require(_dependencyMap[4], "../views/NativeStackView");
  var _jsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  const _excluded = ["id", "initialRouteName", "children", "layout", "screenListeners", "screenOptions", "screenLayout", "UNSTABLE_router"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function NativeStackNavigator(_ref) {
    let {
        id,
        initialRouteName,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_router
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      state,
      describe,
      descriptors,
      navigation,
      NavigationContent
    } = (0, _native.useNavigationBuilder)(_native.StackRouter, {
      id,
      initialRouteName,
      children,
      layout,
      screenListeners,
      screenOptions,
      screenLayout,
      UNSTABLE_router
    });
    React.useEffect(() =>
    // @ts-expect-error: there may not be a tab navigator in parent
    navigation?.addListener?.('tabPress', e => {
      const isFocused = navigation.isFocused();

      // Run the operation in the next frame so we're sure all listeners have been run
      // This is necessary to know if preventDefault() has been called
      requestAnimationFrame(() => {
        if (state.index > 0 && isFocused && !e.defaultPrevented) {
          // When user taps on already focused tab and we're inside the tab,
          // reset the stack to replicate native behaviour
          navigation.dispatch(Object.assign({}, _native.StackActions.popToTop(), {
            target: state.key
          }));
        }
      });
    }), [navigation, state.index, state.key]);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(NavigationContent, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_NativeStackView.NativeStackView, Object.assign({}, rest, {
        state: state,
        navigation: navigation,
        descriptors: descriptors,
        describe: describe
      }))
    });
  }
  function createNativeStackNavigator(config) {
    return (0, _native.createNavigatorFactory)(NativeStackNavigator)(config);
  }
},539,[17,29,350,3,540,6],"node_modules\\@react-navigation\\native-stack\\lib\\module\\navigators\\createNativeStackNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeStackView = NativeStackView;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _elements = require(_dependencyMap[2], "@react-navigation/elements");
  var _native = require(_dependencyMap[3], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Animated"));
  var _Image = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Image"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/View"));
  var _useAnimatedHeaderHeight = require(_dependencyMap[9], "../utils/useAnimatedHeaderHeight.js");
  var _jsxRuntime = require(_dependencyMap[10], "react/jsx-runtime");
  const _excluded = ["header", "headerShown", "headerBackImageSource", "headerLeft", "headerTransparent", "headerBackTitle", "presentation", "contentStyle"],
    _excluded2 = ["label"],
    _excluded3 = ["tintColor", "label"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const TRANSPARENT_PRESENTATIONS = ['transparentModal', 'containedTransparentModal'];
  function NativeStackView({
    state,
    descriptors,
    describe
  }) {
    const parentHeaderBack = React.useContext(_elements.HeaderBackContext);
    const {
      buildHref
    } = (0, _native.useLinkBuilder)();
    const preloadedDescriptors = state.preloadedRoutes.reduce((acc, route) => {
      acc[route.key] = acc[route.key] || describe(route, true);
      return acc;
    }, {});
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.SafeAreaProviderCompat, {
      children: state.routes.concat(state.preloadedRoutes).map((route, i) => {
        const isFocused = state.index === i;
        const previousKey = state.routes[i - 1]?.key;
        const nextKey = state.routes[i + 1]?.key;
        const previousDescriptor = previousKey ? descriptors[previousKey] : undefined;
        const nextDescriptor = nextKey ? descriptors[nextKey] : undefined;
        const {
          options,
          navigation,
          render
        } = descriptors[route.key] ?? preloadedDescriptors[route.key];
        const headerBack = previousDescriptor ? {
          title: (0, _elements.getHeaderTitle)(previousDescriptor.options, previousDescriptor.route.name),
          href: buildHref(previousDescriptor.route.name, previousDescriptor.route.params)
        } : parentHeaderBack;
        const canGoBack = headerBack != null;
        const {
            header,
            headerShown,
            headerBackImageSource,
            headerLeft,
            headerTransparent,
            headerBackTitle,
            presentation,
            contentStyle
          } = options,
          rest = (0, _objectWithoutPropertiesLoose2.default)(options, _excluded);
        const nextPresentation = nextDescriptor?.options.presentation;
        const isPreloaded = preloadedDescriptors[route.key] !== undefined && descriptors[route.key] === undefined;
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.Screen, {
          focused: isFocused,
          route: route,
          navigation: navigation,
          headerShown: headerShown,
          headerTransparent: headerTransparent,
          header: header !== undefined ? header({
            back: headerBack,
            options,
            route,
            navigation
          }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.Header, Object.assign({}, rest, {
            back: headerBack,
            title: (0, _elements.getHeaderTitle)(options, route.name),
            headerLeft: typeof headerLeft === 'function' ? _ref => {
              let {
                  label
                } = _ref,
                rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded2);
              return headerLeft(Object.assign({}, rest, {
                label: headerBackTitle ?? label
              }));
            } : headerLeft === undefined && canGoBack ? _ref2 => {
              let {
                  tintColor,
                  label
                } = _ref2,
                rest = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded3);
              return /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.HeaderBackButton, Object.assign({}, rest, {
                label: headerBackTitle ?? label,
                tintColor: tintColor,
                backImage: headerBackImageSource !== undefined ? () => /*#__PURE__*/(0, _jsxRuntime.jsx)(_Image.default, {
                  source: headerBackImageSource,
                  resizeMode: "contain",
                  tintColor: tintColor,
                  style: styles.backImage
                }) : undefined,
                onPress: navigation.goBack
              }));
            } : headerLeft,
            headerTransparent: headerTransparent
          })),
          style: [_StyleSheet.default.absoluteFill, {
            display: (isFocused || nextPresentation != null && TRANSPARENT_PRESENTATIONS.includes(nextPresentation)) && !isPreloaded ? 'flex' : 'none'
          }, presentation != null && TRANSPARENT_PRESENTATIONS.includes(presentation) ? {
            backgroundColor: 'transparent'
          } : null],
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.HeaderBackContext.Provider, {
            value: headerBack,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(AnimatedHeaderHeightProvider, {
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
                style: [styles.contentContainer, contentStyle],
                children: render()
              })
            })
          })
        }, route.key);
      })
    });
  }
  const AnimatedHeaderHeightProvider = ({
    children
  }) => {
    const headerHeight = (0, _elements.useHeaderHeight)();
    const [animatedHeaderHeight] = React.useState(() => new _Animated.default.Value(headerHeight));
    React.useEffect(() => {
      animatedHeaderHeight.setValue(headerHeight);
    }, [animatedHeaderHeight, headerHeight]);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_useAnimatedHeaderHeight.AnimatedHeaderHeightContext.Provider, {
      value: animatedHeaderHeight,
      children: children
    });
  };
  const styles = _StyleSheet.default.create({
    contentContainer: {
      flex: 1
    },
    backImage: {
      height: 24,
      width: 24,
      margin: 3
    }
  });
},540,[17,29,541,350,3,104,180,30,111,582,6],"node_modules\\@react-navigation\\native-stack\\lib\\module\\views\\NativeStackView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    Assets: true,
    Background: true,
    Button: true,
    getDefaultSidebarWidth: true,
    getDefaultHeaderHeight: true,
    getHeaderTitle: true,
    Header: true,
    HeaderBackButton: true,
    HeaderBackContext: true,
    HeaderBackground: true,
    HeaderButton: true,
    HeaderHeightContext: true,
    HeaderShownContext: true,
    HeaderTitle: true,
    useHeaderHeight: true,
    getLabel: true,
    Label: true,
    MissingIcon: true,
    PlatformPressable: true,
    ResourceSavingView: true,
    SafeAreaProviderCompat: true,
    Screen: true,
    Text: true
  };
  exports.Assets = void 0;
  Object.defineProperty(exports, "Background", {
    enumerable: true,
    get: function () {
      return _Background.Background;
    }
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function () {
      return _Button.Button;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function () {
      return _Header.Header;
    }
  });
  Object.defineProperty(exports, "HeaderBackButton", {
    enumerable: true,
    get: function () {
      return _HeaderBackButton.HeaderBackButton;
    }
  });
  Object.defineProperty(exports, "HeaderBackContext", {
    enumerable: true,
    get: function () {
      return _HeaderBackContext.HeaderBackContext;
    }
  });
  Object.defineProperty(exports, "HeaderBackground", {
    enumerable: true,
    get: function () {
      return _HeaderBackground.HeaderBackground;
    }
  });
  Object.defineProperty(exports, "HeaderButton", {
    enumerable: true,
    get: function () {
      return _HeaderButton.HeaderButton;
    }
  });
  Object.defineProperty(exports, "HeaderHeightContext", {
    enumerable: true,
    get: function () {
      return _HeaderHeightContext.HeaderHeightContext;
    }
  });
  Object.defineProperty(exports, "HeaderShownContext", {
    enumerable: true,
    get: function () {
      return _HeaderShownContext.HeaderShownContext;
    }
  });
  Object.defineProperty(exports, "HeaderTitle", {
    enumerable: true,
    get: function () {
      return _HeaderTitle.HeaderTitle;
    }
  });
  Object.defineProperty(exports, "Label", {
    enumerable: true,
    get: function () {
      return _Label.Label;
    }
  });
  Object.defineProperty(exports, "MissingIcon", {
    enumerable: true,
    get: function () {
      return _MissingIcon.MissingIcon;
    }
  });
  Object.defineProperty(exports, "PlatformPressable", {
    enumerable: true,
    get: function () {
      return _PlatformPressable.PlatformPressable;
    }
  });
  Object.defineProperty(exports, "ResourceSavingView", {
    enumerable: true,
    get: function () {
      return _ResourceSavingView.ResourceSavingView;
    }
  });
  Object.defineProperty(exports, "SafeAreaProviderCompat", {
    enumerable: true,
    get: function () {
      return _SafeAreaProviderCompat.SafeAreaProviderCompat;
    }
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function () {
      return _Screen.Screen;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function () {
      return _Text.Text;
    }
  });
  Object.defineProperty(exports, "getDefaultHeaderHeight", {
    enumerable: true,
    get: function () {
      return _getDefaultHeaderHeight.getDefaultHeaderHeight;
    }
  });
  Object.defineProperty(exports, "getDefaultSidebarWidth", {
    enumerable: true,
    get: function () {
      return _getDefaultSidebarWidth.getDefaultSidebarWidth;
    }
  });
  Object.defineProperty(exports, "getHeaderTitle", {
    enumerable: true,
    get: function () {
      return _getHeaderTitle.getHeaderTitle;
    }
  });
  Object.defineProperty(exports, "getLabel", {
    enumerable: true,
    get: function () {
      return _getLabel.getLabel;
    }
  });
  Object.defineProperty(exports, "useHeaderHeight", {
    enumerable: true,
    get: function () {
      return _useHeaderHeight.useHeaderHeight;
    }
  });
  var _backIcon = _interopRequireDefault(require(_dependencyMap[1], "./assets/back-icon.png"));
  var _backIconMask = _interopRequireDefault(require(_dependencyMap[2], "./assets/back-icon-mask.png"));
  var _clearIcon = _interopRequireDefault(require(_dependencyMap[3], "./assets/clear-icon.png"));
  var _closeIcon = _interopRequireDefault(require(_dependencyMap[4], "./assets/close-icon.png"));
  var _searchIcon = _interopRequireDefault(require(_dependencyMap[5], "./assets/search-icon.png"));
  var _Background = require(_dependencyMap[6], "./Background.js");
  var _Button = require(_dependencyMap[7], "./Button.js");
  var _getDefaultSidebarWidth = require(_dependencyMap[8], "./getDefaultSidebarWidth.js");
  var _getDefaultHeaderHeight = require(_dependencyMap[9], "./Header/getDefaultHeaderHeight.js");
  var _getHeaderTitle = require(_dependencyMap[10], "./Header/getHeaderTitle.js");
  var _Header = require(_dependencyMap[11], "./Header/Header.js");
  var _HeaderBackButton = require(_dependencyMap[12], "./Header/HeaderBackButton.js");
  var _HeaderBackContext = require(_dependencyMap[13], "./Header/HeaderBackContext.js");
  var _HeaderBackground = require(_dependencyMap[14], "./Header/HeaderBackground.js");
  var _HeaderButton = require(_dependencyMap[15], "./Header/HeaderButton.js");
  var _HeaderHeightContext = require(_dependencyMap[16], "./Header/HeaderHeightContext.js");
  var _HeaderShownContext = require(_dependencyMap[17], "./Header/HeaderShownContext.js");
  var _HeaderTitle = require(_dependencyMap[18], "./Header/HeaderTitle.js");
  var _useHeaderHeight = require(_dependencyMap[19], "./Header/useHeaderHeight.js");
  var _getLabel = require(_dependencyMap[20], "./Label/getLabel.js");
  var _Label = require(_dependencyMap[21], "./Label/Label.js");
  var _MissingIcon = require(_dependencyMap[22], "./MissingIcon.js");
  var _PlatformPressable = require(_dependencyMap[23], "./PlatformPressable.js");
  var _ResourceSavingView = require(_dependencyMap[24], "./ResourceSavingView.js");
  var _SafeAreaProviderCompat = require(_dependencyMap[25], "./SafeAreaProviderCompat.js");
  var _Screen = require(_dependencyMap[26], "./Screen.js");
  var _Text = require(_dependencyMap[27], "./Text.js");
  var _types = require(_dependencyMap[28], "./types.js");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  const Assets = exports.Assets = [_backIcon.default, _backIconMask.default, _searchIcon.default, _closeIcon.default, _clearIcon.default];
},541,[17,542,543,544,545,546,547,548,559,560,561,562,563,572,567,565,573,569,571,574,575,576,577,557,578,579,580,558,581],"node_modules\\@react-navigation\\elements\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/back-icon.png",
    width: 96,
    height: 96
  };
},542,[],"node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/back-icon-mask.png",
    width: 50,
    height: 85
  };
},543,[],"node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon-mask.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/clear-icon.png",
    width: 64,
    height: 64
  };
},544,[],"node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/close-icon.png",
    width: 96,
    height: 96
  };
},545,[],"node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/search-icon.png",
    width: 96,
    height: 96
  };
},546,[],"node_modules\\@react-navigation\\elements\\lib\\module\\assets\\search-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Background = Background;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Animated"));
  var _jsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  const _excluded = ["style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function Background(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors
    } = (0, _native.useTheme)();
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.View, Object.assign({}, rest, {
      style: [{
        flex: 1,
        backgroundColor: colors.background
      }, style]
    }));
  }
},547,[17,29,350,3,104,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Background.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Button = Button;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _color = _interopRequireDefault(require(_dependencyMap[3], "color"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _PlatformPressable = require(_dependencyMap[7], "./PlatformPressable.js");
  var _Text = require(_dependencyMap[8], "./Text.js");
  var _jsxRuntime = require(_dependencyMap[9], "react/jsx-runtime");
  const _excluded = ["screen", "params", "action", "href"],
    _excluded2 = ["variant", "color", "android_ripple", "style", "children"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const BUTTON_RADIUS = 40;
  function Button(props) {
    if ('screen' in props || 'action' in props) {
      // @ts-expect-error: This is already type-checked by the prop types
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(ButtonLink, Object.assign({}, props));
    } else {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(ButtonBase, Object.assign({}, props));
    }
  }
  function ButtonLink(_ref) {
    let {
        screen,
        params,
        action,
        href
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    // @ts-expect-error: This is already type-checked by the prop types
    const props = (0, _native.useLinkProps)({
      screen,
      params,
      action,
      href
    });
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(ButtonBase, Object.assign({}, rest, props));
  }
  function ButtonBase(_ref2) {
    let {
        variant = 'tinted',
        color: customColor,
        android_ripple,
        style,
        children
      } = _ref2,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    const color = customColor ?? colors.primary;
    let backgroundColor;
    let textColor;
    switch (variant) {
      case 'plain':
        backgroundColor = 'transparent';
        textColor = color;
        break;
      case 'tinted':
        backgroundColor = (0, _color.default)(color).fade(0.85).string();
        textColor = color;
        break;
      case 'filled':
        backgroundColor = color;
        textColor = (0, _color.default)(color).isDark() ? 'white' : (0, _color.default)(color).darken(0.71).string();
        break;
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_PlatformPressable.PlatformPressable, Object.assign({}, rest, {
      android_ripple: Object.assign({
        radius: BUTTON_RADIUS,
        color: (0, _color.default)(textColor).fade(0.85).string()
      }, android_ripple),
      pressOpacity: _Platform.default.OS === 'ios' ? undefined : 1,
      hoverEffect: {
        color: textColor
      },
      style: [{
        backgroundColor
      }, styles.button, style],
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Text.Text, {
        style: [{
          color: textColor
        }, fonts.regular, styles.text],
        children: children
      })
    }));
  }
  const styles = _StyleSheet.default.create({
    button: {
      paddingHorizontal: 24,
      paddingVertical: 10,
      borderRadius: BUTTON_RADIUS
    },
    text: {
      fontSize: 14,
      lineHeight: 20,
      letterSpacing: 0.1,
      textAlign: 'center'
    }
  });
},548,[17,29,350,549,3,106,30,557,558,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Button.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const colorString = require(_dependencyMap[0], "color-string");
  const convert = require(_dependencyMap[1], "color-convert");
  const skippedModels = [
  // To be honest, I don't really feel like keyword belongs in color convert, but eh.
  'keyword',
  // Gray conflicts with some method names, and has its own method defined.
  'gray',
  // Shouldn't really be in color-convert either...
  'hex'];
  const hashedModelKeys = {};
  for (const model of Object.keys(convert)) {
    hashedModelKeys[[...convert[model].labels].sort().join('')] = model;
  }
  const limiters = {};
  function Color(object, model) {
    if (!(this instanceof Color)) {
      return new Color(object, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error('Unknown model: ' + model);
    }
    let i;
    let channels;
    if (object == null) {
      // eslint-disable-line no-eq-null,eqeqeq
      this.model = 'rgb';
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === 'string') {
      const result = colorString.get(object);
      if (result === null) {
        throw new Error('Unable to parse color from string: ' + object);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || 'rgb';
      channels = convert[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
    } else if (typeof object === 'number') {
      // This is always RGB - can be converted later on.
      this.model = 'rgb';
      this.color = [object >> 16 & 0xFF, object >> 8 & 0xFF, object & 0xFF];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object);
      if ('alpha' in object) {
        keys.splice(keys.indexOf('alpha'), 1);
        this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
      }
      const hashedKeys = keys.sort().join('');
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const {
        labels
      } = convert[this.model];
      const color = [];
      for (i = 0; i < labels.length; i++) {
        color.push(object[labels[i]]);
      }
      this.color = zeroArray(color);
    }

    // Perform limitations (clamping, etc.)
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0; i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self = this.model in colorString.to ? this : this.rgb();
      self = self.round(typeof places === 'number' ? places : 1);
      const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
      return colorString.to[self.model](args);
    },
    percentString(places) {
      const self = this.rgb().round(typeof places === 'number' ? places : 1);
      const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const {
        channels
      } = convert[this.model];
      const {
        labels
      } = convert[this.model];
      for (let i = 0; i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    // Rgb
    red: getset('rgb', 0, maxfn(255)),
    green: getset('rgb', 1, maxfn(255)),
    blue: getset('rgb', 2, maxfn(255)),
    hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => (value % 360 + 360) % 360),
    saturationl: getset('hsl', 1, maxfn(100)),
    lightness: getset('hsl', 2, maxfn(100)),
    saturationv: getset('hsv', 1, maxfn(100)),
    value: getset('hsv', 2, maxfn(100)),
    chroma: getset('hcg', 1, maxfn(100)),
    gray: getset('hcg', 2, maxfn(100)),
    white: getset('hwb', 1, maxfn(100)),
    wblack: getset('hwb', 2, maxfn(100)),
    cyan: getset('cmyk', 0, maxfn(100)),
    magenta: getset('cmyk', 1, maxfn(100)),
    yellow: getset('cmyk', 2, maxfn(100)),
    black: getset('cmyk', 3, maxfn(100)),
    x: getset('xyz', 0, maxfn(95.047)),
    y: getset('xyz', 1, maxfn(100)),
    z: getset('xyz', 2, maxfn(108.833)),
    l: getset('lab', 0, maxfn(100)),
    a: getset('lab', 1),
    b: getset('lab', 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return convert[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = '0' + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;
    },
    luminosity() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      // https://www.w3.org/TR/WCAG/#contrast-enhanced
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return 'AAA';
      }
      return contrastRatio >= 4.5 ? 'AA' : '';
    },
    isDark() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0; i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      // Ported from sass implementation in C
      // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };

  // Model conversion methods and static constructors
  for (const model of Object.keys(convert)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const {
      channels
    } = convert[model];

    // Conversion methods
    Color.prototype[model] = function (...args) {
      if (this.model === model) {
        return new Color(this);
      }
      if (args.length > 0) {
        return new Color(args, model);
      }
      return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
    };

    // 'static' construction methods
    Color[model] = function (...args) {
      let color = args[0];
      if (typeof color === 'number') {
        color = zeroArray(args, channels);
      }
      return new Color(color, model);
    };
  }
  function roundTo(number, places) {
    return Number(number.toFixed(places));
  }
  function roundToPlace(places) {
    return function (number) {
      return roundTo(number, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    }
    model = model[0];
    return function (value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function (v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function zeroArray(array, length) {
    for (let i = 0; i < length; i++) {
      if (typeof array[i] !== 'number') {
        array[i] = 0;
      }
    }
    return array;
  }
  module.exports = Color;
},549,[550,554],"node_modules\\color\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* MIT license */
  var colorNames = require(_dependencyMap[0], "color-name");
  var swizzle = require(_dependencyMap[1], "simple-swizzle");
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);

  // create a list of reverse color names
  for (var name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function (string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case 'hsl':
        val = cs.get.hsl(string);
        model = 'hsl';
        break;
      case 'hwb':
        val = cs.get.hwb(string);
        model = 'hwb';
        break;
      default:
        val = cs.get.rgb(string);
        model = 'rgb';
        break;
    }
    if (!val) {
      return null;
    }
    return {
      model: model,
      value: val
    };
  };
  cs.get.rgb = function (string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0; i < 3; i++) {
        // https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === 'transparent') {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function (string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function (string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function () {
    var rgba = swizzle(arguments);
    return '#' + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : '');
  };
  cs.to.rgb = function () {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')' : 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
  };
  cs.to.rgb.percent = function () {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)' : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
  };
  cs.to.hsl = function () {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)' : 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
  };

  // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
  // (hwb have alpha optional & 1 is default value)
  cs.to.hwb = function () {
    var hwba = swizzle(arguments);
    var a = '';
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ', ' + hwba[3];
    }
    return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
  };
  cs.to.keyword = function (rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };

  // helpers
  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? '0' + str : str;
  }
},550,[551,552],"node_modules\\color-string\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
},551,[],"node_modules\\color-name\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var isArrayish = require(_dependencyMap[0], "is-arrayish");
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        // http://jsperf.com/javascript-array-concat-vs-push/98
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function (fn) {
    return function () {
      return fn(swizzle(arguments));
    };
  };
},552,[553],"node_modules\\simple-swizzle\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === 'string') {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== 'String');
  };
},553,[],"node_modules\\simple-swizzle\\node_modules\\is-arrayish\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const conversions = require(_dependencyMap[0], "./conversions");
  const route = require(_dependencyMap[1], "./route");
  const convert = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };

    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);

      // We're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.
      if (typeof result === 'object') {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };

    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(fromModel => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach(toModel => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
},554,[555,556],"node_modules\\color-convert\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* MIT license */
  /* eslint-disable no-mixed-operators */
  const cssKeywords = require(_dependencyMap[0], "color-name");

  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)

  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };
  module.exports = convert;

  // Hide .channels and .labels properties
  for (const model of Object.keys(convert)) {
    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }
    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }
    const {
      channels,
      labels
    } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
      value: labels
    });
  }
  convert.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [h * 360, s * 100, v * 100];
  };
  convert.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    /*
    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
    */
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function (rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];

      // Compute comparative distance
      const distance = comparativeDistance(rgb, value);

      // Check if its less, if so set as closest
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function (keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;

    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function (rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  convert.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;

    // Wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh); // Linear interpolation

    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */

    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function (args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];

    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function (args) {
    let color = args % 10;

    // Handle greyscale
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function (args) {
    // Handle greyscale
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function (args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split('').map(char => {
        return char + char;
      }).join('');
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [r, g, b];
  };
  convert.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;

    /* eslint-disable max-statements-per-line */
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };
  convert.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function (gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
},555,[551],"node_modules\\color-convert\\conversions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const conversions = require(_dependencyMap[0], "./conversions");

  /*
  	This function routes a model to all other models.
  
  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).
  
  	conversions that are not possible simply are not included.
  */

  function buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }

  // https://en.wikipedia.org/wiki/Breadth-first_search
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel]; // Unshift -> queue -> pop

    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function (fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        // No possible conversion, or this node is the source model.
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
},556,[555],"node_modules\\color-convert\\route.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PlatformPressable = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Animated"));
  var _Easing = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Easing"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Platform"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/Pressable"));
  var _jsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  const _excluded = ["disabled", "onPress", "onPressIn", "onPressOut", "android_ripple", "pressColor", "pressOpacity", "hoverEffect", "style", "children"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const AnimatedPressable = _Animated.default.createAnimatedComponent(_Pressable.default);
  const ANDROID_VERSION_LOLLIPOP = 21;
  const ANDROID_SUPPORTS_RIPPLE = _Platform.default.OS === 'android' && _Platform.default.Version >= ANDROID_VERSION_LOLLIPOP;
  const useNativeDriver = _Platform.default.OS !== 'web';

  /**
   * PlatformPressable provides an abstraction on top of Pressable to handle platform differences.
   */
  function PlatformPressableInternal(_ref, ref) {
    let {
        disabled,
        onPress,
        onPressIn,
        onPressOut,
        android_ripple,
        pressColor,
        pressOpacity = 0.3,
        hoverEffect,
        style,
        children
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      dark
    } = (0, _native.useTheme)();
    const [opacity] = React.useState(() => new _Animated.default.Value(1));
    const animateTo = (toValue, duration) => {
      if (ANDROID_SUPPORTS_RIPPLE) {
        return;
      }
      _Animated.default.timing(opacity, {
        toValue,
        duration,
        easing: _Easing.default.inOut(_Easing.default.quad),
        useNativeDriver
      }).start();
    };
    const handlePress = e => {
      if (_Platform.default.OS === 'web' && rest.href !== null) {
        // ignore clicks with modifier keys
        const hasModifierKey = 'metaKey' in e && e.metaKey || 'altKey' in e && e.altKey || 'ctrlKey' in e && e.ctrlKey || 'shiftKey' in e && e.shiftKey;

        // only handle left clicks
        const isLeftClick = 'button' in e ? e.button == null || e.button === 0 : true;

        // let browser handle "target=_blank" etc.
        const isSelfTarget = e.currentTarget && 'target' in e.currentTarget ? [undefined, null, '', 'self'].includes(e.currentTarget.target) : true;
        if (!hasModifierKey && isLeftClick && isSelfTarget) {
          e.preventDefault();
          // call `onPress` only when browser default is prevented
          // this prevents app from handling the click when a link is being opened
          onPress?.(e);
        }
      } else {
        onPress?.(e);
      }
    };
    const handlePressIn = e => {
      animateTo(pressOpacity, 0);
      onPressIn?.(e);
    };
    const handlePressOut = e => {
      animateTo(1, 200);
      onPressOut?.(e);
    };
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(AnimatedPressable, Object.assign({
      ref: ref,
      accessible: true,
      role: _Platform.default.OS === 'web' && rest.href != null ? 'link' : 'button',
      onPress: disabled ? undefined : handlePress,
      onPressIn: handlePressIn,
      onPressOut: handlePressOut,
      android_ripple: ANDROID_SUPPORTS_RIPPLE ? Object.assign({
        color: pressColor !== undefined ? pressColor : dark ? 'rgba(255, 255, 255, .32)' : 'rgba(0, 0, 0, .32)'
      }, android_ripple) : undefined,
      style: [{
        cursor: _Platform.default.OS === 'web' || _Platform.default.OS === 'ios' ?
        // Pointer cursor on web
        // Hover effect on iPad and visionOS
        'pointer' : 'auto',
        opacity: !ANDROID_SUPPORTS_RIPPLE ? opacity : 1
      }, style]
    }, rest, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(HoverEffect, Object.assign({}, hoverEffect)), children]
    }));
  }
  const PlatformPressable = exports.PlatformPressable = /*#__PURE__*/React.forwardRef(PlatformPressableInternal);
  PlatformPressable.displayName = 'PlatformPressable';
  const css = String.raw;
  const CLASS_NAME = `__react-navigation_elements_Pressable_hover`;
  const CSS_TEXT = css`
  .${CLASS_NAME} {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: inherit;
    background-color: var(--overlay-color);
    opacity: 0;
    transition: opacity 0.15s;
  }

  a:hover > .${CLASS_NAME}, button:hover > .${CLASS_NAME} {
    opacity: var(--overlay-hover-opacity);
  }

  a:active > .${CLASS_NAME}, button:active > .${CLASS_NAME} {
    opacity: var(--overlay-active-opacity);
  }
`;
  const HoverEffect = ({
    color,
    hoverOpacity = 0.08,
    activeOpacity = 0.16
  }) => {
    if (_Platform.default.OS !== 'web' || color == null) {
      return null;
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("style", {
        href: CLASS_NAME,
        precedence: "elements",
        children: CSS_TEXT
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: CLASS_NAME,
        style: {
          // @ts-expect-error: CSS variables are not typed
          '--overlay-color': color,
          '--overlay-hover-opacity': hoverOpacity,
          '--overlay-active-opacity': activeOpacity
        }
      })]
    });
  };
},557,[17,29,350,3,104,208,106,244,6],"node_modules\\@react-navigation\\elements\\lib\\module\\PlatformPressable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Text = Text;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _jsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const _excluded = ["style"]; // eslint-disable-next-line no-restricted-imports
  function Text(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Text.default, Object.assign({}, rest, {
      style: [{
        color: colors.text
      }, fonts.regular, style]
    }));
  }
},558,[17,29,350,190,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Text.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDefaultSidebarWidth = void 0;
  const APPROX_APP_BAR_HEIGHT = 56;
  const DEFAULT_DRAWER_WIDTH = 360;
  const getDefaultSidebarWidth = ({
    width
  }) => {
    /**
     * Default sidebar width is 360dp
     * On screens smaller than 320dp, ideally the drawer would collapse to a tab bar
     * https://m3.material.io/components/navigation-drawer/specs
     */
    if (width - APPROX_APP_BAR_HEIGHT <= 360) {
      return width - APPROX_APP_BAR_HEIGHT;
    }
    return DEFAULT_DRAWER_WIDTH;
  };
  exports.getDefaultSidebarWidth = getDefaultSidebarWidth;
},559,[],"node_modules\\@react-navigation\\elements\\lib\\module\\getDefaultSidebarWidth.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDefaultHeaderHeight = getDefaultHeaderHeight;
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/PixelRatio"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  function getDefaultHeaderHeight(layout, modalPresentation, topInset) {
    let headerHeight;

    // On models with Dynamic Island the status bar height is smaller than the safe area top inset.
    const hasDynamicIsland = _Platform.default.OS === 'ios' && topInset > 50;
    const statusBarHeight = hasDynamicIsland ? topInset - (5 + 1 / _PixelRatio.default.get()) : topInset;
    const isLandscape = layout.width > layout.height;
    if (_Platform.default.OS === 'ios') {
      if (_Platform.default.isPad || _Platform.default.isTV) {
        if (modalPresentation) {
          headerHeight = 56;
        } else {
          headerHeight = 50;
        }
      } else {
        if (isLandscape) {
          headerHeight = 32;
        } else {
          if (modalPresentation) {
            headerHeight = 56;
          } else {
            headerHeight = 44;
          }
        }
      }
    } else {
      headerHeight = 64;
    }
    return headerHeight + statusBarHeight;
  }
},560,[17,183,106],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\getDefaultHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getHeaderTitle = getHeaderTitle;
  function getHeaderTitle(options, fallback) {
    return typeof options.headerTitle === 'string' ? options.headerTitle : options.title !== undefined ? options.title : fallback;
  }
},561,[],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\getHeaderTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Header = Header;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _color = _interopRequireDefault(require(_dependencyMap[3], "color"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/View"));
  var _reactNativeSafeAreaContext = require(_dependencyMap[9], "react-native-safe-area-context");
  var _searchIcon = _interopRequireDefault(require(_dependencyMap[10], "../assets/search-icon.png"));
  var _getDefaultHeaderHeight = require(_dependencyMap[11], "./getDefaultHeaderHeight.js");
  var _HeaderBackButton = require(_dependencyMap[12], "./HeaderBackButton.js");
  var _HeaderBackground = require(_dependencyMap[13], "./HeaderBackground.js");
  var _HeaderButton = require(_dependencyMap[14], "./HeaderButton.js");
  var _HeaderIcon = require(_dependencyMap[15], "./HeaderIcon.js");
  var _HeaderSearchBar = require(_dependencyMap[16], "./HeaderSearchBar.js");
  var _HeaderShownContext = require(_dependencyMap[17], "./HeaderShownContext.js");
  var _HeaderTitle = require(_dependencyMap[18], "./HeaderTitle.js");
  var _jsxRuntime = require(_dependencyMap[19], "react/jsx-runtime");
  const _excluded = ["height", "minHeight", "maxHeight", "backgroundColor", "borderBottomColor", "borderBottomEndRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStartRadius", "borderBottomWidth", "borderColor", "borderEndColor", "borderEndWidth", "borderLeftColor", "borderLeftWidth", "borderRadius", "borderRightColor", "borderRightWidth", "borderStartColor", "borderStartWidth", "borderStyle", "borderTopColor", "borderTopEndRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStartRadius", "borderTopWidth", "borderWidth", "boxShadow", "elevation", "shadowColor", "shadowOffset", "shadowOpacity", "shadowRadius", "opacity", "transform"]; // Width of the screen in split layout on portrait mode on iPad Mini
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const IPAD_MINI_MEDIUM_WIDTH = 414;
  const warnIfHeaderStylesDefined = styles => {
    Object.keys(styles).forEach(styleProp => {
      const value = styles[styleProp];
      if (styleProp === 'position' && value === 'absolute') {
        console.warn("position: 'absolute' is not supported on headerStyle. If you would like to render content under the header, use the 'headerTransparent' option.");
      } else if (value !== undefined) {
        console.warn(`${styleProp} was given a value of ${value}, this has no effect on headerStyle.`);
      }
    });
  };
  function Header(props) {
    const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
    const frame = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
    const {
      colors
    } = (0, _native.useTheme)();
    const navigation = (0, _native.useNavigation)();
    const isParentHeaderShown = React.useContext(_HeaderShownContext.HeaderShownContext);
    const [searchBarVisible, setSearchBarVisible] = React.useState(false);
    const [titleLayout, setTitleLayout] = React.useState(undefined);
    const onTitleLayout = e => {
      const {
        height,
        width
      } = e.nativeEvent.layout;
      setTitleLayout(titleLayout => {
        if (titleLayout && height === titleLayout.height && width === titleLayout.width) {
          return titleLayout;
        }
        return {
          height,
          width
        };
      });
    };
    const {
      layout = frame,
      modal = false,
      back,
      title,
      headerTitle: customTitle,
      headerTitleAlign = _Platform.default.OS === 'ios' ? 'center' : 'left',
      headerLeft = back ? props => /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderBackButton.HeaderBackButton, Object.assign({}, props)) : undefined,
      headerSearchBarOptions,
      headerTransparent,
      headerTintColor,
      headerBackground,
      headerRight,
      headerTitleAllowFontScaling: titleAllowFontScaling,
      headerTitleStyle: titleStyle,
      headerLeftContainerStyle: leftContainerStyle,
      headerRightContainerStyle: rightContainerStyle,
      headerTitleContainerStyle: titleContainerStyle,
      headerBackButtonDisplayMode = _Platform.default.OS === 'ios' ? 'default' : 'minimal',
      headerBackTitleStyle,
      headerBackgroundContainerStyle: backgroundContainerStyle,
      headerStyle: customHeaderStyle,
      headerShadowVisible,
      headerPressColor,
      headerPressOpacity,
      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top
    } = props;
    const defaultHeight = (0, _getDefaultHeaderHeight.getDefaultHeaderHeight)(layout, modal, headerStatusBarHeight);
    const _StyleSheet$flatten = _StyleSheet.default.flatten(customHeaderStyle || {}),
      {
        height = defaultHeight,
        minHeight,
        maxHeight,
        backgroundColor,
        borderBottomColor,
        borderBottomEndRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius,
        borderBottomStartRadius,
        borderBottomWidth,
        borderColor,
        borderEndColor,
        borderEndWidth,
        borderLeftColor,
        borderLeftWidth,
        borderRadius,
        borderRightColor,
        borderRightWidth,
        borderStartColor,
        borderStartWidth,
        borderStyle,
        borderTopColor,
        borderTopEndRadius,
        borderTopLeftRadius,
        borderTopRightRadius,
        borderTopStartRadius,
        borderTopWidth,
        borderWidth,
        boxShadow,
        elevation,
        shadowColor,
        shadowOffset,
        shadowOpacity,
        shadowRadius,
        opacity,
        transform
      } = _StyleSheet$flatten,
      unsafeStyles = (0, _objectWithoutPropertiesLoose2.default)(_StyleSheet$flatten, _excluded);
    if (process.env.NODE_ENV !== 'production') {
      warnIfHeaderStylesDefined(unsafeStyles);
    }
    const safeStyles = {
      backgroundColor,
      borderBottomColor,
      borderBottomEndRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius,
      borderBottomStartRadius,
      borderBottomWidth,
      borderColor,
      borderEndColor,
      borderEndWidth,
      borderLeftColor,
      borderLeftWidth,
      borderRadius,
      borderRightColor,
      borderRightWidth,
      borderStartColor,
      borderStartWidth,
      borderStyle,
      borderTopColor,
      borderTopEndRadius,
      borderTopLeftRadius,
      borderTopRightRadius,
      borderTopStartRadius,
      borderTopWidth,
      borderWidth,
      boxShadow,
      elevation,
      shadowColor,
      shadowOffset,
      shadowOpacity,
      shadowRadius,
      opacity,
      transform
    };

    // Setting a property to undefined triggers default style
    // So we need to filter them out
    // Users can use `null` instead
    for (const styleProp in safeStyles) {
      // @ts-expect-error: typescript wrongly complains that styleProp cannot be used to index safeStyles
      if (safeStyles[styleProp] === undefined) {
        // @ts-expect-error don't need to care about index signature for deletion
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete safeStyles[styleProp];
      }
    }
    const backgroundStyle = Object.assign({}, headerTransparent && {
      backgroundColor: 'transparent'
    }, (headerTransparent || headerShadowVisible === false) && Object.assign({
      borderBottomWidth: 0
    }, _Platform.default.select({
      android: {
        elevation: 0
      },
      web: {
        boxShadow: 'none'
      },
      default: {
        shadowOpacity: 0
      }
    })), safeStyles);
    const iconTintColor = headerTintColor ?? _Platform.default.select({
      ios: colors.primary,
      default: colors.text
    });
    const leftButton = headerLeft ? headerLeft({
      tintColor: iconTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity,
      displayMode: headerBackButtonDisplayMode,
      titleLayout,
      screenLayout: layout,
      canGoBack: Boolean(back),
      onPress: back ? navigation.goBack : undefined,
      label: back?.title,
      labelStyle: headerBackTitleStyle,
      href: back?.href
    }) : null;
    const rightButton = headerRight ? headerRight({
      tintColor: iconTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity,
      canGoBack: Boolean(back)
    }) : null;
    const headerTitle = typeof customTitle !== 'function' ? props => /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderTitle.HeaderTitle, Object.assign({}, props)) : customTitle;
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Animated.default.View, {
      pointerEvents: "box-none",
      style: [{
        height,
        minHeight,
        maxHeight,
        opacity,
        transform
      }],
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.View, {
        pointerEvents: "box-none",
        style: [_StyleSheet.default.absoluteFill, backgroundContainerStyle],
        children: headerBackground ? headerBackground({
          style: backgroundStyle
        }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderBackground.HeaderBackground, {
          pointerEvents:
          // Allow touch through the header when background color is transparent
          headerTransparent && (backgroundStyle.backgroundColor === 'transparent' || (0, _color.default)(backgroundStyle.backgroundColor).alpha() === 0) ? 'none' : 'auto',
          style: backgroundStyle
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        pointerEvents: "none",
        style: {
          height: headerStatusBarHeight
        }
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_View.default, {
        pointerEvents: "box-none",
        style: [styles.content, _Platform.default.OS === 'ios' && frame.width >= IPAD_MINI_MEDIUM_WIDTH ? styles.large : null],
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.View, {
          pointerEvents: "box-none",
          style: [styles.start, !searchBarVisible && headerTitleAlign === 'center' && styles.expand, {
            marginStart: insets.left
          }, leftContainerStyle],
          children: leftButton
        }), _Platform.default.OS === 'ios' || !searchBarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.View, {
            pointerEvents: "box-none",
            style: [styles.title, {
              // Avoid the title from going offscreen or overlapping buttons
              maxWidth: headerTitleAlign === 'center' ? layout.width - ((leftButton ? headerBackButtonDisplayMode !== 'minimal' ? 80 : 32 : 16) + (rightButton || headerSearchBarOptions ? 16 : 0) + Math.max(insets.left, insets.right)) * 2 : layout.width - ((leftButton ? 52 : 16) + (rightButton || headerSearchBarOptions ? 52 : 16) + insets.left - insets.right)
            }, headerTitleAlign === 'left' && leftButton ? {
              marginStart: 4
            } : {
              marginHorizontal: 16
            }, titleContainerStyle],
            children: headerTitle({
              children: title,
              allowFontScaling: titleAllowFontScaling,
              tintColor: headerTintColor,
              onLayout: onTitleLayout,
              style: titleStyle
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Animated.default.View, {
            pointerEvents: "box-none",
            style: [styles.end, styles.expand, {
              marginEnd: insets.right
            }, rightContainerStyle],
            children: [rightButton, headerSearchBarOptions ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderButton.HeaderButton, {
              tintColor: iconTintColor,
              pressColor: headerPressColor,
              pressOpacity: headerPressOpacity,
              onPress: () => {
                setSearchBarVisible(true);
                headerSearchBarOptions?.onOpen?.();
              },
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderIcon.HeaderIcon, {
                source: _searchIcon.default,
                tintColor: iconTintColor
              })
            }) : null]
          })]
        }) : null, _Platform.default.OS === 'ios' || searchBarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderSearchBar.HeaderSearchBar, Object.assign({}, headerSearchBarOptions, {
          visible: searchBarVisible,
          onClose: () => {
            setSearchBarVisible(false);
            headerSearchBarOptions?.onClose?.();
          },
          tintColor: headerTintColor,
          style: [_Platform.default.OS === 'ios' ? [_StyleSheet.default.absoluteFill, {
            paddingTop: headerStatusBarHeight ? 0 : 4
          }, {
            backgroundColor: backgroundColor ?? colors.card
          }] : !leftButton && {
            marginStart: 8
          }]
        })) : null]
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    content: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    },
    large: {
      marginHorizontal: 5
    },
    title: {
      justifyContent: 'center'
    },
    start: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start'
    },
    end: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end'
    },
    expand: {
      flexGrow: 1,
      flexBasis: 0
    }
  });
},562,[17,29,350,549,3,104,106,30,111,893,546,560,563,567,565,566,568,569,571,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\Header.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderBackButton = HeaderBackButton;
  var _native = require(_dependencyMap[1], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Animated"));
  var _Image = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Image"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/View"));
  var _backIcon = _interopRequireDefault(require(_dependencyMap[8], "../assets/back-icon.png"));
  var _backIconMask = _interopRequireDefault(require(_dependencyMap[9], "../assets/back-icon-mask.png"));
  var _MaskedView = require(_dependencyMap[10], "../MaskedView");
  var _HeaderButton = require(_dependencyMap[11], "./HeaderButton.js");
  var _HeaderIcon = require(_dependencyMap[12], "./HeaderIcon.js");
  var _jsxRuntime = require(_dependencyMap[13], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function HeaderBackButton({
    disabled,
    allowFontScaling,
    backImage,
    label,
    labelStyle,
    displayMode = _Platform.default.OS === 'ios' ? 'default' : 'minimal',
    onLabelLayout,
    onPress,
    pressColor,
    pressOpacity,
    screenLayout,
    tintColor,
    titleLayout,
    truncatedLabel = 'Back',
    accessibilityLabel = label && label !== 'Back' ? `${label}, back` : 'Go back',
    testID,
    style,
    href
  }) {
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    const {
      direction
    } = (0, _native.useLocale)();
    const [labelWidth, setLabelWidth] = React.useState(null);
    const [truncatedLabelWidth, setTruncatedLabelWidth] = React.useState(null);
    const renderBackImage = () => {
      if (backImage) {
        return backImage({
          tintColor: tintColor ?? colors.text
        });
      } else {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderIcon.HeaderIcon, {
          source: _backIcon.default,
          tintColor: tintColor,
          style: [styles.icon, displayMode !== 'minimal' && styles.iconWithLabel]
        });
      }
    };
    const renderLabel = () => {
      if (displayMode === 'minimal') {
        return null;
      }
      const availableSpace = titleLayout && screenLayout ? (screenLayout.width - titleLayout.width) / 2 - (ICON_WIDTH + _HeaderIcon.ICON_MARGIN) : null;
      const potentialLabelText = displayMode === 'default' ? label : truncatedLabel;
      const finalLabelText = availableSpace && labelWidth && truncatedLabelWidth ? availableSpace > labelWidth ? potentialLabelText : availableSpace > truncatedLabelWidth ? truncatedLabel : null : potentialLabelText;
      const commonStyle = [fonts.regular, styles.label, labelStyle];
      const hiddenStyle = [commonStyle, {
        position: 'absolute',
        top: 0,
        left: 0,
        opacity: 0
      }];
      const labelElement = /*#__PURE__*/(0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.labelWrapper,
        children: [label && displayMode === 'default' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.Text, {
          style: hiddenStyle,
          numberOfLines: 1,
          onLayout: e => setLabelWidth(e.nativeEvent.layout.width),
          children: label
        }) : null, truncatedLabel ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.Text, {
          style: hiddenStyle,
          numberOfLines: 1,
          onLayout: e => setTruncatedLabelWidth(e.nativeEvent.layout.width),
          children: truncatedLabel
        }) : null, finalLabelText ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.Text, {
          accessible: false,
          onLayout: onLabelLayout,
          style: [tintColor ? {
            color: tintColor
          } : null, commonStyle],
          numberOfLines: 1,
          allowFontScaling: !!allowFontScaling,
          children: finalLabelText
        }) : null]
      });
      if (backImage || _Platform.default.OS !== 'ios') {
        // When a custom backimage is specified, we can't mask the label
        // Otherwise there might be weird effect due to our mask not being the same as the image
        return labelElement;
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_MaskedView.MaskedView, {
        maskElement: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_View.default, {
          style: [styles.iconMaskContainer,
          // Extend the mask to the center of the screen so that label isn't clipped during animation
          screenLayout ? {
            minWidth: screenLayout.width / 2 - 27
          } : null],
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Image.default, {
            source: _backIconMask.default,
            resizeMode: "contain",
            style: [styles.iconMask, direction === 'rtl' && styles.flip]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
            style: styles.iconMaskFillerRect
          })]
        }),
        children: labelElement
      });
    };
    const handlePress = () => {
      if (onPress) {
        requestAnimationFrame(() => onPress());
      }
    };
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderButton.HeaderButton, {
      disabled: disabled,
      href: href,
      accessibilityLabel: accessibilityLabel,
      testID: testID,
      onPress: handlePress,
      pressColor: pressColor,
      pressOpacity: pressOpacity,
      style: [styles.container, style],
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {
        children: [renderBackImage(), renderLabel()]
      })
    });
  }
  const ICON_WIDTH = _Platform.default.OS === 'ios' ? 13 : 24;
  const ICON_MARGIN_END = _Platform.default.OS === 'ios' ? 22 : 3;
  const styles = _StyleSheet.default.create({
    container: Object.assign({
      paddingHorizontal: 0,
      minWidth: _StyleSheet.default.hairlineWidth
    }, _Platform.default.select({
      ios: null,
      default: {
        marginVertical: 3,
        marginHorizontal: 11
      }
    })),
    label: {
      fontSize: 17,
      // Title and back label are a bit different width due to title being bold
      // Adjusting the letterSpacing makes them coincide better
      letterSpacing: 0.35
    },
    labelWrapper: {
      // These styles will make sure that the label doesn't fill the available space
      // Otherwise it messes with the measurement of the label
      flexDirection: 'row',
      alignItems: 'flex-start',
      marginEnd: _HeaderIcon.ICON_MARGIN
    },
    icon: {
      width: ICON_WIDTH,
      marginEnd: ICON_MARGIN_END
    },
    iconWithLabel: _Platform.default.OS === 'ios' ? {
      marginEnd: 6
    } : {},
    iconMaskContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    iconMaskFillerRect: {
      flex: 1,
      backgroundColor: '#000'
    },
    iconMask: {
      height: 21,
      width: 13,
      marginStart: -14.5,
      marginVertical: 12,
      alignSelf: 'center'
    },
    flip: {
      transform: 'scaleX(-1)'
    }
  });
},563,[17,350,3,104,180,106,30,111,542,543,564,565,566,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Use a stub for MaskedView on all Platforms that don't support it.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaskedView = MaskedView;
  function MaskedView({
    children
  }) {
    return children;
  }
},564,[],"node_modules\\@react-navigation\\elements\\lib\\module\\MaskedView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderButton = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _PlatformPressable = require(_dependencyMap[4], "../PlatformPressable.js");
  var _jsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function HeaderButtonInternal({
    disabled,
    onPress,
    pressColor,
    pressOpacity,
    accessibilityLabel,
    testID,
    style,
    href,
    children
  }, ref) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_PlatformPressable.PlatformPressable, {
      ref: ref,
      disabled: disabled,
      href: href,
      "aria-label": accessibilityLabel,
      testID: testID,
      onPress: onPress,
      pressColor: pressColor,
      pressOpacity: pressOpacity,
      android_ripple: androidRipple,
      style: [styles.container, disabled && styles.disabled, style],
      hitSlop: _Platform.default.select({
        ios: undefined,
        default: {
          top: 16,
          right: 16,
          bottom: 16,
          left: 16
        }
      }),
      children: children
    });
  }
  const HeaderButton = exports.HeaderButton = /*#__PURE__*/React.forwardRef(HeaderButtonInternal);
  HeaderButton.displayName = 'HeaderButton';
  const androidRipple = {
    borderless: true,
    foreground: _Platform.default.OS === 'android' && _Platform.default.Version >= 23,
    radius: 20
  };
  const styles = _StyleSheet.default.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      // Roundness for iPad hover effect
      borderRadius: 10
    },
    disabled: {
      opacity: 0.5
    }
  });
},565,[17,3,106,30,557,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderIcon = HeaderIcon;
  exports.ICON_SIZE = exports.ICON_MARGIN = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _Image = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Image"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _jsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  const _excluded = ["source", "style"];
  function HeaderIcon(_ref) {
    let {
        source,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors
    } = (0, _native.useTheme)();
    const {
      direction
    } = (0, _native.useLocale)();
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Image.default, Object.assign({
      source: source,
      resizeMode: "contain",
      fadeDuration: 0,
      tintColor: colors.text,
      style: [styles.icon, direction === 'rtl' && styles.flip, style]
    }, rest));
  }
  const ICON_SIZE = exports.ICON_SIZE = _Platform.default.OS === 'ios' ? 21 : 24;
  const ICON_MARGIN = exports.ICON_MARGIN = _Platform.default.OS === 'ios' ? 8 : 3;
  const styles = _StyleSheet.default.create({
    icon: {
      width: ICON_SIZE,
      height: ICON_SIZE,
      margin: ICON_MARGIN
    },
    flip: {
      transform: 'scaleX(-1)'
    }
  });
},566,[17,29,350,180,106,30,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderBackground = HeaderBackground;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _jsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  const _excluded = ["style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function HeaderBackground(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors,
      dark
    } = (0, _native.useTheme)();
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.View, Object.assign({
      style: [styles.container, Object.assign({
        backgroundColor: colors.card,
        borderBottomColor: colors.border
      }, _Platform.default.OS === 'ios' && {
        shadowColor: dark ? 'rgba(255, 255, 255, 0.45)' : 'rgba(0, 0, 0, 1)'
      }), style]
    }, rest));
  }
  const styles = _StyleSheet.default.create({
    container: Object.assign({
      flex: 1
    }, _Platform.default.select({
      android: {
        elevation: 4
      },
      ios: {
        shadowOpacity: 0.3,
        shadowRadius: 0,
        shadowOffset: {
          width: 0,
          height: _StyleSheet.default.hairlineWidth
        }
      },
      default: {
        borderBottomWidth: _StyleSheet.default.hairlineWidth
      }
    }))
  });
},567,[17,29,350,3,104,106,30,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderBackground.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderSearchBar = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _color = _interopRequireDefault(require(_dependencyMap[3], "color"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Animated"));
  var _Image = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Image"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/StyleSheet"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[9], "react-native-web/dist/exports/TextInput"));
  var _View = _interopRequireDefault(require(_dependencyMap[10], "react-native-web/dist/exports/View"));
  var _clearIcon = _interopRequireDefault(require(_dependencyMap[11], "../assets/clear-icon.png"));
  var _closeIcon = _interopRequireDefault(require(_dependencyMap[12], "../assets/close-icon.png"));
  var _searchIcon = _interopRequireDefault(require(_dependencyMap[13], "../assets/search-icon.png"));
  var _PlatformPressable = require(_dependencyMap[14], "../PlatformPressable.js");
  var _Text = require(_dependencyMap[15], "../Text.js");
  var _HeaderButton = require(_dependencyMap[16], "./HeaderButton.js");
  var _HeaderIcon = require(_dependencyMap[17], "./HeaderIcon.js");
  var _jsxRuntime = require(_dependencyMap[18], "react/jsx-runtime");
  const _excluded = ["visible", "inputType", "autoFocus", "placeholder", "cancelButtonText", "enterKeyHint", "onChangeText", "onClose", "tintColor", "style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const INPUT_TYPE_TO_MODE = {
    text: 'text',
    number: 'numeric',
    phone: 'tel',
    email: 'email'
  };
  const useNativeDriver = _Platform.default.OS !== 'web';
  function HeaderSearchBarInternal(_ref, ref) {
    let {
        visible,
        inputType,
        autoFocus = true,
        placeholder = 'Search',
        cancelButtonText = 'Cancel',
        enterKeyHint = 'search',
        onChangeText,
        onClose,
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const navigation = (0, _native.useNavigation)();
    const {
      dark,
      colors,
      fonts
    } = (0, _native.useTheme)();
    const [value, setValue] = React.useState('');
    const [rendered, setRendered] = React.useState(visible);
    const [visibleAnim] = React.useState(() => new _Animated.default.Value(visible ? 1 : 0));
    const [clearVisibleAnim] = React.useState(() => new _Animated.default.Value(0));
    const visibleValueRef = React.useRef(visible);
    const clearVisibleValueRef = React.useRef(false);
    const inputRef = React.useRef(null);
    React.useEffect(() => {
      // Avoid act warning in tests just by rendering header
      if (visible === visibleValueRef.current) {
        return;
      }
      _Animated.default.timing(visibleAnim, {
        toValue: visible ? 1 : 0,
        duration: 100,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished) {
          setRendered(visible);
          visibleValueRef.current = visible;
        }
      });
      return () => {
        visibleAnim.stopAnimation();
      };
    }, [visible, visibleAnim]);
    const hasText = value !== '';
    React.useEffect(() => {
      if (clearVisibleValueRef.current === hasText) {
        return;
      }
      _Animated.default.timing(clearVisibleAnim, {
        toValue: hasText ? 1 : 0,
        duration: 100,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished) {
          clearVisibleValueRef.current = hasText;
        }
      });
    }, [clearVisibleAnim, hasText]);
    const clearText = React.useCallback(() => {
      inputRef.current?.clear();
      inputRef.current?.focus();
      setValue('');
    }, []);
    const onClear = React.useCallback(() => {
      clearText();
      // FIXME: figure out how to create a SyntheticEvent
      // @ts-expect-error: we don't have the native event here
      onChangeText?.({
        nativeEvent: {
          text: ''
        }
      });
    }, [clearText, onChangeText]);
    const cancelSearch = React.useCallback(() => {
      onClear();
      onClose();
    }, [onClear, onClose]);
    React.useEffect(() => navigation?.addListener('blur', cancelSearch), [cancelSearch, navigation]);
    React.useImperativeHandle(ref, () => ({
      focus: () => {
        inputRef.current?.focus();
      },
      blur: () => {
        inputRef.current?.blur();
      },
      setText: text => {
        inputRef.current?.setNativeProps({
          text
        });
        setValue(text);
      },
      clearText,
      cancelSearch
    }), [cancelSearch, clearText]);
    if (!visible && !rendered) {
      return null;
    }
    const textColor = tintColor ?? colors.text;
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Animated.default.View, {
      pointerEvents: visible ? 'auto' : 'none',
      "aria-live": "polite",
      "aria-hidden": !visible,
      style: [styles.container, {
        opacity: visibleAnim
      }, style],
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.searchbarContainer,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderIcon.HeaderIcon, {
          source: _searchIcon.default,
          tintColor: textColor,
          style: styles.inputSearchIcon
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_TextInput.default, Object.assign({}, rest, {
          ref: inputRef,
          onChange: onChangeText,
          onChangeText: setValue,
          autoFocus: autoFocus,
          inputMode: INPUT_TYPE_TO_MODE[inputType ?? 'text'],
          enterKeyHint: enterKeyHint,
          placeholder: placeholder,
          placeholderTextColor: (0, _color.default)(textColor).alpha(0.5).string(),
          cursorColor: colors.primary,
          selectionHandleColor: colors.primary,
          selectionColor: (0, _color.default)(colors.primary).alpha(0.3).string(),
          style: [fonts.regular, styles.searchbar, {
            backgroundColor: _Platform.default.select({
              ios: dark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
              default: 'transparent'
            }),
            color: textColor,
            borderBottomColor: (0, _color.default)(textColor).alpha(0.2).string()
          }]
        })), _Platform.default.OS === 'ios' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_PlatformPressable.PlatformPressable, {
          onPress: onClear,
          style: [{
            opacity: clearVisibleAnim,
            transform: [{
              scale: clearVisibleAnim
            }]
          }, styles.clearButton],
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Image.default, {
            source: _clearIcon.default,
            resizeMode: "contain",
            tintColor: textColor,
            style: styles.clearIcon
          })
        }) : null]
      }), _Platform.default.OS !== 'ios' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderButton.HeaderButton, {
        onPress: () => {
          if (value) {
            onClear();
          } else {
            onClose();
          }
        },
        style: styles.closeButton,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderIcon.HeaderIcon, {
          source: _closeIcon.default,
          tintColor: textColor
        })
      }) : null, _Platform.default.OS === 'ios' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_PlatformPressable.PlatformPressable, {
        onPress: cancelSearch,
        style: styles.cancelButton,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Text.Text, {
          style: [fonts.regular, {
            color: tintColor ?? colors.primary
          }, styles.cancelText],
          children: cancelButtonText
        })
      }) : null]
    });
  }
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    },
    inputSearchIcon: Object.assign({
      position: 'absolute',
      opacity: 0.5,
      left: _Platform.default.select({
        ios: 16,
        default: 4
      }),
      top: _Platform.default.select({
        ios: -1,
        default: 17
      })
    }, _Platform.default.select({
      ios: {
        height: 18,
        width: 18
      },
      default: {}
    })),
    closeButton: {
      position: 'absolute',
      opacity: 0.5,
      right: _Platform.default.select({
        ios: 0,
        default: 8
      }),
      top: _Platform.default.select({
        ios: -2,
        default: 17
      })
    },
    clearButton: {
      position: 'absolute',
      right: 0,
      top: -7,
      bottom: 0,
      justifyContent: 'center',
      padding: 8
    },
    clearIcon: {
      height: 16,
      width: 16,
      opacity: 0.5
    },
    cancelButton: {
      alignSelf: 'center',
      top: -4
    },
    cancelText: {
      fontSize: 17,
      marginHorizontal: 12
    },
    searchbarContainer: {
      flex: 1
    },
    searchbar: _Platform.default.select({
      ios: {
        flex: 1,
        fontSize: 17,
        paddingHorizontal: 32,
        marginLeft: 16,
        marginTop: -1,
        marginBottom: 4,
        borderRadius: 8
      },
      default: {
        flex: 1,
        fontSize: 18,
        paddingHorizontal: 36,
        marginRight: 8,
        marginTop: 8,
        marginBottom: 8,
        borderBottomWidth: 1
      }
    })
  });
  const HeaderSearchBar = exports.HeaderSearchBar = /*#__PURE__*/React.forwardRef(HeaderSearchBarInternal);
},568,[17,29,350,549,3,104,180,106,30,254,111,544,545,546,557,558,565,566,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderSearchBar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderShownContext = void 0;
  var _getNamedContext = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderShownContext = exports.HeaderShownContext = (0, _getNamedContext.getNamedContext)('HeaderShownContext', false);
},569,[570],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderShownContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNamedContext = getNamedContext;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const contexts = '__react_navigation__elements_contexts';
  // We use a global variable to keep our contexts so that we can reuse same contexts across packages
  globalThis[contexts] = globalThis[contexts] ?? new Map();
  function getNamedContext(name, initialValue) {
    let context = globalThis[contexts].get(name);
    if (context) {
      return context;
    }
    context = /*#__PURE__*/React.createContext(initialValue);
    context.displayName = name;
    globalThis[contexts].set(name, context);
    return context;
  }
},570,[3],"node_modules\\@react-navigation\\elements\\lib\\module\\getNamedContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderTitle = HeaderTitle;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _Animated = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _jsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  const _excluded = ["tintColor", "style"];
  function HeaderTitle(_ref) {
    let {
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.Text, Object.assign({
      role: "heading",
      "aria-level": "1",
      numberOfLines: 1
    }, rest, {
      style: [{
        color: tintColor === undefined ? colors.text : tintColor
      }, _Platform.default.select({
        ios: fonts.bold,
        default: fonts.medium
      }), styles.title, style]
    }));
  }
  const styles = _StyleSheet.default.create({
    title: _Platform.default.select({
      ios: {
        fontSize: 17
      },
      android: {
        fontSize: 20
      },
      default: {
        fontSize: 18
      }
    })
  });
},571,[17,29,350,104,106,30,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderBackContext = void 0;
  var _getNamedContext = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderBackContext = exports.HeaderBackContext = (0, _getNamedContext.getNamedContext)('HeaderBackContext', undefined);
},572,[570],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderBackContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeaderHeightContext = void 0;
  var _getNamedContext = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderHeightContext = exports.HeaderHeightContext = (0, _getNamedContext.getNamedContext)('HeaderHeightContext', undefined);
},573,[570],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\HeaderHeightContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useHeaderHeight = useHeaderHeight;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _HeaderHeightContext = require(_dependencyMap[1], "./HeaderHeightContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useHeaderHeight() {
    const height = React.useContext(_HeaderHeightContext.HeaderHeightContext);
    if (height === undefined) {
      throw new Error("Couldn't find the header height. Are you inside a screen in a navigator with a header?");
    }
    return height;
  }
},574,[3,573],"node_modules\\@react-navigation\\elements\\lib\\module\\Header\\useHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLabel = getLabel;
  function getLabel(options, fallback) {
    return options.label !== undefined ? options.label : options.title !== undefined ? options.title : fallback;
  }
},575,[],"node_modules\\@react-navigation\\elements\\lib\\module\\Label\\getLabel.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Label = Label;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _Text = require(_dependencyMap[3], "../Text.js");
  var _jsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const _excluded = ["tintColor", "style"];
  function Label(_ref) {
    let {
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Text.Text, Object.assign({
      numberOfLines: 1
    }, rest, {
      style: [styles.label, tintColor != null && {
        color: tintColor
      }, style]
    }));
  }
  const styles = _StyleSheet.default.create({
    label: {
      textAlign: 'center',
      backgroundColor: 'transparent'
    }
  });
},576,[17,29,30,558,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Label\\Label.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MissingIcon = MissingIcon;
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet"));
  var _Text = require(_dependencyMap[2], "./Text.js");
  var _jsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  function MissingIcon({
    color,
    size,
    style
  }) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Text.Text, {
      style: [styles.icon, {
        color,
        fontSize: size
      }, style],
      children: "\u23F7"
    });
  }
  const styles = _StyleSheet.default.create({
    icon: {
      backgroundColor: 'transparent'
    }
  });
},577,[17,30,558,6],"node_modules\\@react-navigation\\elements\\lib\\module\\MissingIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ResourceSavingView = ResourceSavingView;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _jsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  const _excluded = ["visible", "children", "style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const FAR_FAR_AWAY = 30000; // this should be big enough to move the whole view out of its container

  function ResourceSavingView(_ref) {
    let {
        visible,
        children,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    if (_Platform.default.OS === 'web') {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default
      // @ts-expect-error: hidden exists on web, but not in React Native
      , Object.assign({
        hidden: !visible,
        style: [{
          display: visible ? 'flex' : 'none'
        }, styles.container, style],
        pointerEvents: visible ? 'auto' : 'none'
      }, rest, {
        children: children
      }));
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
      style: [styles.container, style]
      // box-none doesn't seem to work properly on Android
      ,

      pointerEvents: visible ? 'auto' : 'none',
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        collapsable: false,
        removeClippedSubviews:
        // On iOS & macOS, set removeClippedSubviews to true only when not focused
        // This is an workaround for a bug where the clipped view never re-appears
        _Platform.default.OS === 'ios' || _Platform.default.OS === 'macos' ? !visible : true,
        pointerEvents: visible ? 'auto' : 'none',
        style: visible ? styles.attached : styles.detached,
        children: children
      })
    });
  }
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1,
      overflow: 'hidden'
    },
    attached: {
      flex: 1
    },
    detached: {
      flex: 1,
      top: FAR_FAR_AWAY
    }
  });
},578,[17,29,3,106,30,111,6],"node_modules\\@react-navigation\\elements\\lib\\module\\ResourceSavingView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SafeAreaProviderCompat = SafeAreaProviderCompat;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Dimensions"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _reactNativeSafeAreaContext = require(_dependencyMap[6], "react-native-safe-area-context");
  var _jsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const {
    width = 0,
    height = 0
  } = _Dimensions.default.get('window');

  // To support SSR on web, we need to have empty insets for initial values
  // Otherwise there can be mismatch between SSR and client output
  // We also need to specify empty values to support tests environments
  const initialMetrics = _Platform.default.OS === 'web' || _reactNativeSafeAreaContext.initialWindowMetrics == null ? {
    frame: {
      x: 0,
      y: 0,
      width,
      height
    },
    insets: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  } : _reactNativeSafeAreaContext.initialWindowMetrics;
  function SafeAreaProviderCompat({
    children,
    style
  }) {
    const insets = React.useContext(_reactNativeSafeAreaContext.SafeAreaInsetsContext);
    if (insets) {
      // If we already have insets, don't wrap the stack in another safe area provider
      // This avoids an issue with updates at the cost of potentially incorrect values
      // https://github.com/react-navigation/react-navigation/issues/174
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        style: [styles.container, style],
        children: children
      });
    }
    if (_Platform.default.OS === 'web') {
      children = /*#__PURE__*/(0, _jsxRuntime.jsx)(SafeAreaFrameProvider, {
        initialMetrics: initialMetrics,
        children: children
      });
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeSafeAreaContext.SafeAreaProvider, {
      initialMetrics: initialMetrics,
      style: style,
      children: children
    });
  }

  // FIXME: On the Web, the safe area frame value doesn't update on resize
  // So we workaround this by measuring the frame on resize
  const SafeAreaFrameProvider = ({
    initialMetrics,
    children
  }) => {
    const element = React.useRef(null);
    const [frame, setFrame] = React.useState(initialMetrics.frame);
    React.useEffect(() => {
      if (element.current == null) {
        return;
      }
      const rect = element.current.getBoundingClientRect();

      // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
      setFrame({
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      });
      let timeout;
      const observer = new ResizeObserver(entries => {
        const entry = entries[0];
        if (entry) {
          const {
            x,
            y,
            width,
            height
          } = entry.contentRect;

          // Debounce the frame updates to avoid too many updates in a short time
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            setFrame({
              x,
              y,
              width,
              height
            });
          }, 100);
        }
      });
      observer.observe(element.current);
      return () => {
        observer.disconnect();
        clearTimeout(timeout);
      };
    }, []);
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNativeSafeAreaContext.SafeAreaFrameContext.Provider, {
      value: frame,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        ref: element,
        style: Object.assign({}, _StyleSheet.default.absoluteFillObject, {
          pointerEvents: 'none',
          visibility: 'hidden'
        })
      }), children]
    });
  };
  SafeAreaProviderCompat.initialMetrics = initialMetrics;
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1
    }
  });
},579,[17,3,136,106,30,111,893,6],"node_modules\\@react-navigation\\elements\\lib\\module\\SafeAreaProviderCompat.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Screen = Screen;
  var _native = require(_dependencyMap[1], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var _reactNativeSafeAreaContext = require(_dependencyMap[5], "react-native-safe-area-context");
  var _Background = require(_dependencyMap[6], "./Background.js");
  var _getDefaultHeaderHeight = require(_dependencyMap[7], "./Header/getDefaultHeaderHeight.js");
  var _HeaderHeightContext = require(_dependencyMap[8], "./Header/HeaderHeightContext.js");
  var _HeaderShownContext = require(_dependencyMap[9], "./Header/HeaderShownContext.js");
  var _jsxRuntime = require(_dependencyMap[10], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function Screen(props) {
    const dimensions = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
    const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
    const isParentHeaderShown = React.useContext(_HeaderShownContext.HeaderShownContext);
    const parentHeaderHeight = React.useContext(_HeaderHeightContext.HeaderHeightContext);
    const {
      focused,
      modal = false,
      header,
      headerShown = true,
      headerTransparent,
      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,
      navigation,
      route,
      children,
      style
    } = props;
    const [headerHeight, setHeaderHeight] = React.useState(() => (0, _getDefaultHeaderHeight.getDefaultHeaderHeight)(dimensions, modal, headerStatusBarHeight));
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Background.Background, {
      "aria-hidden": !focused,
      style: [styles.container, style]
      // On Fabric we need to disable collapsing for the background to ensure
      // that we won't render unnecessary views due to the view flattening.
      ,

      collapsable: false,
      children: [headerShown ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_native.NavigationContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_native.NavigationRouteContext.Provider, {
          value: route,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
            pointerEvents: "box-none",
            onLayout: e => {
              const {
                height
              } = e.nativeEvent.layout;
              setHeaderHeight(height);
            },
            style: [styles.header, headerTransparent ? styles.absolute : null],
            children: header
          })
        })
      }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        style: styles.content,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderShownContext.HeaderShownContext.Provider, {
          value: isParentHeaderShown || headerShown !== false,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_HeaderHeightContext.HeaderHeightContext.Provider, {
            value: headerShown ? headerHeight : parentHeaderHeight ?? 0,
            children: children
          })
        })
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1
    },
    content: {
      flex: 1
    },
    header: {
      zIndex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      start: 0,
      end: 0
    }
  });
},580,[17,350,3,30,111,893,547,560,573,569,6],"node_modules\\@react-navigation\\elements\\lib\\module\\Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},581,[],"node_modules\\@react-navigation\\elements\\lib\\module\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnimatedHeaderHeightContext = void 0;
  exports.useAnimatedHeaderHeight = useAnimatedHeaderHeight;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const AnimatedHeaderHeightContext = exports.AnimatedHeaderHeightContext = /*#__PURE__*/React.createContext(undefined);
  function useAnimatedHeaderHeight() {
    const animatedValue = React.useContext(AnimatedHeaderHeightContext);
    if (animatedValue === undefined) {
      throw new Error("Couldn't find the header height. Are you inside a screen in a native stack navigator?");
    }
    return animatedValue;
  }
},582,[3],"node_modules\\@react-navigation\\native-stack\\lib\\module\\utils\\useAnimatedHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\layouts\\withLayoutContext.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFilterScreenChildren = useFilterScreenChildren;
  exports.withLayoutContext = withLayoutContext;
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const Route_1 = require(_dependencyMap[3], "../Route");
  const useScreens_1 = require(_dependencyMap[4], "../useScreens");
  const Protected_1 = require(_dependencyMap[5], "../views/Protected");
  const Screen_1 = require(_dependencyMap[6], "../views/Screen");
  function useFilterScreenChildren(children, {
    isCustomNavigator,
    contextKey
  } = {}) {
    return (0, react_1.useMemo)(() => {
      const customChildren = [];
      const screens = [];
      const protectedScreens = new Set();
      function flattenChild(child, exclude = false) {
        if ((0, Screen_1.isScreen)(child, contextKey)) {
          if (exclude) {
            protectedScreens.add(child.props.name);
          } else {
            screens.push(child.props);
          }
          return;
        }
        if ((0, Protected_1.isProtectedReactElement)(child)) {
          if (child.props.guard) {
            react_1.Children.forEach(child.props.children, protectedChild => flattenChild(protectedChild));
          } else {
            react_1.Children.forEach(child.props.children, protectedChild => {
              flattenChild(protectedChild, true);
            });
          }
          return;
        }
        if (isCustomNavigator) {
          customChildren.push(child);
          return null;
        }
        console.warn(`Layout children must be of type Screen, all other children are ignored. To use custom children, create a custom <Layout />. Update Layout Route at: "app${contextKey}/_layout"`);
        return null;
      }
      react_1.Children.forEach(children, child => flattenChild(child));
      // Add an assertion for development
      if (process.env.NODE_ENV !== 'production') {
        // Assert if names are not unique
        const names = screens?.map(screen => screen && typeof screen === 'object' && 'name' in screen && screen.name);
        if (names && new Set(names).size !== names.length) {
          throw new Error('Screen names must be unique: ' + names);
        }
      }
      return {
        screens,
        children: customChildren,
        protectedScreens
      };
    }, [children]);
  }
  /**
   * Returns a navigator that automatically injects matched routes and renders nothing when there are no children.
   * Return type with `children` prop optional.
   *
   * Enables use of other built-in React Navigation navigators and other navigators built with the React Navigation custom navigator API.
   *
   *  @example
   * ```tsx app/_layout.tsx
   * import { ParamListBase, TabNavigationState } from "@react-navigation/native";
   * import {
   *   createMaterialTopTabNavigator,
   *   MaterialTopTabNavigationOptions,
   *   MaterialTopTabNavigationEventMap,
   * } from "@react-navigation/material-top-tabs";
   * import { withLayoutContext } from "expo-router";
   *
   * const MaterialTopTabs = createMaterialTopTabNavigator();
   *
   * const ExpoRouterMaterialTopTabs = withLayoutContext<
   *   MaterialTopTabNavigationOptions,
   *   typeof MaterialTopTabs.Navigator,
   *   TabNavigationState<ParamListBase>,
   *   MaterialTopTabNavigationEventMap
   * >(MaterialTopTabs.Navigator);
  
   * export default function TabLayout() {
   *   return <ExpoRouterMaterialTopTabs />;
   * }
   * ```
   */
  function withLayoutContext(Nav, processor) {
    return Object.assign((0, react_1.forwardRef)((_ref, ref) => {
      let {
          children: userDefinedChildren
        } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);
      const contextKey = (0, Route_1.useContextKey)();
      const {
        screens,
        protectedScreens
      } = useFilterScreenChildren(userDefinedChildren, {
        contextKey
      });
      const processed = processor ? processor(screens ?? []) : screens;
      const sorted = (0, useScreens_1.useSortedScreens)(processed ?? [], protectedScreens);
      // Prevent throwing an error when there are no screens.
      if (!sorted.length) {
        return null;
      }
      return _reactNativeCssInteropJsxRuntime.jsx(Nav, Object.assign({}, props, {
        id: contextKey,
        ref: ref,
        children: sorted
      }));
    }), {
      Screen: Screen_1.Screen,
      Protected: Protected_1.Protected
    });
  }
},583,[2,29,3,584,587,647,648],"node_modules\\expo-router\\build\\layouts\\withLayoutContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\Route.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortRoutes = exports.sortRoutesWithInitial = exports.LocalRouteParamsContext = void 0;
  exports.useRouteNode = useRouteNode;
  exports.useContextKey = useContextKey;
  exports.Route = Route;
  const react_1 = require(_dependencyMap[1], "react");
  const matchers_1 = require(_dependencyMap[2], "./matchers");
  const sortRoutes_1 = require(_dependencyMap[3], "./sortRoutes");
  Object.defineProperty(exports, "sortRoutesWithInitial", {
    enumerable: true,
    get: function () {
      return sortRoutes_1.sortRoutesWithInitial;
    }
  });
  Object.defineProperty(exports, "sortRoutes", {
    enumerable: true,
    get: function () {
      return sortRoutes_1.sortRoutes;
    }
  });
  const CurrentRouteContext = (0, react_1.createContext)(null);
  exports.LocalRouteParamsContext = (0, react_1.createContext)({});
  if (process.env.NODE_ENV !== 'production') {
    CurrentRouteContext.displayName = 'RouteNode';
  }
  /** Return the RouteNode at the current contextual boundary. */
  function useRouteNode() {
    return (0, react_1.use)(CurrentRouteContext);
  }
  function useContextKey() {
    const node = useRouteNode();
    if (node == null) {
      throw new Error('No filename found. This is likely a bug in expo-router.');
    }
    return (0, matchers_1.getContextKey)(node.contextKey);
  }
  /** Provides the matching routes and filename to the children. */
  function Route({
    children,
    node,
    route
  }) {
    return _reactNativeCssInteropJsxRuntime.jsx(exports.LocalRouteParamsContext.Provider, {
      value: route?.params,
      children: _reactNativeCssInteropJsxRuntime.jsx(CurrentRouteContext.Provider, {
        value: node,
        children: children
      })
    });
  }
},584,[2,3,585,586],"node_modules\\expo-router\\build\\Route.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.matchDynamicName = matchDynamicName;
  exports.testNotFound = testNotFound;
  exports.matchGroupName = matchGroupName;
  exports.matchLastGroupName = matchLastGroupName;
  exports.matchArrayGroupName = matchArrayGroupName;
  exports.getNameFromFilePath = getNameFromFilePath;
  exports.getContextKey = getContextKey;
  exports.removeSupportedExtensions = removeSupportedExtensions;
  exports.removeFileSystemExtensions = removeFileSystemExtensions;
  exports.removeFileSystemDots = removeFileSystemDots;
  exports.stripGroupSegmentsFromPath = stripGroupSegmentsFromPath;
  exports.stripInvisibleSegmentsFromPath = stripInvisibleSegmentsFromPath;
  exports.isTypedRoute = isTypedRoute;
  /** Match `[page]` -> `page` or `[...group]` -> `...group` */
  const dynamicNameRe = /^\[([^[\]]+?)\]$/;
  /** Match `[page]` -> `page` */
  function matchDynamicName(name) {
    const paramName = name.match(dynamicNameRe)?.[1];
    if (paramName == null) {
      return undefined;
    } else if (paramName.startsWith('...')) {
      return {
        name: paramName.slice(3),
        deep: true
      };
    } else {
      return {
        name: paramName,
        deep: false
      };
    }
  }
  /** Test `/` -> `page` */
  function testNotFound(name) {
    return /\+not-found$/.test(name);
  }
  /** Match `(page)` -> `page` */
  function matchGroupName(name) {
    return name.match(/^(?:[^\\()])*?\(([^\\/]+)\)/)?.[1];
  }
  /** Match `(app)/(page)` -> `page` */
  function matchLastGroupName(name) {
    return name.match(/.*(?:\/|^)\(([^\\/]+)\)[^\s]*$/)?.[1];
  }
  /** Match the first array group name `(a,b,c)/(d,c)` -> `'a,b,c'` */
  function matchArrayGroupName(name) {
    return name.match(/(?:[^\\()])*?\(([^\\/]+,[^\\/]+)\)/)?.[1];
  }
  function getNameFromFilePath(name) {
    return removeSupportedExtensions(removeFileSystemDots(name));
  }
  function getContextKey(name) {
    // The root path is `` (empty string) so always prepend `/` to ensure
    // there is some value.
    const normal = '/' + getNameFromFilePath(name);
    if (!normal.endsWith('_layout')) {
      return normal;
    }
    return normal.replace(/\/?_layout$/, '');
  }
  /** Remove `.js`, `.ts`, `.jsx`, `.tsx`, and the +api suffix */
  function removeSupportedExtensions(name) {
    return name.replace(/(\+api)?\.[jt]sx?$/g, '');
  }
  /** Remove `.js`, `.ts`, `.jsx`, `.tsx` */
  function removeFileSystemExtensions(name) {
    return name.replace(/\.[jt]sx?$/g, '');
  }
  // Remove any amount of `./` and `../` from the start of the string
  function removeFileSystemDots(filePath) {
    return filePath.replace(/^(?:\.\.?\/)+/g, '');
  }
  function stripGroupSegmentsFromPath(path) {
    return path.split('/').reduce((acc, v) => {
      if (matchGroupName(v) == null) {
        acc.push(v);
      }
      return acc;
    }, []).join('/');
  }
  function stripInvisibleSegmentsFromPath(path) {
    return stripGroupSegmentsFromPath(path).replace(/\/?index$/, '');
  }
  /**
   * Match:
   *  - _layout files, +html, +not-found, string+api, etc
   *  - Routes can still use `+`, but it cannot be in the last segment.
   */
  function isTypedRoute(name) {
    return !name.startsWith('+') && name.match(/(_layout|[^/]*?\+[^/]*?)\.[tj]sx?$/) === null;
  }
},585,[],"node_modules\\expo-router\\build\\matchers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortRoutes = sortRoutes;
  exports.sortRoutesWithInitial = sortRoutesWithInitial;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  function sortDynamicConvention(a, b) {
    if (a.deep && !b.deep) {
      return 1;
    }
    if (!a.deep && b.deep) {
      return -1;
    }
    return 0;
  }
  function sortRoutes(a, b) {
    if (a.dynamic && !b.dynamic) {
      return 1;
    }
    if (!a.dynamic && b.dynamic) {
      return -1;
    }
    if (a.dynamic && b.dynamic) {
      if (a.dynamic.length !== b.dynamic.length) {
        return b.dynamic.length - a.dynamic.length;
      }
      for (let i = 0; i < a.dynamic.length; i++) {
        const aDynamic = a.dynamic[i];
        const bDynamic = b.dynamic[i];
        if (aDynamic.notFound && bDynamic.notFound) {
          const s = sortDynamicConvention(aDynamic, bDynamic);
          if (s) {
            return s;
          }
        }
        if (aDynamic.notFound && !bDynamic.notFound) {
          return 1;
        }
        if (!aDynamic.notFound && bDynamic.notFound) {
          return -1;
        }
        const s = sortDynamicConvention(aDynamic, bDynamic);
        if (s) {
          return s;
        }
      }
      return 0;
    }
    const aIndex = a.route === 'index' || (0, matchers_1.matchGroupName)(a.route) != null;
    const bIndex = b.route === 'index' || (0, matchers_1.matchGroupName)(b.route) != null;
    if (aIndex && !bIndex) {
      return -1;
    }
    if (!aIndex && bIndex) {
      return 1;
    }
    return a.route.length - b.route.length;
  }
  function sortRoutesWithInitial(initialRouteName) {
    return (a, b) => {
      if (initialRouteName) {
        if (a.route === initialRouteName) {
          return -1;
        }
        if (b.route === initialRouteName) {
          return 1;
        }
      }
      return sortRoutes(a, b);
    };
  }
},586,[585],"node_modules\\expo-router\\build\\sortRoutes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInterop = require(_dependencyMap[0], "react-native-css-interop");
  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[1], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["ErrorBoundary"],
    _excluded2 = ["route", "navigation"],
    _excluded3 = ["options", "getId"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\useScreens.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSortedScreens = useSortedScreens;
  exports.getQualifiedRouteComponent = getQualifiedRouteComponent;
  exports.screenOptionsFactory = screenOptionsFactory;
  exports.routeToScreen = routeToScreen;
  exports.getSingularId = getSingularId;
  const native_1 = require(_dependencyMap[3], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[4], "react"));
  const Route_1 = require(_dependencyMap[5], "./Route");
  const storeContext_1 = require(_dependencyMap[6], "./global-state/storeContext");
  const import_mode_1 = __importDefault(require(_dependencyMap[7], "./import-mode"));
  const primitives_1 = require(_dependencyMap[8], "./primitives");
  const EmptyRoute_1 = require(_dependencyMap[9], "./views/EmptyRoute");
  const SuspenseFallback_1 = require(_dependencyMap[10], "./views/SuspenseFallback");
  const Try_1 = require(_dependencyMap[11], "./views/Try");
  function getSortedChildren(children, order = [], initialRouteName) {
    if (!order?.length) {
      return children.sort((0, Route_1.sortRoutesWithInitial)(initialRouteName)).map(route => ({
        route,
        props: {}
      }));
    }
    const entries = [...children];
    const ordered = order.map(({
      name,
      redirect,
      initialParams,
      listeners,
      options,
      getId,
      dangerouslySingular: singular
    }) => {
      if (!entries.length) {
        console.warn(`[Layout children]: Too many screens defined. Route "${name}" is extraneous.`);
        return null;
      }
      const matchIndex = entries.findIndex(child => child.route === name);
      if (matchIndex === -1) {
        console.warn(`[Layout children]: No route named "${name}" exists in nested children:`, children.map(({
          route
        }) => route));
        return null;
      } else {
        // Get match and remove from entries
        const match = entries[matchIndex];
        entries.splice(matchIndex, 1);
        // Ensure to return null after removing from entries.
        if (redirect) {
          if (typeof redirect === 'string') {
            throw new Error(`Redirecting to a specific route is not supported yet.`);
          }
          return null;
        }
        if (getId) {
          console.warn(`Deprecated: prop 'getId' on screen ${name} is deprecated. Please rename the prop to 'dangerouslySingular'`);
          if (singular) {
            console.warn(`Screen ${name} cannot use both getId and dangerouslySingular together.`);
          }
        } else if (singular) {
          // If singular is set, use it as the getId function.
          if (typeof singular === 'string') {
            getId = () => singular;
          } else if (typeof singular === 'function' && name) {
            getId = options => singular(name, options.params || {});
          } else if (singular === true && name) {
            getId = options => getSingularId(name, options);
          }
        }
        return {
          route: match,
          props: {
            initialParams,
            listeners,
            options,
            getId
          }
        };
      }
    }).filter(Boolean);
    // Add any remaining children
    ordered.push(...entries.sort((0, Route_1.sortRoutesWithInitial)(initialRouteName)).map(route => ({
      route,
      props: {}
    })));
    return ordered;
  }
  /**
   * @returns React Navigation screens sorted by the `route` property.
   */
  function useSortedScreens(order, protectedScreens) {
    const node = (0, Route_1.useRouteNode)();
    const sorted = node?.children?.length ? getSortedChildren(node.children, order, node.initialRouteName) : [];
    return react_1.default.useMemo(() => sorted.filter(item => !protectedScreens.has(item.route.route)).map(value => {
      return routeToScreen(value.route, value.props);
    }), [sorted, protectedScreens]);
  }
  function fromImport(value, _ref) {
    let {
        ErrorBoundary
      } = _ref,
      component = _objectWithoutPropertiesLoose(_ref, _excluded);
    // If possible, add a more helpful display name for the component stack to improve debugging of React errors such as `Text strings must be rendered within a <Text> component.`.
    if (component?.default && __DEV__) {
      component.default.displayName ??= `${component.default.name ?? 'Route'}(${value.contextKey})`;
    }
    if (ErrorBoundary) {
      const Wrapped = react_1.default.forwardRef((props, ref) => {
        const children = react_1.default.createElement(component.default || EmptyRoute_1.EmptyRoute, Object.assign({}, props, {
          ref
        }));
        return _reactNativeCssInteropJsxRuntime.jsx(Try_1.Try, {
          catch: ErrorBoundary,
          children: children
        });
      });
      if (__DEV__) {
        Wrapped.displayName = `ErrorBoundary(${value.contextKey})`;
      }
      return {
        default: Wrapped
      };
    }
    if (process.env.NODE_ENV !== 'production') {
      if (typeof component.default === 'object' && component.default && Object.keys(component.default).length === 0) {
        return {
          default: EmptyRoute_1.EmptyRoute
        };
      }
    }
    return {
      default: component.default
    };
  }
  function fromLoadedRoute(value, res) {
    if (!(res instanceof Promise)) {
      return fromImport(value, res);
    }
    return res.then(fromImport.bind(null, value));
  }
  // TODO: Maybe there's a more React-y way to do this?
  // Without this store, the process enters a recursive loop.
  const qualifiedStore = new WeakMap();
  /** Wrap the component with various enhancements and add access to child routes. */
  function getQualifiedRouteComponent(value) {
    if (qualifiedStore.has(value)) {
      return qualifiedStore.get(value);
    }
    let ScreenComponent;
    // TODO: This ensures sync doesn't use React.lazy, but it's not ideal.
    if (import_mode_1.default === 'lazy') {
      ScreenComponent = react_1.default.lazy(async () => {
        const res = value.loadRoute();
        return fromLoadedRoute(value, res);
      });
      if (__DEV__) {
        ScreenComponent.displayName = `AsyncRoute(${value.route})`;
      }
    } else {
      const res = value.loadRoute();
      ScreenComponent = fromImport(value, res).default;
    }
    function BaseRoute(_ref2) {
      let {
          // Remove these React Navigation props to
          // enforce usage of expo-router hooks (where the query params are correct).
          route,
          navigation
          // Pass all other props to the component
        } = _ref2,
        props = _objectWithoutPropertiesLoose(_ref2, _excluded2);
      const stateForPath = (0, native_1.useStateForPath)();
      const isFocused = (0, native_1.useIsFocused)();
      const store = (0, storeContext_1.useExpoRouterStore)();
      if (isFocused) {
        const state = navigation.getState();
        const isLeaf = !('state' in state.routes[state.index]);
        if (isLeaf && stateForPath) store.setFocusedState(stateForPath);
      }
      return _reactNativeCssInteropJsxRuntime.jsx(Route_1.Route, {
        node: value,
        route: route,
        children: _reactNativeCssInteropJsxRuntime.jsx(react_1.default.Suspense, {
          fallback: _reactNativeCssInteropJsxRuntime.jsx(SuspenseFallback_1.SuspenseFallback, {
            route: value
          }),
          children: _reactNativeCssInteropJsxRuntime.jsx(ScreenComponent, Object.assign({}, props, {
            // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`
            // the intention is to make it possible to deduce shared routes.
            segment: value.route
          }))
        })
      });
    }
    if (__DEV__) {
      BaseRoute.displayName = `Route(${value.route})`;
    }
    qualifiedStore.set(value, BaseRoute);
    return BaseRoute;
  }
  function screenOptionsFactory(route, options) {
    return args => {
      // Only eager load generated components
      const staticOptions = route.generated ? route.loadRoute()?.getNavOptions : null;
      const staticResult = typeof staticOptions === 'function' ? staticOptions(args) : staticOptions;
      const dynamicResult = typeof options === 'function' ? options?.(args) : options;
      const output = Object.assign({}, staticResult, dynamicResult);
      // Prevent generated screens from showing up in the tab bar.
      if (route.generated) {
        output.tabBarItemStyle = {
          display: 'none'
        };
        output.tabBarButton = () => null;
        // TODO: React Navigation doesn't provide a way to prevent rendering the drawer item.
        output.drawerItemStyle = {
          height: 0,
          display: 'none'
        };
      }
      return output;
    };
  }
  function routeToScreen(route, _ref3 = {}) {
    let {
        options,
        getId
      } = _ref3,
      props = _objectWithoutPropertiesLoose(_ref3, _excluded3);
    return _reactNativeCssInterop.createElement(primitives_1.Screen, Object.assign({}, props, {
      name: route.route,
      key: route.route,
      getId: getId,
      options: screenOptionsFactory(route, options),
      getComponent: () => getQualifiedRouteComponent(route),
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 202,
        columnNumber: 13
      }
    }));
  }
  function getSingularId(name, options = {}) {
    return name.split('/').map(segment => {
      if (segment.startsWith('[...')) {
        return options.params?.[segment.slice(4, -1)]?.join('/') || segment;
      } else if (segment.startsWith('[')) {
        return options.params?.[segment.slice(1, -1)] || segment;
      } else {
        return segment;
      }
    }).join('/');
  }
},587,[412,2,29,350,3,584,588,589,590,591,629,630],"node_modules\\expo-router\\build\\useScreens.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useExpoRouterStore = exports.StoreContext = void 0;
  const react_1 = require(_dependencyMap[0], "react");
  exports.StoreContext = (0, react_1.createContext)(null);
  const useExpoRouterStore = () => (0, react_1.use)(exports.StoreContext);
  exports.useExpoRouterStore = useExpoRouterStore;
},588,[3],"node_modules\\expo-router\\build\\global-state\\storeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = "sync" || 'sync';
},589,[],"node_modules\\expo-router\\build\\import-mode\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _a;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Group = exports.Screen = void 0;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  // `@react-navigation/native` does not expose the Screen or Group components directly, so we have to
  // do this hack.
  _a = (0, native_1.createNavigatorFactory)({})(), exports.Screen = _a.Screen, exports.Group = _a.Group;
},590,[350],"node_modules\\expo-router\\build\\primitives.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\EmptyRoute.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EmptyRoute = EmptyRoute;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Toast_1 = require(_dependencyMap[2], "./Toast");
  const Route_1 = require(_dependencyMap[3], "../Route");
  function EmptyRoute() {
    const route = (0, Route_1.useRouteNode)();
    return _reactNativeCssInteropJsxRuntime.jsx(Toast_1.ToastWrapper, {
      children: _reactNativeCssInteropJsxRuntime.jsx(Toast_1.Toast, {
        warning: true,
        filename: route?.contextKey,
        children: "Missing default export"
      })
    });
  }
},591,[2,3,592,584],"node_modules\\expo-router\\build\\views\\EmptyRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\Toast.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CODE_FONT = void 0;
  exports.ToastWrapper = ToastWrapper;
  exports.Toast = Toast;
  const bottom_tabs_1 = require(_dependencyMap[1], "@react-navigation/bottom-tabs");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  exports.CODE_FONT = react_native_1.Platform.select({
    default: 'Courier',
    ios: 'Courier New',
    android: 'monospace'
  });
  function useFadeIn() {
    // Returns a React Native Animated value for fading in
    const [value] = react_1.default.useState(() => new react_native_1.Animated.Value(0));
    react_1.default.useEffect(() => {
      react_native_1.Animated.timing(value, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true
      }).start();
    }, []);
    return value;
  }
  function ToastWrapper({
    children
  }) {
    const inTabBar = react_1.default.use(bottom_tabs_1.BottomTabBarHeightContext);
    const Wrapper = inTabBar ? react_native_1.View : react_native_safe_area_context_1.SafeAreaView;
    return _reactNativeCssInteropJsxRuntime.jsx(Wrapper, {
      collapsable: false,
      style: {
        flex: 1
      },
      children: children
    });
  }
  function Toast({
    children,
    filename,
    warning
  }) {
    const filenamePretty = react_1.default.useMemo(() => {
      if (!filename) return undefined;
      return 'app' + filename.replace(/^\./, '');
    }, [filename]);
    const value = useFadeIn();
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
      style: styles.container,
      children: _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.Animated.View, {
        style: [styles.toast, {
          position: react_native_1.Platform.select({
            // NOTE(@kitten): This isn't typed to support Web properties
            web: 'fixed',
            default: 'absolute'
          }),
          opacity: value
        }],
        children: [!warning && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.ActivityIndicator, {
          color: "white"
        }), warning && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
          source: require(_dependencyMap[5], "expo-router/assets/error.png"),
          style: styles.icon
        }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
          style: {
            marginLeft: 8
          },
          children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: styles.text,
            children: children
          }), filenamePretty && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: styles.filename,
            children: filenamePretty
          })]
        })]
      })
    });
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      backgroundColor: 'transparent',
      flex: 1
    },
    icon: {
      width: 20,
      height: 20,
      resizeMode: 'contain'
    },
    toast: {
      alignItems: 'center',
      borderWidth: 1,
      borderColor: 'rgba(255,255,255,0.2)',
      flexDirection: 'row',
      bottom: 8,
      left: 8,
      paddingVertical: 8,
      paddingHorizontal: 12,
      borderRadius: 4,
      backgroundColor: 'black'
    },
    text: {
      color: 'white',
      fontSize: 16
    },
    filename: {
      fontFamily: exports.CODE_FONT,
      opacity: 0.8,
      color: 'white',
      fontSize: 12
    },
    code: {
      fontFamily: exports.CODE_FONT
    }
  });
},592,[2,593,3,16,893,628],"node_modules\\expo-router\\build\\views\\Toast.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BottomTabBar", {
    enumerable: true,
    get: function () {
      return _BottomTabBar.BottomTabBar;
    }
  });
  Object.defineProperty(exports, "BottomTabBarHeightCallbackContext", {
    enumerable: true,
    get: function () {
      return _BottomTabBarHeightCallbackContext.BottomTabBarHeightCallbackContext;
    }
  });
  Object.defineProperty(exports, "BottomTabBarHeightContext", {
    enumerable: true,
    get: function () {
      return _BottomTabBarHeightContext.BottomTabBarHeightContext;
    }
  });
  Object.defineProperty(exports, "BottomTabView", {
    enumerable: true,
    get: function () {
      return _BottomTabView.BottomTabView;
    }
  });
  exports.TransitionSpecs = exports.TransitionPresets = exports.SceneStyleInterpolators = void 0;
  Object.defineProperty(exports, "createBottomTabNavigator", {
    enumerable: true,
    get: function () {
      return _createBottomTabNavigator.createBottomTabNavigator;
    }
  });
  Object.defineProperty(exports, "useBottomTabBarHeight", {
    enumerable: true,
    get: function () {
      return _useBottomTabBarHeight.useBottomTabBarHeight;
    }
  });
  var SceneStyleInterpolators = _interopRequireWildcard(require(_dependencyMap[0], "./TransitionConfigs/SceneStyleInterpolators.js"));
  exports.SceneStyleInterpolators = SceneStyleInterpolators;
  var TransitionPresets = _interopRequireWildcard(require(_dependencyMap[1], "./TransitionConfigs/TransitionPresets.js"));
  exports.TransitionPresets = TransitionPresets;
  var TransitionSpecs = _interopRequireWildcard(require(_dependencyMap[2], "./TransitionConfigs/TransitionSpecs.js"));
  exports.TransitionSpecs = TransitionSpecs;
  var _createBottomTabNavigator = require(_dependencyMap[3], "./navigators/createBottomTabNavigator.js");
  var _BottomTabBar = require(_dependencyMap[4], "./views/BottomTabBar.js");
  var _BottomTabView = require(_dependencyMap[5], "./views/BottomTabView.js");
  var _BottomTabBarHeightCallbackContext = require(_dependencyMap[6], "./utils/BottomTabBarHeightCallbackContext.js");
  var _BottomTabBarHeightContext = require(_dependencyMap[7], "./utils/BottomTabBarHeightContext.js");
  var _useBottomTabBarHeight = require(_dependencyMap[8], "./utils/useBottomTabBarHeight.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
},593,[594,595,596,597,602,598,599,600,627],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Simple cross fade animation
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.forFade = forFade;
  exports.forShift = forShift;
  function forFade({
    current
  }) {
    return {
      sceneStyle: {
        opacity: current.progress.interpolate({
          inputRange: [-1, 0, 1],
          outputRange: [0, 1, 0]
        })
      }
    };
  }

  /**
   * Animation where the screens slightly shift to left/right
   */
  function forShift({
    current
  }) {
    return {
      sceneStyle: {
        opacity: current.progress.interpolate({
          inputRange: [-1, 0, 1],
          outputRange: [0, 1, 0]
        }),
        transform: [{
          translateX: current.progress.interpolate({
            inputRange: [-1, 0, 1],
            outputRange: [-50, 0, 50]
          })
        }]
      }
    };
  }
},594,[],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\TransitionConfigs\\SceneStyleInterpolators.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ShiftTransition = exports.FadeTransition = void 0;
  var _SceneStyleInterpolators = require(_dependencyMap[0], "./SceneStyleInterpolators.js");
  var _TransitionSpecs = require(_dependencyMap[1], "./TransitionSpecs.js");
  const FadeTransition = exports.FadeTransition = {
    transitionSpec: _TransitionSpecs.FadeSpec,
    sceneStyleInterpolator: _SceneStyleInterpolators.forFade
  };
  const ShiftTransition = exports.ShiftTransition = {
    transitionSpec: _TransitionSpecs.ShiftSpec,
    sceneStyleInterpolator: _SceneStyleInterpolators.forShift
  };
},595,[594,596],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\TransitionConfigs\\TransitionPresets.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ShiftSpec = exports.FadeSpec = void 0;
  var _Easing = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Easing"));
  const FadeSpec = exports.FadeSpec = {
    animation: 'timing',
    config: {
      duration: 150,
      easing: _Easing.default.in(_Easing.default.linear)
    }
  };
  const ShiftSpec = exports.ShiftSpec = {
    animation: 'timing',
    config: {
      duration: 150,
      easing: _Easing.default.inOut(_Easing.default.ease)
    }
  };
},596,[17,208],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\TransitionConfigs\\TransitionSpecs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createBottomTabNavigator = createBottomTabNavigator;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _BottomTabView = require(_dependencyMap[3], "../views/BottomTabView.js");
  var _jsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const _excluded = ["id", "initialRouteName", "backBehavior", "children", "layout", "screenListeners", "screenOptions", "screenLayout", "UNSTABLE_router"];
  function BottomTabNavigator(_ref) {
    let {
        id,
        initialRouteName,
        backBehavior,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_router
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const {
      state,
      descriptors,
      navigation,
      NavigationContent
    } = (0, _native.useNavigationBuilder)(_native.TabRouter, {
      id,
      initialRouteName,
      backBehavior,
      children,
      layout,
      screenListeners,
      screenOptions,
      screenLayout,
      UNSTABLE_router
    });
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(NavigationContent, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_BottomTabView.BottomTabView, Object.assign({}, rest, {
        state: state,
        navigation: navigation,
        descriptors: descriptors
      }))
    });
  }
  function createBottomTabNavigator(config) {
    return (0, _native.createNavigatorFactory)(BottomTabNavigator)(config);
  }
},597,[17,29,350,598,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\navigators\\createBottomTabNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BottomTabView = BottomTabView;
  var _elements = require(_dependencyMap[1], "@react-navigation/elements");
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _reactNativeSafeAreaContext = require(_dependencyMap[7], "react-native-safe-area-context");
  var _TransitionPresets = require(_dependencyMap[8], "../TransitionConfigs/TransitionPresets.js");
  var _BottomTabBarHeightCallbackContext = require(_dependencyMap[9], "../utils/BottomTabBarHeightCallbackContext.js");
  var _BottomTabBarHeightContext = require(_dependencyMap[10], "../utils/BottomTabBarHeightContext.js");
  var _useAnimatedHashMap = require(_dependencyMap[11], "../utils/useAnimatedHashMap.js");
  var _BottomTabBar = require(_dependencyMap[12], "./BottomTabBar.js");
  var _ScreenFallback = require(_dependencyMap[13], "./ScreenFallback.js");
  var _jsxRuntime = require(_dependencyMap[14], "react/jsx-runtime");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const EPSILON = 1e-5;
  const STATE_INACTIVE = 0;
  const STATE_TRANSITIONING_OR_BELOW_TOP = 1;
  const STATE_ON_TOP = 2;
  const NAMED_TRANSITIONS_PRESETS = {
    fade: _TransitionPresets.FadeTransition,
    shift: _TransitionPresets.ShiftTransition,
    none: {
      sceneStyleInterpolator: undefined,
      transitionSpec: {
        animation: 'timing',
        config: {
          duration: 0
        }
      }
    }
  };
  const useNativeDriver = _Platform.default.OS !== 'web';
  const hasAnimation = options => {
    const {
      animation,
      transitionSpec
    } = options;
    if (animation) {
      return animation !== 'none';
    }
    return Boolean(transitionSpec);
  };
  const renderTabBarDefault = props => /*#__PURE__*/(0, _jsxRuntime.jsx)(_BottomTabBar.BottomTabBar, Object.assign({}, props));
  function BottomTabView(props) {
    const {
      tabBar = renderTabBarDefault,
      state,
      navigation,
      descriptors,
      safeAreaInsets,
      detachInactiveScreens = _Platform.default.OS === 'web' || _Platform.default.OS === 'android' || _Platform.default.OS === 'ios'
    } = props;
    const focusedRouteKey = state.routes[state.index].key;

    /**
     * List of loaded tabs, tabs will be loaded when navigated to.
     */
    const [loaded, setLoaded] = React.useState([focusedRouteKey]);
    if (!loaded.includes(focusedRouteKey)) {
      // Set the current tab to be loaded if it was not loaded before
      setLoaded([...loaded, focusedRouteKey]);
    }
    const previousRouteKeyRef = React.useRef(focusedRouteKey);
    const tabAnims = (0, _useAnimatedHashMap.useAnimatedHashMap)(state);
    React.useEffect(() => {
      const previousRouteKey = previousRouteKeyRef.current;
      let popToTopAction;
      if (previousRouteKey !== focusedRouteKey && descriptors[previousRouteKey]?.options.popToTopOnBlur) {
        const prevRoute = state.routes.find(route => route.key === previousRouteKey);
        if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {
          popToTopAction = Object.assign({}, _native.StackActions.popToTop(), {
            target: prevRoute.state.key
          });
        }
      }
      const animateToIndex = () => {
        if (previousRouteKey !== focusedRouteKey) {
          navigation.emit({
            type: 'transitionStart',
            target: focusedRouteKey
          });
        }
        _Animated.default.parallel(state.routes.map((route, index) => {
          const {
            options
          } = descriptors[route.key];
          const {
            animation = 'none',
            transitionSpec = NAMED_TRANSITIONS_PRESETS[animation].transitionSpec
          } = options;
          let spec = transitionSpec;
          if (route.key !== previousRouteKey && route.key !== focusedRouteKey) {
            // Don't animate if the screen is not previous one or new one
            // This will avoid flicker for screens not involved in the transition
            spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;
          }
          spec = spec ?? NAMED_TRANSITIONS_PRESETS.none.transitionSpec;
          const toValue = index === state.index ? 0 : index >= state.index ? 1 : -1;
          return _Animated.default[spec.animation](tabAnims[route.key], Object.assign({}, spec.config, {
            toValue,
            useNativeDriver
          }));
        }).filter(Boolean)).start(({
          finished
        }) => {
          if (finished && popToTopAction) {
            navigation.dispatch(popToTopAction);
          }
          if (previousRouteKey !== focusedRouteKey) {
            navigation.emit({
              type: 'transitionEnd',
              target: focusedRouteKey
            });
          }
        });
      };
      animateToIndex();
      previousRouteKeyRef.current = focusedRouteKey;
    }, [descriptors, focusedRouteKey, navigation, state.index, state.routes, tabAnims]);
    const dimensions = _elements.SafeAreaProviderCompat.initialMetrics.frame;
    const [tabBarHeight, setTabBarHeight] = React.useState(() => (0, _BottomTabBar.getTabBarHeight)({
      state,
      descriptors,
      dimensions,
      insets: Object.assign({}, _elements.SafeAreaProviderCompat.initialMetrics.insets, props.safeAreaInsets),
      style: descriptors[state.routes[state.index].key].options.tabBarStyle
    }));
    const renderTabBar = () => {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, {
        children: insets => tabBar({
          state: state,
          descriptors: descriptors,
          navigation: navigation,
          insets: {
            top: safeAreaInsets?.top ?? insets?.top ?? 0,
            right: safeAreaInsets?.right ?? insets?.right ?? 0,
            bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,
            left: safeAreaInsets?.left ?? insets?.left ?? 0
          }
        })
      });
    };
    const {
      routes
    } = state;

    // If there is no animation, we only have 2 states: visible and invisible
    const hasTwoStates = !routes.some(route => hasAnimation(descriptors[route.key].options));
    const {
      tabBarPosition = 'bottom'
    } = descriptors[focusedRouteKey].options;
    const tabBarElement = /*#__PURE__*/(0, _jsxRuntime.jsx)(_BottomTabBarHeightCallbackContext.BottomTabBarHeightCallbackContext.Provider, {
      value: setTabBarHeight,
      children: renderTabBar()
    }, "tabbar");
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_elements.SafeAreaProviderCompat, {
      style: {
        flexDirection: tabBarPosition === 'left' || tabBarPosition === 'right' ? 'row' : 'column'
      },
      children: [tabBarPosition === 'top' || tabBarPosition === 'left' ? tabBarElement : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(_ScreenFallback.MaybeScreenContainer, {
        enabled: detachInactiveScreens,
        hasTwoStates: hasTwoStates,
        style: styles.screens,
        children: routes.map((route, index) => {
          const descriptor = descriptors[route.key];
          const {
            lazy = true,
            animation = 'none',
            sceneStyleInterpolator = NAMED_TRANSITIONS_PRESETS[animation].sceneStyleInterpolator
          } = descriptor.options;
          const isFocused = state.index === index;
          const isPreloaded = state.preloadedRouteKeys.includes(route.key);
          if (lazy && !loaded.includes(route.key) && !isFocused && !isPreloaded) {
            // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded
            return null;
          }
          const {
            freezeOnBlur,
            header = ({
              layout,
              options
            }) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.Header, Object.assign({}, options, {
              layout: layout,
              title: (0, _elements.getHeaderTitle)(options, route.name)
            })),
            headerShown,
            headerStatusBarHeight,
            headerTransparent,
            sceneStyle: customSceneStyle
          } = descriptor.options;
          const {
            sceneStyle
          } = sceneStyleInterpolator?.({
            current: {
              progress: tabAnims[route.key]
            }
          }) ?? {};
          const animationEnabled = hasAnimation(descriptor.options);
          const activityState = isFocused ? STATE_ON_TOP // the screen is on top after the transition
          : animationEnabled // is animation is not enabled, immediately move to inactive state
          ? tabAnims[route.key].interpolate({
            inputRange: [0, 1 - EPSILON, 1],
            outputRange: [STATE_TRANSITIONING_OR_BELOW_TOP,
            // screen visible during transition
            STATE_TRANSITIONING_OR_BELOW_TOP, STATE_INACTIVE // the screen is detached after transition
            ],
            extrapolate: 'extend'
          }) : STATE_INACTIVE;
          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_ScreenFallback.MaybeScreen, {
            style: [_StyleSheet.default.absoluteFill, {
              zIndex: isFocused ? 0 : -1
            }],
            active: activityState,
            enabled: detachInactiveScreens,
            freezeOnBlur: freezeOnBlur,
            shouldFreeze: activityState === STATE_INACTIVE && !isPreloaded,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_BottomTabBarHeightContext.BottomTabBarHeightContext.Provider, {
              value: tabBarPosition === 'bottom' ? tabBarHeight : 0,
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.Screen, {
                focused: isFocused,
                route: descriptor.route,
                navigation: descriptor.navigation,
                headerShown: headerShown,
                headerStatusBarHeight: headerStatusBarHeight,
                headerTransparent: headerTransparent,
                header: header({
                  layout: dimensions,
                  route: descriptor.route,
                  navigation: descriptor.navigation,
                  options: descriptor.options
                }),
                style: [customSceneStyle, animationEnabled && sceneStyle],
                children: descriptor.render()
              })
            })
          }, route.key);
        })
      }, "screens"), tabBarPosition === 'bottom' || tabBarPosition === 'right' ? tabBarElement : null]
    });
  }
  const styles = _StyleSheet.default.create({
    screens: {
      flex: 1,
      overflow: 'hidden'
    }
  });
},598,[17,541,350,3,104,106,30,893,595,599,600,601,602,607,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\BottomTabView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BottomTabBarHeightCallbackContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const BottomTabBarHeightCallbackContext = exports.BottomTabBarHeightCallbackContext = /*#__PURE__*/React.createContext(undefined);
},599,[3],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\utils\\BottomTabBarHeightCallbackContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BottomTabBarHeightContext = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const BottomTabBarHeightContext = exports.BottomTabBarHeightContext = /*#__PURE__*/React.createContext(undefined);
},600,[3],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\utils\\BottomTabBarHeightContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useAnimatedHashMap = useAnimatedHashMap;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Animated"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useAnimatedHashMap({
    routes,
    index
  }) {
    const refs = React.useRef({});
    const previous = refs.current;
    const routeKeys = Object.keys(previous);
    if (routes.length === routeKeys.length && routes.every(route => routeKeys.includes(route.key))) {
      return previous;
    }
    refs.current = {};
    routes.forEach(({
      key
    }, i) => {
      refs.current[key] = previous[key] ?? new _Animated.default.Value(i === index ? 0 : i >= index ? 1 : -1);
    });
    return refs.current;
  }
},601,[17,3,104],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\utils\\useAnimatedHashMap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BottomTabBar = BottomTabBar;
  exports.getTabBarHeight = void 0;
  var _elements = require(_dependencyMap[1], "@react-navigation/elements");
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _react = _interopRequireDefault(require(_dependencyMap[3], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/View"));
  var _reactNativeSafeAreaContext = require(_dependencyMap[8], "react-native-safe-area-context");
  var _BottomTabBarHeightCallbackContext = require(_dependencyMap[9], "../utils/BottomTabBarHeightCallbackContext.js");
  var _useIsKeyboardShown = require(_dependencyMap[10], "../utils/useIsKeyboardShown.js");
  var _BottomTabItem = require(_dependencyMap[11], "./BottomTabItem.js");
  var _jsxRuntime = require(_dependencyMap[12], "react/jsx-runtime");
  const TABBAR_HEIGHT_UIKIT = 49;
  const TABBAR_HEIGHT_UIKIT_COMPACT = 32;
  const SPACING_UIKIT = 15;
  const SPACING_MATERIAL = 12;
  const DEFAULT_MAX_TAB_ITEM_WIDTH = 125;
  const useNativeDriver = _Platform.default.OS !== 'web';
  const shouldUseHorizontalLabels = ({
    state,
    descriptors,
    dimensions
  }) => {
    const {
      tabBarLabelPosition
    } = descriptors[state.routes[state.index].key].options;
    if (tabBarLabelPosition) {
      switch (tabBarLabelPosition) {
        case 'beside-icon':
          return true;
        case 'below-icon':
          return false;
      }
    }
    if (dimensions.width >= 768) {
      // Screen size matches a tablet
      const maxTabWidth = state.routes.reduce((acc, route) => {
        const {
          tabBarItemStyle
        } = descriptors[route.key].options;
        const flattenedStyle = _StyleSheet.default.flatten(tabBarItemStyle);
        if (flattenedStyle) {
          if (typeof flattenedStyle.width === 'number') {
            return acc + flattenedStyle.width;
          } else if (typeof flattenedStyle.maxWidth === 'number') {
            return acc + flattenedStyle.maxWidth;
          }
        }
        return acc + DEFAULT_MAX_TAB_ITEM_WIDTH;
      }, 0);
      return maxTabWidth <= dimensions.width;
    } else {
      return dimensions.width > dimensions.height;
    }
  };
  const isCompact = ({
    state,
    descriptors,
    dimensions
  }) => {
    const {
      tabBarPosition,
      tabBarVariant
    } = descriptors[state.routes[state.index].key].options;
    if (tabBarPosition === 'left' || tabBarPosition === 'right' || tabBarVariant === 'material') {
      return false;
    }
    const isLandscape = dimensions.width > dimensions.height;
    const horizontalLabels = shouldUseHorizontalLabels({
      state,
      descriptors,
      dimensions
    });
    if (_Platform.default.OS === 'ios' && !_Platform.default.isPad && isLandscape && horizontalLabels) {
      return true;
    }
    return false;
  };
  const getTabBarHeight = ({
    state,
    descriptors,
    dimensions,
    insets,
    style
  }) => {
    const {
      tabBarPosition
    } = descriptors[state.routes[state.index].key].options;
    const flattenedStyle = _StyleSheet.default.flatten(style);
    const customHeight = flattenedStyle && 'height' in flattenedStyle ? flattenedStyle.height : undefined;
    if (typeof customHeight === 'number') {
      return customHeight;
    }
    const inset = insets[tabBarPosition === 'top' ? 'top' : 'bottom'];
    if (isCompact({
      state,
      descriptors,
      dimensions
    })) {
      return TABBAR_HEIGHT_UIKIT_COMPACT + inset;
    }
    return TABBAR_HEIGHT_UIKIT + inset;
  };
  exports.getTabBarHeight = getTabBarHeight;
  function BottomTabBar({
    state,
    navigation,
    descriptors,
    insets,
    style
  }) {
    const {
      colors
    } = (0, _native.useTheme)();
    const {
      direction
    } = (0, _native.useLocale)();
    const {
      buildHref
    } = (0, _native.useLinkBuilder)();
    const focusedRoute = state.routes[state.index];
    const focusedDescriptor = descriptors[focusedRoute.key];
    const focusedOptions = focusedDescriptor.options;
    const {
      tabBarPosition = 'bottom',
      tabBarShowLabel,
      tabBarLabelPosition,
      tabBarHideOnKeyboard = false,
      tabBarVisibilityAnimationConfig,
      tabBarVariant = 'uikit',
      tabBarStyle,
      tabBarBackground,
      tabBarActiveTintColor,
      tabBarInactiveTintColor,
      tabBarActiveBackgroundColor,
      tabBarInactiveBackgroundColor
    } = focusedOptions;
    if (tabBarVariant === 'material' && tabBarPosition !== 'left' && tabBarPosition !== 'right') {
      throw new Error("The 'material' variant for tab bar is only supported when 'tabBarPosition' is set to 'left' or 'right'.");
    }
    if (tabBarLabelPosition === 'below-icon' && tabBarVariant === 'uikit' && (tabBarPosition === 'left' || tabBarPosition === 'right')) {
      throw new Error("The 'below-icon' label position for tab bar is only supported when 'tabBarPosition' is set to 'top' or 'bottom' when using the 'uikit' variant.");
    }
    const dimensions = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
    const isKeyboardShown = (0, _useIsKeyboardShown.useIsKeyboardShown)();
    const onHeightChange = _react.default.useContext(_BottomTabBarHeightCallbackContext.BottomTabBarHeightCallbackContext);
    const shouldShowTabBar = !(tabBarHideOnKeyboard && isKeyboardShown);
    const visibilityAnimationConfigRef = _react.default.useRef(tabBarVisibilityAnimationConfig);
    _react.default.useEffect(() => {
      visibilityAnimationConfigRef.current = tabBarVisibilityAnimationConfig;
    });
    const [isTabBarHidden, setIsTabBarHidden] = _react.default.useState(!shouldShowTabBar);
    const [visible] = _react.default.useState(() => new _Animated.default.Value(shouldShowTabBar ? 1 : 0));
    _react.default.useEffect(() => {
      const visibilityAnimationConfig = visibilityAnimationConfigRef.current;
      if (shouldShowTabBar) {
        const animation = visibilityAnimationConfig?.show?.animation === 'spring' ? _Animated.default.spring : _Animated.default.timing;
        animation(visible, Object.assign({
          toValue: 1,
          useNativeDriver,
          duration: 250
        }, visibilityAnimationConfig?.show?.config)).start(({
          finished
        }) => {
          if (finished) {
            setIsTabBarHidden(false);
          }
        });
      } else {
        // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
        setIsTabBarHidden(true);
        const animation = visibilityAnimationConfig?.hide?.animation === 'spring' ? _Animated.default.spring : _Animated.default.timing;
        animation(visible, Object.assign({
          toValue: 0,
          useNativeDriver,
          duration: 200
        }, visibilityAnimationConfig?.hide?.config)).start();
      }
      return () => visible.stopAnimation();
    }, [visible, shouldShowTabBar]);
    const [layout, setLayout] = _react.default.useState({
      height: 0
    });
    const handleLayout = e => {
      const {
        height
      } = e.nativeEvent.layout;
      onHeightChange?.(height);
      setLayout(layout => {
        if (height === layout.height) {
          return layout;
        } else {
          return {
            height
          };
        }
      });
    };
    const {
      routes
    } = state;
    const tabBarHeight = getTabBarHeight({
      state,
      descriptors,
      insets,
      dimensions,
      style: [tabBarStyle, style]
    });
    const hasHorizontalLabels = shouldUseHorizontalLabels({
      state,
      descriptors,
      dimensions
    });
    const compact = isCompact({
      state,
      descriptors,
      dimensions
    });
    const sidebar = tabBarPosition === 'left' || tabBarPosition === 'right';
    const spacing = tabBarVariant === 'material' ? SPACING_MATERIAL : SPACING_UIKIT;
    const tabBarBackgroundElement = tabBarBackground?.();
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Animated.default.View, {
      style: [tabBarPosition === 'left' ? styles.start : tabBarPosition === 'right' ? styles.end : styles.bottom, (_Platform.default.OS === 'web' ? tabBarPosition === 'right' : direction === 'rtl' && tabBarPosition === 'left' || direction !== 'rtl' && tabBarPosition === 'right') ? {
        borderLeftWidth: _StyleSheet.default.hairlineWidth
      } : (_Platform.default.OS === 'web' ? tabBarPosition === 'left' : direction === 'rtl' && tabBarPosition === 'right' || direction !== 'rtl' && tabBarPosition === 'left') ? {
        borderRightWidth: _StyleSheet.default.hairlineWidth
      } : tabBarPosition === 'top' ? {
        borderBottomWidth: _StyleSheet.default.hairlineWidth
      } : {
        borderTopWidth: _StyleSheet.default.hairlineWidth
      }, {
        backgroundColor: tabBarBackgroundElement != null ? 'transparent' : colors.card,
        borderColor: colors.border
      }, sidebar ? {
        paddingTop: (hasHorizontalLabels ? spacing : spacing / 2) + insets.top,
        paddingBottom: (hasHorizontalLabels ? spacing : spacing / 2) + insets.bottom,
        paddingStart: spacing + (tabBarPosition === 'left' ? insets.left : 0),
        paddingEnd: spacing + (tabBarPosition === 'right' ? insets.right : 0),
        minWidth: hasHorizontalLabels ? (0, _elements.getDefaultSidebarWidth)(dimensions) : 0
      } : [{
        transform: [{
          translateY: visible.interpolate({
            inputRange: [0, 1],
            outputRange: [layout.height + insets[tabBarPosition === 'top' ? 'top' : 'bottom'] + _StyleSheet.default.hairlineWidth, 0]
          })
        }],
        // Absolutely position the tab bar so that the content is below it
        // This is needed to avoid gap at bottom when the tab bar is hidden
        position: isTabBarHidden ? 'absolute' : undefined
      }, {
        height: tabBarHeight,
        paddingBottom: tabBarPosition === 'bottom' ? insets.bottom : 0,
        paddingTop: tabBarPosition === 'top' ? insets.top : 0,
        paddingHorizontal: Math.max(insets.left, insets.right)
      }], tabBarStyle],
      pointerEvents: isTabBarHidden ? 'none' : 'auto',
      onLayout: sidebar ? undefined : handleLayout,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        pointerEvents: "none",
        style: _StyleSheet.default.absoluteFill,
        children: tabBarBackgroundElement
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        role: "tablist",
        style: sidebar ? styles.sideContent : styles.bottomContent,
        children: routes.map((route, index) => {
          const focused = index === state.index;
          const {
            options
          } = descriptors[route.key];
          const onPress = () => {
            const event = navigation.emit({
              type: 'tabPress',
              target: route.key,
              canPreventDefault: true
            });
            if (!focused && !event.defaultPrevented) {
              navigation.dispatch(Object.assign({}, _native.CommonActions.navigate(route), {
                target: state.key
              }));
            }
          };
          const onLongPress = () => {
            navigation.emit({
              type: 'tabLongPress',
              target: route.key
            });
          };
          const label = typeof options.tabBarLabel === 'function' ? options.tabBarLabel : (0, _elements.getLabel)({
            label: options.tabBarLabel,
            title: options.title
          }, route.name);
          const accessibilityLabel = options.tabBarAccessibilityLabel !== undefined ? options.tabBarAccessibilityLabel : typeof label === 'string' && _Platform.default.OS === 'ios' ? `${label}, tab, ${index + 1} of ${routes.length}` : undefined;
          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_native.NavigationContext.Provider, {
            value: descriptors[route.key].navigation,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_native.NavigationRouteContext.Provider, {
              value: route,
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_BottomTabItem.BottomTabItem, {
                href: buildHref(route.name, route.params),
                route: route,
                descriptor: descriptors[route.key],
                focused: focused,
                horizontal: hasHorizontalLabels,
                compact: compact,
                sidebar: sidebar,
                variant: tabBarVariant,
                onPress: onPress,
                onLongPress: onLongPress,
                accessibilityLabel: accessibilityLabel,
                testID: options.tabBarButtonTestID,
                allowFontScaling: options.tabBarAllowFontScaling,
                activeTintColor: tabBarActiveTintColor,
                inactiveTintColor: tabBarInactiveTintColor,
                activeBackgroundColor: tabBarActiveBackgroundColor,
                inactiveBackgroundColor: tabBarInactiveBackgroundColor,
                button: options.tabBarButton,
                icon: options.tabBarIcon ?? (({
                  color,
                  size
                }) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.MissingIcon, {
                  color: color,
                  size: size
                })),
                badge: options.tabBarBadge,
                badgeStyle: options.tabBarBadgeStyle,
                label: label,
                showLabel: tabBarShowLabel,
                labelStyle: options.tabBarLabelStyle,
                iconStyle: options.tabBarIconStyle,
                style: [sidebar ? {
                  marginVertical: hasHorizontalLabels ? tabBarVariant === 'material' ? 0 : 1 : spacing / 2
                } : styles.bottomItem, options.tabBarItemStyle]
              })
            })
          }, route.key);
        })
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    start: {
      top: 0,
      bottom: 0,
      start: 0
    },
    end: {
      top: 0,
      bottom: 0,
      end: 0
    },
    bottom: {
      start: 0,
      end: 0,
      bottom: 0,
      elevation: 8
    },
    bottomContent: {
      flex: 1,
      flexDirection: 'row'
    },
    sideContent: {
      flex: 1,
      flexDirection: 'column'
    },
    bottomItem: {
      flex: 1
    }
  });
},602,[17,541,350,3,104,106,30,111,893,599,603,604,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\BottomTabBar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useIsKeyboardShown = useIsKeyboardShown;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Keyboard = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Keyboard"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useIsKeyboardShown() {
    const [isKeyboardShown, setIsKeyboardShown] = React.useState(false);
    React.useEffect(() => {
      const handleKeyboardShow = () => setIsKeyboardShown(true);
      const handleKeyboardHide = () => setIsKeyboardShown(false);
      let subscriptions;
      if (_Platform.default.OS === 'ios') {
        subscriptions = [_Keyboard.default.addListener('keyboardWillShow', handleKeyboardShow), _Keyboard.default.addListener('keyboardWillHide', handleKeyboardHide)];
      } else {
        subscriptions = [_Keyboard.default.addListener('keyboardDidShow', handleKeyboardShow), _Keyboard.default.addListener('keyboardDidHide', handleKeyboardHide)];
      }
      return () => {
        subscriptions.forEach(s => s.remove());
      };
    }, []);
    return isKeyboardShown;
  }
},603,[17,3,219,106],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\utils\\useIsKeyboardShown.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BottomTabItem = BottomTabItem;
  var _elements = require(_dependencyMap[1], "@react-navigation/elements");
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _color = _interopRequireDefault(require(_dependencyMap[3], "color"));
  var _react = _interopRequireDefault(require(_dependencyMap[4], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/View"));
  var _TabBarIcon = require(_dependencyMap[8], "./TabBarIcon.js");
  var _jsxRuntime = require(_dependencyMap[9], "react/jsx-runtime");
  const renderButtonDefault = props => /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.PlatformPressable, Object.assign({}, props));
  const SUPPORTS_LARGE_CONTENT_VIEWER = _Platform.default.OS === 'ios' && parseInt(_Platform.default.Version, 10) >= 13;
  function BottomTabItem({
    route,
    href,
    focused,
    descriptor,
    label,
    icon,
    badge,
    badgeStyle,
    button = renderButtonDefault,
    accessibilityLabel,
    testID,
    onPress,
    onLongPress,
    horizontal,
    compact,
    sidebar,
    variant,
    activeTintColor: customActiveTintColor,
    inactiveTintColor: customInactiveTintColor,
    activeBackgroundColor: customActiveBackgroundColor,
    inactiveBackgroundColor = 'transparent',
    showLabel = true,
    // On iOS 13+, we use `largeContentTitle` for accessibility
    // So we don't need the font to scale up
    // https://developer.apple.com/documentation/uikit/uiview/3183939-largecontenttitle
    allowFontScaling = SUPPORTS_LARGE_CONTENT_VIEWER ? false : undefined,
    labelStyle,
    iconStyle,
    style
  }) {
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    const activeTintColor = customActiveTintColor ?? (variant === 'uikit' && sidebar && horizontal ? (0, _color.default)(colors.primary).isDark() ? 'white' : (0, _color.default)(colors.primary).darken(0.71).string() : colors.primary);
    const inactiveTintColor = customInactiveTintColor === undefined ? variant === 'material' ? (0, _color.default)(colors.text).alpha(0.68).rgb().string() : (0, _color.default)(colors.text).mix((0, _color.default)(colors.card), 0.5).hex() : customInactiveTintColor;
    const activeBackgroundColor = customActiveBackgroundColor ?? (variant === 'material' ? (0, _color.default)(activeTintColor).alpha(0.12).rgb().string() : sidebar && horizontal ? colors.primary : 'transparent');
    const {
      options
    } = descriptor;
    const labelString = (0, _elements.getLabel)({
      label: typeof options.tabBarLabel === 'string' ? options.tabBarLabel : undefined,
      title: options.title
    }, route.name);
    let labelInactiveTintColor = inactiveTintColor;
    let iconInactiveTintColor = inactiveTintColor;
    if (variant === 'uikit' && sidebar && horizontal && customInactiveTintColor === undefined) {
      iconInactiveTintColor = colors.primary;
      labelInactiveTintColor = colors.text;
    }
    const renderLabel = ({
      focused
    }) => {
      if (showLabel === false) {
        return null;
      }
      const color = focused ? activeTintColor : labelInactiveTintColor;
      if (typeof label !== 'string') {
        return label({
          focused,
          color,
          position: horizontal ? 'beside-icon' : 'below-icon',
          children: labelString
        });
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_elements.Label, {
        style: [horizontal ? [styles.labelBeside, variant === 'material' ? styles.labelSidebarMaterial : sidebar ? styles.labelSidebarUiKit : compact ? styles.labelBesideUikitCompact : styles.labelBesideUikit, icon == null && {
          marginStart: 0
        }] : styles.labelBeneath, compact || variant === 'uikit' && sidebar && horizontal ? fonts.regular : fonts.medium, labelStyle],
        allowFontScaling: allowFontScaling,
        tintColor: color,
        children: label
      });
    };
    const renderIcon = ({
      focused
    }) => {
      if (icon === undefined) {
        return null;
      }
      const activeOpacity = focused ? 1 : 0;
      const inactiveOpacity = focused ? 0 : 1;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_TabBarIcon.TabBarIcon, {
        route: route,
        variant: variant,
        size: compact ? 'compact' : 'regular',
        badge: badge,
        badgeStyle: badgeStyle,
        activeOpacity: activeOpacity,
        allowFontScaling: allowFontScaling,
        inactiveOpacity: inactiveOpacity,
        activeTintColor: activeTintColor,
        inactiveTintColor: iconInactiveTintColor,
        renderIcon: icon,
        style: iconStyle
      });
    };
    const scene = {
      route,
      focused
    };
    const backgroundColor = focused ? activeBackgroundColor : inactiveBackgroundColor;
    const {
      flex
    } = _StyleSheet.default.flatten(style || {});
    const borderRadius = variant === 'material' ? horizontal ? 56 : 16 : sidebar && horizontal ? 10 : 0;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
      style: [
      // Clip ripple effect on Android
      {
        borderRadius,
        overflow: variant === 'material' ? 'hidden' : 'visible'
      }, style],
      children: button({
        href,
        onPress,
        onLongPress,
        testID,
        'aria-label': accessibilityLabel,
        'accessibilityLargeContentTitle': labelString,
        'accessibilityShowsLargeContentViewer': true,
        // FIXME: role: 'tab' doesn't seem to work as expected on iOS
        'role': _Platform.default.select({
          ios: 'button',
          default: 'tab'
        }),
        'aria-selected': focused,
        'android_ripple': {
          borderless: true
        },
        'hoverEffect': variant === 'material' || sidebar && horizontal ? {
          color: colors.text
        } : undefined,
        'pressOpacity': 1,
        'style': [styles.tab, {
          flex,
          backgroundColor,
          borderRadius
        }, sidebar ? variant === 'material' ? horizontal ? styles.tabBarSidebarMaterial : styles.tabVerticalMaterial : horizontal ? styles.tabBarSidebarUiKit : styles.tabVerticalUiKit : variant === 'material' ? styles.tabVerticalMaterial : horizontal ? styles.tabHorizontalUiKit : styles.tabVerticalUiKit],
        'children': /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.default.Fragment, {
          children: [renderIcon(scene), renderLabel(scene)]
        })
      })
    });
  }
  const styles = _StyleSheet.default.create({
    tab: {
      alignItems: 'center',
      // Roundness for iPad hover effect
      borderRadius: 10
    },
    tabVerticalUiKit: {
      justifyContent: 'flex-start',
      flexDirection: 'column',
      padding: 5
    },
    tabVerticalMaterial: {
      padding: 10
    },
    tabHorizontalUiKit: {
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      padding: 5
    },
    tabBarSidebarUiKit: {
      justifyContent: 'flex-start',
      alignItems: 'center',
      flexDirection: 'row',
      paddingVertical: 7,
      paddingHorizontal: 5
    },
    tabBarSidebarMaterial: {
      justifyContent: 'flex-start',
      alignItems: 'center',
      flexDirection: 'row',
      paddingVertical: 15,
      paddingStart: 16,
      paddingEnd: 24
    },
    labelSidebarMaterial: {
      marginStart: 12
    },
    labelSidebarUiKit: {
      fontSize: 17,
      marginStart: 10
    },
    labelBeneath: {
      fontSize: 10
    },
    labelBeside: {
      marginEnd: 12,
      lineHeight: 24
    },
    labelBesideUikit: {
      fontSize: 13,
      marginStart: 5
    },
    labelBesideUikitCompact: {
      fontSize: 12,
      marginStart: 5
    }
  });
},604,[17,541,350,549,3,106,30,111,605,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\BottomTabItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TabBarIcon = TabBarIcon;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Badge = require(_dependencyMap[4], "./Badge.js");
  var _jsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  /**
   * Icon sizes taken from Apple HIG
   * https://developer.apple.com/design/human-interface-guidelines/tab-bars
   */
  const ICON_SIZE_WIDE = 31;
  const ICON_SIZE_WIDE_COMPACT = 23;
  const ICON_SIZE_TALL = 28;
  const ICON_SIZE_TALL_COMPACT = 20;
  const ICON_SIZE_ROUND = 25;
  const ICON_SIZE_ROUND_COMPACT = 18;
  const ICON_SIZE_MATERIAL = 24;
  function TabBarIcon({
    route: _,
    variant,
    size,
    badge,
    badgeStyle,
    activeOpacity,
    inactiveOpacity,
    activeTintColor,
    inactiveTintColor,
    renderIcon,
    allowFontScaling,
    style
  }) {
    const iconSize = variant === 'material' ? ICON_SIZE_MATERIAL : size === 'compact' ? ICON_SIZE_ROUND_COMPACT : ICON_SIZE_ROUND;

    // We render the icon twice at the same position on top of each other:
    // active and inactive one, so we can fade between them.
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_View.default, {
      style: [variant === 'material' ? styles.wrapperMaterial : size === 'compact' ? styles.wrapperUikitCompact : styles.wrapperUikit, style],
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        style: [styles.icon, {
          opacity: activeOpacity,
          // Workaround for react-native >= 0.54 layout bug
          minWidth: iconSize
        }],
        children: renderIcon({
          focused: true,
          size: iconSize,
          color: activeTintColor
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, {
        style: [styles.icon, {
          opacity: inactiveOpacity
        }],
        children: renderIcon({
          focused: false,
          size: iconSize,
          color: inactiveTintColor
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Badge.Badge, {
        visible: badge != null,
        size: iconSize * 0.75,
        allowFontScaling: allowFontScaling,
        style: [styles.badge, badgeStyle],
        children: badge
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    icon: {
      // We render the icon twice at the same position on top of each other:
      // active and inactive one, so we can fade between them:
      // Cover the whole iconContainer:
      position: 'absolute',
      alignSelf: 'center',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      width: '100%'
    },
    wrapperUikit: {
      width: ICON_SIZE_WIDE,
      height: ICON_SIZE_TALL
    },
    wrapperUikitCompact: {
      width: ICON_SIZE_WIDE_COMPACT,
      height: ICON_SIZE_TALL_COMPACT
    },
    wrapperMaterial: {
      width: ICON_SIZE_MATERIAL,
      height: ICON_SIZE_MATERIAL
    },
    badge: {
      position: 'absolute',
      end: -3,
      top: -3
    }
  });
},605,[17,3,30,111,606,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\TabBarIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Badge = Badge;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _native = require(_dependencyMap[2], "@react-navigation/native");
  var _color = _interopRequireDefault(require(_dependencyMap[3], "color"));
  var React = _interopRequireWildcard(require(_dependencyMap[4], "react"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Animated"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/StyleSheet"));
  var _jsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  const _excluded = ["children", "style", "visible", "size"],
    _excluded2 = ["backgroundColor"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const useNativeDriver = _Platform.default.OS !== 'web';
  function Badge(_ref) {
    let {
        children,
        style,
        visible = true,
        size = 18
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const [opacity] = React.useState(() => new _Animated.default.Value(visible ? 1 : 0));
    const [rendered, setRendered] = React.useState(visible);
    const {
      colors,
      fonts
    } = (0, _native.useTheme)();
    React.useEffect(() => {
      if (!rendered) {
        return;
      }
      _Animated.default.timing(opacity, {
        toValue: visible ? 1 : 0,
        duration: 150,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished && !visible) {
          setRendered(false);
        }
      });
      return () => opacity.stopAnimation();
    }, [opacity, rendered, visible]);
    if (!rendered) {
      if (visible) {
        setRendered(true);
      } else {
        return null;
      }
    }

    // @ts-expect-error: backgroundColor definitely exists
    const _ref2 = _StyleSheet.default.flatten(style) || {},
      {
        backgroundColor = colors.notification
      } = _ref2,
      restStyle = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);
    const textColor = (0, _color.default)(backgroundColor).isLight() ? 'black' : 'white';
    const borderRadius = size / 2;
    const fontSize = Math.floor(size * 3 / 4);
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Animated.default.Text, Object.assign({
      numberOfLines: 1,
      style: [{
        transform: [{
          scale: opacity.interpolate({
            inputRange: [0, 1],
            outputRange: [0.5, 1]
          })
        }],
        color: textColor,
        lineHeight: size - 1,
        height: size,
        minWidth: size,
        opacity,
        backgroundColor,
        fontSize,
        borderRadius
      }, fonts.regular, styles.container, restStyle]
    }, rest, {
      children: children
    }));
  }
  const styles = _StyleSheet.default.create({
    container: {
      alignSelf: 'flex-end',
      textAlign: 'center',
      paddingHorizontal: 4,
      overflow: 'hidden'
    }
  });
},606,[17,29,350,549,3,104,106,30,6],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\Badge.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaybeScreen = MaybeScreen;
  exports.MaybeScreenContainer = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _jsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const _excluded = ["enabled"],
    _excluded2 = ["enabled", "active"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  let Screens;
  try {
    Screens = require(_dependencyMap[5], "react-native-screens");
  } catch (e) {
    // Ignore
  }
  const MaybeScreenContainer = _ref => {
    let {
        enabled
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    if (Screens?.screensEnabled?.()) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(Screens.ScreenContainer, Object.assign({
        enabled: enabled
      }, rest));
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, Object.assign({}, rest));
  };
  exports.MaybeScreenContainer = MaybeScreenContainer;
  function MaybeScreen(_ref2) {
    let {
        enabled,
        active
      } = _ref2,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);
    if (Screens?.screensEnabled?.()) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(Screens.Screen, Object.assign({
        enabled: enabled,
        activityState: active
      }, rest));
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_View.default, Object.assign({}, rest));
  }
},607,[17,29,3,111,6,901],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\views\\ScreenFallback.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const DEV = process.env.NODE_ENV !== "production";
  const warnings = new Set();
  function warnOnce(condition, ...rest) {
    if (DEV && condition) {
      const key = rest.join(" ");
      if (warnings.has(key)) {
        return;
      }
      warnings.add(key);
      console.warn(...rest);
    }
  }
  module.exports = warnOnce;
},618,[],"node_modules\\warn-once\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useBottomTabBarHeight = useBottomTabBarHeight;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _BottomTabBarHeightContext = require(_dependencyMap[1], "./BottomTabBarHeightContext.js");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useBottomTabBarHeight() {
    const height = React.useContext(_BottomTabBarHeightContext.BottomTabBarHeightContext);
    if (height === undefined) {
      throw new Error("Couldn't find the bottom tab bar height. Are you inside a screen in Bottom Tab Navigator?");
    }
    return height;
  }
},627,[3,600],"node_modules\\@react-navigation\\bottom-tabs\\lib\\module\\utils\\useBottomTabBarHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/error.png",
    width: 48,
    height: 48
  };
},628,[],"node_modules\\expo-router\\assets\\error.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\SuspenseFallback.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SuspenseFallback = SuspenseFallback;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Toast_1 = require(_dependencyMap[2], "./Toast");
  function SuspenseFallback({
    route
  }) {
    if (__DEV__) {
      return _reactNativeCssInteropJsxRuntime.jsx(Toast_1.ToastWrapper, {
        children: _reactNativeCssInteropJsxRuntime.jsx(Toast_1.Toast, {
          filename: route?.contextKey,
          children: "Bundling..."
        })
      });
    }
    // TODO: Support user's customizing the fallback.
    return null;
  }
},629,[2,3,592],"node_modules\\expo-router\\build\\views\\SuspenseFallback.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\Try.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Try = void 0;
  const react_1 = __importStar(require(_dependencyMap[1], "react"));
  const SplashScreen = __importStar(require(_dependencyMap[2], "./Splash"));
  const errors_1 = require(_dependencyMap[3], "../rsc/router/errors");
  // No way to access `getDerivedStateFromError` from a function component afaict.
  class Try extends react_1.Component {
    state = {
      error: undefined
    };
    static getDerivedStateFromError(error) {
      // Force hide the splash screen if an error occurs.
      SplashScreen.hideAsync();
      if (__DEV__ && error instanceof errors_1.MetroServerError) {
        // Throw up to the LogBox.
        return null;
      }
      return {
        error
      };
    }
    retry = () => {
      return new Promise(resolve => {
        this.setState({
          error: undefined
        }, () => {
          resolve();
        });
      });
    };
    render() {
      const {
        error
      } = this.state;
      const {
        catch: ErrorBoundary,
        children
      } = this.props;
      if (!error) {
        return children;
      }
      return _reactNativeCssInteropJsxRuntime.jsx(ErrorBoundary, {
        error: error,
        retry: this.retry
      });
    }
  }
  exports.Try = Try;
},630,[2,3,631,646],"node_modules\\expo-router\\build\\views\\Try.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(require(_dependencyMap[0], "../utils/splash"), exports);
},631,[632],"node_modules\\expo-router\\build\\views\\Splash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hide = hide;
  exports.hideAsync = hideAsync;
  exports.preventAutoHideAsync = preventAutoHideAsync;
  exports._internal_preventAutoHideAsync = _internal_preventAutoHideAsync;
  exports._internal_maybeHideAsync = _internal_maybeHideAsync;
  const expo_1 = require(_dependencyMap[0], "expo");
  const SplashModule = (0, expo_1.requireOptionalNativeModule)('ExpoSplashScreen');
  let _initializedErrorHandler = false;
  function hide() {
    if (!SplashModule) {
      return;
    }
    SplashModule.hide();
  }
  async function hideAsync() {
    hide();
  }
  async function preventAutoHideAsync() {
    if (!SplashModule) {
      return;
    }
    return SplashModule.preventAutoHideAsync();
  }
  async function _internal_preventAutoHideAsync() {
    if (!SplashModule) {
      return false;
    }
    if (!_initializedErrorHandler) {
      // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.
      // This prevents the splash screen from floating over error screens.
      if (ErrorUtils?.getGlobalHandler) {
        const originalHandler = ErrorUtils.getGlobalHandler();
        ErrorUtils.setGlobalHandler((error, isFatal) => {
          hide();
          originalHandler(error, isFatal);
        });
      }
      _initializedErrorHandler = true;
    }
    return SplashModule.internalPreventAutoHideAsync();
  }
  async function _internal_maybeHideAsync() {
    if (!SplashModule) {
      return false;
    }
    return SplashModule.internalMaybeHideAsync();
  }
},632,[633],"node_modules\\expo-router\\build\\utils\\splash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.EventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.NativeModule;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedRef;
    }
  });
  Object.defineProperty(exports, "disableErrorHandling", {
    enumerable: true,
    get: function () {
      return _ExpoErrorManager.disableErrorHandling;
    }
  });
  Object.defineProperty(exports, "getExpoGoProjectConfig", {
    enumerable: true,
    get: function () {
      return _ExpoGo.getExpoGoProjectConfig;
    }
  });
  Object.defineProperty(exports, "isRunningInExpoGo", {
    enumerable: true,
    get: function () {
      return _ExpoGo.isRunningInExpoGo;
    }
  });
  Object.defineProperty(exports, "registerRootComponent", {
    enumerable: true,
    get: function () {
      return _registerRootComponent.default;
    }
  });
  Object.defineProperty(exports, "registerWebModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.registerWebModule;
    }
  });
  Object.defineProperty(exports, "reloadAppAsync", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.reloadAppAsync;
    }
  });
  Object.defineProperty(exports, "requireNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeModule;
    }
  });
  Object.defineProperty(exports, "requireNativeView", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "requireOptionalNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireOptionalNativeModule;
    }
  });
  Object.defineProperty(exports, "useEvent", {
    enumerable: true,
    get: function () {
      return _useEvent.useEvent;
    }
  });
  Object.defineProperty(exports, "useEventListener", {
    enumerable: true,
    get: function () {
      return _useEvent.useEventListener;
    }
  });
  require(_dependencyMap[1], "./Expo.fx");
  var _ExpoErrorManager = require(_dependencyMap[2], "./errors/ExpoErrorManager");
  var _registerRootComponent = _interopRequireDefault(require(_dependencyMap[3], "./launch/registerRootComponent"));
  var _ExpoGo = require(_dependencyMap[4], "./environment/ExpoGo");
  var _expoModulesCore = require(_dependencyMap[5], "expo-modules-core");
  var _useEvent = require(_dependencyMap[6], "./hooks/useEvent");
},633,[17,634,640,641,644,473,645],"node_modules\\expo\\src\\Expo.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  require(_dependencyMap[0], "./winter");
  require(_dependencyMap[1], "expo/virtual/rsc");
  // When users dangerously import a file inside of react-native, it breaks the web alias.
  // This is one of the most common, and cryptic web errors that users encounter.
  // This conditional side-effect provides a more helpful error message for debugging.
  // Use a wrapper `__DEV__` to remove this entire block in production.
  if (__DEV__) {
    if (
    // Skip mocking if someone is shimming this value out.
    !('__fbBatchedBridgeConfig' in global)) {
      Object.defineProperty(global, '__fbBatchedBridgeConfig', {
        get() {
          throw new Error("Your web project is importing a module from 'react-native' instead of 'react-native-web'. Learn more: https://expo.fyi/fb-batched-bridge-config-web");
        }
      });
    }
  }
},634,[635,639],"node_modules\\expo\\src\\Expo.fx.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  require(_dependencyMap[0], "./runtime");
},635,[636],"node_modules\\expo\\src\\winter\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(globalThis, '__ExpoImportMetaRegistry', {
    value: require(_dependencyMap[0], "./ImportMetaRegistry").ImportMetaRegistry,
    enumerable: false,
    writable: true
  });
},636,[637],"node_modules\\expo\\src\\winter\\runtime.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ImportMetaRegistry = void 0;
  var _getBundleUrl = require(_dependencyMap[0], "../utils/getBundleUrl");
  // Copyright 2015-present 650 Industries. All rights reserved.

  /**
   * Registry to handle import.meta functionality for React Native environment
   * Similar to how it works in the web, but adapted for the RN context
   * https://github.com/wintercg/import-meta-registry
   */
  const ImportMetaRegistry = exports.ImportMetaRegistry = {
    get url() {
      return (0, _getBundleUrl.getBundleUrl)();
    }
  };
},637,[638],"node_modules\\expo\\src\\winter\\ImportMetaRegistry.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getBundleUrl = getBundleUrl;
  // Copyright 2015-present 650 Industries. All rights reserved.

  function getBundleUrl() {
    let scriptURL = null;
    if (typeof window === 'undefined') {
      // For server runtime, we use the filename of the current script
      // @ts-ignore The react-native tsconfig doesn't support CJS
      scriptURL = 'file://' + __filename;
    } else {
      // TODO: Try to support `import.meta.url` when the ecosystem supports ESM,
      // and jest doesn't throw SyntaxError when accessing `import.meta`.
      scriptURL = document.currentScript?.src;
    }
    if (scriptURL == null) {
      return null;
    }
    const url = new URL(scriptURL);
    return `${url.protocol}//${url.host}${url.pathname}`;
  }
},638,[],"node_modules\\expo\\src\\utils\\getBundleUrl.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},639,[],"node_modules\\expo\\virtual\\rsc.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createErrorHandler = createErrorHandler;
  exports.disableErrorHandling = disableErrorHandling;
  function createErrorHandler(originalHandler) {
    return (error, isFatal) => originalHandler(error, isFatal);
  }

  /**
   * @hidden
   * @deprecated Will be removed in the future.
   */
  function disableErrorHandling() {}
},640,[],"node_modules\\expo\\src\\errors\\ExpoErrorManager.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = registerRootComponent;
  require(_dependencyMap[1], "../Expo.fx");
  var _AppRegistry = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/AppRegistry"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  // @needsAudit
  /**
   * Sets the initial React component to render natively in the app's root React Native view on Android, iOS, tvOS and the web.
   *
   * This method does the following:
   * - Invokes React Native's `AppRegistry.registerComponent`.
   * - Invokes React Native web's `AppRegistry.runApplication` on web to render to the root `index.html` file.
   * - Polyfills the `process.nextTick` function globally.
   *
   * This method also adds the following dev-only features that are removed in production bundles.
   * - Adds the Fast Refresh and bundle splitting indicator to the app.
   * - Asserts if the `expo-updates` package is misconfigured.
   * - Asserts if `react-native` is not aliased to `react-native-web` when running in the browser.
   * @param component The React component class that renders the rest of your app.
   * @see For information on how to setup `registerRootComponent` in an existing (bare) React Native app, see [Common questions](#rootregistercomponent-setup-for-existing-react-native-projects) below.
   */
  function registerRootComponent(component) {
    let qualifiedComponent = component;
    if (process.env.NODE_ENV !== 'production') {
      const {
        withDevTools
      } = require(_dependencyMap[4], "./withDevTools");
      qualifiedComponent = withDevTools(component);
    }
    _AppRegistry.default.registerComponent('main', () => qualifiedComponent);
    // Skip querying the DOM if we're in a Node.js environment.
    if (_Platform.default.OS === 'web' && typeof window !== 'undefined') {
      const rootTag = document.getElementById('root');
      if (process.env.NODE_ENV !== 'production') {
        if (!rootTag) {
          throw new Error('Required HTML element with id "root" was not found in the document HTML.');
        }
      }
      _AppRegistry.default.runApplication('main', {
        rootTag,
        // Injected by SSR HTML tags.
        hydrate: globalThis.__EXPO_ROUTER_HYDRATE__
      });
    }
  }
},641,[17,634,212,106,642],"node_modules\\expo\\src\\launch\\registerRootComponent.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.withDevTools = withDevTools;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _DevLoadingView = _interopRequireDefault(require(_dependencyMap[2], "../environment/DevLoadingView"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo\\src\\launch\\withDevTools.web.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function withDevTools(AppRootComponent) {
    function WithDevTools(props) {
      return (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [(0, _jsxRuntime.jsx)(AppRootComponent, Object.assign({}, props)), (0, _jsxRuntime.jsx)(_DevLoadingView.default, {})]
      });
    }
    if (process.env.NODE_ENV !== 'production') {
      const name = AppRootComponent.displayName || AppRootComponent.name || 'Anonymous';
      WithDevTools.displayName = `withDevTools(${name})`;
    }
    return WithDevTools;
  }
},642,[17,3,643,2],"node_modules\\expo\\src\\launch\\withDevTools.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = DevLoadingView;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _NativeEventEmitter = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/NativeEventEmitter"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo\\src\\environment\\DevLoadingView.web.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const MIN_DURATION = 400;
  const ANIMATION_DURATION = 150;
  const emitter = new _NativeEventEmitter.default({
    addListener() {},
    removeListeners() {}
  });
  function DevLoadingView() {
    const show = useFastRefresh();
    const timer = (0, _react.useRef)(null);
    const toast = (0, _react.useMemo)(() => (0, _jsxRuntime.jsx)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 48 48",
      width: 24,
      height: 24,
      children: (0, _jsxRuntime.jsx)("path", {
        fill: "#ECEDEE",
        d: "M36.764 1.716a1.477 1.477 0 0 0-2.325-.268L11.721 24.609c-1.464 1.493-.438 4.064 1.623 4.064h4.484a1 1 0 0 1 .889 1.46l-7.54 14.591a1.588 1.588 0 0 0 .059 1.56 1.477 1.477 0 0 0 2.325.268l22.718-23.161c1.464-1.493.438-4.064-1.623-4.064H28.53l8.295-16.051a1.588 1.588 0 0 0-.06-1.56Z"
      })
    }), []);
    const style = (0, _react.useMemo)(() => (0, _jsxRuntime.jsx)("style", {
      dangerouslySetInnerHTML: {
        __html: `
.__expo_fast_refresh {  
  position: fixed;
  pointer-events: none;
  bottom: 8px;
  left: 8px;
  z-index: 9999;
  display: flex;
  background-color: #1B1D1E;
  border: 1px solid #4D5155;
  padding: 8px;
  border-radius: 8px;
  transition: all ${ANIMATION_DURATION}ms;
  opacity: 0; 
  filter: blur(4px); 
  transform: translateY(20%);
}

.__expo_fast_refresh_show { opacity: 1; filter: blur(0); transform: scale(1); }
`
      }
    }), []);
    const [isAnimating, setIsAnimating] = (0, _react.useState)(false);
    const [animationClass, setAnimationClass] = (0, _react.useState)('');
    const refreshIndicator = (0, _react.useMemo)(() => (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [style, (0, _jsxRuntime.jsx)("div", {
        className: '__expo_fast_refresh ' + animationClass,
        children: toast
      })]
    }), [animationClass, style, toast]);
    (0, _react.useEffect)(() => {
      timer.current && clearTimeout(timer.current);
      if (show) {
        setAnimationClass('__expo_fast_refresh_show');
      } else {
        setIsAnimating(true);
        setAnimationClass('');
        timer.current = setTimeout(() => {
          setIsAnimating(false);
        }, MIN_DURATION - ANIMATION_DURATION);
      }
      return () => {
        timer.current && clearTimeout(timer.current);
      };
    }, [show]);
    if (!isAnimating && !show) {
      return null;
    }
    return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: refreshIndicator
    });
  }
  function useFastRefresh() {
    const [isShown, setShown] = (0, _react.useState)(false);
    const duration = (0, _react.useRef)(null);
    const timeout = (0, _react.useRef)(null);
    (0, _react.useEffect)(() => {
      function handleShowMessage() {
        setShown(true);
        duration.current = Date.now();
      }
      function handleHide() {
        // Bail out if the timeout is already set
        if (timeout.current) {
          return;
        }
        const timeVisible = duration.current ? Date.now() - duration.current : 0;
        const min = Math.max(0, MIN_DURATION - timeVisible);
        timeout.current = setTimeout(() => {
          timeout.current = null;
          setShown(false);
        }, min);
      }
      const show = emitter.addListener('devLoadingView:showMessage', handleShowMessage);
      const hide = emitter.addListener('devLoadingView:hide', handleHide);
      return () => {
        if (timeout.current) {
          clearTimeout(timeout.current);
          timeout.current = null;
        }
        show.remove();
        hide.remove();
      };
    }, [emitter]);
    return isShown;
  }
},643,[17,3,223,2],"node_modules\\expo\\src\\environment\\DevLoadingView.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getExpoGoProjectConfig = getExpoGoProjectConfig;
  exports.isRunningInExpoGo = isRunningInExpoGo;
  function isRunningInExpoGo() {
    return false;
  }
  function getExpoGoProjectConfig() {
    return null;
  }
},644,[],"node_modules\\expo\\src\\environment\\ExpoGo.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useEvent = useEvent;
  exports.useEventListener = useEventListener;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Type helper that infers the event name from the emitter's events map.
   */

  /**
   * Type helper that infers the event listener from the emitter's events map.
   */

  /**
   * Type helper that infers the first parameter of the event listener.
   */

  /**
   * React hook that listens to events emitted by the given object. The returned value is an event parameter
   * that gets updated whenever a new event is dispatched.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param initialValue An event parameter to use until the event is called for the first time.
   * @returns A parameter of the event listener.
   * @example
   * ```tsx
   * import { useEvent } from 'expo';
   * import { VideoPlayer } from 'expo-video';
   *
   * export function PlayerStatus({ videoPlayer }: { videoPlayer: VideoPlayer }) {
   *   const { status } = useEvent(videoPlayer, 'statusChange', { status: videoPlayer.status });
   *
   *   return <Text>{`Player status: ${status}`}</Text>;
   * }
   * ```
   */
  function useEvent(eventEmitter, eventName, initialValue = null) {
    const [event, setEvent] = (0, _react.useState)(initialValue);
    const listener = event => setEvent(event);
    useEventListener(eventEmitter, eventName, listener);
    return event;
  }

  /**
   * React hook that listens to events emitted by the given object and calls the listener function whenever a new event is dispatched.
   * The event listener is automatically added during the first render and removed when the component unmounts.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param listener A function to call when the event is dispatched.
   * @example
   * ```tsx
   * import { useEventListener } from 'expo';
   * import { useVideoPlayer, VideoView } from 'expo-video';
   *
   * export function VideoPlayerView() {
   *   const player = useVideoPlayer(videoSource);
   *
   *   useEventListener(player, 'playingChange', ({ isPlaying }) => {
   *     console.log('Player is playing:', isPlaying);
   *   });
   *
   *   return <VideoView player={player} />;
   * }
   * ```
   */
  function useEventListener(eventEmitter, eventName, listener) {
    // Always use the most recent version of the listener inside the effect,
    // without memoization so the listeners don't have to be swapped with every render.
    const listenerRef = (0, _react.useRef)(listener);
    listenerRef.current = listener;
    (0, _react.useEffect)(() => {
      const callback = (...args) => listenerRef.current(...args);
      const subscription = eventEmitter.addListener(eventName, callback);
      return () => subscription.remove();
    }, [eventEmitter, eventName, listenerRef]);
  }
},645,[3],"node_modules\\expo\\src\\hooks\\useEvent.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright  2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NetworkError = exports.ReactServerError = exports.MetroServerError = void 0;
  class MetroServerError extends Error {
    code = 'METRO_SERVER_ERROR';
    constructor(errorObject, url) {
      super(errorObject.message);
      this.url = url;
      this.name = 'MetroServerError';
      for (const key in errorObject) {
        this[key] = errorObject[key];
      }
    }
  }
  exports.MetroServerError = MetroServerError;
  class ReactServerError extends Error {
    code = 'REACT_SERVER_ERROR';
    constructor(message, url, statusCode, /** Response headers from the server. */
    headers) {
      super(message);
      this.url = url;
      this.statusCode = statusCode;
      this.headers = headers;
      this.name = 'ReactServerError';
    }
  }
  exports.ReactServerError = ReactServerError;
  class NetworkError extends Error {
    code = 'NETWORK_ERROR';
    constructor(message, url) {
      super(message);
      this.url = url;
      this.name = 'NetworkError';
    }
  }
  exports.NetworkError = NetworkError;
},646,[],"node_modules\\expo-router\\build\\rsc\\router\\errors.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Protected = void 0;
  exports.isProtectedReactElement = isProtectedReactElement;
  const react_1 = require(_dependencyMap[0], "react");
  const primitives_1 = require(_dependencyMap[1], "../primitives");
  exports.Protected = primitives_1.Group;
  function isProtectedReactElement(child) {
    return Boolean((0, react_1.isValidElement)(child) && child.type === primitives_1.Group && child.props && 'guard' in child.props);
  }
},647,[3,590],"node_modules\\expo-router\\build\\views\\Protected.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Screen = Screen;
  exports.isScreen = isScreen;
  const react_1 = __importStar(require(_dependencyMap[0], "react"));
  const useNavigation_1 = require(_dependencyMap[1], "../useNavigation");
  const useLayoutEffect = typeof window !== 'undefined' ? react_1.default.useLayoutEffect : function () {};
  /** Component for setting the current screen's options dynamically. */
  function Screen({
    name,
    options
  }) {
    const navigation = (0, useNavigation_1.useNavigation)(name);
    useLayoutEffect(() => {
      if (options &&
      // React Navigation will infinitely loop in some cases if an empty object is passed to setOptions.
      // https://github.com/expo/router/issues/452
      Object.keys(options).length) {
        navigation.setOptions(options);
      }
    }, [navigation, options]);
    return null;
  }
  function isScreen(child, contextKey) {
    if ((0, react_1.isValidElement)(child) && child && child.type === Screen) {
      if (typeof child.props === 'object' && child.props && 'name' in child.props && !child.props.name) {
        throw new Error(`<Screen /> component in \`default export\` at \`app${contextKey}/_layout\` must have a \`name\` prop when used as a child of a Layout Route.`);
      }
      if (process.env.NODE_ENV !== 'production') {
        if (['children', 'component', 'getComponent'].some(key => child.props && typeof child.props === 'object' && key in child.props)) {
          throw new Error(`<Screen /> component in \`default export\` at \`app${contextKey}/_layout\` must not have a \`children\`, \`component\`, or \`getComponent\` prop when used as a child of a Layout Route`);
        }
      }
      return true;
    }
    return false;
  }
},648,[3,649],"node_modules\\expo-router\\build\\views\\Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigation = useNavigation;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const constants_1 = require(_dependencyMap[1], "./constants");
  const href_1 = require(_dependencyMap[2], "./link/href");
  /**
   * Returns the underlying React Navigation [`navigation` object](https://reactnavigation.org/docs/navigation-object)
   * to imperatively access layout-specific functionality like `navigation.openDrawer()` in a
   * [Drawer](/router/advanced/drawer/) layout.
   *
   * @example
   * ```tsx app/index.tsx
   * import { useNavigation } from 'expo-router';
   *
   * export default function Route() {
   *   // Access the current navigation object for the current route.
   *   const navigation = useNavigation();
   *
   *   return (
   *     <View>
   *       <Text onPress={() => {
   *         // Open the drawer view.
   *         navigation.openDrawer();
   *       }}>
   *         Open Drawer
   *       </Text>
   *     </View>
   *   );
   * }
   * ```
   *
   * When using nested layouts, you can access higher-order layouts by passing a secondary argument denoting the layout route.
   * For example, `/menu/_layout.tsx` is nested inside `/app/orders/`, you can use `useNavigation('/orders/menu/')`.
   *
   * @example
   * ```tsx app/orders/menu/index.tsx
   * import { useNavigation } from 'expo-router';
   *
   * export default function MenuRoute() {
   *   const rootLayout = useNavigation('/');
   *   const ordersLayout = useNavigation('/orders');
   *
   *   // Same as the default results of `useNavigation()` when invoked in this route.
   *   const parentLayout = useNavigation('/orders/menu');
   * }
   * ```
   *
   * If you attempt to access a layout that doesn't exist, an error such as
   * `Could not find parent navigation with route "/non-existent"` is thrown.
   *
   *
   * @param parent Provide an absolute path such as `/(root)` to the parent route or a relative path like `../../` to the parent route.
   * @returns The navigation object for the current route.
   *
   * @see React Navigation documentation on [navigation dependent functions](https://reactnavigation.org/docs/navigation-object/#navigator-dependent-functions)
   * for more information.
   */
  function useNavigation(parent) {
    let navigation = (0, native_1.useNavigation)();
    let state = (0, native_1.useStateForPath)();
    if (parent === undefined) {
      // If no parent is provided, return the current navigation object
      return navigation;
    }
    // Check for the top-level navigator - we cannot fetch anything higher!
    const currentId = navigation.getId();
    if (currentId === '' || currentId === `/expo-router/build/views/Navigator`) {
      return navigation;
    }
    if (typeof parent === 'object') {
      parent = (0, href_1.resolveHref)(parent);
    }
    if (parent === '/') {
      // This is the root navigator
      return navigation.getParent(`/expo-router/build/views/Navigator`) ?? navigation.getParent(``);
    } else if (parent?.startsWith('../')) {
      const names = [];
      while (state) {
        const route = state.routes[0];
        state = route.state;
        // Don't include the last router, as thats the current route
        if (state) {
          names.push(route.name);
        }
      }
      // Removing the trailing slash to make splitting easier
      const originalParent = parent;
      if (parent.endsWith('/')) {
        parent = parent.slice(0, -1);
      }
      const segments = parent.split('/');
      if (!segments.every(segment => segment === '..')) {
        throw new Error(`Invalid parent path "${originalParent}". Only "../" segments are allowed when using relative paths.`);
      }
      const levels = segments.length;
      const index = names.length - 1 - levels;
      if (index < 0) {
        throw new Error(`Invalid parent path "${originalParent}". Cannot go up ${levels} levels from the current route.`);
      }
      parent = names[index];
      // Expo Router navigators use the context key as the name which has a leading `/`
      // The exception to this is the INTERNAL_SLOT_NAME, and the root navigator which uses ''
      if (parent && parent !== constants_1.INTERNAL_SLOT_NAME) {
        parent = `/${parent}`;
      }
    }
    navigation = navigation.getParent(parent);
    if (process.env.NODE_ENV !== 'production') {
      if (!navigation) {
        const ids = [];
        while (navigation) {
          ids.push(navigation.getId() || '/');
          navigation = navigation.getParent();
        }
        throw new Error(`Could not find parent navigation with route "${parent}". Available routes are: '${ids.join("', '")}'`);
      }
    }
    return navigation;
  }
},649,[350,650,651],"node_modules\\expo-router\\build\\useNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.INTERNAL_SLOT_NAME = void 0;
  exports.INTERNAL_SLOT_NAME = '__root';
},650,[],"node_modules\\expo-router\\build\\constants.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveHref = void 0;
  exports.resolveHrefStringWithSegments = resolveHrefStringWithSegments;
  /** Resolve an href object into a fully qualified, relative href. */
  const resolveHref = href => {
    if (typeof href === 'string') {
      return (0, exports.resolveHref)({
        pathname: href
      });
    }
    const path = href.pathname ?? '';
    if (!href?.params) {
      return path;
    }
    const {
      pathname,
      params
    } = createQualifiedPathname(path, Object.assign({}, href.params));
    const paramsString = createQueryParams(params);
    return pathname + (paramsString ? `?${paramsString}` : '');
  };
  exports.resolveHref = resolveHref;
  function resolveHrefStringWithSegments(href, {
    segments = [],
    params = {}
  } = {}, {
    relativeToDirectory
  } = {}) {
    if (href.startsWith('.')) {
      // Resolve base path by merging the current segments with the params
      let base = segments?.map(segment => {
        if (!segment.startsWith('[')) return segment;
        if (segment.startsWith('[...')) {
          segment = segment.slice(4, -1);
          const param = params[segment];
          if (Array.isArray(param)) {
            return param.join('/');
          } else {
            return param?.split(',')?.join('/') ?? '';
          }
        } else {
          segment = segment.slice(1, -1);
          return params[segment];
        }
      }).filter(Boolean).join('/') ?? '/';
      if (relativeToDirectory) {
        base = `${base}/`;
      }
      const url = new URL(href, `http://hostname/${base}`);
      href = `${url.pathname}${url.search}`;
    }
    return href;
  }
  function createQualifiedPathname(pathname, params) {
    for (const [key, value = ''] of Object.entries(params)) {
      const dynamicKey = `[${key}]`;
      const deepDynamicKey = `[...${key}]`;
      if (pathname.includes(dynamicKey)) {
        pathname = pathname.replace(dynamicKey, encodeParam(value));
      } else if (pathname.includes(deepDynamicKey)) {
        pathname = pathname.replace(deepDynamicKey, encodeParam(value));
      } else {
        continue;
      }
      delete params[key];
    }
    return {
      pathname,
      params
    };
  }
  function encodeParam(param) {
    if (Array.isArray(param)) {
      return param.map(p => encodeParam(p)).join('/');
    }
    return encodeURIComponent(param.toString());
  }
  function createQueryParams(params) {
    return Object.entries(params)
    // Allow nullish params
    .filter(([, value]) => value != null).map(([key, value]) => `${key}=${encodeURIComponent(value.toString())}`).join('&');
  }
},651,[],"node_modules\\expo-router\\build\\link\\href.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tabs = void 0;
  const TabsClient_1 = __importDefault(require(_dependencyMap[0], "./TabsClient"));
  exports.Tabs = TabsClient_1.default;
  const Screen_1 = require(_dependencyMap[1], "../views/Screen");
  TabsClient_1.default.Screen = Screen_1.Screen;
  exports.default = TabsClient_1.default;
},652,[653,648],"node_modules\\expo-router\\build\\layouts\\Tabs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\layouts\\TabsClient.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const bottom_tabs_1 = require(_dependencyMap[2], "@react-navigation/bottom-tabs");
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const withLayoutContext_1 = require(_dependencyMap[5], "./withLayoutContext");
  const Link_1 = require(_dependencyMap[6], "../link/Link");
  const TabRouter_1 = require(_dependencyMap[7], "./TabRouter");
  const Protected_1 = require(_dependencyMap[8], "../views/Protected");
  // This is the only way to access the navigator.
  const BottomTabNavigator = (0, bottom_tabs_1.createBottomTabNavigator)().Navigator;
  const ExpoTabs = (0, withLayoutContext_1.withLayoutContext)(BottomTabNavigator, screens => {
    // Support the `href` shortcut prop.
    return screens.map(screen => {
      if (typeof screen.options !== 'function' && screen.options?.href !== undefined) {
        const _screen$options = screen.options,
          {
            href
          } = _screen$options,
          options = _objectWithoutPropertiesLoose(_screen$options, _excluded);
        if (options.tabBarButton) {
          throw new Error('Cannot use `href` and `tabBarButton` together.');
        }
        return Object.assign({}, screen, {
          options: Object.assign({}, options, {
            tabBarItemStyle: href == null ? {
              display: 'none'
            } : options.tabBarItemStyle,
            // @ts-expect-error: TODO(@kitten): This isn't properly typed
            tabBarButton: props => {
              if (href == null) {
                return null;
              }
              const children = react_native_1.Platform.OS === 'web' ? props.children : _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Pressable, {
                children: props.children
              });
              // TODO: React Navigation types these props as Animated.WithAnimatedValue<StyleProp<ViewStyle>>
              //       While Link expects a TextStyle. We need to reconcile these types.
              return _reactNativeCssInteropJsxRuntime.jsx(Link_1.Link, Object.assign({}, props, {
                style: [{
                  display: 'flex'
                }, props.style],
                href: href,
                asChild: react_native_1.Platform.OS !== 'web',
                children: children
              }));
            }
          })
        });
      }
      return screen;
    });
  });
  const Tabs = Object.assign(props => {
    return _reactNativeCssInteropJsxRuntime.jsx(ExpoTabs, Object.assign({}, props, {
      UNSTABLE_router: TabRouter_1.tabRouterOverride
    }));
  }, {
    Screen: ExpoTabs.Screen,
    Protected: Protected_1.Protected
  });
  exports.default = Tabs;
},653,[2,29,593,3,16,583,654,713,647],"node_modules\\expo-router\\build\\layouts\\TabsClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href", "replace", "push", "dismissTo", "relativeToDirectory", "asChild", "rel", "target", "download", "withAnchor", "dangerouslySingular", "prefetch"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\link\\Link.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Link = void 0;
  exports.Redirect = Redirect;
  // Fork of @react-navigation/native Link.tsx with `href` and `replace` support added and
  // `to` / `action` support removed.
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const href_1 = require(_dependencyMap[4], "./href");
  const useLinkToPathProps_1 = __importDefault(require(_dependencyMap[5], "./useLinkToPathProps"));
  const hooks_1 = require(_dependencyMap[6], "../hooks");
  const useFocusEffect_1 = require(_dependencyMap[7], "../useFocusEffect");
  const useLinkHooks_1 = require(_dependencyMap[8], "./useLinkHooks");
  const Prefetch_1 = require(_dependencyMap[9], "../Prefetch");
  const Slot_1 = require(_dependencyMap[10], "../ui/Slot");
  /**
   * Redirects to the `href` as soon as the component is mounted.
   *
   * @example
   * ```tsx
   * import { View, Text } from 'react-native';
   * import { Redirect } from 'expo-router';
   *
   * export default function Page() {
   *  const { user } = useAuth();
   *
   *  if (!user) {
   *    return <Redirect href="/login" />;
   *  }
   *
   *  return (
   *    <View>
   *      <Text>Welcome Back!</Text>
   *    </View>
   *  );
   * }
   * ```
   */
  function Redirect({
    href,
    relativeToDirectory,
    withAnchor
  }) {
    const router = (0, hooks_1.useRouter)();
    (0, useFocusEffect_1.useFocusEffect)(() => {
      try {
        router.replace(href, {
          relativeToDirectory,
          withAnchor
        });
      } catch (error) {
        console.error(error);
      }
    });
    return null;
  }
  /**
   * Component that renders a link using [`href`](#href) to another route.
   * By default, it accepts children and wraps them in a `<Text>` component.
   *
   * Uses an anchor tag (`<a>`) on web and performs a client-side navigation to preserve
   * the state of the website and navigate faster. The web-only attributes such as `target`,
   * `rel`, and `download` are supported and passed to the anchor tag on web. See
   * [`WebAnchorProps`](#webanchorprops) for more details.
   *
   * > **Note**: Client-side navigation works with both single-page apps,
   * and [static-rendering](/router/reference/static-rendering/).
   *
   * @example
   * ```tsx
   * import { Link } from 'expo-router';
   * import { View } from 'react-native';
   *
   * export default function Route() {
   *  return (
   *   <View>
   *    <Link href="/about">About</Link>
   *   </View>
   *  );
   *}
   * ```
   */
  exports.Link = (0, react_1.forwardRef)(ExpoRouterLink);
  exports.Link.resolveHref = href_1.resolveHref;
  function ExpoRouterLink(_ref, ref) {
    let {
        href,
        replace,
        push,
        dismissTo,
        // TODO: This does not prevent default on the anchor tag.
        relativeToDirectory,
        asChild,
        rel,
        target,
        download,
        withAnchor,
        dangerouslySingular: singular,
        prefetch
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    // Mutate the style prop to add the className on web.
    const style = (0, useLinkHooks_1.useInteropClassName)(rest);
    // If not passing asChild, we need to forward the props to the anchor tag using React Native Web's `hrefAttrs`.
    const hrefAttrs = (0, useLinkHooks_1.useHrefAttrs)({
      asChild,
      rel,
      target,
      download
    });
    const resolvedHref = (0, react_1.useMemo)(() => {
      if (href == null) {
        throw new Error('Link: href is required');
      }
      return (0, href_1.resolveHref)(href);
    }, [href]);
    let event;
    if (push) event = 'PUSH';
    if (replace) event = 'REPLACE';
    if (dismissTo) event = 'POP_TO';
    const props = (0, useLinkToPathProps_1.default)({
      href: resolvedHref,
      event,
      relativeToDirectory,
      withAnchor,
      dangerouslySingular: singular
    });
    const onPress = e => {
      if ('onPress' in rest) {
        rest.onPress?.(e);
      }
      props.onPress(e);
    };
    const Component = asChild ? Slot_1.Slot : react_native_1.Text;
    // Avoid using createElement directly, favoring JSX, to allow tools like NativeWind to perform custom JSX handling on native.
    const element = _reactNativeCssInteropJsxRuntime.jsx(Component, Object.assign({
      ref: ref
    }, props, hrefAttrs, rest, {
      style: style
    }, react_native_1.Platform.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress
      }
    })));
    return prefetch ? _reactNativeCssInteropJsxRuntime.jsxs(_reactNativeCssInteropJsxRuntime.Fragment, {
      children: [_reactNativeCssInteropJsxRuntime.jsx(Prefetch_1.Prefetch, {
        href: href
      }), element]
    }) : element;
  }
},654,[2,29,3,16,651,655,680,706,708,709,710],"node_modules\\expo-router\\build\\link\\Link.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href"];
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinkToPathProps;
  exports.shouldHandleMouseEvent = shouldHandleMouseEvent;
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const emitDomEvent_1 = require(_dependencyMap[2], "../domComponents/emitDomEvent");
  const getPathFromState_forks_1 = require(_dependencyMap[3], "../fork/getPathFromState-forks");
  const routing_1 = require(_dependencyMap[4], "../global-state/routing");
  const matchers_1 = require(_dependencyMap[5], "../matchers");
  const url_1 = require(_dependencyMap[6], "../utils/url");
  function eventShouldPreventDefault(e) {
    if (e?.defaultPrevented) {
      return false;
    }
    if (
    // Only check MouseEvents
    'button' in e &&
    // ignore clicks with modifier keys
    !e.metaKey && !e.altKey && !e.ctrlKey && !e.shiftKey && (e.button == null || e.button === 0) &&
    // Only accept left clicks
    [undefined, null, '', 'self'].includes(e.currentTarget.target) // let browser handle "target=_blank" etc.
    ) {
      return true;
    }
    return false;
  }
  function useLinkToPathProps(_ref) {
    let {
        href
      } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);
    const onPress = event => {
      if (shouldHandleMouseEvent(event)) {
        if ((0, emitDomEvent_1.emitDomLinkEvent)(href, options)) {
          return;
        }
        (0, routing_1.linkTo)(href, options);
      }
    };
    let strippedHref = (0, matchers_1.stripGroupSegmentsFromPath)(href) || '/';
    // Append base url only if needed.
    if (!(0, url_1.shouldLinkExternally)(strippedHref)) {
      strippedHref = (0, getPathFromState_forks_1.appendBaseUrl)(strippedHref);
    }
    return {
      href: strippedHref,
      role: 'link',
      onPress
    };
  }
  function shouldHandleMouseEvent(event) {
    if (react_native_1.Platform.OS !== 'web') {
      return !event?.defaultPrevented;
    }
    if (event && eventShouldPreventDefault(event)) {
      event.preventDefault();
      return true;
    }
    return false;
  }
},655,[29,16,656,658,659,585,691],"node_modules\\expo-router\\build\\link\\useLinkToPathProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.emitDomSetParams = emitDomSetParams;
  exports.emitDomDismiss = emitDomDismiss;
  exports.emitDomGoBack = emitDomGoBack;
  exports.emitDomDismissAll = emitDomDismissAll;
  exports.emitDomLinkEvent = emitDomLinkEvent;
  const events_1 = require(_dependencyMap[0], "./events");
  function emitDomEvent(type, data = {}) {
    // @ts-expect-error: ReactNativeWebView is a global variable injected by the WebView
    if (typeof ReactNativeWebView !== 'undefined') {
      window.ReactNativeWebView.postMessage(JSON.stringify({
        type,
        data
      }));
      return true;
    }
    return false;
  }
  function emitDomSetParams(params = {}) {
    return emitDomEvent(events_1.ROUTER_SET_PARAMS_TYPE, {
      params
    });
  }
  function emitDomDismiss(count) {
    return emitDomEvent(events_1.ROUTER_DISMISS_TYPE, {
      count
    });
  }
  function emitDomGoBack() {
    return emitDomEvent(events_1.ROUTER_BACK_TYPE);
  }
  function emitDomDismissAll() {
    return emitDomEvent(events_1.ROUTER_DISMISS_ALL_TYPE);
  }
  function emitDomLinkEvent(href, options) {
    return emitDomEvent(events_1.ROUTER_LINK_TYPE, {
      href,
      options
    });
  }
},656,[657],"node_modules\\expo-router\\build\\domComponents\\emitDomEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ROUTER_SET_PARAMS_TYPE = exports.ROUTER_BACK_TYPE = exports.ROUTER_DISMISS_TYPE = exports.ROUTER_DISMISS_ALL_TYPE = exports.ROUTER_LINK_TYPE = void 0;
  exports.ROUTER_LINK_TYPE = '$$router_link';
  exports.ROUTER_DISMISS_ALL_TYPE = '$$router_dismissAll';
  exports.ROUTER_DISMISS_TYPE = '$$router_dismiss';
  exports.ROUTER_BACK_TYPE = '$$router_goBack';
  exports.ROUTER_SET_PARAMS_TYPE = '$$router_setParams';
},657,[],"node_modules\\expo-router\\build\\domComponents\\events.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["preserveDynamicRoutes", "preserveGroups", "shouldEncodeURISegment"],
    _excluded2 = ["#"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getParamName = void 0;
  exports.validatePathConfig = validatePathConfig;
  exports.fixCurrentParams = fixCurrentParams;
  exports.appendQueryAndHash = appendQueryAndHash;
  exports.appendBaseUrl = appendBaseUrl;
  exports.getPathWithConventionsCollapsed = getPathWithConventionsCollapsed;
  exports.isDynamicPart = isDynamicPart;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const queryString = __importStar(require(_dependencyMap[2], "query-string"));
  const matchers_1 = require(_dependencyMap[3], "../matchers");
  function validatePathConfig(_ref) {
    let options = _objectWithoutPropertiesLoose(_ref, _excluded);
    (0, native_1.validatePathConfig)(options);
  }
  function fixCurrentParams(allParams, route, stringify) {
    // Better handle array params
    const currentParams = Object.fromEntries(Object.entries(route.params).flatMap(([key, value]) => {
      if (key === 'screen' || key === 'params') {
        return [];
      }
      return [[key, stringify?.[key] ? stringify[key](value) : Array.isArray(value) ? value.map(String) : String(value)]];
    }));
    // We always assign params, as non pattern routes may still have query params
    Object.assign(allParams, currentParams);
    return currentParams;
  }
  function appendQueryAndHash(path, _ref2) {
    let {
        '#': hash
      } = _ref2,
      focusedParams = _objectWithoutPropertiesLoose(_ref2, _excluded2);
    const query = queryString.stringify(focusedParams, {
      sort: false
    });
    if (query) {
      path += `?${query}`;
    }
    if (hash) {
      path += `#${hash}`;
    }
    return path;
  }
  function appendBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return `/${baseUrl.replace(/^\/+/, '').replace(/\/$/, '')}${path}`;
      }
    }
    return path;
  }
  function getPathWithConventionsCollapsed({
    pattern,
    route,
    params,
    preserveGroups,
    preserveDynamicRoutes,
    shouldEncodeURISegment = true,
    initialRouteName
  }) {
    const segments = pattern.split('/');
    return segments.map((p, i) => {
      const name = (0, exports.getParamName)(p);
      // Showing the route name seems ok, though whatever we show here will be incorrect
      // Since the page doesn't actually exist
      if (p.startsWith('*')) {
        if (preserveDynamicRoutes) {
          if (name === 'not-found') {
            return '+not-found';
          }
          return `[...${name}]`;
        } else if (params[name]) {
          if (Array.isArray(params[name])) {
            return params[name].join('/');
          }
          return params[name];
        } else if (route.name.startsWith('[') && route.name.endsWith(']')) {
          return '';
        } else if (p === '*not-found') {
          return '';
        } else {
          return route.name;
        }
      }
      // If the path has a pattern for a param, put the param in the path
      if (p.startsWith(':')) {
        if (preserveDynamicRoutes) {
          return `[${name}]`;
        }
        // Optional params without value assigned in route.params should be ignored
        const value = params[name];
        if (value === undefined && p.endsWith('?')) {
          return;
        }
        return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';
      }
      if (!preserveGroups && (0, matchers_1.matchGroupName)(p) != null) {
        // When the last part is a group it could be a shared URL
        // if the route has an initialRouteName defined, then we should
        // use that as the component path as we can assume it will be shown.
        if (segments.length - 1 === i) {
          if (initialRouteName) {
            // Return an empty string if the init route is ambiguous.
            if (segmentMatchesConvention(initialRouteName)) {
              return '';
            }
            return shouldEncodeURISegment ? encodeURISegment(initialRouteName, {
              preserveBrackets: true
            }) : initialRouteName;
          }
        }
        return '';
      }
      // Preserve dynamic syntax for rehydration
      return shouldEncodeURISegment ? encodeURISegment(p, {
        preserveBrackets: true
      }) : p;
    }).map(v => v ?? '').join('/');
  }
  const getParamName = pattern => pattern.replace(/^[:*]/, '').replace(/\?$/, '');
  exports.getParamName = getParamName;
  function isDynamicPart(p) {
    return p.startsWith(':') || p.startsWith('*');
  }
  function segmentMatchesConvention(segment) {
    return segment === 'index' || (0, matchers_1.matchGroupName)(segment) != null || (0, matchers_1.matchDynamicName)(segment) != null;
  }
  function encodeURISegment(str, {
    preserveBrackets = false
  } = {}) {
    // Valid characters according to
    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
    str = String(str).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));
    if (preserveBrackets) {
      // Preserve brackets
      str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');
    }
    return str;
  }
},658,[29,350,394,585],"node_modules\\expo-router\\build\\fork\\getPathFromState-forks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.routingQueue = void 0;
  exports.navigate = navigate;
  exports.reload = reload;
  exports.prefetch = prefetch;
  exports.push = push;
  exports.dismiss = dismiss;
  exports.dismissTo = dismissTo;
  exports.replace = replace;
  exports.dismissAll = dismissAll;
  exports.goBack = goBack;
  exports.canGoBack = canGoBack;
  exports.canDismiss = canDismiss;
  exports.setParams = setParams;
  exports.linkTo = linkTo;
  const dom_1 = require(_dependencyMap[0], "expo/dom");
  const Linking = __importStar(require(_dependencyMap[1], "expo-linking"));
  const react_native_1 = require(_dependencyMap[2], "react-native-web/dist/index");
  const router_store_1 = require(_dependencyMap[3], "./router-store");
  const emitDomEvent_1 = require(_dependencyMap[4], "../domComponents/emitDomEvent");
  const getRoutesRedirects_1 = require(_dependencyMap[5], "../getRoutesRedirects");
  const href_1 = require(_dependencyMap[6], "../link/href");
  const matchers_1 = require(_dependencyMap[7], "../matchers");
  const url_1 = require(_dependencyMap[8], "../utils/url");
  function assertIsReady() {
    if (!router_store_1.store.navigationRef.isReady()) {
      throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');
    }
  }
  exports.routingQueue = {
    queue: [],
    subscribers: new Set(),
    subscribe(callback) {
      exports.routingQueue.subscribers.add(callback);
      return () => {
        exports.routingQueue.subscribers.delete(callback);
      };
    },
    snapshot() {
      return exports.routingQueue.queue;
    },
    add(action) {
      // Reset the identity of the queue.
      if (exports.routingQueue.queue.length === 0) {
        exports.routingQueue.queue = [];
      }
      exports.routingQueue.queue.push(action);
      for (const callback of exports.routingQueue.subscribers) {
        callback();
      }
    },
    run() {
      const queue = exports.routingQueue.queue;
      if (queue.length === 0 || !router_store_1.store.navigationRef) {
        return;
      }
      exports.routingQueue.queue = [];
      for (const action of queue) {
        router_store_1.store.navigationRef.dispatch(action);
      }
    }
  };
  function navigate(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'NAVIGATE'
    }));
  }
  function reload() {
    // TODO(EvanBacon): add `reload` support.
    throw new Error('The reload method is not implemented in the client-side router yet.');
  }
  function prefetch(href, options) {
    return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {
      event: 'PRELOAD'
    }));
  }
  function push(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'PUSH'
    }));
  }
  function dismiss(count = 1) {
    if ((0, emitDomEvent_1.emitDomDismiss)(count)) {
      return;
    }
    exports.routingQueue.add({
      type: 'POP',
      payload: {
        count
      }
    });
  }
  function dismissTo(href, options) {
    return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {
      event: 'POP_TO'
    }));
  }
  function replace(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'REPLACE'
    }));
  }
  function dismissAll() {
    if ((0, emitDomEvent_1.emitDomDismissAll)()) {
      return;
    }
    exports.routingQueue.add({
      type: 'POP_TO_TOP'
    });
  }
  function goBack() {
    if ((0, emitDomEvent_1.emitDomGoBack)()) {
      return;
    }
    assertIsReady();
    exports.routingQueue.add({
      type: 'GO_BACK'
    });
  }
  function canGoBack() {
    if (dom_1.IS_DOM) {
      throw new Error('canGoBack imperative method is not supported. Pass the property to the DOM component instead.');
    }
    // Return a default value here if the navigation hasn't mounted yet.
    // This can happen if the user calls `canGoBack` from the Root Layout route
    // before mounting a navigator. This behavior exists due to React Navigation being dynamically
    // constructed at runtime. We can get rid of this in the future if we use
    // the static configuration internally.
    if (!router_store_1.store.navigationRef.isReady()) {
      return false;
    }
    return router_store_1.store.navigationRef?.current?.canGoBack() ?? false;
  }
  function canDismiss() {
    if (dom_1.IS_DOM) {
      throw new Error('canDismiss imperative method is not supported. Pass the property to the DOM component instead.');
    }
    let state = router_store_1.store.state;
    // Keep traversing down the state tree until we find a stack navigator that we can pop
    while (state) {
      if (state.type === 'stack' && state.routes.length > 1) {
        return true;
      }
      if (state.index === undefined) return false;
      state = state.routes?.[state.index]?.state;
    }
    return false;
  }
  function setParams(params = {}) {
    if ((0, emitDomEvent_1.emitDomSetParams)(params)) {
      return;
    }
    assertIsReady();
    return (router_store_1.store.navigationRef?.current?.setParams)(params);
  }
  function linkTo(originalHref, options = {}) {
    originalHref = typeof originalHref == 'string' ? originalHref : (0, href_1.resolveHref)(originalHref);
    let href = originalHref;
    if ((0, emitDomEvent_1.emitDomLinkEvent)(href, options)) {
      return;
    }
    if ((0, url_1.shouldLinkExternally)(href)) {
      if (href.startsWith('//') && react_native_1.Platform.OS !== 'web') {
        href = `https:${href}`;
      }
      Linking.openURL(href);
      return;
    }
    assertIsReady();
    const navigationRef = router_store_1.store.navigationRef.current;
    if (navigationRef == null) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    if (!router_store_1.store.linking) {
      throw new Error('Attempted to link to route when no routes are present');
    }
    if (href === '..' || href === '../') {
      navigationRef.goBack();
      return;
    }
    const rootState = navigationRef.getRootState();
    href = (0, href_1.resolveHrefStringWithSegments)(href, router_store_1.store.getRouteInfo(), options);
    href = (0, getRoutesRedirects_1.applyRedirects)(href, router_store_1.store.redirects);
    // If the href is undefined, it means that the redirect has already been handled the navigation
    if (!href) {
      return;
    }
    const state = router_store_1.store.linking.getStateFromPath(href, router_store_1.store.linking.config);
    if (!state || state.routes.length === 0) {
      console.error('Could not generate a valid navigation state for the given path: ' + href);
      return;
    }
    exports.routingQueue.add(getNavigateAction(state, rootState, options.event, options.withAnchor, options.dangerouslySingular));
  }
  function getNavigateAction(actionState, navigationState, type = 'NAVIGATE', withAnchor, singular) {
    /**
     * We need to find the deepest navigator where the action and current state diverge, If they do not diverge, the
     * lowest navigator is the target.
     *
     * By default React Navigation will target the current navigator, but this doesn't work for all actions
     * For example:
     *  - /deeply/nested/route -> /top-level-route the target needs to be the top-level navigator
     *  - /stack/nestedStack/page -> /stack1/nestedStack/other-page needs to target the nestedStack navigator
     *
     * This matching needs to done by comparing the route names and the dynamic path, for example
     * - /1/page -> /2/anotherPage needs to target the /[id] navigator
     *
     * Other parameters such as search params and hash are not evaluated.
     */
    let actionStateRoute;
    // Traverse the state tree comparing the current state and the action state until we find where they diverge
    while (actionState && navigationState) {
      const stateRoute = navigationState.routes[navigationState.index];
      actionStateRoute = actionState.routes[actionState.routes.length - 1];
      const childState = actionStateRoute.state;
      const nextNavigationState = stateRoute.state;
      const dynamicName = (0, matchers_1.matchDynamicName)(actionStateRoute.name);
      const didActionAndCurrentStateDiverge = actionStateRoute.name !== stateRoute.name || !childState || !nextNavigationState || dynamicName &&
      // @ts-expect-error: TODO(@kitten): This isn't properly typed, so the index access fails
      actionStateRoute.params?.[dynamicName.name] !== stateRoute.params?.[dynamicName.name];
      if (didActionAndCurrentStateDiverge) {
        break;
      }
      actionState = childState;
      navigationState = nextNavigationState;
    }
    /*
     * We found the target navigator, but the payload is in the incorrect format
     * We need to convert the action state to a payload that can be dispatched
     */
    const rootPayload = {
      params: {}
    };
    let payload = rootPayload;
    let params = payload.params;
    // The root level of payload is a bit weird, its params are in the child object
    while (actionStateRoute) {
      Object.assign(params, Object.assign({}, payload.params, actionStateRoute.params));
      // Assign the screen name to the payload
      payload.screen = actionStateRoute.name;
      // Merge the params, ensuring that we create a new object
      payload.params = Object.assign({}, params);
      // Params don't include the screen, thats a separate attribute
      delete payload.params['screen'];
      // Continue down the payload tree
      // Initially these values are separate, but React Nav merges them after the first layer
      payload = payload.params;
      params = payload;
      actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];
    }
    if (type === 'PUSH' && navigationState.type !== 'stack') {
      type = 'NAVIGATE';
    } else if (navigationState.type === 'expo-tab') {
      type = 'JUMP_TO';
    } else if (type === 'REPLACE' && navigationState.type === 'drawer') {
      type = 'JUMP_TO';
    }
    if (withAnchor !== undefined) {
      if (rootPayload.params.initial) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);
        }
      }
      /*
       * The logic for initial can seen backwards depending on your perspective
       *   True: The initialRouteName is not loaded. The incoming screen is the initial screen (default)
       *   False: The initialRouteName is loaded. THe incoming screen is placed after the initialRouteName
       *
       * withAnchor flips the perspective.
       *   True: You want the initialRouteName to load.
       *   False: You do not want the initialRouteName to load.
       */
      rootPayload.params.initial = !withAnchor;
    }
    return {
      type,
      target: navigationState.key,
      payload: {
        // key: rootPayload.key,
        name: rootPayload.screen,
        params: rootPayload.params,
        singular
      }
    };
  }
},659,[660,664,16,671,656,679,651,585,691],"node_modules\\expo-router\\build\\global-state\\routing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _dom = require(_dependencyMap[0], "../src/dom/dom");
  Object.keys(_dom).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _dom[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _dom[key];
      }
    });
  });
},660,[661],"node_modules\\expo\\dom\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    IS_DOM: true
  };
  exports.IS_DOM = void 0;
  var _domHooks = require(_dependencyMap[0], "./dom-hooks");
  Object.keys(_domHooks).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _domHooks[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _domHooks[key];
      }
    });
  });
  // TODO: Maybe this could be a bundler global instead.
  const IS_DOM = exports.IS_DOM =
  // @ts-expect-error: Added via react-native-webview
  typeof ReactNativeWebView !== 'undefined';
},661,[662],"node_modules\\expo\\src\\dom\\dom.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDOMImperativeHandle = useDOMImperativeHandle;
  var _react = require(_dependencyMap[0], "react");
  var _injection = require(_dependencyMap[1], "./injection");
  /**
   * A React `useImperativeHandle` like hook for DOM components.
   *
   */
  function useDOMImperativeHandle(ref, init, deps) {
    // @ts-expect-error: Added via react-native-webview
    const isTargetWeb = typeof window.ReactNativeWebView === 'undefined';
    const stubHandlerFactory = (0, _react.useCallback)(() => ({}), deps ?? []);

    // This standard useImperativeHandle hook is serving for web
    (0, _react.useImperativeHandle)(ref, isTargetWeb ? init : stubHandlerFactory, deps);

    // This `globalThis._domRefProxy` is serving for native
    (0, _react.useEffect)(() => {
      if (!isTargetWeb) {
        globalThis._domRefProxy = init();
        // TODO(@kitten): Type `ReactNativeWebView` and the message data
        // @ts-expect-error: Added via react-native-webview
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: _injection.REGISTER_DOM_IMPERATIVE_HANDLE_PROPS,
          data: Object.keys(globalThis._domRefProxy)
        }));
      }
      return () => {
        if (!isTargetWeb) {
          globalThis._domRefProxy = undefined;
        }
      };
    }, deps);
  }
},662,[3,663],"node_modules\\expo\\src\\dom\\dom-hooks.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.REGISTER_DOM_IMPERATIVE_HANDLE_PROPS = exports.NATIVE_ACTION_RESULT = exports.NATIVE_ACTION = exports.MATCH_CONTENTS_EVENT = exports.DOM_EVENT = void 0;
  exports.getInjectBodySizeObserverScript = getInjectBodySizeObserverScript;
  exports.getInjectEventScript = void 0;
  const NATIVE_ACTION = exports.NATIVE_ACTION = '$$native_action';
  const NATIVE_ACTION_RESULT = exports.NATIVE_ACTION_RESULT = '$$native_action_result';
  const DOM_EVENT = exports.DOM_EVENT = '$$dom_event';
  const MATCH_CONTENTS_EVENT = exports.MATCH_CONTENTS_EVENT = '$$match_contents_event';
  const REGISTER_DOM_IMPERATIVE_HANDLE_PROPS = exports.REGISTER_DOM_IMPERATIVE_HANDLE_PROPS = '$$register_dom_imperative_handle_props';
  const getInjectEventScript = detail => {
    return `;(function() {
  try {
  window.dispatchEvent(new CustomEvent("${DOM_EVENT}",${JSON.stringify({
      detail
    })}));
  } catch (e) {}
  })();
  true;`;
  };
  exports.getInjectEventScript = getInjectEventScript;
  function getInjectBodySizeObserverScript() {
    return `;(function observeDocumentBodySize() {
  window.addEventListener('DOMContentLoaded', () => {
    new ResizeObserver(entries => {
      const { width, height } = entries[0].contentRect;
      window.ReactNativeWebView?.postMessage(JSON.stringify({
        type: '${MATCH_CONTENTS_EVENT}',
        data: {
          width,
          height,
        },
      }));
    })
    .observe(document.body);
    window.ReactNativeWebView?.postMessage(JSON.stringify({
      type: '${MATCH_CONTENTS_EVENT}',
      data: {
        width: document.body.clientWidth,
        height: document.body.clientHeight,
      },
    }));
  });
  })();
  true;`;
  }
},663,[],"node_modules\\expo\\src\\dom\\injection.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    addEventListener: true,
    parseInitialURLAsync: true,
    sendIntent: true,
    openSettings: true,
    getInitialURL: true,
    getLinkingURL: true,
    openURL: true,
    canOpenURL: true,
    useURL: true,
    useLinkingURL: true,
    parse: true,
    createURL: true
  };
  exports.addEventListener = addEventListener;
  exports.canOpenURL = canOpenURL;
  Object.defineProperty(exports, "createURL", {
    enumerable: true,
    get: function () {
      return _createURL.createURL;
    }
  });
  exports.getInitialURL = getInitialURL;
  exports.getLinkingURL = getLinkingURL;
  exports.openSettings = openSettings;
  exports.openURL = openURL;
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return _createURL.parse;
    }
  });
  exports.parseInitialURLAsync = parseInitialURLAsync;
  exports.sendIntent = sendIntent;
  exports.useLinkingURL = useLinkingURL;
  exports.useURL = useURL;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _react = require(_dependencyMap[2], "react");
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _ExpoLinking = _interopRequireDefault(require(_dependencyMap[4], "./ExpoLinking"));
  var _RNLinking = _interopRequireDefault(require(_dependencyMap[5], "./RNLinking"));
  var _createURL = require(_dependencyMap[6], "./createURL");
  var _validateURL = require(_dependencyMap[7], "./validateURL");
  var _Linking = require(_dependencyMap[8], "./Linking.types");
  Object.keys(_Linking).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Linking[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Linking[key];
      }
    });
  });
  var _Schemes = require(_dependencyMap[9], "./Schemes");
  Object.keys(_Schemes).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Schemes[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Schemes[key];
      }
    });
  });
  // @needsAudit
  /**
   * Add a handler to `Linking` changes by listening to the `url` event type and providing the handler.
   * It is recommended to use the [`useURL()`](#useurl) hook instead.
   * @param type The only valid type is `'url'`.
   * @param handler An [`URLListener`](#urllistener) function that takes an `event` object of the type
   * [`EventType`](#eventtype).
   * @return An EmitterSubscription that has the remove method from EventSubscription
   * @see [React Native documentation on Linking](https://reactnative.dev/docs/linking#addeventlistener).
   */
  function addEventListener(type, handler) {
    return _RNLinking.default.addEventListener(type, handler);
  }
  // @needsAudit
  /**
   * Helper method which wraps React Native's `Linking.getInitialURL()` in `Linking.parse()`.
   * Parses the deep link information out of the URL used to open the experience initially.
   * If no link opened the app, all the fields will be `null`.
   * > On the web it parses the current window URL.
   * @return A promise that resolves with `ParsedURL` object.
   */
  async function parseInitialURLAsync() {
    const initialUrl = await _RNLinking.default.getInitialURL();
    if (!initialUrl) {
      return {
        scheme: null,
        hostname: null,
        path: null,
        queryParams: null
      };
    }
    return (0, _createURL.parse)(initialUrl);
  }
  // @needsAudit
  /**
   * Launch an Android intent with extras.
   * > Use [`expo-intent-launcher`](./intent-launcher) instead. `sendIntent` is only included in
   * > `Linking` for API compatibility with React Native's Linking API.
   * @platform android
   */
  async function sendIntent(action, extras) {
    if (_Platform.default.OS === 'android') {
      return await _RNLinking.default.sendIntent(action, extras);
    }
    throw new _expoModulesCore.UnavailabilityError('Linking', 'sendIntent');
  }
  // @needsAudit
  /**
   * Open the operating system settings app and displays the apps custom settings, if it has any.
   */
  async function openSettings() {
    if (_Platform.default.OS === 'web') {
      throw new _expoModulesCore.UnavailabilityError('Linking', 'openSettings');
    }
    if (_RNLinking.default.openSettings) {
      return await _RNLinking.default.openSettings();
    }
    await openURL('app-settings:');
  }
  // @needsAudit
  /**
   * Get the URL that was used to launch the app if it was launched by a link.
   * @return The URL string that launched your app, or `null`.
   */
  async function getInitialURL() {
    return (await _RNLinking.default.getInitialURL()) ?? null;
  }
  /**
   * Get the URL that was used to launch the app if it was launched by a link.
   * @return The URL string that launched your app, or `null`.
   */
  function getLinkingURL() {
    return _ExpoLinking.default.getLinkingURL();
  }
  // @needsAudit
  /**
   * Attempt to open the given URL with an installed app. See the [Linking guide](/guides/linking)
   * for more information.
   * @param url A URL for the operating system to open. For example: `tel:5555555`, `exp://`.
   * @return A `Promise` that is fulfilled with `true` if the link is opened operating system
   * automatically or the user confirms the prompt to open the link. The `Promise` rejects if there
   * are no applications registered for the URL or the user cancels the dialog.
   */
  async function openURL(url) {
    (0, _validateURL.validateURL)(url);
    return await _RNLinking.default.openURL(url);
  }
  // @needsAudit
  /**
   * Determine whether or not an installed app can handle a given URL.
   * On web this always returns `true` because there is no API for detecting what URLs can be opened.
   * @param url The URL that you want to test can be opened.
   * @return A `Promise` object that is fulfilled with `true` if the URL can be handled, otherwise it
   * `false` if not.
   * The `Promise` will reject on Android if it was impossible to check if the URL can be opened, and
   * on iOS if you didn't [add the specific scheme in the `LSApplicationQueriesSchemes` key inside **Info.plist**](/guides/linking#linking-from-your-app).
   */
  async function canOpenURL(url) {
    (0, _validateURL.validateURL)(url);
    return await _RNLinking.default.canOpenURL(url);
  }
  // @needsAudit
  /**
   * Returns the initial URL followed by any subsequent changes to the URL.
   * @return Returns the initial URL or `null`.
   */
  function useURL() {
    const [url, setLink] = (0, _react.useState)(null);
    function onChange(event) {
      setLink(event.url);
    }
    (0, _react.useEffect)(() => {
      getInitialURL().then(url => setLink(url));
      const subscription = addEventListener('url', onChange);
      return () => subscription.remove();
    }, []);
    return url;
  }
  /**
   * Returns the linking URL followed by any subsequent changes to the URL.
   * Always returns the initial URL immediately on reload.
   * @return Returns the initial URL or `null`.
   */
  function useLinkingURL() {
    const [url, setLink] = (0, _react.useState)(_ExpoLinking.default.getLinkingURL);
    function onChange(event) {
      setLink(event.url);
    }
    (0, _react.useEffect)(() => {
      const subscription = _ExpoLinking.default.addListener('onURLReceived', onChange);
      return () => subscription.remove();
    }, []);
    return url ?? null;
  }
},664,[17,473,3,106,665,666,667,668,669,670],"node_modules\\expo-linking\\build\\Linking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "invariant"));
  var _default = exports.default = {
    addListener(eventName, listener) {
      (0, _invariant.default)(eventName === 'onURLReceived', `Linking.addListener(): ${eventName} is not a valid event`);
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return {
          remove() {}
        };
      }
      const nativeListener = nativeEvent => listener({
        url: window.location.href,
        nativeEvent
      });
      window.addEventListener('message', nativeListener, false);
      return {
        remove: () => {
          window.removeEventListener('message', nativeListener);
        }
      };
    },
    getLinkingURL() {
      if (typeof window === 'undefined') return '';
      return window.location.href;
    }
  };
},665,[17,919],"node_modules\\expo-linking\\build\\ExpoLinking.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "invariant"));
  const listeners = [];
  var _default = exports.default = {
    addEventListener(type, listener) {
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return {
          remove() {}
        };
      }
      (0, _invariant.default)(type === 'url', `Linking.addEventListener(): ${type} is not a valid event`);
      const nativeListener = nativeEvent => listener({
        url: window.location.href,
        nativeEvent
      });
      listeners.push({
        listener,
        nativeListener
      });
      window.addEventListener('message', nativeListener, false);
      return {
        remove: () => {
          this.removeEventListener(type, listener);
        }
      };
    },
    removeEventListener(type, listener) {
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return;
      }
      (0, _invariant.default)(type === 'url', `Linking.addEventListener(): ${type} is not a valid event`);
      const listenerIndex = listeners.findIndex(pair => pair.listener === listener);
      (0, _invariant.default)(listenerIndex !== -1, 'Linking.removeEventListener(): cannot remove an unregistered event listener.');
      const nativeListener = listeners[listenerIndex].nativeListener;
      window.removeEventListener('message', nativeListener, false);
      listeners.splice(listenerIndex, 1);
    },
    async canOpenURL() {
      // In reality this should be able to return false for links like `chrome://` on chrome.
      return true;
    },
    async getInitialURL() {
      if (typeof window === 'undefined') return '';
      return window.location.href;
    },
    async openURL(url) {
      if (typeof window !== 'undefined') {
        // @ts-ignore
        window.location = new URL(url, window.location).toString();
      }
    }
  };
},666,[17,919],"node_modules\\expo-linking\\build\\RNLinking.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createURL = createURL;
  exports.parse = parse;
  function createURL(path, {
    queryParams = {}
  } = {}) {
    if (typeof window === 'undefined') return '';
    const url = new URL(path, window.location.origin);
    Object.entries(queryParams).forEach(([key, value]) => {
      if (typeof value === 'string') {
        url.searchParams.set(key, encodeURIComponent(value));
      } else if (value != null) {
        url.searchParams.set(key,
        // @ts-expect-error: browser supports using array
        value);
      }
    });
    return url.toString().replace(/\/$/, '');
  }
  function parse(url) {
    let parsed;
    try {
      parsed = new URL(url);
    } catch {
      if (typeof window === 'undefined') {
        return {
          hostname: null,
          path: url,
          queryParams: {},
          scheme: null
        };
      }
      return {
        hostname: 'localhost',
        path: url,
        queryParams: {},
        scheme: 'http'
      };
    }
    const queryParams = {};
    parsed.searchParams.forEach((value, key) => {
      queryParams[key] = decodeURIComponent(value);
    });
    return {
      hostname: parsed.hostname || null,
      // TODO: We should probably update native to follow the default URL behavior closer.
      path: !parsed.hostname && !parsed.pathname ? null : parsed.pathname === '' ? null : parsed.pathname.replace(/^\//, ''),
      queryParams,
      scheme: parsed.protocol.replace(/:$/, '')
    };
  }
},667,[],"node_modules\\expo-linking\\build\\createURL.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateURL = validateURL;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "invariant"));
  function validateURL(url) {
    (0, _invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
    (0, _invariant.default)(url, 'Invalid URL: cannot be empty');
  }
},668,[17,919],"node_modules\\expo-linking\\build\\validateURL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},669,[],"node_modules\\expo-linking\\build\\Linking.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.collectManifestSchemes = collectManifestSchemes;
  exports.hasConstantsManifest = hasConstantsManifest;
  exports.hasCustomScheme = hasCustomScheme;
  exports.resolveScheme = resolveScheme;
  function hasCustomScheme() {
    return true;
  }
  function collectManifestSchemes() {
    return [];
  }
  function hasConstantsManifest() {
    return false;
  }
  function resolveScheme() {
    return 'https';
  }
},670,[],"node_modules\\expo-linking\\build\\Schemes.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.store = void 0;
  exports.useStore = useStore;
  exports.useRouteInfo = useRouteInfo;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const expo_constants_1 = __importDefault(require(_dependencyMap[1], "expo-constants"));
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const extractPathFromURL_1 = require(_dependencyMap[4], "../fork/extractPathFromURL");
  const getStateFromPath_forks_1 = require(_dependencyMap[5], "../fork/getStateFromPath-forks");
  const getLinkingConfig_1 = require(_dependencyMap[6], "../getLinkingConfig");
  const getReactNavigationConfig_1 = require(_dependencyMap[7], "../getReactNavigationConfig");
  const getRoutes_1 = require(_dependencyMap[8], "../getRoutes");
  const routeInfo_1 = require(_dependencyMap[9], "./routeInfo");
  const useScreens_1 = require(_dependencyMap[10], "../useScreens");
  const url_1 = require(_dependencyMap[11], "../utils/url");
  const SplashScreen = __importStar(require(_dependencyMap[12], "../views/Splash"));
  const storeRef = {
    current: {}
  };
  const routeInfoCache = new WeakMap();
  let splashScreenAnimationFrame;
  let hasAttemptedToHideSplash = false;
  exports.store = {
    shouldShowTutorial() {
      return !storeRef.current.routeNode && process.env.NODE_ENV === 'development';
    },
    get state() {
      return storeRef.current.state;
    },
    get navigationRef() {
      return storeRef.current.navigationRef;
    },
    get routeNode() {
      return storeRef.current.routeNode;
    },
    getRouteInfo() {
      return storeRef.current.routeInfo || routeInfo_1.defaultRouteInfo;
    },
    get redirects() {
      return storeRef.current.redirects || [];
    },
    get rootComponent() {
      return storeRef.current.rootComponent;
    },
    get linking() {
      return storeRef.current.linking;
    },
    setFocusedState(state) {
      const routeInfo = getCachedRouteInfo(state);
      storeRef.current.routeInfo = routeInfo;
    },
    onReady() {
      if (!hasAttemptedToHideSplash) {
        hasAttemptedToHideSplash = true;
        // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.
        splashScreenAnimationFrame = requestAnimationFrame(() => {
          SplashScreen._internal_maybeHideAsync?.();
        });
      }
      storeRef.current.navigationRef.addListener('state', e => {
        if (!e.data.state) {
          return;
        }
        let isStale = false;
        let state = e.data.state;
        while (!isStale && state) {
          isStale = state.stale;
          state = state.routes?.['index' in state && typeof state.index === 'number' ? state.index : state.routes.length - 1]?.state;
        }
        storeRef.current.state = e.data.state;
        if (!isStale) {
          storeRef.current.routeInfo = getCachedRouteInfo(e.data.state);
        }
        for (const callback of routeInfoSubscribers) {
          callback();
        }
      });
    },
    assertIsReady() {
      if (!storeRef.current.navigationRef.isReady()) {
        throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');
      }
    }
  };
  function useStore(context, linkingConfigOptions, serverUrl) {
    const navigationRef = (0, native_1.useNavigationContainerRef)();
    const config = expo_constants_1.default.expoConfig?.extra?.router;
    let linking;
    let rootComponent = react_1.Fragment;
    let initialState;
    const routeNode = (0, getRoutes_1.getRoutes)(context, Object.assign({}, config, {
      ignoreEntryPoints: true,
      platform: react_native_1.Platform.OS
    }));
    const redirects = [config?.redirects, config?.rewrites].filter(Boolean).flat().map(route => {
      return [(0, getStateFromPath_forks_1.routePatternToRegex)((0, getReactNavigationConfig_1.parseRouteSegments)(route.source)), route, (0, url_1.shouldLinkExternally)(route.destination)];
    });
    if (routeNode) {
      // We have routes, so get the linking config and the root component
      linking = (0, getLinkingConfig_1.getLinkingConfig)(routeNode, context, () => exports.store.getRouteInfo(), {
        metaOnly: linkingConfigOptions.metaOnly,
        serverUrl,
        redirects
      });
      rootComponent = (0, useScreens_1.getQualifiedRouteComponent)(routeNode);
      // By default React Navigation is async and does not render anything in the first pass as it waits for `getInitialURL`
      // This will cause static rendering to fail, which once performs a single pass.
      // If the initialURL is a string, we can prefetch the state and routeInfo, skipping React Navigation's async behavior.
      const initialURL = linking?.getInitialURL?.();
      if (typeof initialURL === 'string') {
        let initialPath = (0, extractPathFromURL_1.extractExpoPathFromURL)(linking.prefixes, initialURL);
        // It does not matter if the path starts with a `/` or not, but this keeps the behavior consistent
        if (!initialPath.startsWith('/')) initialPath = '/' + initialPath;
        initialState = linking.getStateFromPath(initialPath, linking.config);
        const initialRouteInfo = (0, routeInfo_1.getRouteInfoFromState)(initialState);
        routeInfoCache.set(initialState, initialRouteInfo);
      }
    } else {
      // Only error in production, in development we will show the onboarding screen
      if (process.env.NODE_ENV === 'production') {
        throw new Error('No routes found');
      }
      // In development, we will show the onboarding screen
      rootComponent = react_1.Fragment;
    }
    storeRef.current = {
      navigationRef,
      routeNode,
      config,
      rootComponent,
      linking,
      redirects,
      state: initialState
    };
    if (initialState) {
      storeRef.current.routeInfo = getCachedRouteInfo(initialState);
    }
    (0, react_1.useEffect)(() => {
      return () => {
        // listener();
        if (splashScreenAnimationFrame) {
          cancelAnimationFrame(splashScreenAnimationFrame);
          splashScreenAnimationFrame = undefined;
        }
      };
    });
    return exports.store;
  }
  const routeInfoSubscribers = new Set();
  const routeInfoSubscribe = callback => {
    routeInfoSubscribers.add(callback);
    return () => {
      routeInfoSubscribers.delete(callback);
    };
  };
  function useRouteInfo() {
    return (0, react_1.useSyncExternalStore)(routeInfoSubscribe, exports.store.getRouteInfo, exports.store.getRouteInfo);
  }
  function getCachedRouteInfo(state) {
    let routeInfo = routeInfoCache.get(state);
    if (!routeInfo) {
      routeInfo = (0, routeInfo_1.getRouteInfoFromState)(state);
      const previousRouteInfo = storeRef.current.routeInfo;
      if (previousRouteInfo) {
        const areEqual = routeInfo.segments.length === previousRouteInfo.segments.length && routeInfo.segments.every((segment, index) => previousRouteInfo.segments[index] === segment) && routeInfo.pathnameWithParams === previousRouteInfo.pathnameWithParams;
        if (areEqual) {
          // If they are equal, keep the previous route info for object reference equality
          routeInfo = previousRouteInfo;
        }
      }
      routeInfoCache.set(state, routeInfo);
    }
    return routeInfo;
  }
},671,[350,672,3,16,675,676,677,678,689,705,587,691,631],"node_modules\\expo-router\\build\\global-state\\router-store.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "AppOwnership", {
    enumerable: true,
    get: function () {
      return _Constants.AppOwnership;
    }
  });
  Object.defineProperty(exports, "ExecutionEnvironment", {
    enumerable: true,
    get: function () {
      return _Constants.ExecutionEnvironment;
    }
  });
  Object.defineProperty(exports, "UserInterfaceIdiom", {
    enumerable: true,
    get: function () {
      return _Constants.UserInterfaceIdiom;
    }
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/NativeModules"));
  var _Constants = require(_dependencyMap[5], "./Constants.types");
  var _ExponentConstants = _interopRequireDefault(require(_dependencyMap[6], "./ExponentConstants"));
  if (!_ExponentConstants.default) {
    console.warn("No native ExponentConstants module found, are you sure the expo-constants's module is linked properly?");
  }
  const ExpoUpdates = (0, _expoModulesCore.requireOptionalNativeModule)('ExpoUpdates');
  let rawUpdatesManifest = null;
  // If expo-updates defines a non-empty manifest, prefer that one
  if (ExpoUpdates) {
    let updatesManifest;
    if (ExpoUpdates.manifest) {
      updatesManifest = ExpoUpdates.manifest;
    } else if (ExpoUpdates.manifestString) {
      updatesManifest = JSON.parse(ExpoUpdates.manifestString);
    }
    if (updatesManifest && Object.keys(updatesManifest).length > 0) {
      rawUpdatesManifest = updatesManifest;
    }
  }
  // If dev-launcher defines a non-empty manifest, prefer that one
  let rawDevLauncherManifest = null;
  if (_NativeModules.default.EXDevLauncher) {
    let devLauncherManifest;
    if (_NativeModules.default.EXDevLauncher.manifestString) {
      devLauncherManifest = JSON.parse(_NativeModules.default.EXDevLauncher.manifestString);
    }
    if (devLauncherManifest && Object.keys(devLauncherManifest).length > 0) {
      rawDevLauncherManifest = devLauncherManifest;
    }
  }
  // Fall back to ExponentConstants.manifest if we don't have one from Updates
  let rawAppConfig = null;
  if (_ExponentConstants.default && _ExponentConstants.default.manifest) {
    const appConfig = _ExponentConstants.default.manifest;
    // On Android we pass the manifest in JSON form so this step is necessary
    if (typeof appConfig === 'string') {
      rawAppConfig = JSON.parse(appConfig);
    } else {
      rawAppConfig = appConfig;
    }
  }
  let rawManifest = rawUpdatesManifest ?? rawDevLauncherManifest ?? rawAppConfig;
  const _ref = _ExponentConstants.default || {},
    {
      appOwnership
    } = _ref,
    nativeConstants = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["name", "appOwnership"]);
  const constants = Object.assign({}, nativeConstants, {
    // Ensure this is null in bare workflow
    appOwnership: appOwnership ?? null
  });
  Object.defineProperties(constants, {
    /**
     * Use `manifest` property by default.
     * This property is only used for internal purposes.
     * It behaves similarly to the original one, but suppresses warning upon no manifest available.
     * `expo-asset` uses it to prevent users from seeing mentioned warning.
     */
    __unsafeNoWarnManifest: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: false
    },
    __unsafeNoWarnManifest2: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: false
    },
    manifest: {
      get() {
        const maybeManifest = getManifest();
        if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: true
    },
    manifest2: {
      get() {
        const maybeManifest = getManifest();
        if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: true
    },
    expoConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        // if running an embedded update, maybeManifest is a EmbeddedManifest which doesn't have
        // the expo config. Instead, the embedded expo-constants app.config should be used.
        if (ExpoUpdates && ExpoUpdates.isEmbeddedLaunch) {
          return rawAppConfig;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.expoClient ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    expoGoConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.expoGo ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    easConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.eas ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    __rawManifest_TEST: {
      get() {
        return rawManifest;
      },
      set(value) {
        rawManifest = value;
      },
      enumerable: false
    }
  });
  function isEmbeddedManifest(manifest) {
    return !isExpoUpdatesManifest(manifest);
  }
  function isExpoUpdatesManifest(manifest) {
    return 'metadata' in manifest;
  }
  function getManifest(suppressWarning = false) {
    if (!rawManifest) {
      const invalidManifestType = rawManifest === null ? 'null' : 'undefined';
      if (nativeConstants.executionEnvironment === _Constants.ExecutionEnvironment.Bare && _Platform.default.OS !== 'web') {
        if (!suppressWarning) {
          console.warn(`Constants.manifest is ${invalidManifestType} because the embedded app.config could not be read. Ensure that you have installed the expo-constants build scripts if you need to read from Constants.manifest.`);
        }
      } else if (nativeConstants.executionEnvironment === _Constants.ExecutionEnvironment.StoreClient || nativeConstants.executionEnvironment === _Constants.ExecutionEnvironment.Standalone) {
        // If we somehow get here, this is a truly exceptional state to be in.
        // Constants.manifest should *always* be defined in those contexts.
        throw new _expoModulesCore.CodedError('ERR_CONSTANTS_MANIFEST_UNAVAILABLE', `Constants.manifest is ${invalidManifestType}, must be an object.`);
      }
    }
    return rawManifest;
  }
  var _default = exports.default = constants;
},672,[17,29,473,106,96,673,674],"node_modules\\expo-constants\\build\\Constants.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UserInterfaceIdiom = exports.ExecutionEnvironment = exports.AppOwnership = void 0;
  var AppOwnership;
  (function (AppOwnership) {
    /**
     * The experience is running inside the Expo Go app.
     * @deprecated Use [`Constants.executionEnvironment`](#executionenvironment) instead.
     */
    AppOwnership["Expo"] = "expo";
  })(AppOwnership || (exports.AppOwnership = AppOwnership = {}));
  // @docsMissing
  var ExecutionEnvironment;
  (function (ExecutionEnvironment) {
    ExecutionEnvironment["Bare"] = "bare";
    ExecutionEnvironment["Standalone"] = "standalone";
    ExecutionEnvironment["StoreClient"] = "storeClient";
  })(ExecutionEnvironment || (exports.ExecutionEnvironment = ExecutionEnvironment = {}));
  // @needsAudit
  /**
   * Current supported values are `handset`, `tablet`, `desktop` and `tv`. CarPlay will show up
   * as `unsupported`.
   */
  var UserInterfaceIdiom;
  (function (UserInterfaceIdiom) {
    UserInterfaceIdiom["Handset"] = "handset";
    UserInterfaceIdiom["Tablet"] = "tablet";
    UserInterfaceIdiom["Desktop"] = "desktop";
    UserInterfaceIdiom["TV"] = "tv";
    UserInterfaceIdiom["Unsupported"] = "unsupported";
  })(UserInterfaceIdiom || (exports.UserInterfaceIdiom = UserInterfaceIdiom = {}));
},673,[],"node_modules\\expo-constants\\build\\Constants.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Constants = require(_dependencyMap[0], "./Constants.types");
  const _sessionId = (Date.now() + '-' + Math.floor(Math.random() * 1000000000)).toString();
  function getBrowserName() {
    if (typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string') {
      const agent = navigator.userAgent.toLowerCase();
      if (agent.includes('edge')) {
        return 'Edge';
      } else if (agent.includes('edg')) {
        return 'Chromium Edge';
      } else if (agent.includes('opr') && 'opr' in window && !!window['opr']) {
        return 'Opera';
      } else if (agent.includes('chrome') && 'chrome' in window && !!window['chrome']) {
        return 'Chrome';
      } else if (agent.includes('trident')) {
        return 'IE';
      } else if (agent.includes('firefox')) {
        return 'Firefox';
      } else if (agent.includes('safari')) {
        return 'Safari';
      }
    }
    return undefined;
  }
  var _default = exports.default = {
    get appOwnership() {
      return null;
    },
    get executionEnvironment() {
      return _Constants.ExecutionEnvironment.Bare;
    },
    get sessionId() {
      return _sessionId;
    },
    get isHeadless() {
      if (typeof navigator === 'undefined') return true;
      return /\bHeadlessChrome\//.test(navigator.userAgent);
    },
    get expoVersion() {
      return this.manifest.sdkVersion || null;
    },
    get linkingUri() {
      if (typeof location !== 'undefined') {
        // On native this is `exp://`
        // On web we should use the protocol and hostname (location.origin)
        return location.origin;
      } else {
        return '';
      }
    },
    get expoRuntimeVersion() {
      return this.expoVersion;
    },
    get deviceName() {
      return getBrowserName();
    },
    get systemFonts() {
      // TODO: Bacon: Maybe possible.
      return [];
    },
    get statusBarHeight() {
      return 0;
    },
    get deviceYearClass() {
      // TODO: Bacon: The android version isn't very accurate either, maybe we could try and guess this value.
      return null;
    },
    get manifest() {
      // This is defined by @expo/webpack-config or babel-preset-expo.
      // If your site is bundled with a different config then you may not have access to the app.json automatically.
      return "{\"name\":\"Rockland\",\"slug\":\"Rockland\",\"version\":\"1.0.0\",\"orientation\":\"portrait\",\"icon\":\"./assets/images/icon.png\",\"scheme\":\"rockland\",\"userInterfaceStyle\":\"automatic\",\"newArchEnabled\":true,\"web\":{\"bundler\":\"metro\",\"output\":\"static\",\"favicon\":\"./assets/images/favicon.png\",\"shortName\":\"Rockland\",\"orientation\":\"portrait\",\"name\":\"Rockland\"},\"experiments\":{\"typedRoutes\":true},\"sdkVersion\":\"53.0.0\",\"platforms\":[\"ios\",\"android\",\"web\"],\"extra\":{\"router\":{}}}" || {};
    },
    get manifest2() {
      return null;
    },
    get experienceUrl() {
      if (typeof location !== 'undefined') {
        return location.origin;
      } else {
        return '';
      }
    },
    get debugMode() {
      return __DEV__;
    },
    async getWebViewUserAgentAsync() {
      if (typeof navigator !== 'undefined') {
        return navigator.userAgent;
      } else {
        return null;
      }
    }
  };
},674,[673],"node_modules\\expo-constants\\build\\ExponentConstants.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parsePathAndParamsFromExpoGoLink = parsePathAndParamsFromExpoGoLink;
  exports.parsePathFromExpoGoLink = parsePathFromExpoGoLink;
  exports.extractExpoPathFromURL = extractExpoPathFromURL;
  function parsePathAndParamsFromExpoGoLink(url) {
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    const href = parsePathFromExpoGoLink(url);
    const results = href.match(/([^?]*)(\?.*)?/);
    return {
      pathname: results?.[1] ?? '',
      queryString: results?.[2] ?? ''
    };
  }
  function parsePathFromExpoGoLink(url) {
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    return url.match(/exps?:\/\/.*?\/--\/(.*)/)?.[1] ?? '';
  }
  // This is only run on native.
  function extractExactPathFromURL(url) {
    if (
    // If a universal link / app link / web URL is used, we should use the path
    // from the URL, while stripping the origin.
    url.match(/^https?:\/\//)) {
      const {
        origin,
        href,
        hostname
      } = new URL(url);
      if (hostname === 'exp.host' || hostname === 'u.expo.dev') {
        // These are QR code generate deep-link that always like to the '/' path
        // TODO: In the future, QR code may link to a specific path and this logic will need to be udpated
        return '';
      }
      return href.replace(origin, '');
    }
    const isExpoGo = typeof expo !== 'undefined' && globalThis.expo?.modules?.ExpoGo;
    // Handle special URLs used in Expo Go: `/--/pathname` -> `pathname`
    if (isExpoGo &&
    // while not exhaustive, `exp` and `exps` are the only two schemes which
    // are passed through to other apps in Expo Go.
    url.match(/^exp(s)?:\/\//)) {
      const pathname = parsePathFromExpoGoLink(url);
      if (pathname) {
        return fromDeepLink('a://' + pathname);
      }
      // Match the `?.*` segment of the URL.
      const queryParams = url.match(/exps?:\/\/.*\?(.*)/)?.[1];
      if (queryParams) {
        return fromDeepLink('a://?' + queryParams);
      }
      return '';
    }
    // TODO: Support dev client URLs
    return fromDeepLink(url);
  }
  /** Major hack to support the makeshift expo-development-client system. */
  function isExpoDevelopmentClient(url) {
    return url.hostname === 'expo-development-client';
  }
  function fromDeepLink(url) {
    let res;
    try {
      // This is for all standard deep links, e.g. `foobar://` where everything
      // after the `://` is the path.
      res = new URL(url);
    } catch {
      /**
       * We failed to parse the URL. This can occur for a variety of reasons, including:
       * - Its a partial URL (e.g. `/route?query=param`).
       * - It has a valid App scheme, but the scheme isn't a valid URL scheme (e.g. `my_app://`)
       */
      /**
       * App schemes are not valid URL schemes, so they will fail to parse.
       * We need to strip the scheme from these URLs
       */
      return url.replace(/^[^:]+:\/\//, '');
    }
    if (isExpoDevelopmentClient(res)) {
      if (!res.searchParams.get('url')) {
        return '';
      }
      const incomingUrl = res.searchParams.get('url');
      return extractExactPathFromURL(decodeURI(incomingUrl));
    }
    let results = '';
    if (res.host) {
      results += res.host;
    }
    if (res.pathname) {
      results += res.pathname;
    }
    const qs = !res.search ? '' :
    // @ts-ignore: `entries` is not on `URLSearchParams` in some typechecks.
    [...res.searchParams.entries()].map(([k, v]) => `${k}=${decodeURIComponent(v)}`).join('&');
    if (qs) {
      results += '?' + qs;
    }
    return results;
  }
  function extractExpoPathFromURL(_prefixes, url = '') {
    return extractExactPathFromURL(url)
    // TODO: We should get rid of this, dropping specificities is not good
    .replace(/^\//, '');
  }
},675,[],"node_modules\\expo-router\\build\\fork\\extractPathFromURL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.populateParams = populateParams;
  exports.safelyDecodeURIComponent = safelyDecodeURIComponent;
  exports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;
  exports.createConfig = createConfig;
  exports.assertScreens = assertScreens;
  exports.configRegExp = configRegExp;
  exports.isDynamicPart = isDynamicPart;
  exports.replacePart = replacePart;
  exports.getParamValue = getParamValue;
  exports.handleUrlParams = handleUrlParams;
  exports.spreadParamsAcrossAllStates = spreadParamsAcrossAllStates;
  exports.stripBaseUrl = stripBaseUrl;
  exports.matchForEmptyPath = matchForEmptyPath;
  exports.appendIsInitial = appendIsInitial;
  exports.getRouteConfigSorter = getRouteConfigSorter;
  exports.parseQueryParams = parseQueryParams;
  exports.cleanPath = cleanPath;
  exports.routePatternToRegex = routePatternToRegex;
  const escape_string_regexp_1 = __importDefault(require(_dependencyMap[0], "escape-string-regexp"));
  const matchers_1 = require(_dependencyMap[1], "../matchers");
  /**
   * In Expo Router, the params are available at all levels of the routing config
   * @param routes
   * @returns
   */
  function populateParams(routes, params) {
    if (!routes || !params || Object.keys(params).length === 0) return;
    for (const route of routes) {
      Object.assign(route, {
        params
      });
    }
    return routes;
  }
  function safelyDecodeURIComponent(str) {
    try {
      return decodeURIComponent(str);
    } catch {
      return str;
    }
  }
  function getUrlWithReactNavigationConcessions(path, baseUrl = "") {
    let parsed;
    try {
      parsed = new URL(path, 'https://phony.example');
    } catch {
      // Do nothing with invalid URLs.
      return {
        path,
        cleanUrl: '',
        nonstandardPathname: '',
        url: new URL('https://phony.example')
      };
    }
    const pathname = parsed.pathname;
    const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);
    const pathWithoutGroups = (0, matchers_1.stripGroupSegmentsFromPath)(stripBaseUrl(path, baseUrl));
    // Make sure there is a trailing slash
    return {
      // The slashes are at the end, not the beginning
      path,
      nonstandardPathname: withoutBaseUrl.replace(/^\/+/g, '').replace(/\/+$/g, '') + '/',
      url: parsed,
      pathWithoutGroups
    };
  }
  function createConfig(screen, pattern, routeNames, config = {}) {
    const parts = [];
    let isDynamic = false;
    const isIndex = screen === 'index' || screen.endsWith('/index');
    let staticPartCount = 0;
    for (const part of pattern.split('/')) {
      if (part) {
        // If any part is dynamic, then the route is dynamic
        const isDynamicPart = part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');
        isDynamic ||= isDynamicPart;
        if (!(0, matchers_1.matchGroupName)(part)) {
          parts.push(part);
          if (!isDynamicPart) {
            staticPartCount++;
          }
        }
      }
    }
    const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;
    const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';
    if (isIndex) {
      parts.push('index');
      staticPartCount++;
    }
    return {
      type,
      isIndex,
      hasChildren,
      parts,
      staticPartCount,
      userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),
      // Don't include the __root route name
      expandedRouteNames: routeNames.slice(1).flatMap(name => {
        return name.split('/');
      })
    };
  }
  function assertScreens(options) {
    if (!options?.screens) {
      throw Error("You must pass a 'screens' object to 'getStateFromPath' to generate a path.");
    }
  }
  function configRegExp(config) {
    return config.pattern ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;
  }
  function isDynamicPart(p) {
    return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));
  }
  function replacePart(p) {
    return p.replace(/^[:*]/, '').replace(/\?$/, '');
  }
  function getParamValue(p, value) {
    if (p.startsWith('*')) {
      const values = value.split('/').filter(v => v !== '');
      return values.length === 0 && p.endsWith('?') ? undefined : values;
    } else {
      return value;
    }
  }
  function formatRegexPattern(it) {
    // Allow spaces in file path names.
    it = it.replace(' ', '%20');
    if (it.startsWith(':')) {
      // TODO: Remove unused match group
      return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
    } else if (it.startsWith('*')) {
      return `((.*\\/)${it.endsWith('?') ? '?' : ''})`;
    }
    // Strip groups from the matcher
    if ((0, matchers_1.matchGroupName)(it) != null) {
      // Groups are optional segments
      // this enables us to match `/bar` and `/(foo)/bar` for the same route
      // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group
      return `(?:${(0, escape_string_regexp_1.default)(it)}\\/)?`;
    }
    return (0, escape_string_regexp_1.default)(it) + `\\/`;
  }
  function handleUrlParams(route, params) {
    if (params) {
      route.params = Object.assign(Object.create(null), route.params);
      for (const [name, value] of Object.entries(params)) {
        if (route.params?.[name]) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);
          }
        }
        if (!route.params?.[name]) {
          route.params[name] = value;
          continue;
        }
      }
      if (Object.keys(route.params).length === 0) {
        delete route.params;
      }
    }
  }
  function spreadParamsAcrossAllStates(state, params) {
    while (state) {
      const route = state.routes[0];
      route.params = Object.assign({}, route.params, params);
    }
  }
  function stripBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return path.replace(/^\/+/g, '/').replace(new RegExp(`^\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g'), '');
      }
    }
    return path;
  }
  function matchForEmptyPath(configs) {
    // We need to add special handling of empty path so navigation to empty path also works
    // When handling empty path, we should only look at the root level config
    // NOTE(EvanBacon): We only care about matching leaf nodes.
    const leafNodes = configs.filter(config => !config.hasChildren).map(value => {
      return Object.assign({}, value, {
        // Collapse all levels of group segments before testing.
        // This enables `app/(one)/(two)/index.js` to be matched.
        path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)
      });
    });
    const match = leafNodes.find(config =>
    // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.
    config.path === '' && (!config.regex || config.regex.test(''))) ?? leafNodes.find(config =>
    // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.
    config.path.startsWith(':') && config.regex.test('')) ??
    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.
    // This should be done last to enable dynamic routes having a higher priority.
    leafNodes.find(config => config.path.startsWith('*') && config.regex.test('/'));
    return match;
  }
  function appendIsInitial(initialRoutes) {
    const resolvedInitialPatterns = initialRoutes.map(route => joinPaths(...route.parentScreens, route.initialRouteName));
    return function (config) {
      // TODO(EvanBacon): Probably a safer way to do this
      // Mark initial routes to give them potential priority over other routes that match.
      config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));
      return config;
    };
  }
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  function getRouteConfigSorter(previousSegments = []) {
    return function sortConfigs(a, b) {
      // Sort config so that:
      // - the most exhaustive ones are always at the beginning
      // - patterns with wildcard are always at the end
      // If 2 patterns are same, move the one with less route names up
      // This is an error state, so it's only useful for consistent error messages
      if (a.pattern === b.pattern) {
        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
      }
      /*
       * If one of the patterns starts with the other, it is earlier in the config sorting.
       * However, configs are a mix of route configs and layout configs
       * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`
       *
       * This is because you can navigate to a directory and its navigator will determine the route
       * These routes should be later in the config sorting, as their patterns are very open
       * and will prevent routes from being matched
       *
       * Therefore before we compare segment parts, we force these layout configs later in the sorting
       *
       * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.
       */
      if (a.pattern.startsWith(b.pattern) && !b.isIndex) {
        return -1;
      }
      if (b.pattern.startsWith(a.pattern) && !a.isIndex) {
        return 1;
      }
      /*
       * Static routes should always be higher than dynamic and layout routes.
       */
      if (a.type === 'static' && b.type !== 'static') {
        return -1;
      } else if (a.type !== 'static' && b.type === 'static') {
        return 1;
      }
      /*
       * If the routes have any static segments, the one the most static segments should be higher
       */
      if (a.staticPartCount !== b.staticPartCount) {
        return b.staticPartCount - a.staticPartCount;
      }
      /*
       * If both are static/dynamic or a layout file, then we check group similarity
       */
      const similarToPreviousA = previousSegments.filter((value, index) => {
        return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');
      });
      const similarToPreviousB = previousSegments.filter((value, index) => {
        return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');
      });
      if ((similarToPreviousA.length > 0 || similarToPreviousB.length > 0) && similarToPreviousA.length !== similarToPreviousB.length) {
        // One matches more than the other, so pick the one that matches more
        return similarToPreviousB.length - similarToPreviousA.length;
      }
      /*
       * If there is not difference in similarity, then each non-group segment is compared against each other
       */
      for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {
        // if b is longer, b get higher priority
        if (a.parts[i] == null) {
          return 1;
        }
        // if a is longer, a get higher priority
        if (b.parts[i] == null) {
          return -1;
        }
        const aWildCard = a.parts[i].startsWith('*');
        const bWildCard = b.parts[i].startsWith('*');
        // if both are wildcard we compare next component
        if (aWildCard && bWildCard) {
          const aNotFound = a.parts[i].match(/^[*]not-found$/);
          const bNotFound = b.parts[i].match(/^[*]not-found$/);
          if (aNotFound && bNotFound) {
            continue;
          } else if (aNotFound) {
            return 1;
          } else if (bNotFound) {
            return -1;
          }
          continue;
        }
        // if only a is wild card, b get higher priority
        if (aWildCard) {
          return 1;
        }
        // if only b is wild card, a get higher priority
        if (bWildCard) {
          return -1;
        }
        const aSlug = a.parts[i].startsWith(':');
        const bSlug = b.parts[i].startsWith(':');
        // if both are wildcard we compare next component
        if (aSlug && bSlug) {
          const aNotFound = a.parts[i].match(/^[*]not-found$/);
          const bNotFound = b.parts[i].match(/^[*]not-found$/);
          if (aNotFound && bNotFound) {
            continue;
          } else if (aNotFound) {
            return 1;
          } else if (bNotFound) {
            return -1;
          }
          continue;
        }
        // if only a is wild card, b get higher priority
        if (aSlug) {
          return 1;
        }
        // if only b is wild card, a get higher priority
        if (bSlug) {
          return -1;
        }
      }
      /*
       * Both configs are identical in specificity and segments count/type
       * Try and sort by initial instead.
       *
       * TODO: We don't differentiate between the default initialRoute and group specific default routes
       *
       * const unstable_settings = {
       *   "group": {
       *     initialRouteName: "article"
       *  }
       * }
       *
       * "article" will be ranked higher because its an initialRoute for a group - even if not your not currently in
       * that group. The current work around is to ways provide initialRouteName for all groups
       */
      if (a.isInitial && !b.isInitial) {
        return -1;
      } else if (!a.isInitial && b.isInitial) {
        return 1;
      }
      return b.parts.length - a.parts.length;
    };
  }
  function parseQueryParams(path, route, parseConfig, hash) {
    const searchParams = new URL(path, 'https://phony.example').searchParams;
    const params = Object.create(null);
    if (hash) {
      params['#'] = hash.slice(1);
    }
    for (const name of searchParams.keys()) {
      if (route.params?.[name]) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);
        }
      } else {
        const values = parseConfig?.hasOwnProperty(name) ? searchParams.getAll(name).map(value => parseConfig[name](value)) : searchParams.getAll(name);
        // searchParams.getAll returns an array.
        // if we only have a single value, and its not an array param, we need to extract the value
        params[name] = values.length === 1 ? values[0] : values;
      }
    }
    return Object.keys(params).length ? params : undefined;
  }
  function cleanPath(path) {
    path = path
    // let remaining = path
    // END FORK
    .replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // Make sure there is a trailing slash
    return path.endsWith('/') ? path : `${path}/`;
  }
  function routePatternToRegex(pattern) {
    return new RegExp(`^(${pattern.split('/').map(it => {
      if (it.startsWith(':')) {
        return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
      }
      return `${it === '*' ? '.*' : (0, escape_string_regexp_1.default)(it)}\\/`;
    }).join('')})`);
  }
},676,[402,585],"node_modules\\expo-router\\build\\fork\\getStateFromPath-forks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNavigationConfig = getNavigationConfig;
  exports.getLinkingConfig = getLinkingConfig;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const expo_modules_core_1 = require(_dependencyMap[1], "expo-modules-core");
  const constants_1 = require(_dependencyMap[2], "./constants");
  const getReactNavigationConfig_1 = require(_dependencyMap[3], "./getReactNavigationConfig");
  const getRoutesRedirects_1 = require(_dependencyMap[4], "./getRoutesRedirects");
  const linking_1 = require(_dependencyMap[5], "./link/linking");
  function getNavigationConfig(routes, metaOnly = true) {
    return {
      screens: {
        [constants_1.INTERNAL_SLOT_NAME]: Object.assign({
          path: ''
        }, (0, getReactNavigationConfig_1.getReactNavigationConfig)(routes, metaOnly))
      }
    };
  }
  function getLinkingConfig(routes, context, getRouteInfo, {
    metaOnly = true,
    serverUrl,
    redirects
  } = {}) {
    // Returning `undefined` / `null from `getInitialURL` are valid values, so we need to track if it's been called.
    let hasCachedInitialUrl = false;
    let initialUrl;
    const nativeLinkingKey = context.keys().find(key => key.match(/^\.\/\+native-intent\.[tj]sx?$/));
    const nativeLinking = nativeLinkingKey ? context(nativeLinkingKey) : undefined;
    const config = getNavigationConfig(routes, metaOnly);
    return {
      prefixes: [],
      config,
      // A custom getInitialURL is used on native to ensure the app always starts at
      // the root path if it's launched from something other than a deep link.
      // This helps keep the native functionality working like the web functionality.
      // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`
      // then `/index` would be used on web and `/settings` would be used on native.
      getInitialURL() {
        // Expo Router calls `getInitialURL` twice, which may confuse the user if they provide a custom `getInitialURL`.
        // Therefor we memoize the result.
        if (!hasCachedInitialUrl) {
          if (expo_modules_core_1.Platform.OS === 'web') {
            initialUrl = serverUrl ?? (0, linking_1.getInitialURL)();
          } else {
            initialUrl = serverUrl ?? (0, linking_1.getInitialURL)();
            if (typeof initialUrl === 'string') {
              initialUrl = (0, getRoutesRedirects_1.applyRedirects)(initialUrl, redirects);
              if (initialUrl && typeof nativeLinking?.redirectSystemPath === 'function') {
                initialUrl = nativeLinking.redirectSystemPath({
                  path: initialUrl,
                  initial: true
                });
              }
            } else if (initialUrl) {
              initialUrl = initialUrl.then(url => {
                url = (0, getRoutesRedirects_1.applyRedirects)(url, redirects);
                if (url && typeof nativeLinking?.redirectSystemPath === 'function') {
                  return nativeLinking.redirectSystemPath({
                    path: url,
                    initial: true
                  });
                }
                return url;
              });
            }
          }
          hasCachedInitialUrl = true;
        }
        return initialUrl;
      },
      subscribe: (0, linking_1.subscribe)(nativeLinking, redirects),
      getStateFromPath: (path, options) => {
        return (0, linking_1.getStateFromPath)(path, options, getRouteInfo().segments);
      },
      getPathFromState(state, options) {
        return (0, linking_1.getPathFromState)(state, Object.assign({}, config, options, {
          screens: config.screens ?? options?.screens ?? {}
        })) ?? '/';
      },
      // Add all functions to ensure the types never need to fallback.
      // This is a convenience for usage in the package.
      getActionFromState: native_1.getActionFromState
    };
  }
},677,[350,473,650,678,679,682],"node_modules\\expo-router\\build\\getLinkingConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseRouteSegments = parseRouteSegments;
  exports.getReactNavigationScreensConfig = getReactNavigationScreensConfig;
  exports.getReactNavigationConfig = getReactNavigationConfig;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  // `[page]` -> `:page`
  // `page` -> `page`
  function convertDynamicRouteToReactNavigation(segment) {
    // NOTE(EvanBacon): To support shared routes we preserve group segments.
    if (segment === 'index') {
      return '';
    }
    if (segment === '+not-found') {
      return '*not-found';
    }
    const dynamicName = (0, matchers_1.matchDynamicName)(segment);
    if (dynamicName && !dynamicName.deep) {
      return `:${dynamicName.name}`;
    } else if (dynamicName?.deep) {
      return '*' + dynamicName.name;
    } else {
      return segment;
    }
  }
  function parseRouteSegments(segments) {
    return (
      // NOTE(EvanBacon): When there are nested routes without layouts
      // the node.route will be something like `app/home/index`
      // this needs to be split to ensure each segment is parsed correctly.
      segments.split('/')
      // Convert each segment to a React Navigation format.
      .map(convertDynamicRouteToReactNavigation)
      // Remove any empty paths from groups or index routes.
      .filter(Boolean)
      // Join to return as a path.
      .join('/')
    );
  }
  function convertRouteNodeToScreen(node, metaOnly) {
    const path = parseRouteSegments(node.route);
    if (!node.children.length) {
      if (!metaOnly) {
        return {
          path,
          screens: {},
          _route: node
        };
      }
      return path;
    }
    const screens = getReactNavigationScreensConfig(node.children, metaOnly);
    const screen = {
      path,
      screens
    };
    if (node.initialRouteName) {
      // NOTE(EvanBacon): This is bad because it forces all Layout Routes
      // to be loaded into memory. We should move towards a system where
      // the initial route name is either loaded asynchronously in the Layout Route
      // or defined via a file system convention.
      screen.initialRouteName = node.initialRouteName;
    }
    if (!metaOnly) {
      screen._route = node;
    }
    return screen;
  }
  function getReactNavigationScreensConfig(nodes, metaOnly) {
    return Object.fromEntries(nodes.map(node => [node.route, convertRouteNodeToScreen(node, metaOnly)]));
  }
  function getReactNavigationConfig(routes, metaOnly) {
    const config = {
      initialRouteName: undefined,
      screens: getReactNavigationScreensConfig(routes.children, metaOnly)
    };
    if (routes.initialRouteName) {
      // We're using LinkingOptions the generic type is `object` instead of a proper ParamList.
      // So we need to cast the initialRouteName to `any` to avoid type errors.
      config.initialRouteName = routes.initialRouteName;
    }
    return config;
  }
},678,[585],"node_modules\\expo-router\\build\\getReactNavigationConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.applyRedirects = applyRedirects;
  exports.getRedirectModule = getRedirectModule;
  exports.convertRedirect = convertRedirect;
  exports.mergeVariablesWithPath = mergeVariablesWithPath;
  const Linking = __importStar(require(_dependencyMap[0], "expo-linking"));
  const react_1 = require(_dependencyMap[1], "react");
  const getStateFromPath_forks_1 = require(_dependencyMap[2], "./fork/getStateFromPath-forks");
  const matchers_1 = require(_dependencyMap[3], "./matchers");
  function applyRedirects(url, redirects) {
    if (typeof url !== 'string' || !redirects) {
      return url;
    }
    const nextUrl = (0, getStateFromPath_forks_1.cleanPath)(url);
    const redirect = redirects.find(([regex]) => regex.test(nextUrl));
    if (!redirect) {
      return url;
    }
    // If the redirect is external, open the URL
    if (redirect[2]) {
      let href = redirect[1].destination;
      if (href.startsWith('//') && false) {
        href = `https:${href}`;
      }
      Linking.openURL(href);
      return href;
    }
    return applyRedirects(convertRedirect(url, redirect[1]), redirects);
  }
  function getRedirectModule(route) {
    return {
      default: function RedirectComponent() {
        // Use the store directly instead of useGlobalSearchParams.
        // Importing the hooks directly causes build errors on the server
        const params = require(_dependencyMap[4], "./hooks").useGlobalSearchParams();
        // Replace dynamic parts of the route with the actual values from the params
        let href = route.split('/').map(part => {
          const dynamicName = (0, matchers_1.matchDynamicName)(part);
          if (!dynamicName) {
            return part;
          } else {
            const param = params[dynamicName.name];
            delete params[dynamicName.name];
            return param;
          }
        }).filter(Boolean).join('/');
        // Add any remaining params as query string
        const queryString = new URLSearchParams(params).toString();
        if (queryString) {
          href += `?${queryString}`;
        }
        return (0, react_1.createElement)(require(_dependencyMap[5], "./link/Link").Redirect, {
          href
        });
      }
    };
  }
  function convertRedirect(path, config) {
    const params = {};
    const parts = path.split('/');
    const sourceParts = config.source.split('/');
    for (const [index, sourcePart] of sourceParts.entries()) {
      const dynamicName = (0, matchers_1.matchDynamicName)(sourcePart);
      if (!dynamicName) {
        continue;
      } else if (!dynamicName.deep) {
        params[dynamicName.name] = parts[index];
        continue;
      } else {
        params[dynamicName.name] = parts.slice(index);
        break;
      }
    }
    return mergeVariablesWithPath(config.destination, params);
  }
  function mergeVariablesWithPath(path, params) {
    return path.split('/').map(part => {
      const dynamicName = (0, matchers_1.matchDynamicName)(part);
      if (!dynamicName) {
        return part;
      } else {
        const param = params[dynamicName.name];
        delete params[dynamicName.name];
        return param;
      }
    }).filter(Boolean).join('/');
  }
},679,[664,3,676,585,680,654],"node_modules\\expo-router\\build\\getRoutesRedirects.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useRouteInfo = void 0;
  exports.useRootNavigationState = useRootNavigationState;
  exports.useRootNavigation = useRootNavigation;
  exports.useNavigationContainerRef = useNavigationContainerRef;
  exports.useRouter = useRouter;
  exports.useUnstableGlobalHref = useUnstableGlobalHref;
  exports.useSegments = useSegments;
  exports.usePathname = usePathname;
  exports.useGlobalSearchParams = useGlobalSearchParams;
  exports.useLocalSearchParams = useLocalSearchParams;
  exports.useSearchParams = useSearchParams;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Route_1 = require(_dependencyMap[2], "./Route");
  const constants_1 = require(_dependencyMap[3], "./constants");
  const router_store_1 = require(_dependencyMap[4], "./global-state/router-store");
  Object.defineProperty(exports, "useRouteInfo", {
    enumerable: true,
    get: function () {
      return router_store_1.useRouteInfo;
    }
  });
  const imperative_api_1 = require(_dependencyMap[5], "./imperative-api");
  /**
   * Returns the [navigation state](https://reactnavigation.org/docs/navigation-state/)
   * of the navigator which contains the current screen.
   *
   * @example
   * ```tsx
   * import { useRootNavigationState } from 'expo-router';
   *
   * export default function Route() {
   *  const { routes } = useRootNavigationState();
   *
   *  return <Text>{routes[0].name}</Text>;
   * }
   * ```
   */
  function useRootNavigationState() {
    return (0, native_1.useNavigation)().getParent(constants_1.INTERNAL_SLOT_NAME).getState();
  }
  /**
   * @deprecated Use [`useNavigationContainerRef`](#usenavigationcontainerref) instead,
   * which returns a React `ref`.
   */
  function useRootNavigation() {
    return router_store_1.store.navigationRef.current;
  }
  /**
   * @return The root `<NavigationContainer />` ref for the app. The `ref.current` may be `null`
   * if the `<NavigationContainer />` hasn't mounted yet.
   */
  function useNavigationContainerRef() {
    return router_store_1.store.navigationRef;
  }
  /**
   *
   * Returns the [Router](#router) object for imperative navigation.
   *
   * @example
   *```tsx
   * import { useRouter } from 'expo-router';
   * import { Text } from 'react-native';
   *
   * export default function Route() {
   *  const router = useRouter();
   *
   *  return (
   *   <Text onPress={() => router.push('/home')}>Go Home</Text>
   *  );
   *}
   * ```
   */
  function useRouter() {
    return imperative_api_1.router;
  }
  /**
   * @private
   * @returns The current global pathname with query params attached. This may change in the future to include the hostname
   * from a predefined universal link. For example, `/foobar?hey=world` becomes `https://acme.dev/foobar?hey=world`.
   */
  function useUnstableGlobalHref() {
    return (0, router_store_1.useRouteInfo)().unstable_globalHref;
  }
  function useSegments() {
    return (0, router_store_1.useRouteInfo)().segments;
  }
  /**
   * Returns the currently selected route location without search parameters. For example, `/acme?foo=bar` returns `/acme`.
   * Segments will be normalized. For example, `/[id]?id=normal` becomes `/normal`.
   *
   * @example
   * ```tsx app/profile/[user].tsx
   * import { Text } from 'react-native';
   * import { usePathname } from 'expo-router';
   *
   * export default function Route() {
   *   // pathname = "/profile/baconbrix"
   *   const pathname = usePathname();
   *
   *   return <Text>User: {user}</Text>;
   * }
   * ```
   */
  function usePathname() {
    return (0, router_store_1.useRouteInfo)().pathname;
  }
  function useGlobalSearchParams() {
    return (0, router_store_1.useRouteInfo)().params;
  }
  function useLocalSearchParams() {
    const params = react_1.default.use(Route_1.LocalRouteParamsContext) ?? {};
    return Object.fromEntries(Object.entries(params).map(([key, value]) => {
      // React Navigation doesn't remove "undefined" values from the params object, and you cannot remove them via
      // navigation.setParams as it shallow merges. Hence, we hide them here
      if (value === undefined) {
        return [key, undefined];
      }
      if (Array.isArray(value)) {
        return [key, value.map(v => {
          try {
            return decodeURIComponent(v);
          } catch {
            return v;
          }
        })];
      } else {
        try {
          return [key, decodeURIComponent(value)];
        } catch {
          return [key, value];
        }
      }
    }));
  }
  function useSearchParams({
    global = false
  } = {}) {
    const globalRef = react_1.default.useRef(global);
    if (process.env.NODE_ENV !== 'production') {
      if (global !== globalRef.current) {
        console.warn(`Detected change in 'global' option of useSearchParams. This value cannot change between renders`);
      }
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const params = global ? useGlobalSearchParams() : useLocalSearchParams();
    const entries = Object.entries(params).flatMap(([key, value]) => {
      if (global) {
        if (key === 'params') return [];
        if (key === 'screen') return [];
      }
      return Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]];
    });
    return new ReadOnlyURLSearchParams(entries);
  }
  class ReadOnlyURLSearchParams extends URLSearchParams {
    set() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
    append() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
    delete() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
  }
},680,[350,3,584,650,671,681],"node_modules\\expo-router\\build\\hooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.router = void 0;
  exports.ImperativeApiEmitter = ImperativeApiEmitter;
  const react_1 = require(_dependencyMap[0], "react");
  const routing_1 = require(_dependencyMap[1], "./global-state/routing");
  /**
   * @hidden
   */
  exports.router = {
    navigate: routing_1.navigate,
    push: routing_1.push,
    dismiss: routing_1.dismiss,
    dismissAll: routing_1.dismissAll,
    dismissTo: routing_1.dismissTo,
    canDismiss: routing_1.canDismiss,
    replace: routing_1.replace,
    back: () => (0, routing_1.goBack)(),
    canGoBack: routing_1.canGoBack,
    reload: routing_1.reload,
    prefetch: routing_1.prefetch,
    setParams: routing_1.setParams
  };
  function ImperativeApiEmitter() {
    const events = (0, react_1.useSyncExternalStore)(routing_1.routingQueue.subscribe, routing_1.routingQueue.snapshot, routing_1.routingQueue.snapshot);
    (0, react_1.useEffect)(() => {
      routing_1.routingQueue.run();
    }, [events]);
    return null;
  }
},681,[3,659],"node_modules\\expo-router\\build\\imperative-api.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPathFromState = exports.getStateFromPath = void 0;
  exports.getInitialURL = getInitialURL;
  exports.getRootURL = getRootURL;
  exports.subscribe = subscribe;
  const Linking = __importStar(require(_dependencyMap[0], "expo-linking"));
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const extractPathFromURL_1 = require(_dependencyMap[2], "../fork/extractPathFromURL");
  const getPathFromState_1 = require(_dependencyMap[3], "../fork/getPathFromState");
  Object.defineProperty(exports, "getPathFromState", {
    enumerable: true,
    get: function () {
      return getPathFromState_1.getPathFromState;
    }
  });
  const getStateFromPath_1 = require(_dependencyMap[4], "../fork/getStateFromPath");
  Object.defineProperty(exports, "getStateFromPath", {
    enumerable: true,
    get: function () {
      return getStateFromPath_1.getStateFromPath;
    }
  });
  const useLinking_1 = require(_dependencyMap[5], "../fork/useLinking");
  const getRoutesRedirects_1 = require(_dependencyMap[6], "../getRoutesRedirects");
  const isExpoGo = typeof expo !== 'undefined' && globalThis.expo?.modules?.ExpoGo;
  // A custom getInitialURL is used on native to ensure the app always starts at
  // the root path if it's launched from something other than a deep link.
  // This helps keep the native functionality working like the web functionality.
  // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`
  // then `/index` would be used on web and `/settings` would be used on native.
  function getInitialURL() {
    if (typeof window === 'undefined') {
      return '';
    }
    if (react_native_1.Platform.OS === 'web' && window.location?.href) {
      return window.location.href;
    }
    if (react_native_1.Platform.OS === 'ios') {
      // Use the new Expo API for iOS. This has better support for App Clips and handoff.
      const url = Linking.getLinkingURL();
      return parseExpoGoUrlFromListener(url) ??
      // The path will be nullish in bare apps when the app is launched from the home screen.
      // TODO(EvanBacon): define some policy around notifications.
      getRootURL();
    }
    // TODO: Figure out if expo-linking on Android has full interop with the React Native implementation.
    return Promise.resolve((0, useLinking_1.getInitialURLWithTimeout)()).then(url => parseExpoGoUrlFromListener(url) ??
    // The path will be nullish in bare apps when the app is launched from the home screen.
    // TODO(EvanBacon): define some policy around notifications.
    getRootURL());
  }
  let _rootURL;
  function getRootURL() {
    if (_rootURL === undefined) {
      _rootURL = Linking.createURL('/');
      if (isExpoGo) {
        _rootURL = (0, extractPathFromURL_1.parsePathFromExpoGoLink)(_rootURL);
      }
    }
    return _rootURL;
  }
  // Expo Go is weird and requires the root path to be `/--/`
  function parseExpoGoUrlFromListener(url) {
    if (!url || !isExpoGo) {
      return url;
    }
    const {
      pathname,
      queryString
    } = (0, extractPathFromURL_1.parsePathAndParamsFromExpoGoLink)(url);
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    if (!pathname || pathname === '/') {
      return getRootURL() + queryString;
    }
    return url;
  }
  function subscribe(nativeLinking, redirects) {
    return listener => {
      let callback;
      const legacySubscription = nativeLinking?.legacy_subscribe?.(listener);
      if (isExpoGo) {
        // This extra work is only done in the Expo Go app.
        callback = async ({
          url
        }) => {
          let href = parseExpoGoUrlFromListener(url);
          href = (0, getRoutesRedirects_1.applyRedirects)(href, redirects);
          if (href && nativeLinking?.redirectSystemPath) {
            href = await nativeLinking.redirectSystemPath({
              path: href,
              initial: false
            });
          }
          if (href) {
            listener(href);
          }
        };
      } else {
        callback = async ({
          url
        }) => {
          let href = (0, getRoutesRedirects_1.applyRedirects)(url, redirects);
          if (href && nativeLinking?.redirectSystemPath) {
            href = await nativeLinking.redirectSystemPath({
              path: href,
              initial: false
            });
          }
          if (href) {
            listener(href);
          }
        };
      }
      const subscription = Linking.addEventListener('url', callback);
      return () => {
        // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7
        subscription?.remove?.();
        legacySubscription?.();
      };
    };
  }
},682,[664,16,675,683,684,686,679],"node_modules\\expo-router\\build\\link\\linking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPathFromState = getPathFromState;
  exports.getPathDataFromState = getPathDataFromState;
  exports.appendBaseUrl = appendBaseUrl;
  const queryString = __importStar(require(_dependencyMap[0], "query-string"));
  const expo = __importStar(require(_dependencyMap[1], "./getPathFromState-forks"));
  // END FORK
  const getActiveRoute = state => {
    const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
      return getActiveRoute(route.state);
    }
    return route;
  };
  let cachedNormalizedConfigs = [undefined, {}];
  /**
   * Utility to serialize a navigation state object to a path string.
   *
   * @example
   * ```js
   * getPathFromState(
   *   {
   *     routes: [
   *       {
   *         name: 'Chat',
   *         params: { author: 'Jane', id: 42 },
   *       },
   *     ],
   *   },
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         stringify: { author: author => author.toLowerCase() }
   *       }
   *     }
   *   }
   * )
   * ```
   *
   * @param state Navigation state to serialize.
   * @param options Extra options to fine-tune how to serialize the path.
   * @returns Path representing the state, e.g. /foo/bar?count=42.
   */
  function getPathFromState(state, options) {
    return getPathDataFromState(state, options).path;
  }
  function getPathDataFromState(state, options) {
    if (state == null) {
      throw Error("Got 'undefined' for the navigation state. You must pass a valid state object.");
    }
    if (options) {
      // START FORK
      expo.validatePathConfig(options);
      // validatePathConfig(options);
      // END FORK
    }
    // Create a normalized configs object which will be easier to use
    if (cachedNormalizedConfigs[0] !== options?.screens) {
      cachedNormalizedConfigs = [options?.screens, options?.screens ? createNormalizedConfigs(options.screens) : {}];
    }
    const configs = cachedNormalizedConfigs[1];
    let path = '/';
    let current = state;
    const allParams = {};
    while (current) {
      let index = typeof current.index === 'number' ? current.index : 0;
      let route = current.routes[index];
      let pattern;
      let focusedParams;
      const focusedRoute = getActiveRoute(state);
      let currentOptions = configs;
      // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
      const nestedRouteNames = [];
      let hasNext = true;
      while (route.name in currentOptions && hasNext) {
        pattern = currentOptions[route.name].pattern;
        nestedRouteNames.push(route.name);
        if (route.params) {
          const stringify = currentOptions[route.name]?.stringify;
          // START FORK
          // This mutates allParams
          const currentParams = expo.fixCurrentParams(allParams, route, stringify);
          // const currentParams = Object.fromEntries(
          //   Object.entries(route.params).map(([key, value]) => [
          //     key,
          //     stringify?.[key] ? stringify[key](value) : String(value),
          //   ])
          // );
          // if (pattern) {
          //   Object.assign(allParams, currentParams);
          // }
          // END FORK
          if (focusedRoute === route) {
            // If this is the focused route, keep the params for later use
            // We save it here since it's been stringified already
            focusedParams = Object.assign({}, currentParams);
            pattern?.split('/').filter(p => expo.isDynamicPart(p))
            // eslint-disable-next-line no-loop-func
            .forEach(p => {
              const name = expo.getParamName(p);
              // Remove the params present in the pattern since we'll only use the rest for query string
              if (focusedParams) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete focusedParams[name];
              }
            });
          }
        }
        // If there is no `screens` property or no nested state, we return pattern
        if (!currentOptions[route.name].screens || route.state === undefined) {
          // START FORK
          // Expo Router allows you to navigate to a (group) and not specify a target screen
          // This is different from React Navigation, which requires a target screen
          // We need to handle this case here, by selecting either the index screen or the first screen of the group
          // IMPORTANT: This does not affect groups that use _layout files with initialRouteNames
          // Layout files create a new route config. This only affects groups without layouts that have their screens
          // hoisted.
          // Example:
          // - /home/_layout
          // - /home/(a|b|c)/index          --> Hoisted to /home/_layout navigator
          // - /home/(a|b|c)/other          --> Hoisted to /home/_layout navigator
          // - /home/(profile)/me           --> Hoisted to /home/_layout navigator
          //
          // route.push('/home/(a)')        --> This should navigate to /home/(a)/index
          // route.push('/home/(profile)')  --> This should navigate to /home/(profile)/me
          const screens = currentOptions[route.name].screens;
          // Determine what screen the user wants to navigate to. If no screen is specified, assume there is an index screen
          // In the examples above, this ensures that /home/(a) navigates to /home/(a)/index
          const targetScreen =
          // This is typed as unknown, so we need to add these extra assertions
          route.params && 'screen' in route.params && typeof route.params.screen === 'string' ? route.params.screen : 'index';
          // If the target screen is not in the screens object, default to the first screen
          // In the examples above, this ensures that /home/(profile) navigates to /home/(profile)/me
          // As there is no index screen in the group
          const screen = screens ? screens[targetScreen] ? targetScreen : Object.keys(screens)[0] : undefined;
          if (screen && screens && currentOptions[route.name].screens?.[screen]) {
            route = Object.assign({}, screens[screen], {
              name: screen,
              key: screen
            });
            currentOptions = screens;
          } else {
            hasNext = false;
          }
          // hasNext = false;
          // END FORK
        } else {
          index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
          const nextRoute = route.state.routes[index];
          const nestedConfig = currentOptions[route.name].screens;
          // if there is config for next route name, we go deeper
          if (nestedConfig && nextRoute.name in nestedConfig) {
            route = nextRoute;
            currentOptions = nestedConfig;
          } else {
            // If not, there is no sense in going deeper in config
            hasNext = false;
          }
        }
      }
      if (pattern === undefined) {
        pattern = nestedRouteNames.join('/');
      }
      if (currentOptions[route.name] !== undefined) {
        // START FORK
        path += expo.getPathWithConventionsCollapsed(Object.assign({}, options, {
          pattern,
          route,
          params: allParams,
          initialRouteName: configs[route.name]?.initialRouteName
        }));
        // path += pattern
        //   .split('/')
        //   .map((p) => {
        //     const name = getParamName(p);
        //     // We don't know what to show for wildcard patterns
        //     // Showing the route name seems ok, though whatever we show here will be incorrect
        //     // Since the page doesn't actually exist
        //     if (p === '*') {
        //       return route.name;
        //     }
        //     // If the path has a pattern for a param, put the param in the path
        //     if (p.startsWith(':')) {
        //       const value = allParams[name];
        //       if (value === undefined && p.endsWith('?')) {
        //         // Optional params without value assigned in route.params should be ignored
        //         return '';
        //       }
        //       // Valid characters according to
        //       // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
        //       return String(value).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, (char) =>
        //         encodeURIComponent(char)
        //       );
        //     }
        //     return encodeURIComponent(p);
        //   })
        //   .join('/');
        // } else {
      } else if (!route.name.startsWith('+')) {
        path += encodeURIComponent(route.name);
      }
      // END FORK
      if (!focusedParams) {
        focusedParams = focusedRoute.params;
      }
      if (route.state) {
        path += '/';
      } else if (focusedParams) {
        for (const param in focusedParams) {
          if (focusedParams[param] === 'undefined') {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete focusedParams[param];
          }
        }
        // START FORK
        delete focusedParams['#'];
        // END FORK
        const query = queryString.stringify(focusedParams, {
          sort: false
        });
        if (query) {
          path += `?${query}`;
        }
      }
      current = route.state;
    }
    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    // Include the root path if specified
    if (options?.path) {
      path = joinPaths(options.path, path);
    }
    // START FORK
    path = expo.appendBaseUrl(path);
    if (allParams['#']) {
      path += `#${allParams['#']}`;
    }
    // END FORK
    // START FORK
    return {
      path,
      params: allParams
    };
    // END FORK
  }
  // const getParamName = (pattern: string) => pattern.replace(/^:/, '').replace(/\?$/, '');
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  const createConfigItem = (config, parentPattern) => {
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
      return {
        pattern
      };
    }
    if (config.exact && config.path === undefined) {
      throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }
    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    const pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
    const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;
    return {
      // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
      pattern: pattern?.split('/').filter(Boolean).join('/'),
      stringify: config.stringify,
      screens
    };
  };
  const createNormalizedConfigs = (options, pattern) => Object.fromEntries(Object.entries(options).map(([name, c]) => {
    const result = createConfigItem(c, pattern);
    return [name, result];
  }));
  function appendBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return `/${baseUrl.replace(/^\/+/, '').replace(/\/$/, '')}${path}`;
      }
    }
    return path;
  }
},683,[394,658],"node_modules\\expo-router\\build\\fork\\getPathFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["path"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getStateFromPath = getStateFromPath;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const escape_string_regexp_1 = __importDefault(require(_dependencyMap[2], "escape-string-regexp"));
  const findFocusedRoute_1 = require(_dependencyMap[3], "./findFocusedRoute");
  const expo = __importStar(require(_dependencyMap[4], "./getStateFromPath-forks"));
  const constants_1 = require(_dependencyMap[5], "../constants");
  /**
   * Utility to parse a path string to initial state object accepted by the container.
   * This is useful for deep linking when we need to handle the incoming URL.
   *
   * @example
   * ```js
   * getStateFromPath(
   *   '/chat/jane/42',
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         parse: { id: Number }
   *       }
   *     }
   *   }
   * )
   * ```
   * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
   * @param options Extra options to fine-tune how to parse the path.
   */
  function getStateFromPath(path, options,
  // START FORK
  segments = []
  // END FORK
  ) {
    const {
      initialRoutes,
      configs,
      configWithRegexes
    } = getConfigResources(options,
    // START FORK
    segments
    // END FORK
    );
    const screens = options?.screens;
    // START FORK
    const expoPath = expo.getUrlWithReactNavigationConcessions(path);
    // END FORK
    // START FORK
    let remaining = expo.cleanPath(expoPath.nonstandardPathname);
    // let remaining = path
    //   .replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    //   .replace(/^\//, '') // Remove extra leading slash
    //   .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // // Make sure there is a trailing slash
    // remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    // END FORK
    const prefix = options?.path?.replace(/^\//, ''); // Remove extra leading slash
    if (prefix) {
      // Make sure there is a trailing slash
      const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;
      // If the path doesn't start with the prefix, it's not a match
      if (!remaining.startsWith(normalizedPrefix)) {
        return undefined;
      }
      // Remove the prefix from the path
      remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
      // When no config is specified, use the path segments as route names
      const routes = remaining.split('/').filter(Boolean).map(segment => {
        const name = decodeURIComponent(segment);
        return {
          name
        };
      });
      if (routes.length) {
        return createNestedStateObject(expoPath, routes, initialRoutes, [], expoPath.url.hash);
      }
      return undefined;
    }
    if (remaining === '/') {
      // We need to add special handling of empty path so navigation to empty path also works
      // When handling empty path, we should only look at the root level config
      // START FORK
      const match = expo.matchForEmptyPath(configWithRegexes);
      // const match = configs.find(
      //   (config) =>
      //     config.path === '' &&
      //     config.routeNames.every(
      //       // Make sure that none of the parent configs have a non-empty path defined
      //       (name) => !configs.find((c) => c.screen === name)?.path
      //     )
      // );
      // END FORK
      if (match) {
        return createNestedStateObject(expoPath, match.routeNames.map(name => ({
          name
        })), initialRoutes, configs, expoPath.url.hash);
      }
      return undefined;
    }
    let result;
    let current;
    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    const {
      routes,
      remainingPath
    } = matchAgainstConfigs(remaining, configWithRegexes);
    if (routes !== undefined) {
      // This will always be empty if full path matched
      current = createNestedStateObject(expoPath, routes, initialRoutes, configs, expoPath.url.hash);
      remaining = remainingPath;
      result = current;
    }
    if (current == null || result == null) {
      return undefined;
    }
    return result;
  }
  /**
   * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
   */
  let cachedConfigResources = [undefined, prepareConfigResources()];
  function getConfigResources(options,
  // START FORK
  previousSegments
  // END FORK
  ) {
    // START FORK - We need to disable this caching as our configs can change based upon the current state
    // if (cachedConfigResources[0] !== options) {
    cachedConfigResources = [options, prepareConfigResources(options, previousSegments)];
    // }
    // END FORK FORK
    return cachedConfigResources[1];
  }
  function prepareConfigResources(options, previousSegments) {
    if (options) {
      (0, native_1.validatePathConfig)(options);
    }
    const initialRoutes = getInitialRoutes(options);
    const configs = getNormalizedConfigs(initialRoutes, options?.screens, previousSegments);
    checkForDuplicatedConfigs(configs);
    const configWithRegexes = getConfigsWithRegexes(configs);
    return {
      initialRoutes,
      configs,
      configWithRegexes
    };
  }
  function getInitialRoutes(options) {
    const initialRoutes = [];
    if (options?.initialRouteName) {
      initialRoutes.push({
        initialRouteName: options.initialRouteName,
        parentScreens: []
      });
    }
    return initialRoutes;
  }
  function getNormalizedConfigs(initialRoutes, screens = {},
  // START FORK
  previousSegments
  // END FORK
  ) {
    // Create a normalized configs array which will be easier to use
    return [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, [], initialRoutes, []))).map(expo.appendIsInitial(initialRoutes)).sort(expo.getRouteConfigSorter(previousSegments));
    // .sort((a, b) => {
    //   // Sort config so that:
    //   // - the most exhaustive ones are always at the beginning
    //   // - patterns with wildcard are always at the end
    //   // If 2 patterns are same, move the one with less route names up
    //   // This is an error state, so it's only useful for consistent error messages
    //   if (a.pattern === b.pattern) {
    //     return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
    //   }
    //   // If one of the patterns starts with the other, it's more exhaustive
    //   // So move it up
    //   if (a.pattern.startsWith(b.pattern)) {
    //     return -1;
    //   }
    //   if (b.pattern.startsWith(a.pattern)) {
    //     return 1;
    //   }
    //   const aParts = a.pattern.split('/');
    //   const bParts = b.pattern.split('/');
    //   for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
    //     // if b is longer, b get higher priority
    //     if (aParts[i] == null) {
    //       return 1;
    //     }
    //     // if a is longer, a get higher priority
    //     if (bParts[i] == null) {
    //       return -1;
    //     }
    //     const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');
    //     const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');
    //     // if both are wildcard we compare next component
    //     if (aWildCard && bWildCard) {
    //       continue;
    //     }
    //     // if only a is wild card, b get higher priority
    //     if (aWildCard) {
    //       return 1;
    //     }
    //     // if only b is wild card, a get higher priority
    //     if (bWildCard) {
    //       return -1;
    //     }
    //   }
    //   return bParts.length - aParts.length;
    // });
  }
  function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config) => {
      if (acc[config.pattern]) {
        const a = acc[config.pattern].routeNames;
        const b = config.routeNames;
        // It's not a problem if the path string omitted from a inner most screen
        // For example, it's ok if a path resolves to `A > B > C` or `A > B`
        const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);
        if (!intersects) {
          throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
        }
      }
      return Object.assign(acc, {
        [config.pattern]: config
      });
    }, {});
  }
  function getConfigsWithRegexes(configs) {
    return configs.map(c => Object.assign({}, c, {
      // Add `$` to the regex to make sure it matches till end of the path and not just beginning
      // START FORK
      // regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,
      regex: expo.configRegExp(c)
      // END FORK
    }));
  }
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  const matchAgainstConfigs = (remaining, configs) => {
    let routes;
    let remainingPath = remaining;
    // START FORK
    const allParams = Object.create(null);
    // END FORK
    // Go through all configs, and see if the next path segment matches our regex
    for (const config of configs) {
      if (!config.regex) {
        continue;
      }
      const match = remainingPath.match(config.regex);
      // If our regex matches, we need to extract params from the path
      if (match) {
        const matchResult = config.pattern?.split('/').reduce((acc, p, index) => {
          if (!expo.isDynamicPart(p)) {
            return acc;
          }
          acc.pos += 1;
          // START FORK
          const decodedParamSegment = expo.safelyDecodeURIComponent(
          // const decodedParamSegment = decodeURIComponent(
          // The param segments appear every second item starting from 2 in the regex match result
          match[(acc.pos + 1) * 2]
          // Remove trailing slash
          .replace(/\/$/, ''));
          // END FORK
          Object.assign(acc.matchedParams, {
            [p]: Object.assign(acc.matchedParams[p] || {}, {
              [index]: decodedParamSegment
            })
          });
          return acc;
        }, {
          pos: -1,
          matchedParams: {}
        });
        const matchedParams = matchResult.matchedParams || {};
        routes = config.routeNames.map(name => {
          const routeConfig = configs.find(c => {
            // Check matching name AND pattern in case same screen is used at different levels in config
            return c.screen === name && config.pattern.startsWith(c.pattern);
          });
          // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
          const normalizedPath = routeConfig?.path.split('/').filter(Boolean).join('/');
          // Get the number of segments in the initial pattern
          const numInitialSegments = routeConfig?.pattern
          // Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)
          .replace(new RegExp(`${(0, escape_string_regexp_1.default)(normalizedPath)}$`), '')?.split('/').length;
          const params = normalizedPath?.split('/').reduce((acc, p, index) => {
            if (!expo.isDynamicPart(p)) {
              return acc;
            }
            // Get the real index of the path parameter in the matched path
            // by offsetting by the number of segments in the initial pattern
            const offset = numInitialSegments ? numInitialSegments - 1 : 0;
            // START FORK
            // const value = matchedParams[p]?.[index + offset];
            const value = expo.getParamValue(p, matchedParams[p]?.[index + offset]);
            // END FORK
            if (value) {
              // START FORK
              // const key = p.replace(/^:/, '').replace(/\?$/, '');
              const key = expo.replacePart(p);
              // END FORK
              acc[key] = routeConfig?.parse?.[key] ? routeConfig.parse[key](value) : value;
            }
            return acc;
          }, {});
          if (params && Object.keys(params).length) {
            Object.assign(allParams, params);
            return {
              name,
              params
            };
          }
          return {
            name
          };
        });
        remainingPath = remainingPath.replace(match[1], '');
        break;
      }
    }
    // START FORK
    expo.populateParams(routes, allParams);
    // END FORK
    return {
      routes,
      remainingPath
    };
  };
  const createNormalizedConfigs = (screen, routeConfig, routeNames = [], initials, parentScreens, parentPattern) => {
    const configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    // @ts-expect-error: TODO(@kitten): This is entirely untyped. The index access just flags this, but we're not typing the config properly here
    const config = routeConfig[screen];
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
      configs.push(createConfigItem(screen, routeNames, pattern, config));
    } else if (typeof config === 'object') {
      let pattern;
      // if an object is specified as the value (e.g. Foo: { ... }),
      // it can have `path` property and
      // it could have `screens` prop which has nested configs
      if (typeof config.path === 'string') {
        if (config.exact && config.path === undefined) {
          throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
        }
        pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
        if (screen !== constants_1.INTERNAL_SLOT_NAME) {
          configs.push(createConfigItem(screen, routeNames, pattern, config.path, config.parse, config));
        }
      }
      if (config.screens) {
        // property `initialRouteName` without `screens` has no purpose
        if (config.initialRouteName) {
          initials.push({
            initialRouteName: config.initialRouteName,
            parentScreens
          });
        }
        Object.keys(config.screens).forEach(nestedConfig => {
          const result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, [...parentScreens], pattern ?? parentPattern);
          configs.push(...result);
        });
      }
    }
    routeNames.pop();
    return configs;
  };
  const createConfigItem = (screen, routeNames, pattern, path, parse = undefined, config = {}) => {
    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
    pattern = pattern.split('/').filter(Boolean).join('/');
    // START FORK
    const regex = pattern ? expo.routePatternToRegex(pattern) : undefined;
    // const regex = pattern
    //   ? new RegExp(
    //       `^(${pattern
    //         .split('/')
    //         .map((it) => {
    //           if (it.startsWith(':')) {
    //             return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
    //           }
    //           return `${it === '*' ? '.*' : escape(it)}\\/`;
    //         })
    //         .join('')})`
    //     )
    //   : undefined;
    // END FORK
    return Object.assign({
      screen,
      regex,
      pattern,
      path,
      // The routeNames array is mutated, so copy it to keep the current state
      routeNames: [...routeNames],
      parse
    }, expo.createConfig(screen, pattern, routeNames, config));
  };
  const findParseConfigForRoute = (routeName, flatConfig) => {
    for (const config of flatConfig) {
      if (routeName === config.routeNames[config.routeNames.length - 1]) {
        return config.parse;
      }
    }
    return undefined;
  };
  // Try to find an initial route connected with the one passed
  const findInitialRoute = (routeName, parentScreens, initialRoutes) => {
    for (const config of initialRoutes) {
      if (parentScreens.length === config.parentScreens.length) {
        let sameParents = true;
        for (let i = 0; i < parentScreens.length; i++) {
          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
            sameParents = false;
            break;
          }
        }
        if (sameParents) {
          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
        }
      }
    }
    return undefined;
  };
  // returns state object with values depending on whether
  // it is the end of state and if there is initialRoute for this level
  const createStateObject = (initialRoute, route, isEmpty) => {
    if (isEmpty) {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute,
            params: route.params
          }, route]
        };
      } else {
        return {
          routes: [route]
        };
      }
    } else {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute,
            params: route.params
          }, Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      } else {
        return {
          routes: [Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      }
    }
  };
  const createNestedStateObject = (_ref, routes, initialRoutes, flatConfig, hash) => {
    let {
        path
      } = _ref,
      expoURL = _objectWithoutPropertiesLoose(_ref, _excluded);
    let route = routes.shift();
    const parentScreens = [];
    let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    const state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
      let nestedState = state;
      while (route = routes.shift()) {
        initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
        const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
        nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
        if (routes.length > 0) {
          nestedState = nestedState.routes[nestedStateIndex].state;
        }
        parentScreens.push(route.name);
      }
    }
    route = (0, findFocusedRoute_1.findFocusedRoute)(state);
    // START FORK
    route.path = expoURL.pathWithoutGroups;
    // route.path = path;
    // END FORK
    // START FORK
    // const params = parseQueryParams(
    const params = expo.parseQueryParams(path, route, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined, hash);
    // END FORK
    // START FORK
    // expo.handleUrlParams(route, params, hash);
    if (params) {
      route.params = Object.assign({}, route.params, params);
    }
    // END FORK
    return state;
  };
  // START FORK
  // const parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {
  //   const query = path.split('?')[1];
  //   const params = queryString.parse(query);
  //   if (parseConfig) {
  //     Object.keys(params).forEach((name) => {
  //       if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
  //         params[name] = parseConfig[name](params[name] as string);
  //       }
  //     });
  //   }
  //   return Object.keys(params).length ? params : undefined;
  // };
  // END FORK
},684,[29,350,402,685,676,650],"node_modules\\expo-router\\build\\fork\\getStateFromPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Forked so we can access without importing any React Native code in Node.js environments.
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findFocusedRoute = findFocusedRoute;
  function findFocusedRoute(state) {
    let current = state;
    while (current?.routes[current.index ?? 0].state != null) {
      current = current.routes[current.index ?? 0].state;
    }
    const route = current?.routes[current?.index ?? 0];
    return route;
  }
},685,[],"node_modules\\expo-router\\build\\fork\\findFocusedRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.series = void 0;
  exports.useLinking = useLinking;
  exports.getInitialURLWithTimeout = getInitialURLWithTimeout;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const fast_deep_equal_1 = __importDefault(require(_dependencyMap[1], "fast-deep-equal"));
  const React = __importStar(require(_dependencyMap[2], "react"));
  const createMemoryHistory_1 = require(_dependencyMap[3], "./createMemoryHistory");
  const getPathFromState_1 = require(_dependencyMap[4], "./getPathFromState");
  const serverLocationContext_1 = require(_dependencyMap[5], "../global-state/serverLocationContext");
  const storeContext_1 = require(_dependencyMap[6], "../global-state/storeContext");
  /**
   * Find the matching navigation state that changed between 2 navigation states
   * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state
   */
  const findMatchingState = (a, b) => {
    if (a === undefined || b === undefined || a.key !== b.key) {
      return [undefined, undefined];
    }
    // Tab and drawer will have `history` property, but stack will have history in `routes`
    const aHistoryLength = a.history ? a.history.length : a.routes.length;
    const bHistoryLength = b.history ? b.history.length : b.routes.length;
    const aRoute = a.routes[a.index];
    const bRoute = b.routes[b.index];
    const aChildState = aRoute.state;
    const bChildState = bRoute.state;
    // Stop here if this is the state object that changed:
    // - history length is different
    // - focused routes are different
    // - one of them doesn't have child state
    // - child state keys are different
    if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {
      return [a, b];
    }
    return findMatchingState(aChildState, bChildState);
  };
  /**
   * Run async function in series as it's called.
   */
  const series = cb => {
    let queue = Promise.resolve();
    const callback = () => {
      queue = queue.then(cb);
    };
    return callback;
  };
  exports.series = series;
  const linkingHandlers = [];
  function useLinking(ref, {
    enabled = true,
    config,
    getStateFromPath = native_1.getStateFromPath,
    getPathFromState = native_1.getPathFromState,
    getActionFromState = native_1.getActionFromState
  }, onUnhandledLinking) {
    const independent = (0, native_1.useNavigationIndependentTree)();
    const store = (0, storeContext_1.useExpoRouterStore)();
    React.useEffect(() => {
      if (process.env.NODE_ENV === 'production') {
        return undefined;
      }
      if (independent) {
        return undefined;
      }
      if (enabled !== false && linkingHandlers.length) {
        console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered'].join('\n').trim());
      }
      const handler = Symbol();
      if (enabled !== false) {
        linkingHandlers.push(handler);
      }
      return () => {
        const index = linkingHandlers.indexOf(handler);
        if (index > -1) {
          linkingHandlers.splice(index, 1);
        }
      };
    }, [enabled, independent]);
    const [history] = React.useState(createMemoryHistory_1.createMemoryHistory);
    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    const enabledRef = React.useRef(enabled);
    const configRef = React.useRef(config);
    const getStateFromPathRef = React.useRef(getStateFromPath);
    const getPathFromStateRef = React.useRef(getPathFromState);
    const getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(() => {
      enabledRef.current = enabled;
      configRef.current = config;
      getStateFromPathRef.current = getStateFromPath;
      getPathFromStateRef.current = getPathFromState;
      getActionFromStateRef.current = getActionFromState;
    });
    const validateRoutesNotExistInRootState = React.useCallback(state => {
      // START FORK
      // Instead of using the rootState (which might be stale) we should use the focused state
      // const navigation = ref.current;
      // const rootState = navigation?.getRootState();
      const rootState = store.state;
      // END FORK
      // Make sure that the routes in the state exist in the root navigator
      // Otherwise there's an error in the linking configuration
      return state?.routes.some(r => !rootState?.routeNames.includes(r.name));
    }, [ref]);
    const server = React.use(serverLocationContext_1.ServerContext);
    const getInitialState = React.useCallback(() => {
      let value;
      if (enabledRef.current) {
        const location = server?.location ?? (typeof window !== 'undefined' ? window.location : undefined);
        const path = location ? location.pathname + location.search : undefined;
        if (path) {
          value = getStateFromPathRef.current(path, configRef.current);
        }
        // If the link were handled, it gets cleared in NavigationContainer
        onUnhandledLinking(path);
      }
      const thenable = {
        then(onfulfilled) {
          return Promise.resolve(onfulfilled ? onfulfilled(value) : value);
        },
        catch() {
          return thenable;
        }
      };
      return thenable;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const previousIndexRef = React.useRef(undefined);
    const previousStateRef = React.useRef(undefined);
    const pendingPopStatePathRef = React.useRef(undefined);
    React.useEffect(() => {
      previousIndexRef.current = history.index;
      return history.listen(() => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const {
          location
        } = window;
        const path = location.pathname + location.search + location.hash;
        const index = history.index;
        const previousIndex = previousIndexRef.current ?? 0;
        previousIndexRef.current = index;
        pendingPopStatePathRef.current = path;
        // When browser back/forward is clicked, we first need to check if state object for this index exists
        // If it does we'll reset to that state object
        // Otherwise, we'll handle it like a regular deep link
        const record = history.get(index);
        if (record?.path === path && record?.state) {
          navigation.resetRoot(record.state);
          return;
        }
        const state = getStateFromPathRef.current(path, configRef.current);
        // We should only dispatch an action when going forward
        // Otherwise the action will likely add items to history, which would mess things up
        if (state) {
          // If the link were handled, it gets cleared in NavigationContainer
          onUnhandledLinking(path);
          // Make sure that the routes in the state exist in the root navigator
          // Otherwise there's an error in the linking configuration
          if (validateRoutesNotExistInRootState(state)) {
            return;
          }
          if (index > previousIndex || (
          /* START FORK
           *
           * This is a workaround for React Navigation's handling of hashes (it doesn't handle them)
           * When you click on <a href="#hash">, the browser will first fire a popstate event
           * and this callback will be called.
           *
           * From React Navigation's perspective, it's treating the new hash change like a back/forward
           * button press, so it thinks it should reset the state. When we should
           * be to be pushing the new state
           *
           * Our fix is to check if the index is the same as the previous index
           * and if the incoming path is the same as the old path but with the hash added,
           * then treat it as a push instead of a reset
           *
           * This also works for subsequent hash changes, as internally RN
           * doesn't store the hash in the history state.
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent
           */
          index === previousIndex && (!record || `${record?.path}${location.hash}` === path))
          // END FORK
          ) {
            const action = getActionFromStateRef.current(state, configRef.current);
            if (action !== undefined) {
              try {
                navigation.dispatch(action);
              } catch (e) {
                // Ignore any errors from deep linking.
                // This could happen in case of malformed links, navigation object not being initialized etc.
                console.warn(`An error occurred when trying to handle the link '${path}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
              }
            } else {
              navigation.resetRoot(state);
            }
          } else {
            navigation.resetRoot(state);
          }
        } else {
          // if current path didn't return any state, we should revert to initial state
          navigation.resetRoot(state);
        }
      });
    }, [enabled, history, onUnhandledLinking, ref, validateRoutesNotExistInRootState]);
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const getPathForRoute = (route, state) => {
        let path;
        // If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match
        // This makes sure that we preserve the original URL for wildcard routes
        if (route?.path) {
          const stateForPath = getStateFromPathRef.current(route.path, configRef.current);
          if (stateForPath) {
            const focusedRoute = (0, native_1.findFocusedRoute)(stateForPath);
            if (focusedRoute && focusedRoute.name === route.name && (0, fast_deep_equal_1.default)(Object.assign({}, focusedRoute.params), Object.assign({}, route.params))) {
              // START FORK - Ensure paths coming from events (e.g refresh) have the base URL
              // path = route.path;
              path = (0, getPathFromState_1.appendBaseUrl)(route.path);
              // END FORK
            }
          }
        }
        if (path == null) {
          path = getPathFromStateRef.current(state, configRef.current);
        }
        // START FORK - ExpoRouter manually handles hashes. This code is intentionally removed
        // const previousRoute = previousStateRef.current
        //   ? findFocusedRoute(previousStateRef.current)
        //   : undefined;
        // Preserve the hash if the route didn't change
        // if (
        //   previousRoute &&
        //   route &&
        //   'key' in previousRoute &&
        //   'key' in route &&
        //   previousRoute.key === route.key
        // ) {
        //   path = path + location.hash;
        // }
        // END FORK
        return path;
      };
      if (ref.current) {
        // We need to record the current metadata on the first render if they aren't set
        // This will allow the initial state to be in the history entry
        // START FORK
        // Instead of using the rootState (which might be stale) we should use the focused state
        // const state = ref.current.getRootState();
        const rootState = ref.current.getRootState();
        const state = store.state;
        // END FORK
        if (state) {
          const route = (0, native_1.findFocusedRoute)(state);
          const path = getPathForRoute(route, state);
          if (previousStateRef.current === undefined) {
            // START FORK
            // previousStateRef.current = state;
            previousStateRef.current = rootState;
            // END FORK
          }
          history.replace({
            path,
            state
          });
        }
      }
      const onStateChange = async () => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const previousState = previousStateRef.current;
        // START FORK
        // Instead of using the rootState (which might be stale) we should use the focused state
        // const state = navigation.getRootState();
        const rootState = navigation.getRootState();
        const state = store.state;
        // END FORK
        // root state may not available, for example when root navigators switch inside the container
        if (!state) {
          return;
        }
        const pendingPath = pendingPopStatePathRef.current;
        const route = (0, native_1.findFocusedRoute)(state);
        const path = getPathForRoute(route, state);
        // START FORK
        // previousStateRef.current = state;
        previousStateRef.current = rootState;
        // END FORK
        pendingPopStatePathRef.current = undefined;
        // To detect the kind of state change, we need to:
        // - Find the common focused navigation state in previous and current state
        // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace
        // - If no common focused navigation state found, it's a replace
        const [previousFocusedState, focusedState] = findMatchingState(previousState, state);
        if (previousFocusedState && focusedState &&
        // We should only handle push/pop if path changed from what was in last `popstate`
        // Otherwise it's likely a change triggered by `popstate`
        path !== pendingPath) {
          const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
          if (historyDelta > 0) {
            // If history length is increased, we should pushState
            // Note that path might not actually change here, for example, drawer open should pushState
            history.push({
              path,
              state
            });
          } else if (historyDelta < 0) {
            // If history length is decreased, i.e. entries were removed, we want to go back
            const nextIndex = history.backIndex({
              path
            });
            const currentIndex = history.index;
            try {
              if (nextIndex !== -1 && nextIndex < currentIndex &&
              // We should only go back if the entry exists and it's less than current index
              history.get(nextIndex - currentIndex)) {
                // An existing entry for this path exists and it's less than current index, go back to that
                await history.go(nextIndex - currentIndex);
              } else {
                // We couldn't find an existing entry to go back to, so we'll go back by the delta
                // This won't be correct if multiple routes were pushed in one go before
                // Usually this shouldn't happen and this is a fallback for that
                await history.go(historyDelta);
              }
              // Store the updated state as well as fix the path if incorrect
              history.replace({
                path,
                state
              });
            } catch {
              // The navigation was interrupted
            }
          } else {
            // If history length is unchanged, we want to replaceState
            history.replace({
              path,
              state
            });
          }
        } else {
          // If no common navigation state was found, assume it's a replace
          // This would happen if the user did a reset/conditionally changed navigators
          history.replace({
            path,
            state
          });
        }
      };
      // We debounce onStateChange coz we don't want multiple state changes to be handled at one time
      // This could happen since `history.go(n)` is asynchronous
      // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up
      return ref.current?.addListener('state', (0, exports.series)(onStateChange));
    }, [enabled, history, ref]);
    return {
      getInitialState
    };
  }
  function getInitialURLWithTimeout() {
    return typeof window === 'undefined' ? '' : window.location.href;
  }
},686,[350,459,3,687,683,688,588],"node_modules\\expo-router\\build\\fork\\useLinking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createMemoryHistory = createMemoryHistory;
  const non_secure_1 = require(_dependencyMap[0], "nanoid/non-secure");
  function createMemoryHistory() {
    let index = 0;
    let items = [];
    // Pending callbacks for `history.go(n)`
    // We might modify the callback stored if it was interrupted, so we have a ref to identify it
    const pending = [];
    const interrupt = () => {
      // If another history operation was performed we need to interrupt existing ones
      // This makes sure that calls such as `history.replace` after `history.go` don't happen
      // Since otherwise it won't be correct if something else has changed
      pending.forEach(it => {
        const cb = it.cb;
        it.cb = () => cb(true);
      });
    };
    const history = {
      get index() {
        // We store an id in the state instead of an index
        // Index could get out of sync with in-memory values if page reloads
        const id = window.history.state?.id;
        if (id) {
          const index = items.findIndex(item => item.id === id);
          return index > -1 ? index : 0;
        }
        return 0;
      },
      get(index) {
        return items[index];
      },
      backIndex({
        path
      }) {
        // We need to find the index from the element before current to get closest path to go back to
        for (let i = index - 1; i >= 0; i--) {
          const item = items[i];
          if (item.path === path) {
            return i;
          }
        }
        return -1;
      },
      push({
        path,
        state
      }) {
        interrupt();
        const id = (0, non_secure_1.nanoid)();
        // When a new entry is pushed, all the existing entries after index will be inaccessible
        // So we remove any existing entries after the current index to clean them up
        items = items.slice(0, index + 1);
        items.push({
          path,
          state,
          id
        });
        index = items.length - 1;
        // We pass empty string for title because it's ignored in all browsers except safari
        // We don't store state object in history.state because:
        // - browsers have limits on how big it can be, and we don't control the size
        // - while not recommended, there could be non-serializable data in state
        window.history.pushState({
          id
        }, '', path);
      },
      replace({
        path,
        state
      }) {
        interrupt();
        const id = window.history.state?.id ?? (0, non_secure_1.nanoid)();
        // Need to keep the hash part of the path if there was no previous history entry
        // or the previous history entry had the same path
        let pathWithHash = path;
        const hash = pathWithHash.includes('#') ? '' : location.hash;
        if (!items.length || items.findIndex(item => item.id === id) < 0) {
          // There are two scenarios for creating an array with only one history record:
          // - When loaded id not found in the items array, this function by default will replace
          //   the first item. We need to keep only the new updated object, otherwise it will break
          //   the page when navigating forward in history.
          // - This is the first time any state modifications are done
          //   So we need to push the entry as there's nothing to replace
          pathWithHash = pathWithHash + hash;
          items = [{
            path: pathWithHash,
            state,
            id
          }];
          index = 0;
        } else {
          if (items[index].path === path) {
            pathWithHash = pathWithHash + hash;
          }
          items[index] = {
            path,
            state,
            id
          };
        }
        window.history.replaceState({
          id
        }, '', pathWithHash);
      },
      // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
      // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
      // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.
      // - the `popstate` event fires before the next frame after calling `history.go(n)`.
      // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.
      go(n) {
        interrupt();
        // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory
        // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.
        const nextIndex = index + n;
        const lastItemIndex = items.length - 1;
        if (n < 0 && !items[nextIndex]) {
          // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.
          n = -index;
          index = 0;
        } else if (n > 0 && nextIndex > lastItemIndex) {
          // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.
          n = lastItemIndex - index;
          index = lastItemIndex;
        } else {
          index = nextIndex;
        }
        if (n === 0) {
          return;
        }
        // When we call `history.go`, `popstate` will fire when there's history to go back to
        // So we need to somehow handle following cases:
        // - There's history to go back, `history.go` is called, and `popstate` fires
        // - `history.go` is called multiple times, we need to resolve on respective `popstate`
        // - No history to go back, but `history.go` was called, browser has no API to detect it
        return new Promise((resolve, reject) => {
          const done = interrupted => {
            clearTimeout(timer);
            if (interrupted) {
              reject(new Error('History was changed during navigation.'));
              return;
            }
            // There seems to be a bug in Chrome regarding updating the title
            // If we set a title just before calling `history.go`, the title gets lost
            // However the value of `document.title` is still what we set it to
            // It's just not displayed in the tab bar
            // To update the tab bar, we need to reset the title to something else first (e.g. '')
            // And set the title to what it was before so it gets applied
            // It won't work without setting it to empty string coz otherwise title isn't changing
            // Which means that the browser won't do anything after setting the title
            const {
              title
            } = window.document;
            window.document.title = '';
            window.document.title = title;
            resolve();
          };
          pending.push({
            ref: done,
            cb: done
          });
          // If navigation didn't happen within 100ms, assume that it won't happen
          // This may not be accurate, but hopefully it won't take so much time
          // In Chrome, navigation seems to happen instantly in next microtask
          // But on Firefox, it seems to take much longer, around 50ms from our testing
          // We're using a hacky timeout since there doesn't seem to be way to know for sure
          const timer = setTimeout(() => {
            const index = pending.findIndex(it => it.ref === done);
            if (index > -1) {
              pending[index].cb();
              pending.splice(index, 1);
            }
          }, 100);
          const onPopState = () => {
            const id = window.history.state?.id;
            const currentIndex = items.findIndex(item => item.id === id);
            // Fix createMemoryHistory.index variable's value
            // as it may go out of sync when navigating in the browser.
            index = Math.max(currentIndex, 0);
            const last = pending.pop();
            window.removeEventListener('popstate', onPopState);
            last?.cb();
          };
          window.addEventListener('popstate', onPopState);
          window.history.go(n);
        });
      },
      // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`
      // If we call `history.go(n)` ourselves, we don't want it to trigger the listener
      // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener
      listen(listener) {
        const onPopState = () => {
          if (pending.length) {
            // This was triggered by `history.go(n)`, we shouldn't call the listener
            return;
          }
          listener();
        };
        window.addEventListener('popstate', onPopState);
        return () => window.removeEventListener('popstate', onPopState);
      }
    };
    return history;
  }
},687,[900],"node_modules\\expo-router\\build\\fork\\createMemoryHistory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ServerContext = void 0;
  // This is file should mirror https://github.com/react-navigation/react-navigation/blob/6.x/packages/native/src/ServerContext.tsx
  const react_1 = require(_dependencyMap[0], "react");
  exports.ServerContext = (0, react_1.createContext)(undefined);
},688,[3],"node_modules\\expo-router\\build\\global-state\\serverLocationContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getIgnoreList = exports.extrapolateGroups = exports.generateDynamic = void 0;
  exports.getRoutes = getRoutes;
  exports.getExactRoutes = getExactRoutes;
  const getRoutesCore_1 = require(_dependencyMap[0], "./getRoutesCore");
  /**
   * Given a Metro context module, return an array of nested routes.
   *
   * This is a two step process:
   *  1. Convert the RequireContext keys (file paths) into a directory tree.
   *      - This should extrapolate array syntax into multiple routes
   *      - Routes are given a specificity score
   *  2. Flatten the directory tree into routes
   *      - Routes in directories without _layout files are hoisted to the nearest _layout
   *      - The name of the route is relative to the nearest _layout
   *      - If multiple routes have the same name, the most specific route is used
   */
  function getRoutes(contextModule, options = {}) {
    return (0, getRoutesCore_1.getRoutes)(contextModule, Object.assign({
      getSystemRoute({
        route,
        type
      }, defaults) {
        if (route === '' && type === 'layout') {
          // Root layout when no layout is defined.
          return {
            type: 'layout',
            loadRoute: () => ({
              default: require(_dependencyMap[1], "./views/Navigator").DefaultNavigator
            }),
            // Generate a fake file name for the directory
            contextKey: 'expo-router/build/views/Navigator.js',
            route: '',
            generated: true,
            dynamic: null,
            children: []
          };
        } else if (route === '_sitemap' && type === 'route') {
          return {
            loadRoute() {
              const {
                Sitemap,
                getNavOptions
              } = require(_dependencyMap[2], "./views/Sitemap");
              return {
                default: Sitemap,
                getNavOptions
              };
            },
            route: '_sitemap',
            type: 'route',
            contextKey: 'expo-router/build/views/Sitemap.js',
            generated: true,
            internal: true,
            dynamic: null,
            children: []
          };
        } else if (route === '+not-found' && type === 'route') {
          return {
            loadRoute() {
              return {
                default: require(_dependencyMap[3], "./views/Unmatched").Unmatched
              };
            },
            type: 'route',
            route: '+not-found',
            contextKey: 'expo-router/build/views/Unmatched.js',
            generated: true,
            internal: true,
            dynamic: [{
              name: '+not-found',
              deep: true,
              notFound: true
            }],
            children: []
          };
        } else if ((type === 'redirect' || type === 'rewrite') && defaults) {
          return Object.assign({}, defaults, {
            loadRoute() {
              return require(_dependencyMap[4], "./getRoutesRedirects").getRedirectModule(route);
            }
          });
        }
        throw new Error(`Unknown system route: ${route} and type: ${type}`);
      }
    }, options));
  }
  function getExactRoutes(contextModule, options = {}) {
    return getRoutes(contextModule, Object.assign({}, options, {
      skipGenerated: true
    }));
  }
  var getRoutesCore_2 = require(_dependencyMap[0], "./getRoutesCore");
  Object.defineProperty(exports, "generateDynamic", {
    enumerable: true,
    get: function () {
      return getRoutesCore_2.generateDynamic;
    }
  });
  Object.defineProperty(exports, "extrapolateGroups", {
    enumerable: true,
    get: function () {
      return getRoutesCore_2.extrapolateGroups;
    }
  });
  Object.defineProperty(exports, "getIgnoreList", {
    enumerable: true,
    get: function () {
      return getRoutesCore_2.getIgnoreList;
    }
  });
},689,[690,692,694,703,679],"node_modules\\expo-router\\build\\getRoutes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getRoutes = getRoutes;
  exports.getIgnoreList = getIgnoreList;
  exports.extrapolateGroups = extrapolateGroups;
  exports.generateDynamic = generateDynamic;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  const url_1 = require(_dependencyMap[1], "./utils/url");
  const validPlatforms = new Set(['android', 'ios', 'native', 'web']);
  /**
   * Given a Metro context module, return an array of nested routes.
   *
   * This is a two step process:
   *  1. Convert the RequireContext keys (file paths) into a directory tree.
   *      - This should extrapolate array syntax into multiple routes
   *      - Routes are given a specificity score
   *  2. Flatten the directory tree into routes
   *      - Routes in directories without _layout files are hoisted to the nearest _layout
   *      - The name of the route is relative to the nearest _layout
   *      - If multiple routes have the same name, the most specific route is used
   */
  function getRoutes(contextModule, options) {
    const directoryTree = getDirectoryTree(contextModule, options);
    // If there are no routes
    if (!directoryTree) {
      return null;
    }
    const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);
    if (!options.ignoreEntryPoints) {
      crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);
    }
    return rootNode;
  }
  /**
   * Converts the RequireContext keys (file paths) into a directory tree.
   */
  function getDirectoryTree(contextModule, options) {
    const importMode = options.importMode || "sync";
    const ignoreList = [/^\.\/\+(html|native-intent)\.[tj]sx?$/]; // Ignore the top level ./+html file
    if (options.ignore) {
      ignoreList.push(...options.ignore);
    }
    if (!options.preserveApiRoutes) {
      ignoreList.push(/\+api$/, /\+api\.[tj]sx?$/);
    }
    const rootDirectory = {
      files: new Map(),
      subdirectories: new Map()
    };
    let hasRoutes = false;
    let isValid = false;
    const contextKeys = contextModule.keys();
    const redirects = {};
    const rewrites = {};
    let validRedirectDestinations;
    // If we are keeping redirects as valid routes, then we need to add them to the contextKeys
    // This is useful for generating a sitemap with redirects, or static site generation that includes redirects
    if (options.preserveRedirectAndRewrites) {
      if (options.redirects) {
        for (const redirect of options.redirects) {
          // Remove the leading `./` or `/`
          const source = redirect.source.replace(/^\.?\//, '');
          const isExternalRedirect = (0, url_1.shouldLinkExternally)(redirect.destination);
          const targetDestination = isExternalRedirect ? redirect.destination : (0, matchers_1.stripInvisibleSegmentsFromPath)((0, matchers_1.removeFileSystemDots)((0, matchers_1.removeFileSystemExtensions)(redirect.destination.replace(/^\.?\/?/, ''))));
          const normalizedSource = (0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(source));
          if (ignoreList.some(regex => regex.test(normalizedSource))) {
            continue;
          }
          // Loop over this once and cache the valid destinations
          validRedirectDestinations ??= contextKeys.map(key => {
            return [(0, matchers_1.stripInvisibleSegmentsFromPath)((0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(key))), key];
          });
          const destination = isExternalRedirect ? targetDestination : validRedirectDestinations.find(key => key[0] === targetDestination)?.[1];
          if (!destination) {
            /*
             * Only throw the error when we are preserving the api routes
             * When doing a static export, API routes will not exist so the redirect destination may not exist.
             * The desired behavior for this error is to warn the user when running `expo start`, so its ok if
             * `expo export` swallows this error.
             */
            if (options.preserveApiRoutes) {
              throw new Error(`Redirect destination "${redirect.destination}" does not exist.`);
            }
            continue;
          }
          const fakeContextKey = (0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(source));
          contextKeys.push(fakeContextKey);
          redirects[fakeContextKey] = {
            source,
            destination,
            permanent: Boolean(redirect.permanent),
            external: isExternalRedirect,
            methods: redirect.methods
          };
        }
      }
      if (options.rewrites) {
        for (const rewrite of options.rewrites) {
          // Remove the leading `./` or `/`
          const source = rewrite.source.replace(/^\.?\//, '');
          const targetDestination = (0, matchers_1.stripInvisibleSegmentsFromPath)((0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(rewrite.destination)));
          const normalizedSource = (0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(source));
          if (ignoreList.some(regex => regex.test(normalizedSource))) {
            continue;
          }
          // Loop over this once and cache the valid destinations
          validRedirectDestinations ??= contextKeys.map(key => {
            return [(0, matchers_1.stripInvisibleSegmentsFromPath)((0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(key))), key];
          });
          const destination = validRedirectDestinations.find(key => key[0] === targetDestination)?.[1];
          if (!destination) {
            /*
             * Only throw the error when we are preserving the api routes
             * When doing a static export, API routes will not exist so the redirect destination may not exist.
             * The desired behavior for this error is to warn the user when running `expo start`, so its ok if
             * `expo export` swallows this error.
             */
            if (options.preserveApiRoutes) {
              throw new Error(`Redirect destination "${rewrite.destination}" does not exist.`);
            }
            continue;
          }
          // Add a fake context key
          const fakeContextKey = `./${source}.tsx`;
          contextKeys.push(fakeContextKey);
          rewrites[fakeContextKey] = {
            source,
            destination,
            methods: rewrite.methods
          };
        }
      }
    }
    for (const filePath of contextKeys) {
      if (ignoreList.some(regex => regex.test(filePath))) {
        continue;
      }
      isValid = true;
      const meta = getFileMeta(filePath, options, redirects, rewrites);
      // This is a file that should be ignored. e.g maybe it has an invalid platform?
      if (meta.specificity < 0) {
        continue;
      }
      let node = {
        type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',
        loadRoute() {
          let routeModule;
          if (options.ignoreRequireErrors) {
            try {
              routeModule = contextModule(filePath);
            } catch {
              routeModule = {};
            }
          } else {
            routeModule = contextModule(filePath);
          }
          if (process.env.NODE_ENV === 'development' && importMode === 'sync') {
            // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.
            // This can be useful when you accidentally use an async function in a route file for the default export.
            if (routeModule instanceof Promise) {
              throw new Error(`Route "${filePath}" cannot be a promise when async routes is disabled.`);
            }
            const defaultExport = routeModule?.default;
            if (defaultExport instanceof Promise) {
              throw new Error(`The default export from route "${filePath}" is a promise. Ensure the React Component does not use async or promises.`);
            }
            // check if default is an async function without invoking it
            if (defaultExport instanceof Function &&
            // This only works on web because Hermes support async functions so we have to transform them out.
            defaultExport.constructor.name === 'AsyncFunction') {
              throw new Error(`The default export from route "${filePath}" is an async function. Ensure the React Component does not use async or promises.`);
            }
          }
          return routeModule;
        },
        contextKey: filePath,
        route: '',
        // This is overwritten during hoisting based upon the _layout
        dynamic: null,
        children: [] // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting
      };
      if (meta.isRedirect) {
        node.destinationContextKey = redirects[filePath].destination;
        node.permanent = redirects[filePath].permanent;
        node.generated = true;
        if (node.type === 'route') {
          node = options.getSystemRoute({
            type: 'redirect',
            route: (0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(node.destinationContextKey))
          }, node);
        }
        if (redirects[filePath].methods) {
          node.methods = redirects[filePath].methods;
        }
        node.type = 'redirect';
      }
      if (meta.isRewrite) {
        node.destinationContextKey = rewrites[filePath].destination;
        node.generated = true;
        if (node.type === 'route') {
          node = options.getSystemRoute({
            type: 'rewrite',
            route: (0, matchers_1.removeFileSystemDots)((0, matchers_1.removeSupportedExtensions)(node.destinationContextKey))
          }, node);
        }
        if (redirects[filePath].methods) {
          node.methods = redirects[filePath].methods;
        }
        node.type = 'rewrite';
      }
      if (process.env.NODE_ENV === 'development') {
        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should
        // filter the missing routes.
        if (node.type !== 'api' && importMode === 'sync') {
          const routeItem = node.loadRoute();
          // Have a warning for nullish ex
          const route = routeItem?.default;
          if (route == null) {
            // Do not throw an error since a user may just be creating a new route.
            console.warn(`Route "${filePath}" is missing the required default export. Ensure a React component is exported as default.`);
            continue;
          }
          if (['boolean', 'number', 'string'].includes(typeof route)) {
            throw new Error(`The default export from route "${filePath}" is an unsupported type: "${typeof route}". Only React Components are supported as default exports from route files.`);
          }
        }
      }
      /**
       * A single filepath may be extrapolated into multiple routes if it contains array syntax.
       * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.
       */
      for (const route of extrapolateGroups(meta.route)) {
        // Traverse the directory tree to its leaf node, creating any missing directories along the way
        const subdirectoryParts = route.split('/').slice(0, -1);
        // Start at the root directory and traverse the path to the leaf directory
        let directory = rootDirectory;
        for (const part of subdirectoryParts) {
          let subDirectory = directory.subdirectories.get(part);
          // Create any missing subdirectories
          if (!subDirectory) {
            subDirectory = {
              files: new Map(),
              subdirectories: new Map()
            };
            directory.subdirectories.set(part, subDirectory);
          }
          directory = subDirectory;
        }
        // Clone the node for this route
        node = Object.assign({}, node, {
          route
        });
        if (meta.isLayout) {
          directory.layout ??= [];
          const existing = directory.layout[meta.specificity];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The layouts "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            node = getLayoutNode(node, options);
            directory.layout[meta.specificity] = node;
          }
        } else if (meta.isApi) {
          const fileKey = `${route}+api`;
          let nodes = directory.files.get(fileKey);
          if (!nodes) {
            nodes = [];
            directory.files.set(fileKey, nodes);
          }
          // API Routes have no specificity, they are always the first node
          const existing = nodes[0];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The API route file "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            nodes[0] = node;
          }
        } else {
          let nodes = directory.files.get(route);
          if (!nodes) {
            nodes = [];
            directory.files.set(route, nodes);
          }
          /**
           * If there is an existing node with the same specificity, then we have a conflict.
           * NOTE(Platform Routes):
           *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!
           *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.
           */
          const existing = nodes[meta.specificity];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The route files "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            hasRoutes ||= true;
            nodes[meta.specificity] = node;
          }
        }
      }
    }
    // If there are no routes/layouts then we should display the tutorial.
    if (!isValid) {
      return null;
    }
    /**
     * If there are no top-level _layout, add a default _layout
     * While this is a generated route, it will still be generated even if skipGenerated is true.
     */
    if (!rootDirectory.layout) {
      rootDirectory.layout = [options.getSystemRoute({
        type: 'layout',
        route: ''
      })];
    }
    // Only include the sitemap if there are routes.
    if (!options.skipGenerated) {
      if (hasRoutes && options.sitemap !== false) {
        appendSitemapRoute(rootDirectory, options);
      }
      if (options.notFound !== false) {
        appendNotFoundRoute(rootDirectory, options);
      }
    }
    return rootDirectory;
  }
  /**
   * Flatten the directory tree into routes, hoisting routes to the nearest _layout.
   */
  function flattenDirectoryTreeToRoutes(directory, options, /* The nearest _layout file in the directory tree */
  layout, /* Route names are relative to their layout */
  pathToRemove = '') {
    /**
     * This directory has a _layout file so it becomes the new target for hoisting routes.
     */
    if (directory.layout) {
      const previousLayout = layout;
      layout = getMostSpecific(directory.layout);
      // Add the new layout as a child of its parent
      if (previousLayout) {
        previousLayout.children.push(layout);
      }
      if (options.internal_stripLoadRoute) {
        delete layout.loadRoute;
      }
      // `route` is the absolute pathname. We need to make this relative to the last _layout
      const newRoute = layout.route.replace(pathToRemove, '');
      pathToRemove = layout.route ? `${layout.route}/` : '';
      // Now update this layout with the new relative route and dynamic conventions
      layout.route = newRoute;
      layout.dynamic = generateDynamic(layout.contextKey.slice(0));
    }
    // This should never occur as there will always be a root layout, but it makes the type system happy
    if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');
    for (const routes of directory.files.values()) {
      const routeNode = getMostSpecific(routes);
      // `route` is the absolute pathname. We need to make this relative to the nearest layout
      routeNode.route = routeNode.route.replace(pathToRemove, '');
      routeNode.dynamic = generateDynamic(routeNode.route);
      if (options.internal_stripLoadRoute) {
        delete routeNode.loadRoute;
      }
      layout.children.push(routeNode);
    }
    // Recursively flatten the subdirectories
    for (const child of directory.subdirectories.values()) {
      flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);
    }
    return layout;
  }
  function getFileMeta(originalKey, options, redirects, rewrites) {
    // Remove the leading `./`
    const key = (0, matchers_1.removeSupportedExtensions)((0, matchers_1.removeFileSystemDots)(originalKey));
    let route = key;
    const parts = (0, matchers_1.removeFileSystemDots)(originalKey).split('/');
    const filename = parts[parts.length - 1];
    const [filenameWithoutExtensions, platformExtension] = (0, matchers_1.removeSupportedExtensions)(filename).split('.');
    const isLayout = filenameWithoutExtensions === '_layout';
    const isApi = originalKey.match(/\+api\.(\w+\.)?[jt]sx?$/);
    if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {
      throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);
    }
    // Nested routes cannot start with the '+' character, except for the '+not-found' route
    if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {
      const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');
      throw new Error(`Invalid route ${originalKey}. Route nodes cannot start with the '+' character. "Rename it to ${renamedRoute}"`);
    }
    let specificity = 0;
    const hasPlatformExtension = validPlatforms.has(platformExtension);
    const usePlatformRoutes = options.platformRoutes ?? true;
    if (hasPlatformExtension) {
      if (!usePlatformRoutes) {
        // If the user has disabled platform routes, then we should ignore this file
        specificity = -1;
      } else if (!options.platform) {
        // If we don't have a platform, then we should ignore this file
        // This used by typed routes, sitemap, etc
        specificity = -1;
      } else if (platformExtension === options.platform) {
        // If the platform extension is the same as the options.platform, then it is the most specific
        specificity = 2;
      } else if (platformExtension === 'native' && options.platform !== 'web') {
        // `native` is allow but isn't as specific as the platform
        specificity = 1;
      } else if (platformExtension !== options.platform) {
        // Somehow we have a platform extension that doesn't match the options.platform and it isn't native
        // This is an invalid file and we will ignore it
        specificity = -1;
      }
      if (isApi && specificity !== 0) {
        throw new Error(`API routes cannot have platform extensions. Remove '.${platformExtension}' from '${originalKey}'`);
      }
      route = route.replace(new RegExp(`.${platformExtension}$`), '');
    }
    return {
      route,
      specificity,
      isLayout,
      isApi,
      isRedirect: key in redirects,
      isRewrite: key in rewrites
    };
  }
  function getIgnoreList(options) {
    const ignore = [/^\.\/\+html\.[tj]sx?$/, ...(options?.ignore ?? [])];
    if (options?.preserveApiRoutes !== true) {
      ignore.push(/\+api\.[tj]sx?$/);
    }
    return ignore;
  }
  /**
   * Generates a set of strings which have the router array syntax extrapolated.
   *
   * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])
   */
  function extrapolateGroups(key, keys = new Set()) {
    const match = (0, matchers_1.matchArrayGroupName)(key);
    if (!match) {
      keys.add(key);
      return keys;
    }
    const groups = match.split(',');
    const groupsSet = new Set(groups);
    if (groupsSet.size !== groups.length) {
      throw new Error(`Array syntax cannot contain duplicate group name "${groups}" in "${key}".`);
    }
    if (groups.length === 1) {
      keys.add(key);
      return keys;
    }
    for (const group of groups) {
      extrapolateGroups(key.replace(match, group.trim()), keys);
    }
    return keys;
  }
  function generateDynamic(path) {
    const dynamic = path.split('/').map(part => {
      if (part === '+not-found') {
        return {
          name: '+not-found',
          deep: true,
          notFound: true
        };
      }
      return (0, matchers_1.matchDynamicName)(part) ?? null;
    }).filter(part => !!part);
    return dynamic.length === 0 ? null : dynamic;
  }
  function appendSitemapRoute(directory, options) {
    if (!directory.files.has('_sitemap') && options.getSystemRoute) {
      directory.files.set('_sitemap', [options.getSystemRoute({
        type: 'route',
        route: '_sitemap'
      })]);
    }
  }
  function appendNotFoundRoute(directory, options) {
    if (!directory.files.has('+not-found') && options.getSystemRoute) {
      directory.files.set('+not-found', [options.getSystemRoute({
        type: 'route',
        route: '+not-found'
      })]);
    }
  }
  function getLayoutNode(node, options) {
    /**
     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.
     * Each of these layouts will have a different anchor based upon the first group name.
     */
    // We may strip loadRoute during testing
    const groupName = (0, matchers_1.matchLastGroupName)(node.route);
    const childMatchingGroup = node.children.find(child => {
      return child.route.replace(/\/index$/, '') === groupName;
    });
    let anchor = childMatchingGroup?.route;
    const loaded = node.loadRoute();
    if (loaded?.unstable_settings) {
      try {
        // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.
        anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;
      } catch (error) {
        if (error instanceof Error) {
          if (!error.message.match(/You cannot dot into a client module/)) {
            throw error;
          }
        }
      }
      if (groupName) {
        // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.
        const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;
        anchor = groupSpecificInitialRouteName ?? anchor;
      }
    }
    return Object.assign({}, node, {
      route: node.route.replace(/\/?_layout$/, ''),
      children: [],
      // Each layout should have its own children
      initialRouteName: anchor
    });
  }
  function crawlAndAppendInitialRoutesAndEntryFiles(node, options, entryPoints = []) {
    if (node.type === 'route') {
      node.entryPoints = [...new Set([...entryPoints, node.contextKey])];
    } else if (node.type === 'redirect') {
      node.entryPoints = [...new Set([...entryPoints, node.destinationContextKey])];
    } else if (node.type === 'layout') {
      if (!node.children) {
        throw new Error(`Layout "${node.contextKey}" does not contain any child routes`);
      }
      // Every node below this layout will have it as an entryPoint
      entryPoints = [...entryPoints, node.contextKey];
      /**
       * Calculate the initialRouteNode
       *
       * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.
       * Each of these layouts will have a different anchor based upon the first group.
       */
      const groupName = (0, matchers_1.matchGroupName)(node.route);
      const childMatchingGroup = node.children.find(child => {
        return child.route.replace(/\/index$/, '') === groupName;
      });
      let anchor = childMatchingGroup?.route;
      // We may strip loadRoute during testing
      if (!options.internal_stripLoadRoute) {
        const loaded = node.loadRoute();
        if (loaded?.unstable_settings) {
          try {
            // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.
            anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;
          } catch (error) {
            if (error instanceof Error) {
              if (!error.message.match(/You cannot dot into a client module/)) {
                throw error;
              }
            }
          }
          if (groupName) {
            // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.
            const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;
            anchor = groupSpecificInitialRouteName ?? anchor;
          }
        }
      }
      if (anchor) {
        const anchorRoute = node.children.find(child => child.route === anchor);
        if (!anchorRoute) {
          const validAnchorRoutes = node.children.filter(child => !child.generated).map(child => `'${child.route}'`).join(', ');
          if (groupName) {
            throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`);
          } else {
            throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`);
          }
        }
        // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints
        node.initialRouteName = anchor;
        entryPoints.push(anchorRoute.contextKey);
      }
      for (const child of node.children) {
        crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);
      }
    }
  }
  function getMostSpecific(routes) {
    const route = routes[routes.length - 1];
    if (!routes[0]) {
      throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);
    }
    // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)
    // `.length` includes the holes in its count
    return routes[routes.length - 1];
  }
},690,[585,691],"node_modules\\expo-router\\build\\getRoutesCore.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hasUrlProtocolPrefix = hasUrlProtocolPrefix;
  exports.isWellKnownUri = isWellKnownUri;
  exports.shouldLinkExternally = shouldLinkExternally;
  /**
   * Does the input string start with a valid URL scheme.
   * NOTE: Additional strictness added to ensure URLs sent in query parameters for in-app navigation are not matched.
   */
  function hasUrlProtocolPrefix(href) {
    return /^([\w\d_+.-]+:)?\/\//.test(href);
  }
  function isWellKnownUri(href) {
    // This is a hack and we should change this to work like the web in the future where we have full confidence in the
    // ability to match URLs and send anything unmatched to the OS. The main difference between this and `hasUrlProtocolPrefix` is
    // that we don't require `//`, e.g. `mailto:` is valid and common, and `mailto://bacon` is invalid.
    return /^(https?|mailto|tel|sms|geo|maps|market|itmss?|itms-apps|content|file):/.test(href);
  }
  function shouldLinkExternally(href) {
    // Cheap check first to avoid regex if the href is not a path fragment.
    return !href.startsWith('.') && (hasUrlProtocolPrefix(href) || isWellKnownUri(href));
  }
},691,[],"node_modules\\expo-router\\build\\utils\\url.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright  2024 650 Industries.
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\Navigator.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigatorContext = void 0;
  exports.Navigator = Navigator;
  exports.useNavigatorContext = useNavigatorContext;
  exports.Slot = Slot;
  exports.DefaultNavigator = DefaultNavigator;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const React = __importStar(require(_dependencyMap[2], "react"));
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_is_edge_to_edge_1 = require(_dependencyMap[3], "react-native-is-edge-to-edge");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  const Screen_1 = require(_dependencyMap[5], "./Screen");
  const Route_1 = require(_dependencyMap[6], "../Route");
  const StackClient_1 = require(_dependencyMap[7], "../layouts/StackClient");
  const withLayoutContext_1 = require(_dependencyMap[8], "../layouts/withLayoutContext");
  const useScreens_1 = require(_dependencyMap[9], "../useScreens");
  exports.NavigatorContext = React.createContext(null);
  if (process.env.NODE_ENV !== 'production') {
    exports.NavigatorContext.displayName = 'NavigatorContext';
  }
  /**
   * An unstyled custom navigator. Good for basic web layouts.
   *
   * @hidden
   */
  function Navigator({
    initialRouteName,
    screenOptions,
    children,
    router,
    routerOptions
  }) {
    const contextKey = (0, Route_1.useContextKey)();
    // A custom navigator can have a mix of Screen and other components (like a Slot inside a View)
    const {
      screens,
      children: nonScreenChildren,
      protectedScreens
    } = (0, withLayoutContext_1.useFilterScreenChildren)(children, {
      isCustomNavigator: true,
      contextKey
    });
    const sortedScreens = (0, useScreens_1.useSortedScreens)(screens ?? [], protectedScreens);
    router ||= StackClient_1.StackRouter;
    const navigation = (0, native_1.useNavigationBuilder)(router, Object.assign({}, routerOptions, {
      id: contextKey,
      children: sortedScreens || [_reactNativeCssInteropJsxRuntime.jsx(Screen_1.Screen, {}, "default")],
      screenOptions,
      initialRouteName
    }));
    // useNavigationBuilder requires at least one screen to be defined otherwise it will throw.
    if (!sortedScreens.length) {
      console.warn(`Navigator at "${contextKey}" has no children.`);
      return null;
    }
    return _reactNativeCssInteropJsxRuntime.jsx(exports.NavigatorContext.Provider, {
      value: Object.assign({}, navigation, {
        contextKey,
        router
      }),
      children: nonScreenChildren
    });
  }
  /**
   * @hidden
   */
  function useNavigatorContext() {
    const context = React.use(exports.NavigatorContext);
    if (!context) {
      throw new Error('useNavigatorContext must be used within a <Navigator />');
    }
    return context;
  }
  function SlotNavigator(props) {
    const contextKey = (0, Route_1.useContextKey)();
    // Allows adding Screen components as children to configure routes.
    const {
      screens,
      protectedScreens
    } = (0, withLayoutContext_1.useFilterScreenChildren)([], {
      contextKey
    });
    const {
      state,
      descriptors,
      NavigationContent
    } = (0, native_1.useNavigationBuilder)(StackClient_1.StackRouter, Object.assign({}, props, {
      id: contextKey,
      children: (0, useScreens_1.useSortedScreens)(screens ?? [], protectedScreens)
    }));
    return _reactNativeCssInteropJsxRuntime.jsx(NavigationContent, {
      children: descriptors[state.routes[state.index].key].render()
    });
  }
  /**
   * Renders the currently selected content.
   *
   * There are actually two different implementations of `<Slot/>`:
   *  - Used inside a `_layout` as the `Navigator`
   *  - Used inside a `Navigator` as the content
   *
   * Since a custom `Navigator` will set the `NavigatorContext.contextKey` to
   * the current `_layout`, you can use this to determine if you are inside
   * a custom navigator or not.
   */
  function Slot(props) {
    const contextKey = (0, Route_1.useContextKey)();
    const context = React.use(exports.NavigatorContext);
    if (context?.contextKey !== contextKey) {
      // The _layout has changed since the last navigator
      return _reactNativeCssInteropJsxRuntime.jsx(SlotNavigator, Object.assign({}, props));
    }
    /*
     * The user has defined a custom navigator
     * <Navigator><Slot /></Navigator>
     */
    return _reactNativeCssInteropJsxRuntime.jsx(NavigatorSlot, {});
  }
  /**
   * Render the current navigator content.
   */
  function NavigatorSlot() {
    const context = useNavigatorContext();
    const {
      state,
      descriptors
    } = context;
    return descriptors[state.routes[state.index].key]?.render() ?? null;
  }
  const SlotNavigatorWrapper = false && (0, react_native_is_edge_to_edge_1.isEdgeToEdge)() ? react_1.Fragment : react_native_safe_area_context_1.SafeAreaView;
  /**
   * The default navigator for the app when no root _layout is provided.
   */
  function DefaultNavigator() {
    return _reactNativeCssInteropJsxRuntime.jsx(SlotNavigatorWrapper, {
      style: {
        flex: 1
      },
      children: _reactNativeCssInteropJsxRuntime.jsx(SlotNavigator, {})
    });
  }
  Navigator.Slot = NavigatorSlot;
  Navigator.useContext = useNavigatorContext;
  /** Used to configure route settings. */
  Navigator.Screen = Screen_1.Screen;
},692,[2,350,3,920,893,648,584,537,583,587],"node_modules\\expo-router\\build\\views\\Navigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright  2024 650 Industries.
  'use client';

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[1], "react-native-css-interop/jsx-runtime");
  const _excluded = ["style", "leftIcon", "rightIcon", "filename", "level", "info"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\Sitemap.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNavOptions = getNavOptions;
  exports.Sitemap = Sitemap;
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  const Pressable_1 = require(_dependencyMap[5], "./Pressable");
  const useSitemap_1 = require(_dependencyMap[6], "./useSitemap");
  const Link_1 = require(_dependencyMap[7], "../link/Link");
  const statusbar_1 = require(_dependencyMap[8], "../utils/statusbar");
  const INDENT = 20;
  function getNavOptions() {
    return {
      title: 'sitemap',
      presentation: 'modal',
      headerLargeTitle: false,
      headerTitleStyle: {
        color: 'white'
      },
      headerTintColor: 'white',
      headerLargeTitleStyle: {
        color: 'white'
      },
      headerStyle: {
        backgroundColor: 'black',
        // @ts-expect-error: mistyped
        borderBottomColor: '#323232'
      },
      header: () => {
        const WrapperElement = react_native_1.Platform.OS === 'android' ? react_native_safe_area_context_1.SafeAreaView : react_native_1.View;
        return _reactNativeCssInteropJsxRuntime.jsx(WrapperElement, {
          style: styles.header,
          children: _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
            style: styles.headerContent,
            children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
              style: styles.headerIcon,
              children: _reactNativeCssInteropJsxRuntime.jsx(SitemapIcon, {})
            }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
              role: "heading",
              "aria-level": 1,
              style: styles.title,
              children: "Sitemap"
            })]
          })
        });
      }
    };
  }
  function Sitemap() {
    const sitemap = (0, useSitemap_1.useSitemap)();
    const children = react_1.default.useMemo(() => sitemap?.children.filter(({
      isInternal
    }) => !isInternal) ?? [], [sitemap]);
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
      style: styles.container,
      children: [statusbar_1.canOverrideStatusBarBehavior && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.StatusBar, {
        barStyle: "light-content"
      }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.ScrollView, {
        contentContainerStyle: styles.scroll,
        children: children.map(child => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
          testID: "sitemap-item-container",
          style: styles.itemContainer,
          children: _reactNativeCssInteropJsxRuntime.jsx(SitemapItem, {
            node: child
          })
        }, child.contextKey))
      })]
    });
  }
  function SitemapItem({
    node,
    level = 0
  }) {
    const isLayout = react_1.default.useMemo(() => node.children.length > 0 || node.contextKey.match(/_layout\.[jt]sx?$/), [node]);
    const info = node.isInitial ? 'Initial' : node.isGenerated ? 'Generated' : '';
    if (isLayout) {
      return _reactNativeCssInteropJsxRuntime.jsx(LayoutSitemapItem, {
        node: node,
        level: level,
        info: info
      });
    }
    return _reactNativeCssInteropJsxRuntime.jsx(StandardSitemapItem, {
      node: node,
      level: level,
      info: info
    });
  }
  function LayoutSitemapItem({
    node,
    level,
    info
  }) {
    const [isCollapsed, setIsCollapsed] = react_1.default.useState(true);
    return _reactNativeCssInteropJsxRuntime.jsxs(_reactNativeCssInteropJsxRuntime.Fragment, {
      children: [_reactNativeCssInteropJsxRuntime.jsx(SitemapItemPressable, {
        style: {
          opacity: 0.4
        },
        leftIcon: _reactNativeCssInteropJsxRuntime.jsx(PkgIcon, {}),
        rightIcon: _reactNativeCssInteropJsxRuntime.jsx(ArrowIcon, {
          rotation: isCollapsed ? 0 : 180
        }),
        filename: node.filename,
        level: level,
        info: info,
        onPress: () => setIsCollapsed(prev => !prev)
      }), !isCollapsed && node.children.map(child => _reactNativeCssInteropJsxRuntime.jsx(SitemapItem, {
        node: child,
        level: level + (node.isGenerated ? 0 : 1)
      }, child.contextKey))]
    });
  }
  function StandardSitemapItem({
    node,
    info,
    level
  }) {
    return _reactNativeCssInteropJsxRuntime.jsx(Link_1.Link, {
      accessibilityLabel: node.contextKey,
      href: node.href,
      asChild: true
      // Ensure we replace the history so you can't go back to this page.
      ,
      replace: true,
      children: _reactNativeCssInteropJsxRuntime.jsx(SitemapItemPressable, {
        leftIcon: _reactNativeCssInteropJsxRuntime.jsx(FileIcon, {}),
        rightIcon: _reactNativeCssInteropJsxRuntime.jsx(ForwardIcon, {}),
        filename: node.filename,
        level: level,
        info: info
      })
    });
  }
  function SitemapItemPressable(_ref) {
    let {
        style,
        leftIcon,
        rightIcon,
        filename,
        level,
        info
      } = _ref,
      pressableProps = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, Object.assign({}, pressableProps, {
      children: ({
        pressed,
        hovered
      }) => _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
        testID: "sitemap-item",
        style: [styles.itemPressable, {
          paddingLeft: INDENT + level * INDENT,
          backgroundColor: hovered ? '#202425' : 'transparent'
        }, pressed && {
          backgroundColor: '#26292b'
        }, style],
        children: [_reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
          style: {
            flexDirection: 'row',
            alignItems: 'center'
          },
          children: [leftIcon, _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: styles.filename,
            children: filename
          })]
        }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
          style: {
            flexDirection: 'row',
            alignItems: 'center'
          },
          children: [!!info && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: [styles.virtual, {
              marginRight: 8
            }],
            children: info
          }), rightIcon]
        })]
      })
    }));
  }
  function FileIcon() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[9], "expo-router/assets/file.png")
    });
  }
  function PkgIcon() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[10], "expo-router/assets/pkg.png")
    });
  }
  function ForwardIcon() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[11], "expo-router/assets/forward.png")
    });
  }
  function SitemapIcon() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[12], "expo-router/assets/sitemap.png")
    });
  }
  function ArrowIcon({
    rotation = 0
  }) {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      style: [styles.image, {
        transform: [{
          rotate: `${rotation}deg`
        }]
      }],
      source: require(_dependencyMap[13], "expo-router/assets/arrow_down.png")
    });
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      backgroundColor: 'black',
      flex: 1,
      alignItems: 'stretch'
    },
    header: {
      backgroundColor: '#151718',
      paddingVertical: 16,
      borderBottomWidth: 1,
      borderColor: '#313538',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 3
      },
      shadowOpacity: 0.33,
      shadowRadius: 3,
      elevation: 8
    },
    headerContent: Object.assign({
      flexDirection: 'row',
      alignItems: 'center',
      gap: 14,
      paddingHorizontal: '5%'
    }, react_native_1.Platform.select({
      web: {
        width: '100%',
        maxWidth: 960,
        marginHorizontal: 'auto'
      }
    })),
    title: {
      color: 'white',
      fontSize: 28,
      fontWeight: 'bold'
    },
    scroll: Object.assign({
      paddingHorizontal: '5%',
      paddingVertical: 16
    }, react_native_1.Platform.select({
      ios: {
        paddingBottom: 24
      },
      web: {
        width: '100%',
        maxWidth: 960,
        marginHorizontal: 'auto',
        paddingBottom: 24
      },
      default: {
        paddingBottom: 12
      }
    })),
    itemContainer: {
      borderWidth: 1,
      borderColor: '#313538',
      backgroundColor: '#151718',
      borderRadius: 12,
      marginBottom: 12,
      overflow: 'hidden'
    },
    itemPressable: Object.assign({
      paddingHorizontal: INDENT,
      paddingVertical: 16,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center'
    }, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    })),
    filename: {
      color: 'white',
      fontSize: 20,
      marginLeft: 12
    },
    virtual: {
      textAlign: 'right',
      color: 'white'
    },
    image: {
      width: 24,
      height: 24,
      resizeMode: 'contain',
      opacity: 0.6
    },
    headerIcon: {
      width: 40,
      height: 40,
      backgroundColor: '#202425',
      borderRadius: 8,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center'
    }
  });
},694,[29,2,3,16,893,695,696,654,697,698,699,700,701,702],"node_modules\\expo-router\\build\\views\\Sitemap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Pressable = void 0;
  const react_native_1 = require(_dependencyMap[0], "react-native-web/dist/index");
  exports.Pressable = react_native_1.Pressable;
},695,[16],"node_modules\\expo-router\\build\\views\\Pressable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSitemap = useSitemap;
  const react_1 = require(_dependencyMap[0], "react");
  const Route_1 = require(_dependencyMap[1], "../Route");
  const router_store_1 = require(_dependencyMap[2], "../global-state/router-store");
  const matchers_1 = require(_dependencyMap[3], "../matchers");
  const routeSegments = (route, parents) => [...parents, ...route.route.split('/')];
  const routeHref = (route, parents) => '/' + routeSegments(route, parents).map(segment => {
    // add an extra layer of entropy to the url for deep dynamic routes
    if ((0, matchers_1.matchDynamicName)(segment)?.deep) {
      return segment + '/' + Date.now();
    }
    // index must be erased but groups can be preserved.
    return segment === 'index' ? '' : segment;
  }).filter(Boolean).join('/');
  const routeFilename = route => {
    const segments = route.contextKey.split('/');
    // join last two segments for layout routes
    if (route.contextKey.match(/_layout\.[jt]sx?$/)) {
      return segments[segments.length - 2] + '/' + segments[segments.length - 1];
    }
    const routeSegmentsCount = route.route.split('/').length;
    // Join the segment count in reverse order
    // This presents files without layout routes as children with all relevant segments.
    return segments.slice(-routeSegmentsCount).join('/');
  };
  const mapForRoute = (route, parents) => ({
    contextKey: route.contextKey,
    filename: routeFilename(route),
    href: routeHref(route, parents),
    isInitial: route.initialRouteName === route.route,
    isInternal: route.internal ?? false,
    isGenerated: route.generated ?? false,
    children: [...route.children].sort(Route_1.sortRoutes).map(child => mapForRoute(child, routeSegments(route, parents)))
  });
  function useSitemap() {
    const sitemap = (0, react_1.useMemo)(() => router_store_1.store.routeNode ? mapForRoute(router_store_1.store.routeNode, []) : null, [router_store_1.store.routeNode]);
    return sitemap;
  }
},696,[3,584,671,585],"node_modules\\expo-router\\build\\views\\useSitemap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.canOverrideStatusBarBehavior = void 0;
  const expo_constants_1 = __importDefault(require(_dependencyMap[0], "expo-constants"));
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const react_native_is_edge_to_edge_1 = require(_dependencyMap[2], "react-native-is-edge-to-edge");
  const hasViewControllerBasedStatusBarAppearance = react_native_1.Platform.OS === 'ios' && !!expo_constants_1.default.expoConfig?.ios?.infoPlist?.UIViewControllerBasedStatusBarAppearance;
  exports.canOverrideStatusBarBehavior = !(0, react_native_is_edge_to_edge_1.isEdgeToEdge)() && !hasViewControllerBasedStatusBarAppearance;
},697,[672,16,920],"node_modules\\expo-router\\build\\utils\\statusbar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/file.png",
    width: 48,
    height: 48
  };
},698,[],"node_modules\\expo-router\\assets\\file.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/pkg.png",
    width: 48,
    height: 48
  };
},699,[],"node_modules\\expo-router\\assets\\pkg.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/forward.png",
    width: 48,
    height: 48
  };
},700,[],"node_modules\\expo-router\\assets\\forward.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/sitemap.png",
    width: 48,
    height: 48
  };
},701,[],"node_modules\\expo-router\\assets\\sitemap.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/arrow_down.png",
    width: 48,
    height: 48
  };
},702,[],"node_modules\\expo-router\\assets\\arrow_down.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright  2024 650 Industries.
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\Unmatched.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Unmatched = Unmatched;
  const expo_linking_1 = require(_dependencyMap[1], "expo-linking");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const hooks_1 = require(_dependencyMap[4], "../hooks");
  const Link_1 = require(_dependencyMap[5], "../link/Link");
  const useNavigation_1 = require(_dependencyMap[6], "../useNavigation");
  const Pressable_1 = require(_dependencyMap[7], "../views/Pressable");
  const useLayoutEffect = typeof window !== 'undefined' ? react_1.default.useLayoutEffect : function () {};
  /**
   * Default screen for unmatched routes.
   *
   * @hidden
   */
  function Unmatched() {
    const [render, setRender] = react_1.default.useState(false);
    const router = (0, hooks_1.useRouter)();
    const navigation = (0, useNavigation_1.useNavigation)();
    const pathname = (0, hooks_1.usePathname)();
    const url = (0, expo_linking_1.createURL)(pathname);
    react_1.default.useEffect(() => {
      setRender(true);
    }, []);
    useLayoutEffect(() => {
      navigation.setOptions({
        title: 'Not Found'
      });
    }, [navigation]);
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
      style: styles.container,
      children: [_reactNativeCssInteropJsxRuntime.jsx(NotFoundAsset, {}), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        role: "heading",
        "aria-level": 1,
        style: styles.title,
        children: "Unmatched Route"
      }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        role: "heading",
        "aria-level": 2,
        style: [styles.subtitle, styles.secondaryText],
        children: "Page could not be found."
      }), render ? _reactNativeCssInteropJsxRuntime.jsx(Link_1.Link, Object.assign({
        href: pathname,
        replace: true
      }, react_native_1.Platform.select({
        native: {
          asChild: true
        }
      }), {
        children: _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
          children: ({
            hovered,
            pressed
          }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: [styles.pageLink, styles.secondaryText, react_native_1.Platform.select({
              web: {
                transitionDuration: '200ms',
                opacity: 1
              }
            }), hovered && {
              opacity: 0.8,
              textDecorationLine: 'underline'
            }, pressed && {
              opacity: 0.8
            }],
            children: url
          })
        })
      })) : _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
        style: [styles.pageLink, styles.placeholder]
      }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
        style: styles.linkContainer,
        children: [_reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
          children: ({
            hovered,
            pressed
          }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            onPress: () => {
              if (router.canGoBack()) {
                router.back();
              } else {
                router.replace('/');
              }
            },
            style: [styles.link, react_native_1.Platform.select({
              web: {
                transitionDuration: '200ms',
                opacity: 1
              }
            }), hovered && {
              opacity: 0.8,
              textDecorationLine: 'underline'
            }, pressed && {
              opacity: 0.8
            }],
            children: "Go back"
          })
        }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
          style: [styles.linkSeparator, styles.secondaryText],
          children: "\u2022"
        }), _reactNativeCssInteropJsxRuntime.jsx(Link_1.Link, Object.assign({
          href: "/_sitemap",
          replace: true
        }, react_native_1.Platform.select({
          native: {
            asChild: true
          }
        }), {
          children: _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
            children: ({
              hovered,
              pressed
            }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
              style: [styles.link, react_native_1.Platform.select({
                web: {
                  transitionDuration: '200ms',
                  opacity: 1
                }
              }), hovered && {
                opacity: 0.8,
                textDecorationLine: 'underline'
              }, pressed && {
                opacity: 0.8
              }],
              children: "Sitemap"
            })
          })
        }))]
      })]
    });
  }
  function NotFoundAsset() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
      source: require(_dependencyMap[8], "expo-router/assets/unmatched.png"),
      style: styles.image
    });
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: 'black',
      padding: 24,
      paddingBottom: 64,
      alignItems: 'center',
      justifyContent: 'center'
    },
    image: {
      width: 270,
      height: 168,
      resizeMode: 'contain',
      marginBottom: 28
    },
    title: Object.assign({}, react_native_1.Platform.select({
      web: {
        fontSize: 64,
        lineHeight: 64
      },
      default: {
        fontSize: 56,
        lineHeight: 56
      }
    }), {
      color: '#fff',
      fontWeight: '800',
      textAlign: 'center'
    }),
    subtitle: {
      fontSize: 34,
      marginTop: 4,
      marginBottom: 12,
      fontWeight: '200',
      textAlign: 'center'
    },
    pageLink: {
      minHeight: 20
    },
    secondaryText: {
      color: '#9ba1a6'
    },
    placeholder: {
      backgroundColor: '#9ba1a644',
      minWidth: 180,
      borderRadius: 5
    },
    linkContainer: {
      marginTop: 28,
      flexDirection: 'row',
      gap: 12
    },
    link: {
      fontSize: 20,
      textAlign: 'center',
      color: '#52a9ff'
    },
    linkSeparator: {
      fontSize: 20
    }
  });
},703,[2,664,3,16,680,654,649,695,704],"node_modules\\expo-router\\build\\views\\Unmatched.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/unmatched.png",
    width: 436,
    height: 266
  };
},704,[],"node_modules\\expo-router\\assets\\unmatched.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.defaultRouteInfo = void 0;
  exports.getRouteInfoFromState = getRouteInfoFromState;
  const constants_1 = require(_dependencyMap[0], "../constants");
  const getPathFromState_forks_1 = require(_dependencyMap[1], "../fork/getPathFromState-forks");
  exports.defaultRouteInfo = {
    unstable_globalHref: '',
    searchParams: new URLSearchParams(),
    pathname: '/',
    params: {},
    segments: [],
    pathnameWithParams: '/',
    // TODO: Remove this, it is not used anywhere
    isIndex: false
  };
  function getRouteInfoFromState(state) {
    if (!state) return exports.defaultRouteInfo;
    let route = state.routes[0];
    if (route.name !== constants_1.INTERNAL_SLOT_NAME) {
      throw new Error(`Expected the first route to be ${constants_1.INTERNAL_SLOT_NAME}, but got ${route.name}`);
    }
    state = route.state;
    const segments = [];
    const params = Object.create(null);
    while (state) {
      route = state.routes['index' in state && state.index ? state.index : 0];
      Object.assign(params, route.params);
      let routeName = route.name;
      if (routeName.startsWith('/')) {
        routeName = routeName.slice(1);
      }
      segments.push(...routeName.split('/'));
      state = route.state;
    }
    /**
     * If React Navigation didn't render the entire tree (e.g it was interrupted in a layout)
     * then the state maybe incomplete. The reset of the path is in the params, instead of being a route
     */
    let routeParams = route.params;
    while (routeParams && 'screen' in routeParams) {
      if (typeof routeParams.screen === 'string') {
        const screen = routeParams.screen.startsWith('/') ? routeParams.screen.slice(1) : routeParams.screen;
        segments.push(...screen.split('/'));
      }
      if (typeof routeParams.params === 'object' && !Array.isArray(routeParams.params)) {
        routeParams = routeParams.params;
      } else {
        routeParams = undefined;
      }
    }
    if (route.params && 'screen' in route.params && route.params.screen === 'string') {
      const screen = route.params.screen.startsWith('/') ? route.params.screen.slice(1) : route.params.screen;
      segments.push(...screen.split('/'));
    }
    if (segments[segments.length - 1] === 'index') {
      segments.pop();
    }
    delete params['screen'];
    delete params['params'];
    const pathParams = new Set();
    const pathname = '/' + segments.filter(segment => {
      return !(segment.startsWith('(') && segment.endsWith(')'));
    }).flatMap(segment => {
      if (segment === '+not-found') {
        const notFoundPath = params['not-found'];
        pathParams.add('not-found');
        if (typeof notFoundPath === 'undefined') {
          // Not founds are optional, do nothing if its not present
          return [];
        } else if (Array.isArray(notFoundPath)) {
          return notFoundPath;
        } else {
          return [notFoundPath];
        }
      } else if (segment.startsWith('[...') && segment.endsWith(']')) {
        let paramName = segment.slice(4, -1);
        // Legacy for React Navigation optional params
        if (paramName.endsWith('?')) {
          paramName = paramName.slice(0, -1);
        }
        const values = params[paramName];
        pathParams.add(paramName);
        // Catchall params are optional
        return values || [];
      } else if (segment.startsWith('[') && segment.endsWith(']')) {
        const paramName = segment.slice(1, -1);
        const value = params[paramName];
        pathParams.add(paramName);
        // Optional params are optional
        return value ? [value] : [];
      } else {
        return [segment];
      }
    }).join('/');
    const searchParams = new URLSearchParams(Object.entries(params).flatMap(([key, value]) => {
      // Search params should not include path params
      if (pathParams.has(key)) {
        return [];
      } else if (Array.isArray(value)) {
        return value.map(v => [key, v]);
      }
      return [[key, value]];
    }));
    let hash;
    if (searchParams.has('#')) {
      hash = searchParams.get('#') || undefined;
      searchParams.delete('#');
    }
    // We cannot use searchParams.size because it is not included in the React Native polyfill
    const searchParamString = searchParams.toString();
    let pathnameWithParams = searchParamString ? pathname + '?' + searchParamString : pathname;
    pathnameWithParams = hash ? pathnameWithParams + '#' + hash : pathnameWithParams;
    return {
      segments,
      pathname,
      params,
      unstable_globalHref: (0, getPathFromState_forks_1.appendBaseUrl)(pathnameWithParams),
      searchParams,
      pathnameWithParams,
      // TODO: Remove this, it is not used anywhere
      isIndex: false
    };
  }
},705,[650,658],"node_modules\\expo-router\\build\\global-state\\routeInfo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEffect = useFocusEffect;
  // A fork of `useFocusEffect` that waits for the navigation state to load before
  // running the effect. This is especially useful for native redirects.
  const React = __importStar(require(_dependencyMap[0], "react"));
  const useLoadedNavigation_1 = require(_dependencyMap[1], "./link/useLoadedNavigation");
  /**
   * Hook to run an effect whenever a route is **focused**. Similar to
   * [`React.useEffect`](https://react.dev/reference/react/useEffect).
   *
   * This can be used to perform side-effects such as fetching data or subscribing to events.
   * The passed callback should be wrapped in [`React.useCallback`](https://react.dev/reference/react/useCallback)
   * to avoid running the effect too often.
   *
   * @example
   * ```tsx
   * import { useFocusEffect } from 'expo-router';
   * import { useCallback } from 'react';
   *
   * export default function Route() {
   *   useFocusEffect(
   *     // Callback should be wrapped in `React.useCallback` to avoid running the effect too often.
   *     useCallback(() => {
   *       // Invoked whenever the route is focused.
   *       console.log("Hello, I'm focused!");
   *
   *       // Return function is invoked whenever the route gets out of focus.
   *       return () => {
   *         console.log('This route is now unfocused.');
   *       };
   *     }, []),
   *    );
   *
   *  return </>;
   * }
   *```
   *
   * @param effect Memoized callback containing the effect, should optionally return a cleanup function.
   * @param do_not_pass_a_second_prop
   */
  function useFocusEffect(effect, do_not_pass_a_second_prop) {
    const navigation = (0, useLoadedNavigation_1.useOptionalNavigation)();
    if (do_not_pass_a_second_prop !== undefined) {
      const message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
      console.error(message);
    }
    React.useEffect(() => {
      if (!navigation) {
        return;
      }
      let isFocused = false;
      let cleanup;
      const callback = () => {
        const destroy = effect();
        if (destroy === undefined || typeof destroy === 'function') {
          return destroy;
        }
        if (process.env.NODE_ENV !== 'production') {
          let message = 'An effect function must not return anything besides a function, which is used for clean-up.';
          if (destroy === null) {
            message += " You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).";
          } else if (typeof destroy.then === 'function') {
            message += "\n\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. " + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    async function fetchData() {\n' + '      // You can await here\n' + '      const response = await MyAPI.getData(someId);\n' + '      // ...\n' + '    }\n\n' + '    fetchData();\n' + '  }, [someId])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
          } else {
            message += ` You returned '${JSON.stringify(destroy)}'.`;
          }
          console.error(message);
        }
      };
      // We need to run the effect on initial render/dep changes if the screen is focused
      if (navigation.isFocused()) {
        cleanup = callback();
        isFocused = true;
      }
      const unsubscribeFocus = navigation.addListener('focus', () => {
        // If callback was already called for focus, avoid calling it again
        // The focus event may also fire on initial render, so we guard against running the effect twice
        if (isFocused) {
          return;
        }
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = callback();
        isFocused = true;
      });
      const unsubscribeBlur = navigation.addListener('blur', () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = undefined;
        isFocused = false;
      });
      return () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [effect, navigation]);
  }
},706,[3,707],"node_modules\\expo-router\\build\\useFocusEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLoadedNavigation = useLoadedNavigation;
  exports.useOptionalNavigation = useOptionalNavigation;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = require(_dependencyMap[1], "react");
  const router_store_1 = require(_dependencyMap[2], "../global-state/router-store");
  /** Returns a callback which is invoked when the navigation state has loaded. */
  function useLoadedNavigation() {
    const navigation = (0, native_1.useNavigation)();
    const isMounted = (0, react_1.useRef)(true);
    const pending = (0, react_1.useRef)([]);
    (0, react_1.useEffect)(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    const flush = (0, react_1.useCallback)(() => {
      if (isMounted.current) {
        const pendingCallbacks = pending.current;
        pending.current = [];
        pendingCallbacks.forEach(callback => {
          callback(navigation);
        });
      }
    }, [navigation]);
    (0, react_1.useEffect)(() => {
      if (router_store_1.store.navigationRef.current) {
        flush();
      }
    }, [flush]);
    const push = (0, react_1.useCallback)(fn => {
      pending.current.push(fn);
      if (router_store_1.store.navigationRef.current) {
        flush();
      }
    }, [flush]);
    return push;
  }
  function useOptionalNavigation() {
    const [navigation, setNavigation] = (0, react_1.useState)(null);
    const loadNavigation = useLoadedNavigation();
    (0, react_1.useEffect)(() => {
      loadNavigation(nav => setNavigation(nav));
    }, []);
    return navigation;
  }
},707,[350,3,671],"node_modules\\expo-router\\build\\link\\useLoadedNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useHrefAttrs = void 0;
  exports.useInteropClassName = useInteropClassName;
  // Fork of @react-navigation/native Link.tsx with `href` and `replace` support added and
  // `to` / `action` support removed.
  const react_1 = require(_dependencyMap[0], "react");
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index"); // Mutate the style prop to add the className on web.
  function useInteropClassName(props) {
    if (react_native_1.Platform.OS !== 'web') {
      return props.style;
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (0, react_1.useMemo)(() => {
      if (props.className == null) {
        return props.style;
      }
      const cssStyle = {
        $$css: true,
        __routerLinkClassName: props.className
      };
      if (Array.isArray(props.style)) {
        return [...props.style, cssStyle];
      }
      return [props.style, cssStyle];
    }, [props.style, props.className]);
  }
  exports.useHrefAttrs = react_native_1.Platform.select({
    web: function useHrefAttrs({
      asChild,
      rel,
      target,
      download
    }) {
      return (0, react_1.useMemo)(() => {
        const hrefAttrs = {
          rel,
          target,
          download
        };
        if (asChild) {
          return hrefAttrs;
        }
        return {
          hrefAttrs
        };
      }, [asChild, rel, target, download]);
    },
    default: function useHrefAttrs() {
      return {};
    }
  });
},708,[3,16],"node_modules\\expo-router\\build\\link\\useLinkHooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Prefetch = Prefetch;
  const react_1 = require(_dependencyMap[0], "react");
  const imperative_api_1 = require(_dependencyMap[1], "./imperative-api");
  const useLoadedNavigation_1 = require(_dependencyMap[2], "./link/useLoadedNavigation");
  /**
   * When rendered on a focused screen, this component will preload the specified route.
   */
  function Prefetch(props) {
    const navigation = (0, useLoadedNavigation_1.useOptionalNavigation)();
    (0, react_1.useLayoutEffect)(() => {
      if (navigation?.isFocused()) {
        imperative_api_1.router.prefetch(props.href);
      }
    }, [navigation, props.href]);
    return null;
  }
},709,[3,681,707],"node_modules\\expo-router\\build\\Prefetch.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["style"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\ui\\Slot.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Slot = void 0;
  const react_slot_1 = require(_dependencyMap[2], "@radix-ui/react-slot");
  const react_1 = require(_dependencyMap[3], "react");
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  /**
   * RadixUI has special logic to handle the merging of `style` and `className` props.
   * On the web styles are not allowed so Radix does not handle this scenario.
   * This could be fixed upstream (PR open), but it may not as RN is not their target
   * platform.
   *
   * This shim calls `StyleSheet.flatten` on the styles before we render the <Slot />
   *
   * @see https://github.com/expo/expo/issues/31352
   * @see https://github.com/radix-ui/primitives/issues/3107
   * @param Component
   * @returns
   */
  function ShimSlotForReactNative(Component) {
    return (0, react_1.forwardRef)(function RNSlotHOC(_ref, ref) {
      let {
          style
        } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);
      style = (0, react_1.useMemo)(() => react_native_1.StyleSheet.flatten(style), [style]);
      return _reactNativeCssInteropJsxRuntime.jsx(Component, Object.assign({
        ref: ref
      }, props, {
        style: style
      }));
    });
  }
  exports.Slot = ShimSlotForReactNative(react_slot_1.Slot);
},710,[2,29,711,3,16],"node_modules\\expo-router\\build\\ui\\Slot.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"],
    _excluded2 = ["children"];
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // packages/react/slot/src/index.ts
  var index_exports = {};
  __export(index_exports, {
    Root: () => Slot,
    Slot: () => Slot,
    Slottable: () => Slottable,
    createSlot: () => createSlot,
    createSlottable: () => createSlottable
  });
  module.exports = __toCommonJS(index_exports);

  // packages/react/slot/src/slot.tsx
  var React = __toESM(require(_dependencyMap[1], "react"));
  var import_react_compose_refs = require(_dependencyMap[2], "@radix-ui/react-compose-refs");
  var import_jsx_runtime = require(_dependencyMap[3], "react/jsx-runtime");
  // @__NO_SIDE_EFFECTS__
  function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */createSlotClone(ownerName);
    const Slot2 = React.forwardRef((props, forwardedRef) => {
      const {
          children
        } = props,
        slotProps = _objectWithoutPropertiesLoose(props, _excluded);
      const childrenArray = React.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map(child => {
          if (child === slottable) {
            if (React.Children.count(newElement) > 1) return React.Children.only(null);
            return React.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */(0, import_jsx_runtime.jsx)(SlotClone, Object.assign({}, slotProps, {
          ref: forwardedRef,
          children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null
        }));
      }
      return /* @__PURE__ */(0, import_jsx_runtime.jsx)(SlotClone, Object.assign({}, slotProps, {
        ref: forwardedRef,
        children
      }));
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  var Slot = /* @__PURE__ */createSlot("Slot");
  // @__NO_SIDE_EFFECTS__
  function createSlotClone(ownerName) {
    const SlotClone = React.forwardRef((props, forwardedRef) => {
      const {
          children
        } = props,
        slotProps = _objectWithoutPropertiesLoose(props, _excluded2);
      if (React.isValidElement(children)) {
        const childrenRef = getElementRef(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== React.Fragment) {
          props2.ref = forwardedRef ? (0, import_react_compose_refs.composeRefs)(forwardedRef, childrenRef) : childrenRef;
        }
        return React.cloneElement(children, props2);
      }
      return React.Children.count(children) > 1 ? React.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
  // @__NO_SIDE_EFFECTS__
  function createSlottable(ownerName) {
    const Slottable2 = ({
      children
    }) => {
      return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children
      });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
  }
  var Slottable = /* @__PURE__ */createSlottable("Slottable");
  function isSlottable(child) {
    return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = Object.assign({}, childProps);
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = Object.assign({}, slotPropValue, childPropValue);
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return Object.assign({}, slotProps, overrideProps);
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
},711,[29,3,712,6],"node_modules\\@radix-ui\\react-slot\\dist\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // packages/react/compose-refs/src/index.ts
  var index_exports = {};
  __export(index_exports, {
    composeRefs: () => composeRefs,
    useComposedRefs: () => useComposedRefs
  });
  module.exports = __toCommonJS(index_exports);

  // packages/react/compose-refs/src/compose-refs.tsx
  var React = __toESM(require(_dependencyMap[0], "react"));
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return node => {
      let hasCleanup = false;
      const cleanups = refs.map(ref => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup == "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup == "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return React.useCallback(composeRefs(...refs), refs);
  }
},712,[3],"node_modules\\@radix-ui\\react-compose-refs\\dist\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.tabRouterOverride = void 0;
  const tabRouterOverride = original => {
    return Object.assign({}, original, {
      getStateForAction: (state, action, options) => {
        if (action.target && action.target !== state.key) {
          return null;
        }
        if (isReplaceAction(action)) {
          // Generate the state as if we were using JUMP_TO
          let nextState = original.getStateForAction(state, Object.assign({}, action, {
            type: 'JUMP_TO'
          }), options);
          if (!nextState || nextState.index === undefined || !Array.isArray(nextState.history)) {
            return null;
          }
          // If the state is valid and we didn't JUMP_TO a single history state,
          // then remove the previous state.
          if (nextState.index !== 0) {
            const previousIndex = nextState.index - 1;
            nextState = Object.assign({}, nextState, {
              key: `${nextState.key}-replace`,
              // Omit the previous history entry that we are replacing
              history: [...nextState.history.slice(0, previousIndex), ...nextState.history.splice(nextState.index)]
            });
          }
          return nextState;
        }
        return original.getStateForAction(state, action, options);
      }
    });
  };
  exports.tabRouterOverride = tabRouterOverride;
  function isReplaceAction(action) {
    return action.type === 'REPLACE';
  }
},713,[],"node_modules\\expo-router\\build\\layouts\\TabRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEffect = exports.useNavigation = exports.SplashScreen = exports.ErrorBoundary = exports.useSitemap = exports.Sitemap = exports.Unmatched = exports.ExpoRoot = exports.Slot = exports.Navigator = exports.withLayoutContext = exports.Redirect = exports.Link = exports.router = exports.useRootNavigationState = exports.useRootNavigation = exports.useSegments = exports.useLocalSearchParams = exports.useGlobalSearchParams = exports.useNavigationContainerRef = exports.usePathname = exports.useUnstableGlobalHref = exports.useRouter = void 0;
  // Expo Router API
  const Navigator_1 = require(_dependencyMap[0], "./views/Navigator");
  Object.defineProperty(exports, "Navigator", {
    enumerable: true,
    get: function () {
      return Navigator_1.Navigator;
    }
  });
  Object.defineProperty(exports, "Slot", {
    enumerable: true,
    get: function () {
      return Navigator_1.Slot;
    }
  });
  var hooks_1 = require(_dependencyMap[1], "./hooks");
  Object.defineProperty(exports, "useRouter", {
    enumerable: true,
    get: function () {
      return hooks_1.useRouter;
    }
  });
  Object.defineProperty(exports, "useUnstableGlobalHref", {
    enumerable: true,
    get: function () {
      return hooks_1.useUnstableGlobalHref;
    }
  });
  Object.defineProperty(exports, "usePathname", {
    enumerable: true,
    get: function () {
      return hooks_1.usePathname;
    }
  });
  Object.defineProperty(exports, "useNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return hooks_1.useNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "useGlobalSearchParams", {
    enumerable: true,
    get: function () {
      return hooks_1.useGlobalSearchParams;
    }
  });
  Object.defineProperty(exports, "useLocalSearchParams", {
    enumerable: true,
    get: function () {
      return hooks_1.useLocalSearchParams;
    }
  });
  Object.defineProperty(exports, "useSegments", {
    enumerable: true,
    get: function () {
      return hooks_1.useSegments;
    }
  });
  Object.defineProperty(exports, "useRootNavigation", {
    enumerable: true,
    get: function () {
      return hooks_1.useRootNavigation;
    }
  });
  Object.defineProperty(exports, "useRootNavigationState", {
    enumerable: true,
    get: function () {
      return hooks_1.useRootNavigationState;
    }
  });
  var imperative_api_1 = require(_dependencyMap[2], "./imperative-api");
  Object.defineProperty(exports, "router", {
    enumerable: true,
    get: function () {
      return imperative_api_1.router;
    }
  });
  var Link_1 = require(_dependencyMap[3], "./link/Link");
  Object.defineProperty(exports, "Link", {
    enumerable: true,
    get: function () {
      return Link_1.Link;
    }
  });
  Object.defineProperty(exports, "Redirect", {
    enumerable: true,
    get: function () {
      return Link_1.Redirect;
    }
  });
  var withLayoutContext_1 = require(_dependencyMap[4], "./layouts/withLayoutContext");
  Object.defineProperty(exports, "withLayoutContext", {
    enumerable: true,
    get: function () {
      return withLayoutContext_1.withLayoutContext;
    }
  });
  // Expo Router Views
  var ExpoRoot_1 = require(_dependencyMap[5], "./ExpoRoot");
  Object.defineProperty(exports, "ExpoRoot", {
    enumerable: true,
    get: function () {
      return ExpoRoot_1.ExpoRoot;
    }
  });
  var Unmatched_1 = require(_dependencyMap[6], "./views/Unmatched");
  Object.defineProperty(exports, "Unmatched", {
    enumerable: true,
    get: function () {
      return Unmatched_1.Unmatched;
    }
  });
  var Sitemap_1 = require(_dependencyMap[7], "./views/Sitemap");
  Object.defineProperty(exports, "Sitemap", {
    enumerable: true,
    get: function () {
      return Sitemap_1.Sitemap;
    }
  });
  var useSitemap_1 = require(_dependencyMap[8], "./views/useSitemap");
  Object.defineProperty(exports, "useSitemap", {
    enumerable: true,
    get: function () {
      return useSitemap_1.useSitemap;
    }
  });
  var ErrorBoundary_1 = require(_dependencyMap[9], "./views/ErrorBoundary");
  Object.defineProperty(exports, "ErrorBoundary", {
    enumerable: true,
    get: function () {
      return ErrorBoundary_1.ErrorBoundary;
    }
  });
  // Platform
  /**
   * @hidden
   */
  exports.SplashScreen = __importStar(require(_dependencyMap[10], "./views/Splash"));
  // React Navigation
  var useNavigation_1 = require(_dependencyMap[11], "./useNavigation");
  Object.defineProperty(exports, "useNavigation", {
    enumerable: true,
    get: function () {
      return useNavigation_1.useNavigation;
    }
  });
  var useFocusEffect_1 = require(_dependencyMap[12], "./useFocusEffect");
  Object.defineProperty(exports, "useFocusEffect", {
    enumerable: true,
    get: function () {
      return useFocusEffect_1.useFocusEffect;
    }
  });
},714,[692,680,681,654,583,715,703,694,696,727,631,649,706],"node_modules\\expo-router\\build\\exports.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["wrapper"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\ExpoRoot.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExpoRoot = ExpoRoot;
  const native_1 = require(_dependencyMap[2], "@react-navigation/native");
  const react_1 = __importStar(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[5], "react-native-safe-area-context");
  const constants_1 = require(_dependencyMap[6], "./constants");
  const useDomComponentNavigation_1 = require(_dependencyMap[7], "./domComponents/useDomComponentNavigation");
  const NavigationContainer_1 = require(_dependencyMap[8], "./fork/NavigationContainer");
  const router_store_1 = require(_dependencyMap[9], "./global-state/router-store");
  const serverLocationContext_1 = require(_dependencyMap[10], "./global-state/serverLocationContext");
  const storeContext_1 = require(_dependencyMap[11], "./global-state/storeContext");
  const imperative_api_1 = require(_dependencyMap[12], "./imperative-api");
  const primitives_1 = require(_dependencyMap[13], "./primitives");
  const statusbar_1 = require(_dependencyMap[14], "./utils/statusbar");
  const SplashScreen = __importStar(require(_dependencyMap[15], "./views/Splash"));
  const isTestEnv = process.env.NODE_ENV === 'test';
  const INITIAL_METRICS = react_native_1.Platform.OS === 'web' || isTestEnv ? {
    frame: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    insets: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  } : undefined;
  const documentTitle = {
    enabled: false
  };
  /**
   * @hidden
   */
  function ExpoRoot(_ref) {
    let {
        wrapper: ParentWrapper = react_1.Fragment
      } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, _excluded);
    /*
     * Due to static rendering we need to wrap these top level views in second wrapper
     * View's like <SafeAreaProvider /> generate a <div> so if the parent wrapper
     * is a HTML document, we need to ensure its inside the <body>
     */
    const wrapper = ({
      children
    }) => {
      return _reactNativeCssInteropJsxRuntime.jsx(ParentWrapper, {
        children: _reactNativeCssInteropJsxRuntime.jsxs(react_native_safe_area_context_1.SafeAreaProvider, {
          // SSR support
          initialMetrics: INITIAL_METRICS,
          children: [statusbar_1.canOverrideStatusBarBehavior && _reactNativeCssInteropJsxRuntime.jsx(AutoStatusBar, {}), children]
        })
      });
    };
    return _reactNativeCssInteropJsxRuntime.jsx(ContextNavigator, Object.assign({}, props, {
      wrapper: wrapper
    }));
  }
  function AutoStatusBar() {
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.StatusBar, {
      barStyle: (0, react_native_1.useColorScheme)() === 'light' ? 'dark-content' : 'light-content'
    });
  }
  const initialUrl = react_native_1.Platform.OS === 'web' && typeof window !== 'undefined' ? new URL(window.location.href) : undefined;
  function ContextNavigator({
    context,
    location: initialLocation = initialUrl,
    wrapper: WrapperComponent = react_1.Fragment,
    linking = {}
  }) {
    // location and linking.getInitialURL are both used to initialize the router state
    //  - location is used on web and during static rendering
    //  - linking.getInitialURL is used on native
    const serverContext = (0, react_1.useMemo)(() => {
      let contextType = {};
      if (initialLocation instanceof URL) {
        contextType = {
          location: {
            pathname: initialLocation.pathname + initialLocation.hash,
            search: initialLocation.search
          }
        };
      } else if (typeof initialLocation === 'string') {
        // The initial location is a string, so we need to parse it into a URL.
        const url = new URL(initialLocation, 'http://placeholder.base');
        contextType = {
          location: {
            pathname: url.pathname,
            search: url.search
          }
        };
      }
      return contextType;
    }, []);
    /*
     * The serverUrl is an initial URL used in server rendering environments.
     * e.g Static renders, units tests, etc
     */
    const serverUrl = serverContext.location ? `${serverContext.location.pathname}${serverContext.location.search}` : undefined;
    const store = (0, router_store_1.useStore)(context, linking, serverUrl);
    (0, useDomComponentNavigation_1.useDomComponentNavigation)();
    if (store.shouldShowTutorial()) {
      SplashScreen.hideAsync();
      if (process.env.NODE_ENV === 'development') {
        const Tutorial = require(_dependencyMap[16], "./onboard/Tutorial").Tutorial;
        return _reactNativeCssInteropJsxRuntime.jsx(WrapperComponent, {
          children: _reactNativeCssInteropJsxRuntime.jsx(Tutorial, {})
        });
      } else {
        // Ensure tutorial styles are stripped in production.
        return null;
      }
    }
    return _reactNativeCssInteropJsxRuntime.jsx(storeContext_1.StoreContext.Provider, {
      value: store,
      children: _reactNativeCssInteropJsxRuntime.jsx(NavigationContainer_1.NavigationContainer, {
        ref: store.navigationRef,
        initialState: store.state,
        linking: store.linking,
        onUnhandledAction: onUnhandledAction,
        documentTitle: documentTitle,
        onReady: store.onReady,
        children: _reactNativeCssInteropJsxRuntime.jsx(serverLocationContext_1.ServerContext.Provider, {
          value: serverContext,
          children: _reactNativeCssInteropJsxRuntime.jsxs(WrapperComponent, {
            children: [_reactNativeCssInteropJsxRuntime.jsx(imperative_api_1.ImperativeApiEmitter, {}), _reactNativeCssInteropJsxRuntime.jsx(Content, {})]
          })
        })
      })
    });
  }
  function Content() {
    const {
      state,
      descriptors,
      NavigationContent
    } = (0, native_1.useNavigationBuilder)(native_1.StackRouter, {
      children: _reactNativeCssInteropJsxRuntime.jsx(primitives_1.Screen, {
        name: constants_1.INTERNAL_SLOT_NAME,
        component: router_store_1.store.rootComponent
      }),
      id: constants_1.INTERNAL_SLOT_NAME
    });
    return _reactNativeCssInteropJsxRuntime.jsx(NavigationContent, {
      children: descriptors[state.routes[0].key].render()
    });
  }
  let onUnhandledAction;
  if (process.env.NODE_ENV !== 'production') {
    onUnhandledAction = action => {
      const payload = action.payload;
      let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
      switch (action.type) {
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'JUMP_TO':
          if (payload?.name) {
            message += `\n\nDo you have a route named '${payload.name}'?`;
          } else {
            message += `\n\nYou need to pass the name of the screen to navigate to. This may be a bug.`;
          }
          break;
        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
          message += `\n\nIs there any screen to go back to?`;
          break;
        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
          message += `\n\nIs your screen inside a Drawer navigator?`;
          break;
      }
      message += `\n\nThis is a development-only warning and won't be shown in production.`;
      if (process.env.NODE_ENV === 'test') {
        throw new Error(message);
      }
      console.error(message);
    };
  } else {
    onUnhandledAction = function () {};
  }
},715,[2,29,350,3,16,893,650,716,719,671,688,588,681,590,697,631,723],"node_modules\\expo-router\\build\\ExpoRoot.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDomComponentNavigation = useDomComponentNavigation;
  const global_1 = require(_dependencyMap[0], "expo/dom/global");
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const events_1 = require(_dependencyMap[2], "./events");
  const routing_1 = require(_dependencyMap[3], "../global-state/routing");
  function useDomComponentNavigation() {
    react_1.default.useEffect(() => {
      if (true) {
        return () => {};
      }
      return (0, global_1.addGlobalDomEventListener)(({
        type,
        data
      }) => {
        switch (type) {
          case events_1.ROUTER_LINK_TYPE:
            (0, routing_1.linkTo)(data.href, data.options);
            break;
          case events_1.ROUTER_DISMISS_ALL_TYPE:
            (0, routing_1.dismissAll)();
            break;
          case events_1.ROUTER_DISMISS_TYPE:
            (0, routing_1.dismiss)(data.count);
            break;
          case events_1.ROUTER_BACK_TYPE:
            (0, routing_1.goBack)();
            break;
          case events_1.ROUTER_SET_PARAMS_TYPE:
            (0, routing_1.setParams)(data.params);
            break;
        }
      });
    }, []);
  }
},716,[717,3,657,659],"node_modules\\expo-router\\build\\domComponents\\useDomComponentNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _globalEvents = require(_dependencyMap[0], "../src/dom/global-events");
  Object.keys(_globalEvents).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _globalEvents[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _globalEvents[key];
      }
    });
  });
},717,[718],"node_modules\\expo\\dom\\global.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._emitGlobalEvent = _emitGlobalEvent;
  exports.addGlobalDomEventListener = void 0;
  const globalListeners = new Set();
  function _emitGlobalEvent(message) {
    globalListeners.forEach(listener => listener(message));
  }
  const addGlobalDomEventListener = onSubscribe => {
    globalListeners.add(onSubscribe);
    return () => {
      globalListeners.delete(onSubscribe);
    };
  };
  exports.addGlobalDomEventListener = addGlobalDomEventListener;
},718,[],"node_modules\\expo\\src\\dom\\global-events.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["direction", "theme", "linking", "fallback", "documentTitle", "onReady", "onStateChange"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\fork\\NavigationContainer.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationContainer = void 0;
  const native_1 = require(_dependencyMap[2], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const use_latest_callback_1 = __importDefault(require(_dependencyMap[5], "use-latest-callback"));
  const useBackButton_1 = require(_dependencyMap[6], "./useBackButton");
  const useDocumentTitle_1 = require(_dependencyMap[7], "./useDocumentTitle");
  const useLinking_1 = require(_dependencyMap[8], "./useLinking");
  const useThenable_1 = require(_dependencyMap[9], "./useThenable");
  globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
  /**
   * Container component which holds the navigation state designed for React Native apps.
   * This should be rendered at the root wrapping the whole app.
   *
   * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
   * @param props.onReady Callback which is called after the navigation tree mounts.
   * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
   * @param props.onUnhandledAction Callback which is called when an action is not handled.
   * @param props.direction Text direction of the components. Defaults to `'ltr'`.
   * @param props.theme Theme object for the UI elements.
   * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
   * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
   * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which refers to the navigation object containing helper methods.
   */
  function NavigationContainerInner(_ref, ref) {
    let {
        direction = react_native_1.I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',
        theme = native_1.DefaultTheme,
        linking,
        fallback = null,
        documentTitle,
        onReady,
        onStateChange
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    const isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking?.config) {
      (0, native_1.validatePathConfig)(linking.config);
    }
    const refContainer = react_1.default.useRef(null);
    (0, useBackButton_1.useBackButton)(refContainer);
    (0, useDocumentTitle_1.useDocumentTitle)(refContainer, documentTitle);
    const [lastUnhandledLink, setLastUnhandledLink] = react_1.default.useState();
    const {
      getInitialState
    } = (0, useLinking_1.useLinking)(refContainer, Object.assign({
      enabled: isLinkingEnabled,
      prefixes: []
    }, linking), setLastUnhandledLink);
    const linkingContext = react_1.default.useMemo(() => ({
      options: linking
    }), [linking]);
    const unhandledLinkingContext = react_1.default.useMemo(() => ({
      lastUnhandledLink,
      setLastUnhandledLink
    }), [lastUnhandledLink, setLastUnhandledLink]);
    const onReadyForLinkingHandling = (0, use_latest_callback_1.default)(() => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onReady?.();
    });
    const onStateChangeForLinkingHandling = (0, use_latest_callback_1.default)(state => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onStateChange?.(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    react_1.default.useEffect(() => {
      if (refContainer.current) {
        REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
          get linking() {
            return Object.assign({}, linking, {
              enabled: isLinkingEnabled,
              prefixes: linking?.prefixes ?? [],
              getStateFromPath: linking?.getStateFromPath ?? native_1.getStateFromPath,
              getPathFromState: linking?.getPathFromState ?? native_1.getPathFromState,
              getActionFromState: linking?.getActionFromState ?? native_1.getActionFromState
            });
          }
        });
      }
    });
    const [isResolved, initialState] = (0, useThenable_1.useThenable)(getInitialState);
    react_1.default.useImperativeHandle(ref, () => refContainer.current);
    const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
      // This is temporary until we have Suspense for data-fetching
      // Then the fallback will be handled by a parent `Suspense` component
      return _reactNativeCssInteropJsxRuntime.jsx(native_1.ThemeProvider, {
        value: theme,
        children: fallback
      });
    }
    return _reactNativeCssInteropJsxRuntime.jsx(native_1.LocaleDirContext.Provider, {
      value: direction,
      children: _reactNativeCssInteropJsxRuntime.jsx(native_1.UNSTABLE_UnhandledLinkingContext.Provider, {
        value: unhandledLinkingContext,
        children: _reactNativeCssInteropJsxRuntime.jsx(native_1.LinkingContext.Provider, {
          value: linkingContext,
          children: _reactNativeCssInteropJsxRuntime.jsx(native_1.BaseNavigationContainer, Object.assign({}, rest, {
            theme: theme,
            onReady: onReadyForLinkingHandling,
            onStateChange: onStateChangeForLinkingHandling,
            initialState: rest.initialState == null ? initialState : rest.initialState,
            ref: refContainer
          }))
        })
      })
    });
  }
  exports.NavigationContainer = react_1.default.forwardRef(NavigationContainerInner);
},719,[2,29,350,3,16,363,720,721,686,722],"node_modules\\expo-router\\build\\fork\\NavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useBackButton = useBackButton;
  function useBackButton(_) {
    // No-op
    // BackHandler is not available on web
  }
},720,[],"node_modules\\expo-router\\build\\fork\\useBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDocumentTitle = useDocumentTitle;
  const React = __importStar(require(_dependencyMap[0], "react"));
  // import type { DocumentTitleOptions } from './types';
  /**
   * Set the document title for the active screen
   */
  function useDocumentTitle(ref, {
    enabled = true,
    formatter = (options, route) => options?.title ?? route?.name
  } = {}) {
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const navigation = ref.current;
      if (navigation) {
        const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());
        document.title = title;
      }
      return navigation?.addListener('options', e => {
        const title = formatter(e.data.options, navigation?.getCurrentRoute());
        document.title = title;
      });
    });
  }
},721,[3],"node_modules\\expo-router\\build\\fork\\useDocumentTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useThenable = useThenable;
  /*
   * This file is unchanged, except for moving eslint comments
   */
  const React = __importStar(require(_dependencyMap[0], "react"));
  function useThenable(create) {
    const [promise] = React.useState(create);
    let initialState = [false, undefined];
    // Check if our thenable is synchronous
    promise.then(result => {
      initialState = [true, result];
    });
    const [state, setState] = React.useState(initialState);
    const [resolved] = state;
    React.useEffect(() => {
      let cancelled = false;
      const resolve = async () => {
        let result;
        try {
          result = await promise;
        } finally {
          if (!cancelled) {
            setState([true, result]);
          }
        }
      };
      if (!resolved) {
        resolve();
      }
      return () => {
        cancelled = true;
      };
    }, [promise, resolved]);
    return state;
  }
},722,[3],"node_modules\\expo-router\\build\\fork\\useThenable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\onboard\\Tutorial.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tutorial = Tutorial;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const react_native_1 = require(_dependencyMap[2], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[3], "react-native-safe-area-context");
  const createEntryFile_1 = require(_dependencyMap[4], "./createEntryFile");
  const exports_1 = require(_dependencyMap[5], "../exports");
  const Pressable_1 = require(_dependencyMap[6], "../views/Pressable");
  const canAutoTouchFile = "..\\..\\app" != null;
  function Tutorial() {
    react_1.default.useEffect(() => {
      if (react_native_1.Platform.OS === 'web') {
        // Reset the route on web so the initial route isn't a 404 after
        // the user has created the entry file.
        // This is useful for cases where you are testing the tutorial.
        // To test: touch the new file, then navigate to a missing route `/foobar`, then delete the app folder.
        // you should see the tutorial again and be able to create the entry file once more.
        if (typeof location !== 'undefined' && location.pathname !== '/') {
          location.replace('/');
        }
        if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
          window.document.title = 'Welcome to Expo';
        }
      }
    }, []);
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_safe_area_context_1.SafeAreaView, {
      style: styles.background,
      children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.StatusBar, {
        barStyle: "light-content"
      }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
        style: styles.container,
        children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
          style: styles.logotypeWrapper,
          children: _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Image, {
            style: styles.logotype,
            source: require(_dependencyMap[7], "expo-router/assets/logotype.png")
          })
        }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
          role: "heading",
          "aria-level": 1,
          style: styles.title,
          children: "Welcome to Expo"
        }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.Text, {
          role: "heading",
          "aria-level": 2,
          style: [styles.subtitle, styles.textSecondary],
          children: ["Start by creating a file", react_native_1.Platform.OS !== 'web' ? '\n' : ' ', "in the", ' ', _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: {
              fontWeight: '600'
            },
            children: getRootDir()
          }), " directory."]
        }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
          children: _reactNativeCssInteropJsxRuntime.jsx(exports_1.Link, Object.assign({
            href: "https://docs.expo.dev/router/introduction/"
          }, react_native_1.Platform.select({
            web: {
              target: '_blank'
            },
            native: {
              asChild: true
            }
          }), {
            children: _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
              children: ({
                hovered,
                pressed
              }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
                style: [styles.link, react_native_1.Platform.select({
                  web: {
                    transitionDuration: '200ms',
                    marginBottom: 12
                  }
                }), hovered && {
                  opacity: 0.8,
                  textDecorationLine: 'underline'
                }, pressed && {
                  opacity: 0.8
                }],
                children: "Learn more about Expo Router in the documentation."
              })
            })
          }))
        }), canAutoTouchFile && _reactNativeCssInteropJsxRuntime.jsx(Button, {})]
      })]
    });
  }
  function getRootDir() {
    const dir = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app";
    if (dir.match(/\/src\/app$/)) {
      return 'src/app';
    } else if (dir.match(/\/app$/)) {
      return 'app';
    }
    return dir.split('/').pop() ?? dir;
  }
  function Button() {
    return _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
      onPress: () => {
        (0, createEntryFile_1.createEntryFileAsync)();
      },
      style: styles.button,
      children: ({
        pressed,
        hovered
      }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
        style: [styles.buttonContainer, hovered && {
          backgroundColor: '#fff'
        }, pressed && react_native_1.Platform.select({
          web: {
            transform: 'scale(0.98)',
            transitionDuration: '200ms'
          },
          default: {
            backgroundColor: '#fff'
          }
        })],
        children: _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.Text, {
          style: [styles.code, hovered && {
            color: '#000'
          }, pressed && react_native_1.Platform.select({
            native: {
              color: '#000'
            }
          })],
          children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
            style: styles.textSecondary,
            children: "$"
          }), " touch ", getRootDir(), "/index.tsx"]
        })
      })
    });
  }
  const styles = react_native_1.StyleSheet.create({
    background: {
      backgroundColor: '#000',
      flex: 1
    },
    container: Object.assign({
      flex: 1,
      padding: 24,
      paddingBottom: 64,
      alignItems: 'center',
      justifyContent: 'center',
      marginHorizontal: 'auto',
      gap: 16
    }, react_native_1.Platform.select({
      web: {
        maxWidth: 960
      },
      native: {
        width: '100%'
      }
    })),
    logotypeWrapper: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#151718',
      borderRadius: 12,
      borderWidth: 1,
      borderStyle: 'solid',
      borderColor: '#313538',
      width: 78,
      height: 78,
      marginBottom: 8
    },
    logotype: {
      width: 48,
      height: 44
    },
    title: Object.assign({}, react_native_1.Platform.select({
      web: {
        fontSize: 64,
        lineHeight: 64
      },
      default: {
        fontSize: 56,
        lineHeight: 56
      }
    }), {
      color: '#fff',
      fontWeight: '800',
      textAlign: 'center'
    }),
    buttonContainer: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '200ms'
      }
    }), {
      backgroundColor: 'transparent',
      borderColor: '#fff',
      borderWidth: 2,
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderRadius: 8
    }),
    button: Object.assign({}, react_native_1.Platform.select({
      web: {
        marginTop: 12
      },
      native: {
        position: 'absolute',
        bottom: 24,
        left: 32,
        right: 32,
        overflow: 'hidden'
      }
    })),
    code: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '200ms',
        fontFamily: 'Courier, monospace'
      },
      default: {
        fontFamily: react_native_1.Platform.select({
          ios: 'Courier New',
          android: 'monospace'
        })
      }
    }), {
      color: '#fff',
      textAlign: 'center',
      userSelect: 'none',
      fontSize: 18,
      fontWeight: 'bold'
    }),
    subtitle: {
      fontSize: 34,
      fontWeight: '200',
      textAlign: 'center'
    },
    link: Object.assign({
      fontSize: 20,
      lineHeight: 26,
      textAlign: 'center',
      color: '#52a9ff',
      marginTop: 12
    }, react_native_1.Platform.select({
      web: {
        marginBottom: 24
      }
    })),
    textSecondary: {
      color: '#9ba1a6'
    }
  });
},723,[2,3,16,893,724,714,695,726],"node_modules\\expo-router\\build\\onboard\\Tutorial.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createEntryFileAsync = createEntryFileAsync;
  exports.getAbsolutePath = getAbsolutePath;
  const getDevServer_1 = require(_dependencyMap[0], "../getDevServer");
  /** Middleware for creating an entry file in the project. */
  function createEntryFileAsync() {
    if (process.env.NODE_ENV === 'production') {
      // No dev server
      console.warn('createEntryFile() cannot be used in production');
      return;
    }
    // Pings middleware in the Expo CLI dev server.
    return fetch((0, getDevServer_1.getDevServer)().url + '_expo/touch', {
      method: 'POST',
      body: JSON.stringify({
        contents: TEMPLATE,
        // Legacy
        path: './app/index.js',
        // New
        absolutePath: getAbsolutePath()
      })
    });
  }
  function getAbsolutePath() {
    return "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app" + '/index.js';
  }
  const TEMPLATE = `import { StyleSheet, Text, View } from "react-native";

export default function Page() {
  return (
    <View style={styles.container}>
      <View style={styles.main}>
        <Text style={styles.title}>Hello World</Text>
        <Text style={styles.subtitle}>This is the first page of your app.</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    padding: 24,
  },
  main: {
    flex: 1,
    justifyContent: "center",
    maxWidth: 960,
    marginHorizontal: "auto",
  },
  title: {
    fontSize: 64,
    fontWeight: "bold",
  },
  subtitle: {
    fontSize: 36,
    color: "#38434D",
  },
});
`;
},724,[725],"node_modules\\expo-router\\build\\onboard\\createEntryFile.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDevServer = void 0;
  const getDevServer = () => {
    // Disable for SSR
    if (typeof window === 'undefined') {
      return {
        bundleLoadedFromServer: true,
        fullBundleUrl: '',
        url: ''
      };
    }
    return {
      // The bundle is always loaded from a server in the browser.
      bundleLoadedFromServer: true,
      /** URL but ensures that platform query param is added. */
      get fullBundleUrl() {
        if (document?.currentScript && 'src' in document.currentScript) {
          return document.currentScript.src;
        }
        const bundleUrl = new URL(location.href);
        bundleUrl.searchParams.set('platform', 'web');
        return bundleUrl.toString();
      },
      url: location.origin + '/'
    };
  };
  exports.getDevServer = getDevServer;
},725,[],"node_modules\\expo-router\\build\\getDevServer\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/logotype.png",
    width: 96,
    height: 88
  };
},726,[],"node_modules\\expo-router\\assets\\logotype.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\views\\ErrorBoundary.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorBoundary = ErrorBoundary;
  const bottom_tabs_1 = require(_dependencyMap[1], "@react-navigation/bottom-tabs");
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  const Pressable_1 = require(_dependencyMap[5], "./Pressable");
  const Link_1 = require(_dependencyMap[6], "../link/Link");
  const errors_1 = require(_dependencyMap[7], "../rsc/router/errors");
  function StandardErrorView({
    error
  }) {
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
      style: {
        marginBottom: 12,
        gap: 4,
        flexWrap: true ? 'wrap' : 'nowrap'
      },
      children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        role: "heading",
        "aria-level": 1,
        style: styles.title,
        children: "Something went wrong"
      }), _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.Text, {
        testID: "router_error_message",
        role: "heading",
        "aria-level": 2,
        style: styles.errorMessage,
        children: ["Error: ", error.message]
      })]
    });
  }
  function ErrorBoundary({
    error,
    retry
  }) {
    const inTabBar = (0, react_1.use)(bottom_tabs_1.BottomTabBarHeightContext);
    const Wrapper = inTabBar ? react_native_1.View : react_native_safe_area_context_1.SafeAreaView;
    const isServerError = error instanceof errors_1.ReactServerError;
    return _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
      style: styles.container,
      children: _reactNativeCssInteropJsxRuntime.jsxs(Wrapper, {
        style: {
          flex: 1,
          gap: 8,
          maxWidth: 720,
          marginHorizontal: 'auto'
        },
        children: [isServerError ? _reactNativeCssInteropJsxRuntime.jsx(ReactServerErrorView, {
          error: error
        }) : _reactNativeCssInteropJsxRuntime.jsx(StandardErrorView, {
          error: error
        }), _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
          style: {
            flex: 1
          }
        }), process.env.NODE_ENV === 'development' && _reactNativeCssInteropJsxRuntime.jsx(Link_1.Link, {
          testID: "router_error_sitemap",
          href: "/_sitemap",
          style: styles.link,
          children: "Sitemap"
        }), _reactNativeCssInteropJsxRuntime.jsx(Pressable_1.Pressable, {
          testID: "router_error_retry",
          onPress: retry,
          children: ({
            hovered,
            pressed
          }) => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {
            style: [styles.buttonInner, (hovered || pressed) && {
              backgroundColor: 'white'
            }],
            children: _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
              style: [styles.buttonText, {
                color: hovered || pressed ? 'black' : 'white'
              }],
              children: "Retry"
            })
          })
        })]
      })
    });
  }
  const COMMON_ERROR_STATUS = {
    404: 'NOT_FOUND',
    500: 'INTERNAL_SERVER_ERROR',
    503: 'SERVICE_UNAVAILABLE',
    504: 'GATEWAY_TIMEOUT'
  };
  // TODO: This should probably be replaced by a DOM component that loads server errors in the future.
  function ReactServerErrorView({
    error
  }) {
    let title = String(error.statusCode);
    title += ': ' + (COMMON_ERROR_STATUS[error.statusCode] ?? 'Server Error');
    const errorId = error.headers.get('cf-ray');
    const date = error.headers.get('Date');
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
      style: {
        padding: 12,
        gap: 8
      },
      children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: {
          fontSize: react_native_1.Platform.select({
            web: 24,
            default: 16
          }),
          fontWeight: 'bold',
          marginBottom: 4,
          color: 'white'
        },
        children: title
      }), true ? _reactNativeCssInteropJsxRuntime.jsx(react_native_1.ScrollView, {
        style: {
          borderColor: 'rgba(255,255,255,0.5)',
          borderTopWidth: react_native_1.StyleSheet.hairlineWidth,
          borderBottomWidth: react_native_1.StyleSheet.hairlineWidth,
          maxHeight: 150
        },
        contentContainerStyle: {
          paddingVertical: 4
        },
        children: _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
          testID: "router_error_message",
          selectable: true,
          allowFontScaling: true,
          style: {
            color: 'white'
          },
          children: error.message
        })
      }) : _reactNativeCssInteropJsxRuntime.jsx(react_native_1.TextInput, {
        testID: "router_error_message",
        scrollEnabled: true,
        multiline: true,
        editable: false,
        allowFontScaling: true,
        value: error.message,
        style: {
          borderColor: 'rgba(255,255,255,0.5)',
          borderTopWidth: react_native_1.StyleSheet.hairlineWidth,
          borderBottomWidth: react_native_1.StyleSheet.hairlineWidth,
          paddingVertical: 4,
          maxHeight: 150,
          color: 'white'
        }
      }), _reactNativeCssInteropJsxRuntime.jsx(InfoRow, {
        title: "Code",
        right: error.statusCode
      }), errorId && _reactNativeCssInteropJsxRuntime.jsx(InfoRow, {
        title: "ID",
        right: errorId
      }), date && _reactNativeCssInteropJsxRuntime.jsx(InfoRow, {
        title: "Date",
        right: date
      }), error.url && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: {
          fontSize: 14,
          opacity: 0.5,
          color: 'white'
        },
        children: error.url
      })]
    });
  }
  function InfoRow({
    title,
    right
  }) {
    const style = {
      fontSize: 16,
      color: 'white'
    };
    return _reactNativeCssInteropJsxRuntime.jsxs(react_native_1.View, {
      style: {
        flexDirection: 'row',
        justifyContent: 'space-between'
      },
      children: [_reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: style,
        children: title
      }), right && _reactNativeCssInteropJsxRuntime.jsx(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: [style, styles.code],
        children: right
      })]
    });
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: 'black',
      padding: 24,
      alignItems: 'stretch',
      justifyContent: 'center'
    },
    title: {
      color: 'white',
      fontSize: react_native_1.Platform.select({
        web: 32,
        default: 24
      }),
      fontWeight: 'bold'
    },
    buttonText: Object.assign({
      fontSize: 18,
      fontWeight: 'bold',
      color: 'black'
    }, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    })),
    buttonInner: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    }), {
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderColor: 'white',
      borderWidth: 2,
      marginLeft: 8,
      justifyContent: 'center',
      alignItems: 'center'
    }),
    code: {
      fontFamily: react_native_1.Platform.select({
        default: 'Courier',
        ios: 'Courier New',
        android: 'monospace'
      }),
      fontWeight: '500'
    },
    errorMessage: {
      color: 'white',
      fontSize: 16
    },
    subtitle: {
      color: 'white',
      fontSize: 14,
      marginBottom: 12
    },
    link: {
      color: 'rgba(255,255,255,0.4)',
      textDecorationStyle: 'solid',
      textDecorationLine: 'underline',
      fontSize: 14,
      textAlign: 'center'
    }
  });
},727,[2,593,3,16,893,695,654,646],"node_modules\\expo-router\\build\\views\\ErrorBoundary.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  (() => {
    if (typeof window === 'undefined') {
      return;
    }
    const head = document.head || document.getElementsByTagName('head')[0];
    const style = document.createElement('style');
    style.setAttribute('data-expo-css-hmr', "node_modules_react_native_css_interop__cache_web_css");
    const previousStyle = document.querySelector('[data-expo-css-hmr="node_modules_react_native_css_interop__cache_web_css"]');
    if (previousStyle) {
      previousStyle.parentNode.replaceChild(style, previousStyle);
    }
    style.setAttribute('data-expo-loader', 'css');
    if (!style.parentNode) head.appendChild(style);
    const css = `*, :before, :after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #3b82f680;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: ;
}

::-ms-backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #3b82f680;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #3b82f680;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: ;
}

*, :before, :after {
  box-sizing: border-box;
  border: 0 solid #e5e7eb;
}

:before, :after {
  --tw-content: "";
}

html, :host {
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-font-feature-settings: normal;
  font-feature-settings: normal;
  font-variation-settings: normal;
  -webkit-tap-highlight-color: transparent;
  font-family: ui-sans-serif, system-ui, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
  line-height: 1.5;
}

body {
  line-height: inherit;
  margin: 0;
}

hr {
  color: inherit;
  border-top-width: 1px;
  height: 0;
}

abbr:where([title]) {
  text-decoration: underline dotted;
}

h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

a {
  color: inherit;
  text-decoration: inherit;
}

b, strong {
  font-weight: bolder;
}

code, kbd, samp, pre {
  -webkit-font-feature-settings: normal;
  font-feature-settings: normal;
  font-variation-settings: normal;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
  font-size: 1em;
}

small {
  font-size: 80%;
}

sub, sup {
  vertical-align: baseline;
  font-size: 75%;
  line-height: 0;
  position: relative;
}

sub {
  bottom: -.25em;
}

sup {
  top: -.5em;
}

table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

button, input, optgroup, select, textarea {
  -webkit-font-feature-settings: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-family: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type="button"]), input:where([type="reset"]), input:where([type="submit"]) {
  -webkit-appearance: button;
  background-color: #0000;
  background-image: none;
}

:-moz-focusring {
  outline: auto;
}

:-moz-ui-invalid {
  box-shadow: none;
}

progress {
  vertical-align: baseline;
}

::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
  height: auto;
}

[type="search"] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

::-webkit-search-decoration {
  -webkit-appearance: none;
}

::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

summary {
  display: list-item;
}

blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol, ul, menu {
  margin: 0;
  padding: 0;
  list-style: none;
}

dialog {
  padding: 0;
}

textarea {
  resize: vertical;
}

input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
  opacity: 1;
  color: #9ca3af;
}

input:-ms-input-placeholder, textarea:-ms-input-placeholder {
  opacity: 1;
  color: #9ca3af;
}

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1;
  color: #9ca3af;
}

input::placeholder, textarea::placeholder {
  opacity: 1;
  color: #9ca3af;
}

button, [role="button"] {
  cursor: pointer;
}

:disabled {
  cursor: default;
}

img, svg, video, canvas, audio, iframe, embed, object {
  vertical-align: middle;
  display: block;
}

img, video {
  max-width: 100%;
  height: auto;
}

[hidden]:where(:not([hidden="until-found"])) {
  display: none;
}

:root {
  --css-interop-darkMode: media;
  --css-interop: true;
  --css-interop-nativewind: true;
}

.container {
  width: 100%;
}

@media (width >= 640px) {
  .container {
    max-width: 640px;
  }
}

@media (width >= 768px) {
  .container {
    max-width: 768px;
  }
}

@media (width >= 1024px) {
  .container {
    max-width: 1024px;
  }
}

@media (width >= 1280px) {
  .container {
    max-width: 1280px;
  }
}

@media (width >= 1536px) {
  .container {
    max-width: 1536px;
  }
}

.visible {
  visibility: visible;
}

.absolute {
  position: absolute;
}

.mx-4 {
  margin-left: 1rem;
  margin-right: 1rem;
}

.mx-5 {
  margin-left: 1.25rem;
  margin-right: 1.25rem;
}

.my-5 {
  margin-top: 1.25rem;
  margin-bottom: 1.25rem;
}

.mb-1 {
  margin-bottom: .25rem;
}

.mb-1\\.5 {
  margin-bottom: .375rem;
}

.mb-10 {
  margin-bottom: 2.5rem;
}

.mb-12 {
  margin-bottom: 3rem;
}

.mb-2 {
  margin-bottom: .5rem;
}

.mb-3 {
  margin-bottom: .75rem;
}

.mb-4 {
  margin-bottom: 1rem;
}

.mb-5 {
  margin-bottom: 1.25rem;
}

.mb-6 {
  margin-bottom: 1.5rem;
}

.mb-8 {
  margin-bottom: 2rem;
}

.mr-1 {
  margin-right: .25rem;
}

.mr-2 {
  margin-right: .5rem;
}

.mr-3 {
  margin-right: .75rem;
}

.mr-4 {
  margin-right: 1rem;
}

.mt-3 {
  margin-top: .75rem;
}

.mt-4 {
  margin-top: 1rem;
}

.mt-5 {
  margin-top: 1.25rem;
}

.mt-8 {
  margin-top: 2rem;
}

.inline {
  display: inline;
}

.flex {
  display: flex;
}

.aspect-square {
  aspect-ratio: 1;
}

.h-10 {
  height: 2.5rem;
}

.h-12 {
  height: 3rem;
}

.h-32 {
  height: 8rem;
}

.h-5 {
  height: 1.25rem;
}

.h-6 {
  height: 1.5rem;
}

.h-\\[46px\\] {
  height: 46px;
}

.h-px {
  height: 1px;
}

.w-12 {
  width: 3rem;
}

.w-5 {
  width: 1.25rem;
}

.w-6 {
  width: 1.5rem;
}

.w-\\[295px\\] {
  width: 295px;
}

.w-\\[47\\%\\] {
  width: 47%;
}

.w-full {
  width: 100%;
}

.flex-1 {
  flex: 1;
}

.flex-row {
  flex-direction: row;
}

.flex-wrap {
  flex-wrap: wrap;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-2 {
  gap: .5rem;
}

.space-x-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(.75rem * var(--tw-space-x-reverse));
  margin-left: calc(.75rem * calc(1 - var(--tw-space-x-reverse)));
}

.space-x-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1rem * var(--tw-space-x-reverse));
  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
}

.self-start {
  align-self: flex-start;
}

.overflow-hidden {
  overflow: hidden;
}

.rounded {
  border-radius: .25rem;
}

.rounded-2xl {
  border-radius: 1rem;
}

.rounded-full {
  border-radius: 9999px;
}

.rounded-lg {
  border-radius: .5rem;
}

.rounded-xl {
  border-radius: .75rem;
}

.border {
  border-width: 1px;
}

.border-2 {
  border-width: 2px;
}

.border-b {
  border-bottom-width: 1px;
}

.border-t {
  border-top-width: 1px;
}

.border-\\[\\#D1D5DB\\] {
  --tw-border-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-border-opacity, 1));
}

.border-\\[\\#EFEFEF\\] {
  --tw-border-opacity: 1;
  border-color: rgb(239 239 239 / var(--tw-border-opacity, 1));
}

.border-blue-500 {
  --tw-border-opacity: 1;
  border-color: rgb(59 130 246 / var(--tw-border-opacity, 1));
}

.border-gray-100 {
  --tw-border-opacity: 1;
  border-color: rgb(243 244 246 / var(--tw-border-opacity, 1));
}

.border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(229 231 235 / var(--tw-border-opacity, 1));
}

.border-gray-300 {
  --tw-border-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-border-opacity, 1));
}

.border-green-600 {
  --tw-border-opacity: 1;
  border-color: rgb(22 163 74 / var(--tw-border-opacity, 1));
}

.bg-\\[\\#459B6C\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(69 155 108 / var(--tw-bg-opacity, 1));
}

.bg-\\[\\#EF9E1C\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(239 158 28 / var(--tw-bg-opacity, 1));
}

.bg-\\[\\#EFEFEF\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(239 239 239 / var(--tw-bg-opacity, 1));
}

.bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1));
}

.bg-gray-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1));
}

.bg-gray-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(156 163 175 / var(--tw-bg-opacity, 1));
}

.bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1));
}

.bg-green-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1));
}

.bg-green-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1));
}

.bg-green-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(22 163 74 / var(--tw-bg-opacity, 1));
}

.bg-orange-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(249 115 22 / var(--tw-bg-opacity, 1));
}

.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));
}

.bg-yellow-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(234 179 8 / var(--tw-bg-opacity, 1));
}

.p-1\\.5 {
  padding: .375rem;
}

.p-2 {
  padding: .5rem;
}

.p-3 {
  padding: .75rem;
}

.p-4 {
  padding: 1rem;
}

.p-6 {
  padding: 1.5rem;
}

.px-2 {
  padding-left: .5rem;
  padding-right: .5rem;
}

.px-3 {
  padding-left: .75rem;
  padding-right: .75rem;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.px-5 {
  padding-left: 1.25rem;
  padding-right: 1.25rem;
}

.px-6 {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
}

.py-1 {
  padding-top: .25rem;
  padding-bottom: .25rem;
}

.py-2 {
  padding-top: .5rem;
  padding-bottom: .5rem;
}

.py-3 {
  padding-top: .75rem;
  padding-bottom: .75rem;
}

.py-3\\.5 {
  padding-top: .875rem;
  padding-bottom: .875rem;
}

.py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}

.py-5 {
  padding-top: 1.25rem;
  padding-bottom: 1.25rem;
}

.pb-4 {
  padding-bottom: 1rem;
}

.pb-5 {
  padding-bottom: 1.25rem;
}

.pb-6 {
  padding-bottom: 1.5rem;
}

.pb-8 {
  padding-bottom: 2rem;
}

.pt-4 {
  padding-top: 1rem;
}

.pt-5 {
  padding-top: 1.25rem;
}

.pt-\\[50px\\] {
  padding-top: 50px;
}

.text-center {
  text-align: center;
}

.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}

.text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

.text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}

.text-\\[12px\\] {
  font-size: 12px;
}

.text-\\[14px\\] {
  font-size: 14px;
}

.text-\\[18px\\] {
  font-size: 18px;
}

.text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}

.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

.text-sm {
  font-size: .875rem;
  line-height: 1.25rem;
}

.text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

.text-xs {
  font-size: .75rem;
  line-height: 1rem;
}

.font-bold {
  font-weight: 700;
}

.font-medium {
  font-weight: 500;
}

.font-semibold {
  font-weight: 600;
}

.leading-5 {
  line-height: 1.25rem;
}

.text-\\[\\#111827\\] {
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity, 1));
}

.text-\\[\\#374151\\] {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity, 1));
}

.text-black {
  --tw-text-opacity: 1;
  color: rgb(0 0 0 / var(--tw-text-opacity, 1));
}

.text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(59 130 246 / var(--tw-text-opacity, 1));
}

.text-gray-400 {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity, 1));
}

.text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity, 1));
}

.text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity, 1));
}

.text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity, 1));
}

.text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(31 41 55 / var(--tw-text-opacity, 1));
}

.text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity, 1));
}

.text-green-600 {
  --tw-text-opacity: 1;
  color: rgb(22 163 74 / var(--tw-text-opacity, 1));
}

.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1));
}

.shadow-lg {
  --tw-shadow: 0px 4px 10px #00000059;
  --tw-shadow-colored: 0px 4px 10px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.shadow-black\\/10 {
  --tw-shadow-color: #0000001a;
  --tw-shadow: var(--tw-shadow-colored);
}

.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
`;
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  })();
},728,[],"node_modules\\react-native-css-interop\\.cache\\web.css");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use client";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = AccountScreen;
  var _expoRouter = require(_dependencyMap[1], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/TouchableOpacity"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/SafeAreaView"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/ScrollView"));
  var _BottomTabBar = _interopRequireDefault(require(_dependencyMap[7], "../components/BottomTabBar"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\account.tsx",
    _s = $RefreshSig$();
  function AccountScreen() {
    _s();
    const router = (0, _expoRouter.useRouter)();
    const handleSettings = () => {
      console.log("Settings pressed");
    };
    const handleProfile = () => {
      router.push("/profile");
    };
    const handleSubscribe = () => {
      console.log("Subscribe Now pressed");
    };
    const handleMyCollection = () => {
      console.log("My Collection pressed");
    };
    const handleSettingsNavigation = () => {
      console.log("Settings navigation pressed");
    };
    return (0, _jsxRuntime.jsxs)(_SafeAreaView.default, {
      className: "flex-1 bg-white",
      children: [(0, _jsxRuntime.jsxs)(_ScrollView.default, {
        className: "flex-1 px-5 pt-5",
        children: [(0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-row items-center justify-between mb-8",
          children: [(0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row items-center flex-1",
            children: [(0, _jsxRuntime.jsx)(_View.default, {
              className: "w-15 h-15 rounded-full bg-gray-100 justify-center items-center mr-4",
              children: (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-4xl text-gray-400",
                children: "\uD83D\uDC64"
              })
            }), (0, _jsxRuntime.jsxs)(_View.default, {
              className: "flex-1",
              children: [(0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-xl font-bold text-gray-900 mb-1",
                children: "Anna Kim"
              }), (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-500",
                children: "Free User"
              })]
            })]
          }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            onPress: handleSettings,
            activeOpacity: 0.7,
            className: "p-2",
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-2xl",
              children: "\u2699\uFE0F"
            })
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-row mb-10 space-x-3",
          children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "flex-1 bg-green-600 py-4 rounded-xl items-center",
            onPress: handleProfile,
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-white text-base font-semibold",
              children: "Profile"
            })
          }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "flex-1 bg-orange-500 py-4 rounded-xl items-center",
            onPress: handleSubscribe,
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-white text-base font-semibold",
              children: "Subscribe Now"
            })
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-1",
          children: [(0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
            className: "flex-row justify-between items-center py-5 border-b border-gray-100",
            onPress: handleMyCollection,
            activeOpacity: 0.7,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-medium text-gray-900",
              children: "My Collection"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-xl text-gray-400",
              children: "\u203A"
            })]
          }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
            className: "flex-row justify-between items-center py-5 border-b border-gray-100",
            onPress: handleSettingsNavigation,
            activeOpacity: 0.7,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-medium text-gray-900",
              children: "Setting"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-xl text-gray-400",
              children: "\u203A"
            })]
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "h-10"
        })]
      }), (0, _jsxRuntime.jsx)(_BottomTabBar.default, {
        activeTab: "Account"
      })]
    });
  }
  _s(AccountScreen, "fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = AccountScreen;
  var _c;
  $RefreshReg$(_c, "AccountScreen");
},729,[17,535,111,190,231,250,135,730,2],"app\\account.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/TouchableOpacity"));
  var _Image = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Image"));
  var _expoRouter = require(_dependencyMap[5], "expo-router");
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\components\\BottomTabBar.tsx",
    _s = $RefreshSig$();
  const routes = {
    Home: '/home',
    Feed: '/feed',
    Scan: '/scan',
    Maps: '/maps',
    Account: '/account'
  };

  //  Load icons here
  const icons = {
    Home: require(_dependencyMap[7], "../assets/icons/home.png"),
    Feed: require(_dependencyMap[8], "../assets/icons/feed.png"),
    Scan: require(_dependencyMap[9], "../assets/icons/scan.png"),
    Maps: require(_dependencyMap[10], "../assets/icons/map.png"),
    Account: require(_dependencyMap[11], "../assets/icons/account.png")
  };
  const tabs = ["Home", "Feed", "Scan", "Maps", "Account"];
  const BottomTabBar = ({
    activeTab
  }) => {
    _s();
    const router = (0, _expoRouter.useRouter)();
    return (0, _jsxRuntime.jsx)(_View.default, {
      className: "flex-row bg-white border-t border-gray-200 py-2 pb-5",
      children: tabs.map(tab => (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
        className: "flex-1 items-center py-2",
        onPress: () => router.push(routes[tab]),
        children: [(0, _jsxRuntime.jsx)(_Image.default, {
          source: icons[tab],
          className: "w-6 h-6 mb-1",
          resizeMode: "contain"
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: `text-xs font-medium ${activeTab === tab ? "text-green-600" : "text-gray-500"}`,
          children: tab
        })]
      }, tab))
    });
  };
  _s(BottomTabBar, "fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = BottomTabBar;
  var _default = exports.default = BottomTabBar;
  var _c;
  $RefreshReg$(_c, "BottomTabBar");
},730,[17,111,190,231,180,535,2,731,732,733,734,735],"components\\BottomTabBar.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Ficons/home.png",
    width: 25,
    height: 24
  };
},731,[],"assets\\icons\\home.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Ficons/feed.png",
    width: 25,
    height: 24
  };
},732,[],"assets\\icons\\feed.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Ficons/scan.png",
    width: 25,
    height: 24
  };
},733,[],"assets\\icons\\scan.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Ficons/map.png",
    width: 25,
    height: 24
  };
},734,[],"assets\\icons\\map.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Ficons/account.png",
    width: 25,
    height: 24
  };
},735,[],"assets\\icons\\account.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = FeedScreen;
  var _react = require(_dependencyMap[1], "react");
  var _expoRouter = require(_dependencyMap[2], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TextInput"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/TouchableOpacity"));
  var _FlatList = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/FlatList"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/SafeAreaView"));
  var _ArticleCard = _interopRequireDefault(require(_dependencyMap[9], "../components/ArticleCard"));
  var _FilterModal = _interopRequireDefault(require(_dependencyMap[10], "../components/FilterModal"));
  var _BottomTabBar = _interopRequireDefault(require(_dependencyMap[11], "../components/BottomTabBar"));
  var _profilepicture = _interopRequireDefault(require(_dependencyMap[12], "../assets/images/profilepicture.png"));
  var _article = _interopRequireDefault(require(_dependencyMap[13], "../assets/images/article1.png"));
  var _article2 = _interopRequireDefault(require(_dependencyMap[14], "../assets/images/article2.png"));
  var _article3 = _interopRequireDefault(require(_dependencyMap[15], "../assets/images/article3.png"));
  var _crown = _interopRequireDefault(require(_dependencyMap[16], "../assets/images/crown.svg"));
  var _filter = _interopRequireDefault(require(_dependencyMap[17], "../assets/images/filter.svg"));
  var _search = _interopRequireDefault(require(_dependencyMap[18], "../assets/images/search.svg"));
  var _jsxRuntime = require(_dependencyMap[19], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\feed.tsx",
    _s = $RefreshSig$(); // Load local PNG images
  // Load local SVG icons (these are React components after transformer setup)
  //  Your inline dummy data here
  const sampleArticles = [{
    id: 1,
    authorName: "Song Kim",
    authorImage: _profilepicture.default,
    isPremium: false,
    thumbnail: _article.default,
    title: "What are the type of geological rocks?",
    category: "Beginner",
    preview: "Discover the three main types of rocks...",
    likes: "1.5k"
  }, {
    id: 2,
    authorName: "Dr. Sarah Johnson",
    authorImage: _profilepicture.default,
    isPremium: true,
    thumbnail: _article2.default,
    title: "Advanced Mineral Identification",
    category: "Advanced",
    preview: "Learn professional methods for identifying minerals...",
    likes: "892"
  }, {
    id: 3,
    authorName: "Mike Chen",
    authorImage: _profilepicture.default,
    isPremium: false,
    thumbnail: _article3.default,
    title: "Fossil Hunting Guide",
    category: "Fossils",
    preview: "Everything you need to start your fossil hunting...",
    likes: "2.1k"
  }];
  function FeedScreen() {
    _s();
    const router = (0, _expoRouter.useRouter)();
    const [searchText, setSearchText] = (0, _react.useState)("");
    const [filterModalVisible, setFilterModalVisible] = (0, _react.useState)(false);
    const [activeBottomTab, setActiveBottomTab] = (0, _react.useState)("Feed");
    const handleFilter = () => setFilterModalVisible(true);
    const handleSubscribe = () => console.log("Subscribe pressed");
    return (0, _jsxRuntime.jsxs)(_SafeAreaView.default, {
      className: "flex-1 bg-white",
      children: [(0, _jsxRuntime.jsxs)(_View.default, {
        className: "flex-row px-4 py-3 items-center",
        children: [(0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-1 flex-row items-center bg-gray-100 rounded-xl px-4 py-3 mr-3",
          children: [(0, _jsxRuntime.jsx)(_search.default, {
            width: 20,
            height: 20,
            style: {
              marginRight: 10
            }
          }), (0, _jsxRuntime.jsx)(_TextInput.default, {
            className: "flex-1 text-base text-gray-800",
            value: searchText,
            onChangeText: setSearchText,
            placeholder: "Search articles...",
            placeholderTextColor: "#9ca3af"
          })]
        }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: handleFilter,
          className: "p-3 bg-gray-100 rounded-xl",
          children: (0, _jsxRuntime.jsx)(_filter.default, {
            width: 20,
            height: 20
          })
        })]
      }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
        onPress: handleSubscribe,
        className: "flex-row bg-[#EF9E1C] mx-4 p-4 rounded-xl mb-4 items-center",
        children: [(0, _jsxRuntime.jsx)(_crown.default, {
          width: 22,
          height: 22,
          style: {
            marginRight: 10
          },
          color: "white"
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: "flex-1 text-base font-semibold text-white",
          children: "Subscribe Now to Unlock Full Articles"
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-lg text-white",
          children: "\u2192"
        })]
      }), (0, _jsxRuntime.jsx)(_FlatList.default, {
        data: sampleArticles,
        keyExtractor: item => item.id.toString(),
        renderItem: ({
          item
        }) => (0, _jsxRuntime.jsx)(_ArticleCard.default, {
          article: item
        }),
        showsVerticalScrollIndicator: false,
        contentContainerStyle: {
          paddingHorizontal: 16,
          paddingBottom: 100
        }
      }), (0, _jsxRuntime.jsx)(_BottomTabBar.default, {
        activeTab: "Feed"
      }), (0, _jsxRuntime.jsx)(_FilterModal.default, {
        visible: filterModalVisible,
        onClose: () => setFilterModalVisible(false)
      })]
    });
  }
  _s(FeedScreen, "Vus11K34Wj5pjUsojdckTTYrf58=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = FeedScreen;
  var _c;
  $RefreshReg$(_c, "FeedScreen");
},736,[17,3,535,111,190,254,231,109,250,737,738,730,739,740,741,742,743,766,767,2],"app\\feed.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ArticleCard;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/TouchableOpacity"));
  var _Image = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Image"));
  var _jsxRuntime = require(_dependencyMap[5], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\components\\ArticleCard.tsx";
  function ArticleCard({
    article
  }) {
    const handleLike = () => {
      console.log("Like pressed for:", article.title);
    };
    const handleArticlePress = () => {
      console.log("Article pressed:", article.title);
    };
    return (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
      onPress: handleArticlePress,
      activeOpacity: 0.8,
      className: "bg-[#EFEFEF] rounded-xl mb-4 border border-[#EFEFEF] overflow-hidden",
      children: [(0, _jsxRuntime.jsxs)(_View.default, {
        className: "flex-row items-center px-4 py-3",
        children: [(0, _jsxRuntime.jsx)(_Image.default, {
          source: article.authorImage,
          style: {
            width: 40,
            height: 40,
            borderRadius: 999
          },
          className: "mr-3"
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-1",
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-base font-semibold text-gray-900",
            children: article.authorName
          }), (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xs text-gray-500",
            children: "1 min ago"
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          style: {
            minWidth: 80,
            alignItems: 'center'
          },
          className: `px-3 py-1 rounded-full ${article.isPremium ? "bg-[#EF9E1C]" : "bg-[#459B6C]"}`,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-white text-sm",
            children: article.isPremium ? "Premium" : "Free"
          })
        })]
      }), (0, _jsxRuntime.jsx)(_View.default, {
        children: (0, _jsxRuntime.jsx)(_Image.default, {
          source: article.thumbnail,
          style: {
            width: "100%",
            height: 200
          },
          resizeMode: "cover"
        })
      }), (0, _jsxRuntime.jsxs)(_View.default, {
        className: "px-4 pt-4  pb-4",
        children: [(0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-xl font-semibold text-gray-900 mb-2 leading-5",
          children: article.title
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "self-start bg-green-100 px-2 py-1 rounded-lg mb-2",
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xs font-medium text-green-600",
            children: article.category
          })
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-sm text-gray-500 leading-5",
          children: article.preview
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "flex-row items-center mt-3",
          children: (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
            onPress: handleLike,
            activeOpacity: 0.7,
            className: "flex-row items-center",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base mr-1",
              children: "\u2764\uFE0F"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-sm font-medium text-gray-500",
              children: article.likes
            })]
          })
        })]
      })]
    });
  }
  _c = ArticleCard;
  var _c;
  $RefreshReg$(_c, "ArticleCard");
},737,[17,111,190,231,180,2],"components\\ArticleCard.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = FilterModal;
  var _react = require(_dependencyMap[1], "react");
  var _View = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/TouchableOpacity"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/ScrollView"));
  var _Modal = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Modal"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/SafeAreaView"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\components\\FilterModal.tsx",
    _s = $RefreshSig$();
  function FilterModal({
    visible,
    onClose
  }) {
    _s();
    const [selectedCategories, setSelectedCategories] = (0, _react.useState)(["Beginner", "Fossils"]);
    const [sortBy, setSortBy] = (0, _react.useState)("Sort by Most Liked");
    const categories = ["Beginner", "Fossils", "Intermediate", "Mineral & Crystal", "Advanced", "Geology"];
    const removeCategory = category => {
      setSelectedCategories(prev => prev.filter(cat => cat !== category));
    };
    const addCategory = category => {
      if (!selectedCategories.includes(category)) {
        setSelectedCategories(prev => [...prev, category]);
      }
    };
    const handleReset = () => {
      setSelectedCategories([]);
      setSortBy("Sort by Most Liked");
    };
    const handleApply = () => {
      console.log("Apply filters:", {
        selectedCategories,
        sortBy
      });
      onClose();
    };
    return (0, _jsxRuntime.jsx)(_Modal.default, {
      visible: visible,
      animationType: "slide",
      presentationStyle: "pageSheet",
      onRequestClose: onClose,
      children: (0, _jsxRuntime.jsxs)(_SafeAreaView.default, {
        className: "flex-1 bg-white",
        children: [(0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-row items-center justify-between px-4 py-4 border-b border-gray-200",
          children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            onPress: onClose,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-2xl text-gray-800",
              children: "\u2190"
            })
          }), (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-lg font-semibold text-gray-900",
            children: "Filter"
          }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            onPress: handleReset,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-green-600 font-medium",
              children: "Reset"
            })
          })]
        }), (0, _jsxRuntime.jsxs)(_ScrollView.default, {
          className: "px-4 flex-1",
          children: [(0, _jsxRuntime.jsxs)(_View.default, {
            className: "my-5",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-lg font-semibold mb-3",
              children: "Categories"
            }), (0, _jsxRuntime.jsx)(_View.default, {
              className: "flex-row flex-wrap gap-2",
              children: selectedCategories.map((category, index) => (0, _jsxRuntime.jsxs)(_View.default, {
                className: "flex-row items-center bg-green-600 px-3 py-2 rounded-full",
                children: [(0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-white text-sm font-medium mr-1",
                  children: category
                }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                  onPress: () => removeCategory(category),
                  children: (0, _jsxRuntime.jsx)(_Text.default, {
                    className: "text-white text-lg font-bold",
                    children: "\xD7"
                  })
                })]
              }, index))
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "my-5",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-lg font-semibold mb-3",
              children: "Add Categories"
            }), (0, _jsxRuntime.jsx)(_View.default, {
              className: "flex-row flex-wrap gap-2",
              children: categories.filter(cat => !selectedCategories.includes(cat)).map((category, index) => (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                onPress: () => addCategory(category),
                className: "bg-gray-100 px-3 py-2 rounded-full",
                children: (0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-sm text-gray-600 font-medium",
                  children: category
                })
              }, index))
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "my-5",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-lg font-semibold mb-3",
              children: "Sort"
            }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
              className: "flex-row justify-between items-center bg-gray-100 px-4 py-3 rounded-lg",
              children: [(0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-base text-gray-900",
                children: sortBy
              }), (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-500",
                children: "\u25BC"
              })]
            })]
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "p-4 border-t border-gray-200",
          children: (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            onPress: handleApply,
            className: "bg-green-600 py-4 rounded-lg items-center",
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-white text-lg font-semibold",
              children: "Apply Filter"
            })
          })
        })]
      })
    });
  }
  _s(FilterModal, "7d88jL3tBPh6FuJES73nnIU3au0=");
  _c = FilterModal;
  var _c;
  $RefreshReg$(_c, "FilterModal");
},738,[17,3,111,190,231,135,237,250,2],"components\\FilterModal.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Fimages/profilepicture.png",
    width: 840,
    height: 859
  };
},739,[],"assets\\images\\profilepicture.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Fimages/article1.png",
    width: 268,
    height: 188
  };
},740,[],"assets\\images\\article1.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Fimages/article2.png",
    width: 3274,
    height: 1102
  };
},741,[],"assets\\images\\article2.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets%2Fimages/article3.png",
    width: 1980,
    height: 1200
  };
},742,[],"assets\\images\\article3.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _reactNativeSvg = _interopRequireWildcard(require(_dependencyMap[1], "react-native-svg"));
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\assets\\images\\crown.svg";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const SvgComponent = props => (0, _jsxRuntime.jsx)(_reactNativeSvg.default, Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    fill: "#505050",
    viewBox: "0 -960 960 960"
  }, props, {
    children: (0, _jsxRuntime.jsx)(_reactNativeSvg.Path, {
      d: "M200-160v-80h560v80zm0-140-51-321q-2 0-4.5.5t-4.5.5q-25 0-42.5-17.5T80-680t17.5-42.5T140-740t42.5 17.5T200-680q0 7-1.5 13t-3.5 11l125 56 125-171q-11-8-18-21t-7-28q0-25 17.5-42.5T480-880t42.5 17.5T540-820q0 15-7 28t-18 21l125 171 125-56q-2-5-3.5-11t-1.5-13q0-25 17.5-42.5T820-740t42.5 17.5T880-680t-17.5 42.5T820-620q-2 0-4.5-.5t-4.5-.5l-51 321zm68-80h424l26-167-105 46-133-183-133 183-105-46zm212 0"
    })
  }));
  _c = SvgComponent;
  var _default = exports.default = SvgComponent;
  var _c;
  $RefreshReg$(_c, "SvgComponent");
},743,[3,921,2],"assets\\images\\crown.svg");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _reactNativeSvg = _interopRequireWildcard(require(_dependencyMap[1], "react-native-svg"));
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\assets\\images\\filter.svg";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const SvgComponent = props => (0, _jsxRuntime.jsx)(_reactNativeSvg.default, Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    fill: "#505050",
    viewBox: "0 -960 960 960"
  }, props, {
    children: (0, _jsxRuntime.jsx)(_reactNativeSvg.Path, {
      d: "M440-120v-240h80v80h320v80H520v80zm-320-80v-80h240v80zm160-160v-80H120v-80h160v-80h80v240zm160-80v-80h400v80zm160-160v-240h80v80h160v80H680v80zm-480-80v-80h400v80z"
    })
  }));
  _c = SvgComponent;
  var _default = exports.default = SvgComponent;
  var _c;
  $RefreshReg$(_c, "SvgComponent");
},766,[3,921,2],"assets\\images\\filter.svg");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _reactNativeSvg = _interopRequireWildcard(require(_dependencyMap[1], "react-native-svg"));
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\assets\\images\\search.svg";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const SvgComponent = props => (0, _jsxRuntime.jsx)(_reactNativeSvg.default, Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    fill: "#505050",
    viewBox: "0 -960 960 960"
  }, props, {
    children: (0, _jsxRuntime.jsx)(_reactNativeSvg.Path, {
      d: "M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580t75.5-184.5T380-840t184.5 75.5T640-580q0 44-14 83t-38 69l252 252zM380-400q75 0 127.5-52.5T560-580t-52.5-127.5T380-760t-127.5 52.5T200-580t52.5 127.5T380-400"
    })
  }));
  _c = SvgComponent;
  var _default = exports.default = SvgComponent;
  var _c;
  $RefreshReg$(_c, "SvgComponent");
},767,[3,921,2],"assets\\images\\search.svg");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HomeScreen;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _expoRouter = require(_dependencyMap[2], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TextInput"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/TouchableOpacity"));
  var _Image = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/Image"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/SafeAreaView"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[9], "react-native-web/dist/exports/ScrollView"));
  var _BottomTabBar = _interopRequireDefault(require(_dependencyMap[10], "../components/BottomTabBar"));
  var _jsxRuntime = require(_dependencyMap[11], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\home.tsx",
    _s = $RefreshSig$();
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function HomeScreen() {
    _s();
    const [searchText, setSearchText] = (0, _react.useState)("");
    const router = (0, _expoRouter.useRouter)();
    const handleArticlePress = article => {
      console.log(`Article pressed: ${article}`);
    };
    const rocks = [{
      id: 1,
      name: "Bedrock",
      category: "Igneous Rock",
      rarity: "Common",
      image: {
        uri: "https://via.placeholder.com/48"
      }
    }, {
      id: 2,
      name: "Bedcover",
      category: "Igneous Rock",
      rarity: "Rare",
      image: {
        uri: "https://via.placeholder.com/48"
      }
    }, {
      id: 3,
      name: "Bedcover",
      category: "Igneous Rock",
      rarity: "Legendary",
      image: {
        uri: "https://via.placeholder.com/48"
      }
    }];
    const filteredRocks = rocks.filter(rock => rock.name.toLowerCase().includes(searchText.toLowerCase()));
    return (0, _jsxRuntime.jsxs)(_SafeAreaView.default, {
      className: "flex-1 bg-white",
      children: [(0, _jsxRuntime.jsxs)(_ScrollView.default, {
        className: "flex-1",
        showsVerticalScrollIndicator: false,
        children: [(0, _jsxRuntime.jsxs)(_View.default, {
          className: "items-center pt-5 pb-6",
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-3xl font-bold text-black mb-1",
            children: "ROCKLAND"
          }), (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-sm text-blue-500",
            children: "#1 Rock Learning Platform"
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "px-5 mb-5",
          children: (0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row items-center bg-gray-100 rounded-xl px-4 py-3",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-lg mr-3",
              children: "\uD83D\uDD0D"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              className: "flex-1 text-base text-gray-800",
              value: searchText,
              onChangeText: setSearchText,
              placeholder: "Search rocks, minerals...",
              placeholderTextColor: "#9ca3af"
            })]
          })
        }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
          className: "flex-row items-center bg-yellow-500 mx-5 py-4 px-5 rounded-xl mb-5",
          activeOpacity: 0.8,
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xl mr-3",
            children: "\uD83D\uDC51"
          }), (0, _jsxRuntime.jsx)(_Text.default, {
            className: "flex-1 text-base font-semibold text-white",
            children: "Tap to unlock full features"
          }), (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-lg text-white",
            children: "\u2192"
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-row px-5 mb-8 space-x-3",
          children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "flex-1 bg-green-600 py-4 rounded-xl items-center",
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-semibold text-white",
              children: "Take Quiz"
            })
          }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "flex-1 bg-green-600 py-4 rounded-xl items-center",
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-semibold text-white",
              children: "Leaderboard"
            })
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "px-5 mb-8",
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xl font-bold text-gray-900 mb-4",
            children: "Popular on Rockland"
          }), (0, _jsxRuntime.jsx)(_View.default, {
            className: "flex-row flex-wrap justify-between",
            children: [1, 2, 3, 4].map((_, i) => (0, _jsxRuntime.jsx)(_View.default, {
              className: "w-[47%] aspect-square bg-gray-200 rounded-xl mb-3"
            }, i))
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "px-5 mb-8",
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xl font-bold text-gray-900 mb-4",
            children: "Rock Results"
          }), filteredRocks.map((rock, index) => {
            const containerClass = "flex-row items-center bg-white p-3 border-b border-gray-200 " + (index === 0 ? "border-2 border-blue-500" : "");
            const badgeClass = "px-3 py-1 rounded-full " + (rock.rarity === "Rare" ? "bg-green-500" : rock.rarity === "Legendary" ? "bg-yellow-500" : "bg-gray-400");
            return (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
              className: containerClass,
              activeOpacity: 0.8,
              children: [(0, _jsxRuntime.jsx)(_Image.default, {
                source: rock.image,
                className: "w-12 h-12 mr-3 rounded"
              }), (0, _jsxRuntime.jsxs)(_View.default, {
                className: "flex-1",
                children: [(0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-base font-semibold text-gray-900",
                  children: rock.name
                }), (0, _jsxRuntime.jsxs)(_Text.default, {
                  className: "text-sm text-gray-500",
                  children: ["Category: ", rock.category]
                })]
              }), (0, _jsxRuntime.jsx)(_View.default, {
                className: badgeClass,
                children: (0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-xs font-medium text-white",
                  children: rock.rarity
                })
              })]
            }, rock.id);
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "px-5 mb-8",
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-xl font-bold text-gray-900 mb-4",
            children: "Top Articles"
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row space-x-4",
            children: [(0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
              className: "flex-1",
              onPress: () => handleArticlePress("geological rocks"),
              activeOpacity: 0.8,
              children: [(0, _jsxRuntime.jsx)(_Image.default, {
                source: {
                  uri: "/placeholder.svg?height=120&width=160"
                },
                className: "w-full h-32 rounded-xl mb-2",
                resizeMode: "cover"
              }), (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-700 leading-5",
                children: "What are the type of geological rocks?"
              })]
            }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
              className: "flex-1",
              onPress: () => handleArticlePress("rock formation"),
              activeOpacity: 0.8,
              children: [(0, _jsxRuntime.jsx)(_Image.default, {
                source: {
                  uri: "/placeholder.svg?height=120&width=160"
                },
                className: "w-full h-32 rounded-xl mb-2",
                resizeMode: "cover"
              }), (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-700 leading-5",
                children: "How do sedimentary rocks form?"
              })]
            })]
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "h-5"
        })]
      }), (0, _jsxRuntime.jsx)(_BottomTabBar.default, {
        activeTab: "Home"
      })]
    });
  }
  _s(HomeScreen, "oplQ55BqpGDQGEG4xPKR4hLTcVs=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = HomeScreen;
  var _c;
  $RefreshReg$(_c, "HomeScreen");
},768,[17,3,535,111,190,254,231,180,250,135,730,2],"app\\home.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = WelcomeScreen;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _expoRouter = require(_dependencyMap[2], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TouchableOpacity"));
  var _Image = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Image"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/SafeAreaView"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\index.tsx",
    _s = $RefreshSig$();
  function WelcomeScreen() {
    _s();
    const router = (0, _expoRouter.useRouter)();
    const handleLogin = () => {
      router.push('/login');
    };
    const handleRegister = () => {
      console.log('Navigate to register');
    };
    return (0, _jsxRuntime.jsx)(_SafeAreaView.default, {
      className: "flex-1 bg-white",
      children: (0, _jsxRuntime.jsxs)(_View.default, {
        className: "flex-1 px-6",
        children: [(0, _jsxRuntime.jsxs)(_View.default, {
          className: "flex-1 justify-center items-center",
          children: [(0, _jsxRuntime.jsx)(_Image.default, {
            source: {
              uri: '/placeholder.svg?height=120&width=120'
            },
            className: "w-30 h-30 mb-8",
            resizeMode: "contain"
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "items-center mb-12",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-2xl text-gray-500 mb-2",
              children: "Welcome to"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-4xl font-bold text-green-600",
              children: "ROCKLAND"
            })]
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          className: "pb-8",
          children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "bg-green-600 py-4 rounded-lg mb-4",
            onPress: handleLogin,
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-white text-lg font-semibold text-center",
              children: "Log In"
            })
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row justify-center items-center",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base text-gray-500",
              children: "Don't have an account? "
            }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
              onPress: handleRegister,
              activeOpacity: 0.7,
              children: (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-base text-green-600 font-medium",
                children: "Register"
              })
            })]
          })]
        })]
      })
    });
  }
  _s(WelcomeScreen, "fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = WelcomeScreen;
  var _c;
  $RefreshReg$(_c, "WelcomeScreen");
},769,[17,3,535,111,190,231,180,250,2],"app\\index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = LoginScreen;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _expoRouter = require(_dependencyMap[2], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TextInput"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/TouchableOpacity"));
  var _Image = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/Image"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/SafeAreaView"));
  var _jsxRuntime = require(_dependencyMap[9], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\login.tsx",
    _s = $RefreshSig$();
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function LoginScreen() {
    _s();
    const [email, setEmail] = (0, _react.useState)("");
    const [password, setPassword] = (0, _react.useState)("");
    const [showPassword, setShowPassword] = (0, _react.useState)(false);
    const [rememberMe, setRememberMe] = (0, _react.useState)(false);
    const router = (0, _expoRouter.useRouter)();
    const handleLogin = () => {
      if (email === "test@rockland.com" && password === "rock123") {
        router.replace("/home");
      } else {
        alert("Invalid email or password");
      }
    };
    const handleRegister = () => {
      console.log("Navigate to register");
    };
    const handleForgotPassword = () => {
      console.log("Navigate to forgot password");
    };
    const handleGoogleLogin = () => {
      console.log("Google login pressed");
    };
    return (0, _jsxRuntime.jsx)(_SafeAreaView.default, {
      className: "flex-1 bg-green-600",
      children: (0, _jsxRuntime.jsx)(_View.default, {
        className: "flex-1 justify-center px-6",
        children: (0, _jsxRuntime.jsxs)(_View.default, {
          className: "bg-white rounded-2xl p-6 shadow-lg shadow-black/10",
          children: [(0, _jsxRuntime.jsxs)(_View.default, {
            className: "items-center mb-8",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-2xl font-bold text-gray-800 mb-2",
              children: "Login"
            }), (0, _jsxRuntime.jsxs)(_View.default, {
              className: "flex-row items-center",
              children: [(0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-500",
                children: "Don't have an account? "
              }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                onPress: handleRegister,
                activeOpacity: 0.7,
                children: (0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-sm text-green-600 font-medium",
                  children: "Register"
                })
              })]
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "mb-5",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-medium text-gray-700 mb-2",
              children: "Email"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              className: "border border-gray-300 rounded-lg px-4 py-3.5 text-base text-gray-800 bg-gray-50",
              textAlignVertical: "center",
              value: email,
              onChangeText: setEmail,
              placeholder: "Enter your email",
              placeholderTextColor: "#9ca3af",
              keyboardType: "email-address",
              autoCapitalize: "none"
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "mb-5",
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-medium text-gray-700 mb-2",
              children: "Password"
            }), (0, _jsxRuntime.jsxs)(_View.default, {
              className: "flex-row items-center border border-gray-300 rounded-lg bg-gray-50",
              children: [(0, _jsxRuntime.jsx)(_TextInput.default, {
                className: "flex-1 px-4 py-3 text-base text-gray-800",
                value: password,
                onChangeText: setPassword,
                placeholder: "Enter your password",
                placeholderTextColor: "#9ca3af",
                secureTextEntry: !showPassword
              }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                className: "px-4 py-3",
                onPress: () => setShowPassword(!showPassword),
                activeOpacity: 0.7,
                children: (0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-lg",
                  children: showPassword ? "" : ""
                })
              })]
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row justify-between items-center mb-6",
            children: [(0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
              className: "flex-row items-center",
              onPress: () => setRememberMe(!rememberMe),
              activeOpacity: 0.7,
              children: [(0, _jsxRuntime.jsx)(_View.default, {
                className: `w-5 h-5 border-2 rounded border-gray-300 mr-2 items-center justify-center ${rememberMe ? "bg-green-600 border-green-600" : ""}`,
                children: rememberMe && (0, _jsxRuntime.jsx)(_Text.default, {
                  className: "text-white text-xs font-bold",
                  children: "\u2713"
                })
              }), (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-gray-700",
                children: "Remember me"
              })]
            }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
              onPress: handleForgotPassword,
              activeOpacity: 0.7,
              children: (0, _jsxRuntime.jsx)(_Text.default, {
                className: "text-sm text-green-600 font-medium",
                children: "Forgot Password?"
              })
            })]
          }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
            className: "bg-green-600 py-4 rounded-lg mb-6",
            onPress: handleLogin,
            activeOpacity: 0.8,
            children: (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-white text-lg font-semibold text-center",
              children: "Log In"
            })
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            className: "flex-row items-center mb-6",
            children: [(0, _jsxRuntime.jsx)(_View.default, {
              className: "flex-1 h-px bg-gray-200"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "mx-4 text-sm text-gray-500",
              children: "Or"
            }), (0, _jsxRuntime.jsx)(_View.default, {
              className: "flex-1 h-px bg-gray-200"
            })]
          }), (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
            className: "flex-row items-center justify-center bg-white border border-gray-300 py-4 rounded-lg",
            onPress: handleGoogleLogin,
            activeOpacity: 0.8,
            children: [(0, _jsxRuntime.jsx)(_Image.default, {
              source: {
                uri: "/placeholder.svg?height=20&width=20"
              },
              className: "w-5 h-5 mr-3"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              className: "text-base font-medium text-gray-700",
              children: "Continue with Google"
            })]
          })]
        })
      })
    });
  }
  _s(LoginScreen, "L06EcN8vTeTHXB1JmUxlx+jcAkc=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = LoginScreen;
  var _c;
  $RefreshReg$(_c, "LoginScreen");
},770,[17,3,535,111,190,254,231,180,250,2],"app\\login.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = MapsScreen;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Text"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\maps.tsx";
  function MapsScreen() {
    return (0, _jsxRuntime.jsx)(_View.default, {
      className: "flex-1 justify-center items-center",
      children: (0, _jsxRuntime.jsx)(_Text.default, {
        children: "Maps Screen"
      })
    });
  }
  _c = MapsScreen;
  var _c;
  $RefreshReg$(_c, "MapsScreen");
},771,[17,111,190,2],"app\\maps.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use client";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ProfileScreen;
  var _react = require(_dependencyMap[1], "react");
  var _expoRouter = require(_dependencyMap[2], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TextInput = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TextInput"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/TouchableOpacity"));
  var _SafeAreaView = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/SafeAreaView"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/StyleSheet"));
  var _Image = _interopRequireDefault(require(_dependencyMap[9], "react-native-web/dist/exports/Image"));
  var _ScrollView = _interopRequireDefault(require(_dependencyMap[10], "react-native-web/dist/exports/ScrollView"));
  var _jsxRuntime = require(_dependencyMap[11], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\profile.tsx",
    _s = $RefreshSig$();
  function ProfileScreen() {
    _s();
    const [firstName, setFirstName] = (0, _react.useState)("Lois");
    const [lastName, setLastName] = (0, _react.useState)("Becket");
    const [email, setEmail] = (0, _react.useState)("Loisbecket@gmail.com");
    const [password, setPassword] = (0, _react.useState)("password123");
    const [showPassword, setShowPassword] = (0, _react.useState)(false);
    const [dateOfBirth, setDateOfBirth] = (0, _react.useState)("18/03/2024");
    const [interests, setInterests] = (0, _react.useState)(["Volcanic Rock", "Fossils", "Mineral & Crystal"]);
    const [selectedGender, setSelectedGender] = (0, _react.useState)("Female");
    const genderOptions = ["Female", "Male", "Rather not say"];
    const router = (0, _expoRouter.useRouter)();
    const handleBack = () => {
      router.push("/account");
    };
    const handleEdit = () => {
      console.log("Edit pressed");
    };
    const removeInterest = interest => {
      setInterests(prev => prev.filter(item => item !== interest));
    };
    const handleGenderSelect = gender => {
      setSelectedGender(gender);
    };
    return (0, _jsxRuntime.jsxs)(_SafeAreaView.default, {
      style: styles.container,
      children: [(0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.header,
        children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: handleBack,
          activeOpacity: 0.7,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            style: styles.backIcon,
            children: "\u2190"
          })
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          style: styles.title,
          children: "Profile"
        }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: handleEdit,
          activeOpacity: 0.7,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            style: styles.editButton,
            children: "Edit"
          })
        })]
      }), (0, _jsxRuntime.jsxs)(_ScrollView.default, {
        style: styles.content,
        showsVerticalScrollIndicator: false,
        children: [(0, _jsxRuntime.jsx)(_View.default, {
          style: styles.avatarContainer,
          children: (0, _jsxRuntime.jsx)(_Image.default, {
            source: {
              uri: "/placeholder.svg?height=100&width=100"
            },
            style: styles.avatar
          })
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          style: styles.formSection,
          children: [(0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "First Name"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              style: styles.textInput,
              value: firstName,
              onChangeText: setFirstName,
              placeholder: "Enter first name",
              placeholderTextColor: "#9ca3af"
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Last Name"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              style: styles.textInput,
              value: lastName,
              onChangeText: setLastName,
              placeholder: "Enter last name",
              placeholderTextColor: "#9ca3af"
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Email"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              style: styles.textInput,
              value: email,
              onChangeText: setEmail,
              placeholder: "Enter email",
              placeholderTextColor: "#9ca3af",
              keyboardType: "email-address",
              autoCapitalize: "none"
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Password"
            }), (0, _jsxRuntime.jsxs)(_View.default, {
              style: styles.passwordContainer,
              children: [(0, _jsxRuntime.jsx)(_TextInput.default, {
                style: styles.passwordInput,
                value: showPassword ? password : "",
                onChangeText: setPassword,
                placeholder: "Enter password",
                placeholderTextColor: "#9ca3af",
                secureTextEntry: !showPassword,
                editable: showPassword
              }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                style: styles.eyeButton,
                onPress: () => setShowPassword(!showPassword),
                activeOpacity: 0.7,
                children: (0, _jsxRuntime.jsx)(_Text.default, {
                  style: styles.eyeIcon,
                  children: showPassword ? "" : ""
                })
              })]
            })]
          })]
        }), (0, _jsxRuntime.jsxs)(_View.default, {
          style: styles.profilingSection,
          children: [(0, _jsxRuntime.jsx)(_Text.default, {
            style: styles.sectionTitle,
            children: "Profiling"
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Date of Birth"
            }), (0, _jsxRuntime.jsx)(_TextInput.default, {
              style: styles.textInput,
              value: dateOfBirth,
              onChangeText: setDateOfBirth,
              placeholder: "DD/MM/YYYY",
              placeholderTextColor: "#9ca3af"
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Interests"
            }), (0, _jsxRuntime.jsx)(_View.default, {
              style: styles.interestTags,
              children: interests.map((interest, index) => (0, _jsxRuntime.jsxs)(_View.default, {
                style: styles.interestTag,
                children: [(0, _jsxRuntime.jsx)(_Text.default, {
                  style: styles.interestText,
                  children: interest
                }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
                  onPress: () => removeInterest(interest),
                  activeOpacity: 0.7,
                  children: (0, _jsxRuntime.jsx)(_Text.default, {
                    style: styles.removeIcon,
                    children: "\xD7"
                  })
                })]
              }, index))
            })]
          }), (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.inputContainer,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.inputLabel,
              children: "Gender"
            }), (0, _jsxRuntime.jsx)(_View.default, {
              style: styles.genderOptions,
              children: genderOptions.map((gender, index) => (0, _jsxRuntime.jsxs)(_TouchableOpacity.default, {
                style: styles.genderOption,
                onPress: () => handleGenderSelect(gender),
                activeOpacity: 0.7,
                children: [(0, _jsxRuntime.jsx)(_View.default, {
                  style: styles.radioButton,
                  children: (0, _jsxRuntime.jsx)(_View.default, {
                    style: [styles.radioInner, selectedGender === gender && styles.radioSelected]
                  })
                }), (0, _jsxRuntime.jsx)(_Text.default, {
                  style: styles.genderText,
                  children: gender
                })]
              }, index))
            })]
          })]
        }), (0, _jsxRuntime.jsx)(_View.default, {
          style: styles.bottomSpacing
        })]
      })]
    });
  }
  _s(ProfileScreen, "qPYbTv6a9gj06T6AL4xshpkQ0vc=", false, function () {
    return [_expoRouter.useRouter];
  });
  _c = ProfileScreen;
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1,
      backgroundColor: "#ffffff"
    },
    header: {
      flexDirection: "row",
      alignItems: "center",
      justifyContent: "space-between",
      paddingHorizontal: 16,
      paddingVertical: 16,
      borderBottomWidth: 1,
      borderBottomColor: "#f3f4f6"
    },
    backIcon: {
      fontSize: 24,
      color: "#1f2937"
    },
    title: {
      fontSize: 18,
      fontWeight: "600",
      color: "#1f2937"
    },
    editButton: {
      fontSize: 16,
      color: "#16a34a",
      fontWeight: "500"
    },
    content: {
      flex: 1,
      paddingHorizontal: 16
    },
    avatarContainer: {
      alignItems: "center",
      paddingVertical: 32
    },
    avatar: {
      width: 100,
      height: 100,
      borderRadius: 50,
      backgroundColor: "#f3f4f6"
    },
    formSection: {
      marginBottom: 32
    },
    inputContainer: {
      marginBottom: 20
    },
    inputLabel: {
      fontSize: 16,
      fontWeight: "500",
      color: "#374151",
      marginBottom: 8
    },
    textInput: {
      borderWidth: 1,
      borderColor: "#d1d5db",
      borderRadius: 8,
      paddingHorizontal: 16,
      paddingVertical: 12,
      fontSize: 16,
      color: "#1f2937",
      backgroundColor: "#f9fafb"
    },
    passwordContainer: {
      flexDirection: "row",
      alignItems: "center",
      borderWidth: 1,
      borderColor: "#d1d5db",
      borderRadius: 8,
      backgroundColor: "#f9fafb"
    },
    passwordInput: {
      flex: 1,
      paddingHorizontal: 16,
      paddingVertical: 12,
      fontSize: 16,
      color: "#1f2937"
    },
    eyeButton: {
      paddingHorizontal: 16,
      paddingVertical: 12
    },
    eyeIcon: {
      fontSize: 18
    },
    profilingSection: {
      marginBottom: 32
    },
    sectionTitle: {
      fontSize: 20,
      fontWeight: "600",
      color: "#1f2937",
      marginBottom: 20
    },
    interestTags: {
      flexDirection: "row",
      flexWrap: "wrap",
      gap: 8
    },
    interestTag: {
      flexDirection: "row",
      alignItems: "center",
      backgroundColor: "#16a34a",
      paddingHorizontal: 12,
      paddingVertical: 8,
      borderRadius: 20
    },
    interestText: {
      color: "#ffffff",
      fontSize: 14,
      fontWeight: "500",
      marginRight: 8
    },
    removeIcon: {
      color: "#ffffff",
      fontSize: 16,
      fontWeight: "bold"
    },
    genderOptions: {
      gap: 16
    },
    genderOption: {
      flexDirection: "row",
      alignItems: "center"
    },
    radioButton: {
      width: 20,
      height: 20,
      borderRadius: 10,
      borderWidth: 2,
      borderColor: "#d1d5db",
      marginRight: 12,
      justifyContent: "center",
      alignItems: "center"
    },
    radioInner: {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: "transparent"
    },
    radioSelected: {
      backgroundColor: "#16a34a"
    },
    genderText: {
      fontSize: 16,
      color: "#1f2937"
    },
    bottomSpacing: {
      height: 40
    }
  });
  var _c;
  $RefreshReg$(_c, "ProfileScreen");
},772,[17,3,535,111,190,254,231,250,30,180,135,2],"app\\profile.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ScanResult;
  var _expoRouter = require(_dependencyMap[1], "expo-router");
  var _View = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/TouchableOpacity"));
  var _expoImage = require(_dependencyMap[5], "expo-image");
  var _Ionicons = _interopRequireDefault(require(_dependencyMap[6], "@expo/vector-icons/Ionicons"));
  var _jsxRuntime = require(_dependencyMap[7], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\scan-result.tsx",
    _s = $RefreshSig$(); // Function to randomize rarity
  const getRandomRarity = () => {
    const rarities = [{
      label: "Common",
      color: "#9CA3AF",
      width: 100
    }, {
      label: "Rare",
      color: "#16A34A",
      width: 100
    }, {
      label: "Legendary",
      color: "#EF9E1C",
      width: 120
    }];
    const randomIndex = Math.floor(Math.random() * rarities.length);
    return rarities[randomIndex];
  };
  function ScanResult() {
    _s();
    const params = (0, _expoRouter.useLocalSearchParams)();
    const image = typeof params.image === "string" ? params.image : undefined;
    const router = (0, _expoRouter.useRouter)();
    const rarity = getRandomRarity();
    const displayImage = image ?? "https://via.placeholder.com/200";
    return (0, _jsxRuntime.jsxs)(_View.default, {
      className: "flex-1 bg-white pt-[50px] items-center",
      children: [(0, _jsxRuntime.jsxs)(_View.default, {
        className: "flex-row items-center justify-between w-full px-5 mb-10",
        children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: () => router.back(),
          className: "p-1.5",
          children: (0, _jsxRuntime.jsx)(_Ionicons.default, {
            name: "chevron-back",
            size: 24,
            color: "#111827"
          })
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-[18px] font-bold text-[#111827]",
          children: "Scan Result"
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "w-6"
        })]
      }), (0, _jsxRuntime.jsx)(_expoImage.Image, {
        source: {
          uri: displayImage
        },
        style: {
          width: 200,
          height: 200,
          borderRadius: 12
        },
        contentFit: "cover"
      }), (0, _jsxRuntime.jsx)(_View.default, {
        className: "mt-5 h-5 rounded-full justify-center items-center",
        style: {
          backgroundColor: rarity.color,
          width: rarity.width
        },
        children: (0, _jsxRuntime.jsxs)(_Text.default, {
          className: "text-white text-[12px] font-semibold",
          children: ["Rarity: ", rarity.label]
        })
      }), (0, _jsxRuntime.jsxs)(_View.default, {
        className: "mt-8",
        children: [(0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-[12px] text-[#374151] mb-1.5",
          children: "Rock Name"
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "w-[295px] h-[46px] border border-[#D1D5DB] rounded-lg px-3 flex-row items-center",
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-[14px] text-[#111827]",
            children: "Granite"
          })
        }), (0, _jsxRuntime.jsx)(_Text.default, {
          className: "text-[12px] text-[#374151] mt-4 mb-1.5",
          children: "Rock Type"
        }), (0, _jsxRuntime.jsx)(_View.default, {
          className: "w-[295px] h-[46px] border border-[#D1D5DB] rounded-lg px-3 flex-row items-center",
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            className: "text-[14px] text-[#111827]",
            children: "Igneous"
          })
        })]
      })]
    });
  }
  _s(ScanResult, "hOQnOjHVTyGJQgEc3Bwsg+C0M9A=", false, function () {
    return [_expoRouter.useLocalSearchParams, _expoRouter.useRouter];
  });
  _c = ScanResult;
  var _c;
  $RefreshReg$(_c, "ScanResult");
},773,[17,535,111,190,231,774,801,2],"app\\scan-result.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    Image: true,
    ImageBackground: true,
    useImage: true
  };
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return _Image2.Image;
    }
  });
  Object.defineProperty(exports, "ImageBackground", {
    enumerable: true,
    get: function () {
      return _ImageBackground.ImageBackground;
    }
  });
  Object.defineProperty(exports, "useImage", {
    enumerable: true,
    get: function () {
      return _useImage.useImage;
    }
  });
  var _Image = require(_dependencyMap[0], "./Image.types");
  Object.keys(_Image).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Image[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Image[key];
      }
    });
  });
  var _Image2 = require(_dependencyMap[1], "./Image");
  var _ImageBackground = require(_dependencyMap[2], "./ImageBackground");
  var _useImage = require(_dependencyMap[3], "./useImage");
},774,[775,776,799,800],"node_modules\\expo-image\\src\\index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},775,[],"node_modules\\expo-image\\src\\Image.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Image = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _react = _interopRequireDefault(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _ExpoImage = _interopRequireDefault(require(_dependencyMap[5], "./ExpoImage"));
  var _ImageModule = _interopRequireDefault(require(_dependencyMap[6], "./ImageModule"));
  var _utils = require(_dependencyMap[7], "./utils");
  var _resolveSources = require(_dependencyMap[8], "./utils/resolveSources");
  var _jsxRuntime = require(_dependencyMap[9], "react-native-css-interop/jsx-runtime");
  const _excluded = ["style", "source", "placeholder", "contentFit", "contentPosition", "transition", "fadeDuration", "resizeMode", "defaultSource", "loadingIndicatorSource"],
    _excluded2 = ["resizeMode"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\Image.tsx";
  let loggedDefaultSourceDeprecationWarning = false;
  let loggedRenderingChildrenWarning = false;
  class Image extends _react.default.PureComponent {
    constructor(props) {
      super(props);
      this.nativeViewRef = (0, _expoModulesCore.createSnapshotFriendlyRef)();
      this.containerViewRef = (0, _expoModulesCore.createSnapshotFriendlyRef)();
    }

    // Reanimated support on web
    getAnimatableRef = () => {
      if (_expoModulesCore.Platform.OS === 'web') {
        return this.containerViewRef.current;
      } else {
        return this;
      }
    };

    /**
     * @hidden
     */
    static Image = _ImageModule.default.Image;

    /**
     * Preloads images at the given URLs that can be later used in the image view.
     * Preloaded images are cached to the memory and disk by default, so make sure
     * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).
     * @param urls - A URL string or an array of URLs of images to prefetch.
     * @param {ImagePrefetchOptions['cachePolicy']} cachePolicy - The cache policy for prefetched images.
     * @return A promise resolving to `true` as soon as all images have been
     * successfully prefetched. If an image fails to be prefetched, the promise
     * will immediately resolve to `false` regardless of whether other images have
     * finished prefetching.
     */

    /**
     * Preloads images at the given URLs that can be later used in the image view.
     * Preloaded images are cached to the memory and disk by default, so make sure
     * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).
     * @param urls - A URL string or an array of URLs of images to prefetch.
     * @param options - Options for prefetching images.
     * @return A promise resolving to `true` as soon as all images have been
     * successfully prefetched. If an image fails to be prefetched, the promise
     * will immediately resolve to `false` regardless of whether other images have
     * finished prefetching.
     */

    static async prefetch(urls, options) {
      let cachePolicy = 'memory-disk';
      let headers;
      switch (typeof options) {
        case 'string':
          cachePolicy = options;
          break;
        case 'object':
          cachePolicy = options.cachePolicy ?? cachePolicy;
          headers = options.headers;
          break;
      }
      return _ImageModule.default.prefetch(Array.isArray(urls) ? urls : [urls], cachePolicy, headers);
    }

    /**
     * Asynchronously clears all images stored in memory.
     * @platform android
     * @platform ios
     * @return A promise resolving to `true` when the operation succeeds.
     * It may resolve to `false` on Android when the activity is no longer available.
     * Resolves to `false` on Web.
     */
    static async clearMemoryCache() {
      return await _ImageModule.default.clearMemoryCache();
    }

    /**
     * Asynchronously clears all images from the disk cache.
     * @platform android
     * @platform ios
     * @return A promise resolving to `true` when the operation succeeds.
     * It may resolve to `false` on Android when the activity is no longer available.
     * Resolves to `false` on Web.
     */
    static async clearDiskCache() {
      return await _ImageModule.default.clearDiskCache();
    }

    /**
     * Asynchronously checks if an image exists in the disk cache and resolves to
     * the path of the cached image if it does.
     * @param cacheKey - The cache key for the requested image. Unless you have set
     * a custom cache key, this will be the source URL of the image.
     * @platform android
     * @platform ios
     * @return A promise resolving to the path of the cached image. It will resolve
     * to `null` if the image does not exist in the cache.
     */
    static async getCachePathAsync(cacheKey) {
      return await _ImageModule.default.getCachePathAsync(cacheKey);
    }

    /**
     * Asynchronously generates a [Blurhash](https://blurha.sh) from an image.
     * @param url - The URL of the image to generate a blurhash from.
     * @param numberOfComponents - The number of components to encode the blurhash with.
     * Must be between 1 and 9. Defaults to `[4, 3]`.
     * @platform ios
     * @return A promise resolving to the blurhash string.
     */
    static async generateBlurhashAsync(url, numberOfComponents) {
      return await _ImageModule.default.generateBlurhashAsync(url, numberOfComponents);
    }

    /**
     * Asynchronously starts playback of the view's image if it is animated.
     * @platform android
     * @platform ios
     */
    async startAnimating() {
      await this.nativeViewRef.current?.startAnimating();
    }

    /**
     * Asynchronously stops the playback of the view's image if it is animated.
     * @platform android
     * @platform ios
     */
    async stopAnimating() {
      await this.nativeViewRef.current?.stopAnimating();
    }

    /**
     * Prevents the resource from being reloaded by locking it.
     * @platform android
     * @platform ios
     */
    async lockResourceAsync() {
      await this.nativeViewRef.current?.lockResourceAsync();
    }

    /**
     * Releases the lock on the resource, allowing it to be reloaded.
     * @platform android
     * @platform ios
     */
    async unlockResourceAsync() {
      await this.nativeViewRef.current?.unlockResourceAsync();
    }

    /**
     * Reloads the resource, ignoring lock.
     * @platform android
     * @platform ios
     */
    async reloadAsync() {
      await this.nativeViewRef.current?.reloadAsync();
    }

    /**
     * Loads an image from the given source to memory and resolves to
     * an object that references the native image instance.
     * @platform android
     * @platform ios
     * @platform web
     */
    static async loadAsync(source, options) {
      const resolvedSource = (0, _resolveSources.resolveSource)(source);
      return await _ImageModule.default.loadAsync(resolvedSource, options);
    }
    render() {
      const _this$props = this.props,
        {
          style,
          source,
          placeholder,
          contentFit,
          contentPosition,
          transition,
          fadeDuration,
          resizeMode: resizeModeProp,
          defaultSource,
          loadingIndicatorSource
        } = _this$props,
        restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      const _ref = _StyleSheet.default.flatten(style) || {},
        {
          resizeMode: resizeModeStyle
        } = _ref,
        restStyle = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded2);
      const resizeMode = resizeModeProp ?? resizeModeStyle;
      if ((defaultSource || loadingIndicatorSource) && !loggedDefaultSourceDeprecationWarning) {
        console.warn('[expo-image]: `defaultSource` and `loadingIndicatorSource` props are deprecated, use `placeholder` instead');
        loggedDefaultSourceDeprecationWarning = true;
      }
      // @ts-expect-error
      if (restProps.children && !loggedRenderingChildrenWarning) {
        console.warn('The <Image> component does not support children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
        loggedRenderingChildrenWarning = true;
      }
      return (0, _jsxRuntime.jsx)(_ExpoImage.default, Object.assign({}, restProps, {
        style: restStyle,
        source: (0, _resolveSources.resolveSources)(source),
        placeholder: (0, _resolveSources.resolveSources)(placeholder ?? defaultSource ?? loadingIndicatorSource),
        contentFit: (0, _utils.resolveContentFit)(contentFit, resizeMode),
        contentPosition: (0, _utils.resolveContentPosition)(contentPosition),
        transition: (0, _utils.resolveTransition)(transition, fadeDuration),
        nativeViewRef: this.nativeViewRef,
        containerViewRef: this.containerViewRef
      }));
    }
  }
  exports.Image = Image;
},776,[17,29,473,3,30,777,797,786,782,2],"node_modules\\expo-image\\src\\Image.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ExpoImage;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireDefault(require(_dependencyMap[2], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _AnimationManager = _interopRequireDefault(require(_dependencyMap[4], "./web/AnimationManager"));
  var _ImageWrapper = _interopRequireDefault(require(_dependencyMap[5], "./web/ImageWrapper"));
  var _imageStyles = _interopRequireDefault(require(_dependencyMap[6], "./web/imageStyles"));
  var _useSourceSelection = _interopRequireDefault(require(_dependencyMap[7], "./web/useSourceSelection"));
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  const _excluded = ["source", "placeholder", "contentFit", "contentPosition", "placeholderContentFit", "cachePolicy", "onLoad", "transition", "onError", "responsivePolicy", "onLoadEnd", "onDisplay", "priority", "blurRadius", "recyclingKey", "style", "nativeViewRef", "accessibilityLabel", "tintColor", "containerViewRef"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\ExpoImage.web.tsx"; // TODO(@kitten): We shouldn't be importing all of react-native-web or rely on it for a web module in this way optimally
  (0, _imageStyles.default)();
  function onLoadAdapter(onLoad) {
    return event => {
      const target = event.target;
      onLoad?.({
        source: {
          url: target.currentSrc,
          width: target.naturalWidth,
          height: target.naturalHeight,
          mediaType: null
        },
        cacheType: 'none'
      });
    };
  }
  function onErrorAdapter(onError) {
    return ({
      source
    }) => {
      onError?.({
        error: `Failed to load image from url: ${source?.uri}`
      });
    };
  }

  // Used for flip transitions to mimic native animations
  function setCssVariablesForFlipTransitions(element, size) {
    element?.style.setProperty('--expo-image-width', `${size.width}px`);
    element?.style.setProperty('--expo-image-height', `${size.height}px`);
  }
  function isFlipTransition(transition) {
    return transition?.effect === 'flip-from-bottom' || transition?.effect === 'flip-from-top' || transition?.effect === 'flip-from-left' || transition?.effect === 'flip-from-right';
  }
  function getAnimationKey(source, recyclingKey) {
    const uri = source && 'uri' in source && source.uri || '';
    return recyclingKey ? [recyclingKey, uri].join('-') : uri;
  }
  function ExpoImage(_ref) {
    let {
        source,
        placeholder,
        contentFit,
        contentPosition,
        placeholderContentFit,
        cachePolicy,
        onLoad,
        transition,
        onError,
        responsivePolicy,
        onLoadEnd,
        onDisplay,
        priority,
        blurRadius,
        recyclingKey,
        style,
        nativeViewRef,
        accessibilityLabel,
        tintColor,
        containerViewRef
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const imagePlaceholderContentFit = placeholderContentFit || 'scale-down';
    const imageHashStyle = {
      objectFit: placeholderContentFit || contentFit
    };
    const selectedSource = (0, _useSourceSelection.default)(source, responsivePolicy,
    // TODO(@vonovak): this cast is a workaround
    containerViewRef, isFlipTransition(transition) ? setCssVariablesForFlipTransitions : null);

    // TODO(@kitten): This should narrow before accessing `placeholder?.[0]`
    const firstPlaceholder = placeholder?.[0];
    const initialNodeAnimationKey = getAnimationKey(firstPlaceholder, recyclingKey);
    const initialNode = firstPlaceholder?.uri ? [initialNodeAnimationKey, ({
      onAnimationFinished
    }) => (className, style) => (0, _jsxRuntime.jsx)(_ImageWrapper.default, {
      ref: nativeViewRef,
      source: firstPlaceholder,
      style: Object.assign({
        objectFit: imagePlaceholderContentFit
      }, blurRadius ? {
        filter: `blur(${blurRadius}px)`
      } : {}, style),
      className: className,
      events: {
        onTransitionEnd: [onAnimationFinished]
      },
      contentPosition: {
        left: '50%',
        top: '50%'
      },
      hashPlaceholderContentPosition: contentPosition,
      hashPlaceholderStyle: imageHashStyle,
      accessibilityLabel: accessibilityLabel,
      cachePolicy: cachePolicy,
      priority: priority,
      tintColor: tintColor
    })] : null;

    // @ts-expect-error: TODO(@kitten): This was implicitly cast to `any`, but with correct types this is now a mismatch
    const currentNodeAnimationKey = getAnimationKey(selectedSource ?? firstPlaceholder, recyclingKey);
    const currentNode = [currentNodeAnimationKey, ({
      onAnimationFinished,
      onReady,
      onMount,
      onError: onErrorInner
    }) => (className, style) => (0, _jsxRuntime.jsx)(_ImageWrapper.default, {
      ref: nativeViewRef
      // @ts-expect-error: TODO(@kitten): This was implicitly cast to `any`, but with correct types this is now a mismatch
      ,
      source: selectedSource || firstPlaceholder,
      events: {
        onError: [onErrorAdapter(onError), onLoadEnd, onErrorInner],
        onLoad: [onLoadAdapter(onLoad), onLoadEnd, onReady],
        onMount: [onMount],
        onTransitionEnd: [onAnimationFinished],
        onDisplay: [onDisplay]
      },
      style: Object.assign({
        objectFit: selectedSource ? contentFit : imagePlaceholderContentFit
      }, blurRadius ? {
        filter: `blur(${blurRadius}px)`
      } : {}, style),
      className: className,
      cachePolicy: cachePolicy,
      priority: priority,
      contentPosition: selectedSource ? contentPosition : {
        top: '50%',
        left: '50%'
      },
      hashPlaceholderContentPosition: contentPosition,
      hashPlaceholderStyle: imageHashStyle,
      accessibilityLabel: accessibilityLabel,
      tintColor: tintColor
    })];
    return (0, _jsxRuntime.jsx)(_View.default, Object.assign({
      ref: containerViewRef
      // @ts-expect-error: TODO(@kitten): This is related to react-native-web presumably
      ,
      dataSet: {
        expoimage: true
      },
      style: [{
        overflow: 'hidden'
      }, style]
    }, props, {
      children: (0, _jsxRuntime.jsx)(_AnimationManager.default, {
        transition: transition,
        recyclingKey: recyclingKey,
        initial: initialNode,
        children: currentNode
      })
    }));
  }
},777,[17,29,3,111,778,779,795,796,2],"node_modules\\expo-image\\src\\ExpoImage.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = AnimationManager;
  exports.getAnimatorFromTransition = getAnimatorFromTransition;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\web\\AnimationManager.tsx";
  const SUPPORTED_ANIMATIONS = ['cross-dissolve', 'flip-from-left', 'flip-from-right', 'flip-from-top', 'flip-from-bottom'];
  function useAnimationManagerNode(node, initialStatus) {
    const newNode = _react.default.useMemo(() => {
      if (!node) {
        return null;
      }
      const [animationKey, renderFunction] = node;
      // key, ReactElement, ref, callbacks
      return {
        animationKey,
        persistedElement: renderFunction,
        status: initialStatus || 'mounted'
      };
    }, [node?.[0]]);
    return newNode;
  }
  function validateTimingFunctionForAnimation(animationClass, timingFunction) {
    if (animationClass?.includes('flip')) {
      if (timingFunction?.includes('ease')) {
        return 'ease-in-out';
      }
      return 'linear';
    }
    return timingFunction || null;
  }
  function validateAnimationClass(effect) {
    if (SUPPORTED_ANIMATIONS.includes(effect)) {
      return effect;
    }
    return 'cross-dissolve';
  }
  function getAnimatorFromTransition(transition) {
    if (!transition?.duration) {
      return null;
    }
    const animationClass = validateAnimationClass(transition.effect);
    if (!animationClass) {
      return {
        startingClass: '',
        animateInClass: '',
        animateOutClass: '',
        containerClass: '',
        timingFunction: 'linear',
        animationClass: '',
        duration: 0
      };
    }
    const timingFunction = validateTimingFunctionForAnimation(animationClass, transition.timing);
    const timingClass = `image-timing-${timingFunction}`;
    return {
      startingClass: `${animationClass}-start`,
      animateInClass: [animationClass, 'transitioning', `${animationClass}-active`, timingClass].join(' '),
      animateOutClass: [animationClass, `${animationClass}-end`, timingClass].join(' '),
      containerClass: `${animationClass}-container`,
      timingFunction,
      animationClass,
      duration: transition?.duration || 0
    };
  }
  function AnimationManager({
    children: renderFunction,
    initial,
    transition,
    recyclingKey
  }) {
    const animation = getAnimatorFromTransition(transition);
    const initialNode = useAnimationManagerNode(initial, 'active');
    const [nodes, setNodes] = _react.default.useState(initialNode ? [initialNode] : []);
    const [prevRecyclingKey, setPrevRecyclingKey] = _react.default.useState(recyclingKey ?? '');
    if (prevRecyclingKey !== (recyclingKey ?? '')) {
      setPrevRecyclingKey(recyclingKey ?? '');
      setNodes(initialNode ? [initialNode] : []);
    }
    const removeAllNodesOfKeyExceptShowing = key => {
      setNodes(n => n.filter(node => (key ? node.animationKey !== key : false) || node.status === 'in' || node.status === 'active'));
    };
    const newNode = useAnimationManagerNode(renderFunction);
    _react.default.useEffect(() => {
      setNodes(n => {
        if (!newNode) {
          return n;
        }
        const existingNodeIndex = n.findIndex(node => node.animationKey === newNode.animationKey);
        if (existingNodeIndex >= 0) {
          if (animation) {
            return n.map(n2 => n2.animationKey === newNode.animationKey ? Object.assign({}, newNode, {
              status: 'in'
            }) : Object.assign({}, n2, {
              status: 'out'
            }));
          } else {
            return [Object.assign({}, newNode, {
              status: 'in'
            })];
          }
        }
        return [...n, newNode];
      });
    }, [newNode]);
    function wrapNodeWithCallbacks(node) {
      if (renderFunction[0] === node.animationKey) {
        return renderFunction[1]({
          onReady: () => {
            if (animation) {
              setNodes(nodes => nodes.map(n => n === newNode ? Object.assign({}, n, {
                status: 'in'
              }) : Object.assign({}, n, {
                status: 'out'
              })));
            } else {
              setNodes([Object.assign({}, node, {
                status: 'in'
              })]);
            }
          },
          onAnimationFinished: () => {
            setNodes([Object.assign({}, node, {
              status: 'in'
            })]);
          },
          onError: () => {
            setNodes(nodes => nodes.map(n => n === node ? Object.assign({}, n, {
              status: 'errored'
            }) : n));
          }
        });
      }
      if (initial?.[0] === node.animationKey) {
        return initial[1]({
          onAnimationFinished: () => {
            if (node.status === 'out') {
              removeAllNodesOfKeyExceptShowing(node.animationKey);
            }
          },
          onError: () => {
            setNodes(nodes => nodes.map(n => n === node ? Object.assign({}, n, {
              status: 'errored'
            }) : n));
          }
        });
      }
      return node.persistedElement({
        onAnimationFinished: () => {
          removeAllNodesOfKeyExceptShowing(node.animationKey);
        }
      });
    }
    const styles = {
      transitionDuration: `${animation?.duration || 0}ms`,
      transitionTimingFunction: animation?.timingFunction || 'linear'
    };
    const classes = {
      in: animation?.animateInClass,
      out: animation?.animateOutClass,
      mounted: animation?.startingClass
    };
    return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: [...nodes].filter(n => n.status !== 'errored').map(n => {
        const status = n.status;
        // TODO(@kitten): This creates impossible states!
        // Ensure that the above type is either exhaustively reflected in this `map` so `className` sheds `undefined`,
        // or retype the `MountedAnimationNode` function to accept `className: string | undefined`
        const className = classes[status];
        return (0, _jsxRuntime.jsx)("div", {
          className: animation?.containerClass,
          children: wrapNodeWithCallbacks(n)(className, styles)
        }, n.animationKey);
      })
    });
  }
},778,[17,3,2],"node_modules\\expo-image\\src\\web\\AnimationManager.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _ColorTintFilter = _interopRequireWildcard(require(_dependencyMap[3], "./ColorTintFilter"));
  var _getImageWrapperEventHandler = require(_dependencyMap[4], "./getImageWrapperEventHandler");
  var _hooks = require(_dependencyMap[5], "./hooks");
  var _positioning = require(_dependencyMap[6], "./positioning");
  var _jsxRuntime = require(_dependencyMap[7], "react-native-css-interop/jsx-runtime");
  const _excluded = ["source", "events", "contentPosition", "hashPlaceholderContentPosition", "priority", "style", "hashPlaceholderStyle", "tintColor", "className", "accessibilityLabel", "cachePolicy"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\web\\ImageWrapper.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function getFetchPriorityFromImagePriority(priority = 'normal') {
    return priority && ['low', 'high'].includes(priority) ? priority : 'auto';
  }
  function getImgPropsFromSource(source) {
    if (source && 'srcset' in source) {
      return {
        srcSet: source.srcset,
        sizes: source.sizes
      };
    }
    return {};
  }
  const ImageWrapper = /*#__PURE__*/_react.default.forwardRef((_ref, ref) => {
    let {
        source,
        events,
        contentPosition,
        hashPlaceholderContentPosition,
        priority,
        style,
        hashPlaceholderStyle,
        tintColor,
        className,
        accessibilityLabel,
        cachePolicy
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    (0, _react.useEffect)(() => {
      events?.onMount?.forEach(e => e?.());
    }, []);
    const tintId = (0, _react.useId)();

    // Thumbhash uri always has to start with 'thumbhash:/'
    const {
      resolvedSource,
      isImageHash
    } = (0, _hooks.useImageHashes)(source);
    const objectPosition = (0, _positioning.getObjectPositionFromContentPositionObject)(isImageHash ? hashPlaceholderContentPosition : contentPosition);
    const sourceWithHeaders = (0, _hooks.useHeaders)(resolvedSource, cachePolicy, events?.onError);
    if (!sourceWithHeaders) {
      return null;
    }
    return (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [(0, _jsxRuntime.jsx)(_ColorTintFilter.default, {
        id: tintId,
        tintColor: tintColor
      }), (0, _jsxRuntime.jsx)("img", Object.assign({
        ref: ref,
        alt: accessibilityLabel,
        className: className,
        src: sourceWithHeaders?.uri || undefined,
        style: Object.assign({
          objectPosition
        }, _positioning.absoluteFilledPosition, (0, _ColorTintFilter.getTintColorStyle)(tintId, tintColor), style, isImageHash ? hashPlaceholderStyle : {})
        // @ts-ignore
        // eslint-disable-next-line react/no-unknown-property
        ,
        fetchPriority: getFetchPriorityFromImagePriority(priority || 'normal')
      }, (0, _getImageWrapperEventHandler.getImageWrapperEventHandler)(events, sourceWithHeaders), getImgPropsFromSource(source), props), source?.uri)]
    });
  });
  var _default = exports.default = ImageWrapper;
},779,[17,29,3,780,781,787,794,2],"node_modules\\expo-image\\src\\web\\ImageWrapper.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = TintColorFilter;
  exports.getTintColorStyle = getTintColorStyle;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _jsxRuntime = require(_dependencyMap[3], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\web\\ColorTintFilter.tsx";
  function getTintColorStyle(tintId, tintColor) {
    if (!tintColor) {
      return {};
    }
    return {
      filter: `url(#expo-image-tint-${tintId})`
    };
  }
  function TintColorFilter({
    id,
    tintColor
  }) {
    if (!tintColor) {
      return null;
    }
    return (0, _jsxRuntime.jsx)("svg", {
      style: styles.svg,
      children: (0, _jsxRuntime.jsx)("defs", {
        children: (0, _jsxRuntime.jsxs)("filter", {
          id: `expo-image-tint-${id}`,
          children: [(0, _jsxRuntime.jsx)("feFlood", {
            floodColor: tintColor
          }), (0, _jsxRuntime.jsx)("feComposite", {
            in2: "SourceAlpha",
            operator: "atop"
          })]
        })
      })
    });
  }
  const styles = _StyleSheet.default.create({
    svg: {
      width: 0,
      height: 0
    }
  });
},780,[17,3,30,2],"node_modules\\expo-image\\src\\web\\ColorTintFilter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageWrapperEventHandler = getImageWrapperEventHandler;
  var _resolveSources = require(_dependencyMap[0], "../utils/resolveSources");
  function getImageWrapperEventHandler(events, source) {
    return {
      onLoad: event => {
        events?.onLoad?.forEach(e => e?.(event));
        if (typeof window !== 'undefined') {
          // On Web there is no way to detect when the image gets displayed, but we can assume it happens on the repaint right after the image is successfully loaded.
          window.requestAnimationFrame(() => {
            events?.onDisplay?.forEach(e => e?.());
          });
        }
      },
      onTransitionEnd: () => events?.onTransitionEnd?.forEach(e => e?.()),
      onError: () => {
        // A temporary workaround for blurhash blobs throwing opaque errors when used in an img tag.
        if (source?.uri && (0, _resolveSources.isBlurhashString)(source?.uri)) {
          return;
        }
        events?.onError?.forEach(e => e?.({
          source: source || null
        }));
      }
    };
  }
},781,[782],"node_modules\\expo-image\\src\\web\\getImageWrapperEventHandler.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isBlurhashString = isBlurhashString;
  exports.isThumbhashString = isThumbhashString;
  exports.resolveSource = resolveSource;
  exports.resolveSources = resolveSources;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _resolveAssetSource = _interopRequireDefault(require(_dependencyMap[3], "./resolveAssetSource"));
  var _resolveHashString = require(_dependencyMap[4], "./resolveHashString");
  var _utils = require(_dependencyMap[5], "../utils");
  const _excluded = ["blurhash", "thumbhash"];
  function isBlurhashString(str) {
    return /^(blurhash:\/)+[\w#$%*+,\-.:;=?@[\]^_{}|~]+(\/[\d.]+)*$/.test(str);
  }

  // Base64 strings will be recognized as blurhash by default (to keep compatibility),
  // interpret as thumbhash only if correct uri scheme is provided
  function isThumbhashString(str) {
    return str.startsWith('thumbhash:/');
  }
  function resolveSource(source) {
    if (typeof source === 'string') {
      if (isBlurhashString(source)) {
        return (0, _resolveHashString.resolveBlurhashString)(source);
      } else if (isThumbhashString(source)) {
        return (0, _resolveHashString.resolveThumbhashString)(source);
      }
      return {
        uri: source
      };
    }
    if (typeof source === 'number') {
      return (0, _resolveAssetSource.default)(source);
    }
    if (typeof source === 'object' && (source?.blurhash || source?.thumbhash)) {
      const {
          blurhash,
          thumbhash
        } = source,
        restSource = (0, _objectWithoutPropertiesLoose2.default)(source, _excluded);
      const resolved = thumbhash ? (0, _resolveHashString.resolveThumbhashString)(thumbhash) : (0, _resolveHashString.resolveBlurhashString)(blurhash);
      return Object.assign({}, resolved, restSource);
    }
    return source ?? null;
  }

  /**
   * Resolves provided `source` prop to an array of objects expected by the native implementation.
   */
  function resolveSources(sources) {
    if (Array.isArray(sources)) {
      return sources.map(resolveSource).filter(Boolean);
    }
    if ((0, _utils.isImageRef)(sources)) {
      if (_expoModulesCore.Platform.OS === 'web') {
        return sources;
      }
      // @ts-expect-error
      return sources.__expo_shared_object_id__;
    }
    return [resolveSource(sources)].filter(Boolean);
  }
},782,[17,29,473,783,785,786],"node_modules\\expo-image\\src\\utils\\resolveSources.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = resolveAssetSource;
  exports.pickScale = void 0;
  exports.setCustomSourceTransformer = setCustomSourceTransformer;
  var _registry = require(_dependencyMap[1], "@react-native/assets-registry/registry");
  var _AssetSourceResolver = _interopRequireDefault(require(_dependencyMap[2], "./AssetSourceResolver.web"));
  let _customSourceTransformer;
  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }

  /**
   * `source` is either a number (opaque type returned by require('./foo.png'))
   * or an `ImageSource` like { uri: '<http location || file path>' }
   */
  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }
    const asset = (0, _registry.getAssetByID)(source);
    if (!asset) {
      return undefined;
    }
    const resolver = new _AssetSourceResolver.default('https://expo.dev', null, asset);
    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }
    return resolver.defaultAsset();
  }
  Object.defineProperty(resolveAssetSource, 'setCustomSourceTransformer', {
    get() {
      return setCustomSourceTransformer;
    }
  });
  const {
    pickScale
  } = _AssetSourceResolver.default;
  exports.pickScale = pickScale;
},783,[17,181,784],"node_modules\\expo-image\\src\\utils\\resolveAssetSource.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/PixelRatio"));
  // Returns the Metro dev server-specific asset location.
  function getScaledAssetPath(asset) {
    const scale = AssetSourceResolver.pickScale(asset.scales, _PixelRatio.default.get());
    const scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
    const type = !asset.type ? '' : `.${asset.type}`;
    if (__DEV__) {
      return asset.httpServerLocation + '/' + asset.name + scaleSuffix + type;
    } else {
      return asset.httpServerLocation.replace(/\.\.\//g, '_') + '/' + asset.name + scaleSuffix + type;
    }
  }
  class AssetSourceResolver {
    // where the jsbundle is being run from
    // NOTE(EvanBacon): Never defined on web.

    // the asset to resolve

    constructor(serverUrl, jsbundleUrl, asset) {
      this.serverUrl = serverUrl || 'https://expo.dev';
      this.jsbundleUrl = null;
      this.asset = asset;
    }

    // Always true for web runtimes
    isLoadedFromServer() {
      return true;
    }

    // Always false for web runtimes
    isLoadedFromFileSystem() {
      return false;
    }
    defaultAsset() {
      return this.assetServerURL();
    }

    /**
     * @returns absolute remote URL for the hosted asset.
     */
    assetServerURL() {
      const fromUrl = new URL(getScaledAssetPath(this.asset), this.serverUrl);
      fromUrl.searchParams.set('platform', _expoModulesCore.Platform.OS);
      fromUrl.searchParams.set('hash', this.asset.hash);
      return this.fromSource(
      // Relative on web
      fromUrl.toString().replace(fromUrl.origin, ''));
    }
    fromSource(source) {
      return {
        __packager_asset: true,
        width: this.asset.width ?? undefined,
        height: this.asset.height ?? undefined,
        uri: source,
        scale: AssetSourceResolver.pickScale(this.asset.scales, _PixelRatio.default.get())
      };
    }
    static pickScale(scales, deviceScale) {
      for (let i = 0; i < scales.length; i++) {
        if (scales[i] >= deviceScale) {
          return scales[i];
        }
      }
      return scales[scales.length - 1] || 1;
    }
  }
  exports.default = AssetSourceResolver;
},784,[17,473,183],"node_modules\\expo-image\\src\\utils\\AssetSourceResolver.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveBlurhashString = resolveBlurhashString;
  exports.resolveThumbhashString = resolveThumbhashString;
  /**
   * Converts a string in blurhash format (`blurhash:/<hash>/<width>/<height>`
   * or <hash>/<width>/<height>) into an `ImageSource`.
   *
   * @return An ImageSource representing the provided blurhash.
   * */
  function resolveBlurhashString(str) {
    const [hash, width, height] = str.replace(/^blurhash:\//, '').split('/');
    return {
      uri: 'blurhash:/' + hash,
      width: parseInt(width, 10) || 16,
      height: parseInt(height, 10) || 16
    };
  }

  /**
   * Converts a string in thumbhash format (`thumbhash:/<hash>` or `<hash>`)
   * into an `ImageSource`.
   * Note: Unlike the `resolveBlurhashString` the `thumbhash:/` scheme has to be present,
   * as the scheme has to be explicitly stated to be interpreted a `thumbhash` source.
   *
   * @return An ImageSource representing the provided thumbhash.
   * */
  function resolveThumbhashString(str) {
    const hash = str.replace(/^thumbhash:\//, '');
    return {
      uri: 'thumbhash:/' + hash
    };
  }
},785,[],"node_modules\\expo-image\\src\\utils\\resolveHashString.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isImageRef = isImageRef;
  exports.resolveContentFit = resolveContentFit;
  exports.resolveContentPosition = resolveContentPosition;
  exports.resolveTransition = resolveTransition;
  var _expo = require(_dependencyMap[0], "expo");
  let loggedResizeModeDeprecationWarning = false;
  let loggedRepeatDeprecationWarning = false;
  let loggedFadeDurationDeprecationWarning = false;

  /**
   * If the `contentFit` is not provided, it's resolved from the equivalent `resizeMode` prop
   * that we support to provide compatibility with React Native Image.
   */
  function resolveContentFit(contentFit, resizeMode) {
    if (contentFit) {
      return contentFit;
    }
    if (resizeMode) {
      if (!loggedResizeModeDeprecationWarning) {
        console.log('[expo-image]: Prop "resizeMode" is deprecated, use "contentFit" instead');
        loggedResizeModeDeprecationWarning = true;
      }
      switch (resizeMode) {
        case 'contain':
        case 'cover':
        case 'none':
          return resizeMode;
        case 'stretch':
          return 'fill';
        case 'center':
          return 'scale-down';
        case 'repeat':
          if (!loggedRepeatDeprecationWarning) {
            console.log('[expo-image]: Resize mode "repeat" is no longer supported');
            loggedRepeatDeprecationWarning = true;
          }
          return 'cover';
        default:
          {
            const exhaustiveCheck = resizeMode;
            throw new Error(`Unhandled resizeMode case: ${exhaustiveCheck}`);
          }
      }
    }
    return 'cover';
  }

  /**
   * It resolves a stringified form of the `contentPosition` prop to an object,
   * which is the only form supported in the native code.
   */
  function resolveContentPosition(contentPosition) {
    if (typeof contentPosition === 'string') {
      const contentPositionStringMappings = {
        center: {
          top: '50%',
          left: '50%'
        },
        top: {
          top: 0,
          left: '50%'
        },
        right: {
          top: '50%',
          right: 0
        },
        bottom: {
          bottom: 0,
          left: '50%'
        },
        left: {
          top: '50%',
          left: 0
        },
        'top center': {
          top: 0,
          left: '50%'
        },
        'top right': {
          top: 0,
          right: 0
        },
        'top left': {
          top: 0,
          left: 0
        },
        'right center': {
          top: '50%',
          right: 0
        },
        'right top': {
          top: 0,
          right: 0
        },
        'right bottom': {
          bottom: 0,
          right: 0
        },
        'bottom center': {
          bottom: 0,
          left: '50%'
        },
        'bottom right': {
          bottom: 0,
          right: 0
        },
        'bottom left': {
          bottom: 0,
          left: 0
        },
        'left center': {
          top: '50%',
          left: 0
        },
        'left top': {
          top: 0,
          left: 0
        },
        'left bottom': {
          bottom: 0,
          left: 0
        }
      };
      const contentPositionObject = contentPositionStringMappings[contentPosition];
      if (!contentPositionObject) {
        console.warn(`[expo-image]: Content position "${contentPosition}" is invalid`);
        return contentPositionStringMappings.center;
      }
      return contentPositionObject;
    }
    return contentPosition ?? {
      top: '50%',
      left: '50%'
    };
  }

  /**
   * If `transition` or `fadeDuration` is a number, it's resolved to a cross dissolve transition with the given duration.
   * When `fadeDuration` is used, it logs an appropriate deprecation warning.
   */
  function resolveTransition(transition, fadeDuration) {
    if (typeof transition === 'number') {
      return {
        duration: transition
      };
    }
    if (!transition && typeof fadeDuration === 'number') {
      if (!loggedFadeDurationDeprecationWarning) {
        console.warn('[expo-image]: Prop "fadeDuration" is deprecated, use "transition" instead');
        loggedFadeDurationDeprecationWarning = true;
      }
      return {
        duration: fadeDuration
      };
    }
    return transition ?? null;
  }

  /**
   * Checks whether the given value is an instance of the `SharedRef<'image'>` class.
   */
  function isImageRef(value) {
    return value instanceof _expo.SharedRef && value.nativeRefType === 'image';
  }
},786,[633],"node_modules\\expo-image\\src\\utils.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useHeaders = useHeaders;
  exports.useImageHashes = useImageHashes;
  exports.useThumbhash = useThumbhash;
  var _react = require(_dependencyMap[0], "react");
  var _useBlurhash = require(_dependencyMap[1], "../utils/blurhash/useBlurhash");
  var _resolveSources = require(_dependencyMap[2], "../utils/resolveSources");
  var _thumbhash = require(_dependencyMap[3], "../utils/thumbhash/thumbhash");
  function useThumbhash(source) {
    const isThumbhash = (0, _resolveSources.isThumbhashString)(source?.uri || '');
    const strippedThumbhashString = source?.uri?.replace(/thumbhash:\//, '') ?? '';
    const thumbhashSource = (0, _react.useMemo)(() => isThumbhash ? {
      uri: (0, _thumbhash.thumbHashStringToDataURL)(strippedThumbhashString)
    } : null, [strippedThumbhashString, isThumbhash]);
    return [thumbhashSource, isThumbhash];
  }
  function useImageHashes(source) {
    const [thumbhash, isThumbhashString] = useThumbhash(source);
    const [blurhash, isBlurhashString] = (0, _useBlurhash.useBlurhash)(source);
    return (0, _react.useMemo)(() => {
      if (!isThumbhashString && !isBlurhashString) {
        return {
          resolvedSource: source,
          isImageHash: false
        };
      }
      if (!blurhash && !thumbhash) {
        return {
          resolvedSource: null,
          isImageHash: true
        };
      }
      return {
        resolvedSource: blurhash ?? thumbhash,
        isImageHash: true
      };
    }, [blurhash, thumbhash, isThumbhashString, isBlurhashString, source]);
  }
  function useHeaders(source, cachePolicy, onError) {
    const [objectURL, setObjectURL] = (0, _react.useState)(null);
    (0, _react.useEffect)(() => {
      (async () => {
        if (!source?.headers || !source.uri) {
          return;
        }
        try {
          const result = await fetch(source.uri, {
            headers: source.headers,
            cache: cachePolicy === 'none' ? 'no-cache' : 'default',
            redirect: 'follow'
          });
          if (!result.ok) {
            throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);
          }
          const blob = await result.blob();
          setObjectURL(prevObjURL => {
            if (prevObjURL) {
              URL.revokeObjectURL(prevObjURL);
            }
            return URL.createObjectURL(blob);
          });
        } catch {
          onError?.forEach(e => e?.({
            source
          }));
        }
      })();
    }, [source]);
    if (!source?.headers) {
      return source;
    }
    if (!objectURL) {
      // Avoid fetching a URL without headers if we have headers
      return null;
    }
    return Object.assign({}, source, {
      uri: objectURL
    });
  }
},787,[3,788,782,793],"node_modules\\expo-image\\src\\web\\hooks.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useBlurhash = useBlurhash;
  var _react = require(_dependencyMap[1], "react");
  var _decode = _interopRequireDefault(require(_dependencyMap[2], "./decode"));
  var _resolveSources = require(_dependencyMap[3], "../resolveSources");
  // adapted from https://gist.github.com/ngbrown/d62eb518753378eb0a9bf02bb4723235
  // modified from https://gist.github.com/WorldMaker/a3cbe0059acd827edee568198376b95a
  // https://github.com/woltapp/react-blurhash/issues/3

  const DEFAULT_SIZE = {
    width: 32,
    height: 32
  };

  // We scale up the canvas to avoid an irritating visual glitch when animating in Chrome.
  const scaleRatio = 10;
  function useBlurhash(blurhash, punch = 1) {
    punch = punch || 1;
    const [uri, setUri] = (0, _react.useState)(null);
    const isBlurhash = (blurhash?.uri && (0, _resolveSources.isBlurhashString)(blurhash.uri)) ?? false;
    (0, _react.useEffect)(() => {
      let isCanceled = false;
      if (!blurhash || !blurhash.uri || !isBlurhash) {
        return;
      }
      const strippedBlurhashString = blurhash.uri.replace(/blurhash:\//, '');
      const pixels = (0, _decode.default)(strippedBlurhashString, blurhash.width ?? DEFAULT_SIZE.width, blurhash.height ?? DEFAULT_SIZE.height, punch);
      const canvas = document.createElement('canvas');
      const upscaledCanvas = document.createElement('canvas');
      canvas.width = blurhash.width ?? DEFAULT_SIZE.width;
      canvas.height = blurhash.height ?? DEFAULT_SIZE.height;
      upscaledCanvas.width = (blurhash.width ?? DEFAULT_SIZE.width) * scaleRatio;
      upscaledCanvas.height = (blurhash.height ?? DEFAULT_SIZE.height) * scaleRatio;
      const context = canvas.getContext('2d');
      if (!context) {
        console.warn('Failed to decode blurhash');
        return;
      }
      const imageData = context.createImageData(canvas.width, canvas.height);
      imageData.data.set(pixels);
      context.putImageData(imageData, 0, 0);
      const upscaledContext = upscaledCanvas.getContext('2d');
      if (!upscaledContext) {
        console.warn('Failed to decode blurhash');
        return;
      }
      upscaledContext.scale(scaleRatio, scaleRatio);
      upscaledContext.drawImage(canvas, 0, 0);
      upscaledCanvas.toBlob(blob => {
        if (!isCanceled) {
          setUri(oldUrl => {
            if (oldUrl) {
              URL.revokeObjectURL(oldUrl);
            }
            return blob ? URL.createObjectURL(blob) : oldUrl;
          });
        }
      });
      return function cleanupBlurhash() {
        isCanceled = true;
        setUri(oldUrl => {
          if (oldUrl) {
            URL.revokeObjectURL(oldUrl);
          }
          return null;
        });
      };
    }, [blurhash?.uri, blurhash?.height, blurhash?.width, punch, isBlurhash]);
    const source = (0, _react.useMemo)(() => uri ? {
      uri
    } : null, [uri]);
    return [source, isBlurhash];
  }
},788,[17,3,789,782],"node_modules\\expo-image\\src\\utils\\blurhash\\useBlurhash.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isBlurhashValid = exports.default = void 0;
  var _base = require(_dependencyMap[0], "./base83");
  var _error = require(_dependencyMap[1], "./error");
  var _utils = require(_dependencyMap[2], "./utils");
  /**
   * Returns an error message if invalid or undefined if valid
   * @param blurhash
   */
  const validateBlurhash = blurhash => {
    if (!blurhash || blurhash.length < 6) {
      throw new _error.ValidationError('The blurhash string must be at least 6 characters');
    }
    const sizeFlag = (0, _base.decode83)(blurhash[0]);
    const numY = Math.floor(sizeFlag / 9) + 1;
    const numX = sizeFlag % 9 + 1;
    if (blurhash.length !== 4 + 2 * numX * numY) {
      throw new _error.ValidationError(`blurhash length mismatch: length is ${blurhash.length} but it should be ${4 + 2 * numX * numY}`);
    }
  };
  const isBlurhashValid = blurhash => {
    try {
      validateBlurhash(blurhash);
    } catch (error) {
      return {
        result: false,
        errorReason: error.message
      };
    }
    return {
      result: true
    };
  };
  exports.isBlurhashValid = isBlurhashValid;
  const decodeDC = value => {
    const intR = value >> 16;
    const intG = value >> 8 & 255;
    const intB = value & 255;
    return [(0, _utils.sRGBToLinear)(intR), (0, _utils.sRGBToLinear)(intG), (0, _utils.sRGBToLinear)(intB)];
  };
  const decodeAC = (value, maximumValue) => {
    const quantR = Math.floor(value / (19 * 19));
    const quantG = Math.floor(value / 19) % 19;
    const quantB = value % 19;
    const rgb = [(0, _utils.signPow)((quantR - 9) / 9, 2.0) * maximumValue, (0, _utils.signPow)((quantG - 9) / 9, 2.0) * maximumValue, (0, _utils.signPow)((quantB - 9) / 9, 2.0) * maximumValue];
    return rgb;
  };
  const decode = (blurhash, width, height, punch) => {
    validateBlurhash(blurhash);
    punch = (punch || 1) | 1;
    const sizeFlag = (0, _base.decode83)(blurhash[0]);
    const numY = Math.floor(sizeFlag / 9) + 1;
    const numX = sizeFlag % 9 + 1;
    const quantisedMaximumValue = (0, _base.decode83)(blurhash[1]);
    const maximumValue = (quantisedMaximumValue + 1) / 166;
    const colors = new Array(numX * numY);
    for (let i = 0; i < colors.length; i++) {
      if (i === 0) {
        const value = (0, _base.decode83)(blurhash.substring(2, 6));
        colors[i] = decodeDC(value);
      } else {
        const value = (0, _base.decode83)(blurhash.substring(4 + i * 2, 6 + i * 2));
        colors[i] = decodeAC(value, maximumValue * punch);
      }
    }
    const bytesPerRow = width * 4;
    const pixels = new Uint8ClampedArray(bytesPerRow * height);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0;
        let g = 0;
        let b = 0;
        for (let j = 0; j < numY; j++) {
          for (let i = 0; i < numX; i++) {
            const basis = Math.cos(Math.PI * x * i / width) * Math.cos(Math.PI * y * j / height);
            const color = colors[i + j * numX];
            r += color[0] * basis;
            g += color[1] * basis;
            b += color[2] * basis;
          }
        }
        const intR = (0, _utils.linearTosRGB)(r);
        const intG = (0, _utils.linearTosRGB)(g);
        const intB = (0, _utils.linearTosRGB)(b);
        pixels[4 * x + 0 + y * bytesPerRow] = intR;
        pixels[4 * x + 1 + y * bytesPerRow] = intG;
        pixels[4 * x + 2 + y * bytesPerRow] = intB;
        pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha
      }
    }
    return pixels;
  };
  var _default = exports.default = decode;
},789,[790,791,792],"node_modules\\expo-image\\src\\utils\\blurhash\\decode.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.encode83 = exports.decode83 = void 0;
  const digitCharacters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '#', '$', '%', '*', '+', ',', '-', '.', ':', ';', '=', '?', '@', '[', ']', '^', '_', '{', '|', '}', '~'];
  const decode83 = str => {
    let value = 0;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      const digit = digitCharacters.indexOf(c);
      value = value * 83 + digit;
    }
    return value;
  };
  exports.decode83 = decode83;
  const encode83 = (n, length) => {
    let result = '';
    for (let i = 1; i <= length; i++) {
      const digit = Math.floor(n) / Math.pow(83, length - i) % 83;
      result += digitCharacters[Math.floor(digit)];
    }
    return result;
  };
  exports.encode83 = encode83;
},790,[],"node_modules\\expo-image\\src\\utils\\blurhash\\base83.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValidationError = void 0;
  class ValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = 'ValidationError';
      this.message = message;
    }
  }
  exports.ValidationError = ValidationError;
},791,[],"node_modules\\expo-image\\src\\utils\\blurhash\\error.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.signPow = exports.sign = exports.sRGBToLinear = exports.linearTosRGB = void 0;
  const sRGBToLinear = value => {
    const v = value / 255;
    if (v <= 0.04045) {
      return v / 12.92;
    } else {
      return Math.pow((v + 0.055) / 1.055, 2.4);
    }
  };
  exports.sRGBToLinear = sRGBToLinear;
  const linearTosRGB = value => {
    const v = Math.max(0, Math.min(1, value));
    if (v <= 0.0031308) {
      return Math.trunc(v * 12.92 * 255 + 0.5);
    } else {
      return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);
    }
  };
  exports.linearTosRGB = linearTosRGB;
  const sign = n => n < 0 ? -1 : 1;
  exports.sign = sign;
  const signPow = (val, exp) => sign(val) * Math.pow(Math.abs(val), exp);
  exports.signPow = signPow;
},792,[],"node_modules\\expo-image\\src\\utils\\blurhash\\utils.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rgbaToDataURL = rgbaToDataURL;
  exports.rgbaToThumbHash = rgbaToThumbHash;
  exports.thumbHashStringToDataURL = thumbHashStringToDataURL;
  exports.thumbHashToApproximateAspectRatio = thumbHashToApproximateAspectRatio;
  exports.thumbHashToAverageRGBA = thumbHashToAverageRGBA;
  exports.thumbHashToDataURL = thumbHashToDataURL;
  exports.thumbHashToRGBA = thumbHashToRGBA;
  // Code copied and slightly modified from https://github.com/evanw/thumbhash

  /**
   * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.
   *
   * @param w The width of the input image. Must be 100px.
   * @param h The height of the input image. Must be 100px.
   * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
   * @returns The ThumbHash as a Uint8Array.
   */

  function rgbaToThumbHash(w, h, rgba) {
    // Encoding an image larger than 100x100 is slow with no benefit
    if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`);
    const {
      PI,
      round,
      max,
      cos,
      abs
    } = Math;

    // Determine the average color
    let avg_r = 0,
      avg_g = 0,
      avg_b = 0,
      avg_a = 0;
    for (let i = 0, j = 0; i < w * h; i++, j += 4) {
      const alpha = rgba[j + 3] / 255;
      avg_r += alpha / 255 * rgba[j];
      avg_g += alpha / 255 * rgba[j + 1];
      avg_b += alpha / 255 * rgba[j + 2];
      avg_a += alpha;
    }
    if (avg_a) {
      avg_r /= avg_a;
      avg_g /= avg_a;
      avg_b /= avg_a;
    }
    const hasAlpha = avg_a < w * h;
    const l_limit = hasAlpha ? 5 : 7; // Use fewer luminance bits if there's alpha
    const lx = max(1, round(l_limit * w / max(w, h)));
    const ly = max(1, round(l_limit * h / max(w, h)));
    const l = []; // luminance
    const p = []; // yellow - blue
    const q = []; // red - green
    const a = []; // alpha

    // Convert the image from RGBA to LPQA (composite atop the average color)
    for (let i = 0, j = 0; i < w * h; i++, j += 4) {
      const alpha = rgba[j + 3] / 255;
      const r = avg_r * (1 - alpha) + alpha / 255 * rgba[j];
      const g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1];
      const b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2];
      l[i] = (r + g + b) / 3;
      p[i] = (r + g) / 2 - b;
      q[i] = r - g;
      a[i] = alpha;
    }

    // Encode using the DCT into DC (constant) and normalized AC (varying) terms
    const encodeChannel = (channel, nx, ny) => {
      let dc = 0;
      const ac = [];
      let scale = 0;
      const fx = [];
      for (let cy = 0; cy < ny; cy++) {
        for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {
          let f = 0;
          for (let x = 0; x < w; x++) fx[x] = cos(PI / w * cx * (x + 0.5));
          for (let y = 0; y < h; y++) for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++) f += channel[x + y * w] * fx[x] * fy;
          f /= w * h;
          if (cx || cy) {
            ac.push(f);
            scale = max(scale, abs(f));
          } else {
            dc = f;
          }
        }
      }
      if (scale) for (let i = 0; i < ac.length; i++) ac[i] = 0.5 + 0.5 / scale * ac[i];
      return [dc, ac, scale];
    };
    const [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly));
    const [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3);
    const [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3);
    const [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : [];

    // Write the constants
    const isLandscape = w > h;
    const header24 = round(63 * l_dc) | round(31.5 + 31.5 * p_dc) << 6 | round(31.5 + 31.5 * q_dc) << 12 | round(31 * l_scale) << 18 | (hasAlpha ? 1 : 0) << 23;
    const header16 = (isLandscape ? ly : lx) | round(63 * p_scale) << 3 | round(63 * q_scale) << 9 | (isLandscape ? 1 : 0) << 15;
    const hash = [header24 & 255, header24 >> 8 & 255, header24 >> 16, header16 & 255, header16 >> 8];
    const ac_start = hasAlpha ? 6 : 5;
    let ac_index = 0;
    if (hasAlpha) hash.push(round(15 * a_dc) | round(15 * a_scale) << 4);

    // Write the varying factors
    for (const ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac]) for (const f of ac) hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2);
    return new Uint8Array(hash);
  }

  /**
   * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The width, height, and pixels of the rendered placeholder image.
   */
  function thumbHashToRGBA(hash) {
    const {
      PI,
      min,
      max,
      cos,
      round
    } = Math;

    // Read the constants
    const header24 = hash[0] | hash[1] << 8 | hash[2] << 16;
    const header16 = hash[3] | hash[4] << 8;
    const l_dc = (header24 & 63) / 63;
    const p_dc = (header24 >> 6 & 63) / 31.5 - 1;
    const q_dc = (header24 >> 12 & 63) / 31.5 - 1;
    const l_scale = (header24 >> 18 & 31) / 31;
    const hasAlpha = header24 >> 23;
    const p_scale = (header16 >> 3 & 63) / 63;
    const q_scale = (header16 >> 9 & 63) / 63;
    const isLandscape = header16 >> 15;
    const lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7);
    const ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7);
    const a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1;
    const a_scale = (hash[5] >> 4) / 15;

    // Read the varying factors (boost saturation by 1.25x to compensate for quantization)
    const ac_start = hasAlpha ? 6 : 5;
    let ac_index = 0;
    const decodeChannel = (nx, ny, scale) => {
      const ac = [];
      for (let cy = 0; cy < ny; cy++) for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++) ac.push(((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2) & 15) / 7.5 - 1) * scale);
      return ac;
    };
    const l_ac = decodeChannel(lx, ly, l_scale);
    const p_ac = decodeChannel(3, 3, p_scale * 1.25);
    const q_ac = decodeChannel(3, 3, q_scale * 1.25);
    const a_ac = hasAlpha ? decodeChannel(5, 5, a_scale) : null;

    // Decode using the DCT into RGB
    const ratio = thumbHashToApproximateAspectRatio(hash);
    const w = round(ratio > 1 ? 32 : 32 * ratio);
    const h = round(ratio > 1 ? 32 / ratio : 32);
    const rgba = new Uint8Array(w * h * 4),
      fx = [],
      fy = [];
    for (let y = 0, i = 0; y < h; y++) {
      for (let x = 0; x < w; x++, i += 4) {
        let l = l_dc,
          p = p_dc,
          q = q_dc,
          a = a_dc;

        // Precompute the coefficients
        for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++) fx[cx] = cos(PI / w * (x + 0.5) * cx);
        for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++) fy[cy] = cos(PI / h * (y + 0.5) * cy);

        // Decode L
        for (let cy = 0, j = 0; cy < ly; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++) l += l_ac[j] * fx[cx] * fy2;

        // Decode P and Q
        for (let cy = 0, j = 0; cy < 3; cy++) {
          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {
            const f = fx[cx] * fy2;
            p += p_ac[j] * f;
            q += q_ac[j] * f;
          }
        }

        // Decode A
        if (hasAlpha) for (let cy = 0, j = 0; cy < 5; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++) a += a_ac[j] * fx[cx] * fy2;

        // Convert to RGB
        const b = l - 2 / 3 * p;
        const r = (3 * l - b + q) / 2;
        const g = r - q;
        rgba[i] = max(0, 255 * min(1, r));
        rgba[i + 1] = max(0, 255 * min(1, g));
        rgba[i + 2] = max(0, 255 * min(1, b));
        rgba[i + 3] = max(0, 255 * min(1, a));
      }
    }
    return {
      w,
      h,
      rgba
    };
  }

  /**
   * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The RGBA values for the average color. Each value ranges from 0 to 1.
   */
  function thumbHashToAverageRGBA(hash) {
    const {
      min,
      max
    } = Math;
    const header = hash[0] | hash[1] << 8 | hash[2] << 16;
    const l = (header & 63) / 63;
    const p = (header >> 6 & 63) / 31.5 - 1;
    const q = (header >> 12 & 63) / 31.5 - 1;
    const hasAlpha = header >> 23;
    const a = hasAlpha ? (hash[5] & 15) / 15 : 1;
    const b = l - 2 / 3 * p;
    const r = (3 * l - b + q) / 2;
    const g = r - q;
    return {
      r: max(0, min(1, r)),
      g: max(0, min(1, g)),
      b: max(0, min(1, b)),
      a
    };
  }

  /**
   * Extracts the approximate aspect ratio of the original image.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The approximate aspect ratio (i.e. width / height).
   */
  function thumbHashToApproximateAspectRatio(hash) {
    const header = hash[3];
    const hasAlpha = hash[2] & 0x80;
    const isLandscape = hash[4] & 0x80;
    const lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7;
    const ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7;
    return lx / ly;
  }

  /**
   * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by
   * A. This is optimized for speed and simplicity and does not optimize for size
   * at all. This doesn't do any compression (all values are stored uncompressed).
   *
   * @param w The width of the input image. Must be 100px.
   * @param h The height of the input image. Must be 100px.
   * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
   * @returns A data URL containing a PNG for the input image.
   */
  function rgbaToDataURL(w, h, rgba) {
    const row = w * 4 + 1;
    const idat = 6 + h * (5 + row);
    const bytes = [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0, idat >>> 24, idat >> 16 & 255, idat >> 8 & 255, idat & 255, 73, 68, 65, 84, 120, 1];
    const table = [0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960, 1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376, -2032938284, -1609899400, -1111625188];
    let a = 1,
      b = 0;
    for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {
      bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, row >> 8 ^ 255, 0);
      for (b = (b + a) % 65521; i < end; i++) {
        const u = rgba[i] & 255;
        bytes.push(u);
        a = (a + u) % 65521;
        b = (b + a) % 65521;
      }
    }
    bytes.push(b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130);
    for (let [start, end] of [[12, 29], [37, 41 + idat]]) {
      let c = ~0;
      for (let i = start; i < end; i++) {
        c ^= bytes[i];
        c = c >>> 4 ^ table[c & 15];
        c = c >>> 4 ^ table[c & 15];
      }
      c = ~c;
      bytes[end++] = c >>> 24;
      bytes[end++] = c >> 16 & 255;
      bytes[end++] = c >> 8 & 255;
      bytes[end++] = c & 255;
    }
    return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes));
  }

  /**
   * Decodes a ThumbHash to a PNG data URL. This is a convenience function that
   * just calls "thumbHashToRGBA" followed by "rgbaToDataURL".
   *
   * @param hash The bytes of the ThumbHash.
   * @returns A data URL containing a PNG for the rendered ThumbHash.
   */
  function thumbHashToDataURL(hash) {
    const image = thumbHashToRGBA(hash);
    return rgbaToDataURL(image.w, image.h, image.rgba);
  }

  /**
   * Convenience function added to the original thumbhash code, allows generating a thumbhash image directly from
   * thumbhash string.
   * @param thumbhash string from which thumbhashDataURL should be generated
   * @returns A data URL containing a PNG for the rendered ThumbHash
   */
  function thumbHashStringToDataURL(thumbhash) {
    const hash = Uint8Array.from(atob(thumbhash), c => c.charCodeAt(0));
    return thumbHashToDataURL(hash);
  }
},793,[],"node_modules\\expo-image\\src\\utils\\thumbhash\\thumbhash.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.absoluteFilledPosition = void 0;
  exports.ensureValueIsWebUnits = ensureValueIsWebUnits;
  exports.getObjectPositionFromContentPositionObject = getObjectPositionFromContentPositionObject;
  function ensureValueIsWebUnits(value) {
    const trimmedValue = String(value).trim();
    if (trimmedValue.endsWith('%')) {
      return trimmedValue;
    }
    return `${trimmedValue}px`;
  }
  const absoluteFilledPosition = exports.absoluteFilledPosition = {
    width: '100%',
    height: '100%',
    position: 'absolute',
    left: 0,
    top: 0
  };
  function getObjectPositionFromContentPositionObject(contentPosition) {
    const resolvedPosition = Object.assign({}, contentPosition);
    if (!resolvedPosition) {
      return '50% 50%';
    }
    if (resolvedPosition.top == null && resolvedPosition.bottom == null) {
      resolvedPosition.top = '50%';
    }
    if (resolvedPosition.left == null && resolvedPosition.right == null) {
      resolvedPosition.left = '50%';
    }
    return ['top', 'bottom', 'left', 'right'].map(key => {
      if (key in resolvedPosition) {
        return `${key} ${ensureValueIsWebUnits(resolvedPosition[key])}`;
      }
      return '';
    }).join(' ') || '50% 50%';
  }
},794,[],"node_modules\\expo-image\\src\\web\\positioning.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = loadStyle;
  const style = `
[data-expoimage] .cross-dissolve {
  transition-property: opacity;
  animation-fill-mode: forwards;
}
[data-expoimage] .cross-dissolve-start:not(.transitioning) {
  opacity: 0;
}
[data-expoimage] .cross-dissolve-active {
  opacity: 1;
}
[data-expoimage] .cross-dissolve-end {
  opacity: 0;
}
[data-expoimage] .flip-from-left {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;

}
[data-expoimage] .flip-from-left-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-left-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-left-active {
  transform: translateZ(0px) rotateY(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-left-end {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-right {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-right-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-right-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-right-active {
  transform: translateZ(0px) rotateY(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-right-end {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-top {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-top-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-top-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.5)) rotateX(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-top-active {
  transform: translateZ(0px) rotateX(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-top-end {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.5)) rotateX(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-bottom {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-bottom-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-bottom-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.25)) rotateX(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-bottom-active {
  transform: translateZ(0px) rotateX(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-bottom-end {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.25)) rotateX(180deg);
  opacity: 0;
}
[data-expoimage] .image-timing-linear {
  --expo-image-timing: linear;
}
[data-expoimage] .image-timing-ease-in {
  --expo-image-timing: ease-in;
}
[data-expoimage] .image-timing-ease-out {
  --expo-image-timing: ease-out;
}
[data-expoimage] .image-timing-ease-in-out {
  --expo-image-timing: ease-in-out;
}
`;
  function loadStyle() {
    if (typeof window !== 'undefined') {
      const styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      styleTag.id = 'expo-image-styles';
      document.head.appendChild(styleTag);
    }
  }
},795,[],"node_modules\\expo-image\\src\\web\\imageStyles.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useSourceSelection;
  var _react = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _utils = require(_dependencyMap[1], "../utils");
  var _resolveSources = require(_dependencyMap[2], "../utils/resolveSources");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function findBestSourceForSize(sources, size) {
    if (sources?.length === 1) {
      return sources[0];
    }
    return [...(sources || [])]
    // look for the smallest image that's still larger then a container
    ?.map(source => {
      if (!size) {
        return {
          source,
          penalty: 0,
          covers: false
        };
      }
      const {
        width,
        height
      } = typeof source === 'object' ? source : {
        width: null,
        height: null
      };
      if (width == null || height == null) {
        return {
          source,
          penalty: 0,
          covers: false
        };
      }
      if (width < size.width || height < size.height) {
        return {
          source,
          penalty: Math.max(size.width - width, size.height - height),
          covers: false
        };
      }
      return {
        source,
        penalty: (width - size.width) * (height - size.height),
        covers: true
      };
    }).sort((a, b) => a.penalty - b.penalty).sort((a, b) => Number(b.covers) - Number(a.covers))[0]?.source ?? null;
  }
  function getCSSMediaQueryForSource(source) {
    return `(max-width: ${source.webMaxViewportWidth ?? source.width}px) ${source.width}px`;
  }
  function selectSource(sources, size, responsivePolicy) {
    if (sources == null || sources.length === 0) {
      return null;
    }
    if (sources.length === 1) {
      return sources[0];
    }
    if (responsivePolicy !== 'static') {
      return findBestSourceForSize(sources, size);
    }
    const staticSupportedSources = sources.filter(s => s.uri && s.width != null && !(0, _resolveSources.isBlurhashString)(s.uri) && !(0, _resolveSources.isThumbhashString)(s.uri)).sort((a, b) => (a.webMaxViewportWidth ?? a.width ?? 0) - (b.webMaxViewportWidth ?? b.width ?? 0));
    if (staticSupportedSources.length === 0) {
      console.warn("You've set the `static` responsivePolicy but none of the sources have the `width` properties set. Make sure you set both `width` and `webMaxViewportWidth` for best results when using static responsiveness. Falling back to the `initial` policy.");
      return findBestSourceForSize(sources, size);
    }
    const srcset = staticSupportedSources?.map(source => `${source.uri} ${source.width}w`).join(', ');
    const sizes = `${staticSupportedSources?.map(getCSSMediaQueryForSource).join(', ')}, ${staticSupportedSources[staticSupportedSources.length - 1]?.width}px`;
    return {
      srcset,
      sizes,
      uri: staticSupportedSources[staticSupportedSources.length - 1]?.uri ?? '',
      type: 'srcset'
    };
  }
  function useSourceSelection(sources, responsivePolicy = 'static', containerRef, measurementCallback = null) {
    const hasMoreThanOneSource = (Array.isArray(sources) ? sources.length : 0) > 1;
    const [size, setSize] = (0, _react.useState)(containerRef.current?.getBoundingClientRect() ?? null);
    if (size && containerRef.current) {
      measurementCallback?.(containerRef.current, size);
    }
    _react.default.useEffect(() => {
      if (!hasMoreThanOneSource && !measurementCallback || !containerRef.current) {
        return () => {};
      }
      if (responsivePolicy === 'live') {
        const resizeObserver = new ResizeObserver(entries => {
          setSize(entries[0].contentRect);
          measurementCallback?.(entries[0].target, entries[0].contentRect);
        });
        resizeObserver.observe(containerRef.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
      return () => {};
    }, [responsivePolicy, hasMoreThanOneSource, containerRef.current, measurementCallback]);
    if ((0, _utils.isImageRef)(sources)) {
      // There is always only one image ref, so there is nothing else to select from.
      return sources;
    }
    return selectSource(sources, size, responsivePolicy);
  }
},796,[3,786,782],"node_modules\\expo-image\\src\\web\\useSourceSelection.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ImageRef = _interopRequireDefault(require(_dependencyMap[2], "./web/ImageRef"));
  class ImageModule extends _expoModulesCore.NativeModule {
    Image = _ImageRef.default;
    async prefetch(urls, _, __) {
      const urlsArray = Array.isArray(urls) ? urls : [urls];
      return new Promise(resolve => {
        let imagesLoaded = 0;
        urlsArray.forEach(url => {
          const img = new Image();
          img.src = url;
          img.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === urlsArray.length) {
              resolve(true);
            }
          };
          img.onerror = () => resolve(false);
        });
      });
    }
    async clearMemoryCache() {
      return false;
    }
    async clearDiskCache() {
      return false;
    }
    async loadAsync(source) {
      if (!source.uri) {
        // TODO: Add support for sources without the uri, e.g. blurhash and thumbhash.
        throw new Error('The image source must have the "uri" property defined');
      }
      const response = await fetch(source.uri, {
        headers: source.headers
      });
      if (!response.ok) {
        throw new Error(`Image request failed with the status code: ${response.status}`);
      }
      const blob = await response.blob();
      const imageObjectUrl = URL.createObjectURL(blob);
      const image = await loadImageElementAsync(imageObjectUrl);
      return _ImageRef.default.init(imageObjectUrl, image.width, image.height, response.headers.get('Content-Type'));
    }
  }

  /**
   * Helper that resolves to an `<img />` element once it finishes loading the given source.
   */
  async function loadImageElementAsync(src) {
    return new Promise((resolve, reject) => {
      const image = document.createElement('img');
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error(`Unable to load the image from '${src}'`));
      image.src = src;
    });
  }
  var _default = exports.default = (0, _expoModulesCore.registerWebModule)(ImageModule, 'ExpoImage');
},797,[17,473,798],"node_modules\\expo-image\\src\\ImageModule.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expo = require(_dependencyMap[0], "expo");
  class ImageRefWeb extends _expo.SharedRef {
    nativeRefType = 'image';
    uri = null;
    width = 0;
    height = 0;
    mediaType = null;
    scale = 1;
    isAnimated = false;
    static init(uri, width, height, mediaType) {
      return Object.assign(new ImageRefWeb(), {
        uri,
        width,
        height,
        mediaType,
        isAnimated: mediaType === 'image/gif'
      });
    }
  }
  exports.default = ImageRefWeb;
},798,[633],"node_modules\\expo-image\\src\\web\\ImageRef.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ImageBackground = ImageBackground;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireDefault(require(_dependencyMap[2], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _Image = require(_dependencyMap[5], "./Image");
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  const _excluded = ["style", "imageStyle", "children"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-image\\src\\ImageBackground.tsx";
  function ImageBackground(_ref) {
    let {
        style,
        imageStyle,
        children
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: style,
      children: [(0, _jsxRuntime.jsx)(_Image.Image, Object.assign({}, props, {
        style: [_StyleSheet.default.absoluteFill, imageStyle]
      })), children]
    });
  }
},799,[17,29,3,111,30,776,2],"node_modules\\expo-image\\src\\ImageBackground.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useImage = useImage;
  var _react = require(_dependencyMap[0], "react");
  var _Image = require(_dependencyMap[1], "./Image");
  var _resolveSources = require(_dependencyMap[2], "./utils/resolveSources");
  /**
   * A hook that loads an image from the given source and returns a reference
   * to the native image instance, or `null` until the first image is successfully loaded.
   *
   * It loads a new image every time the `uri` of the provided source changes.
   * To trigger reloads in some other scenarios, you can provide an additional dependency list.
   * @platform android
   * @platform ios
   * @platform web
   *
   * @example
   * ```ts
   * import { useImage, Image } from 'expo-image';
   * import { Text } from 'react-native';
   *
   * export default function MyImage() {
   *   const image = useImage('https://picsum.photos/1000/800', {
   *     maxWidth: 800,
   *     onError(error, retry) {
   *       console.error('Loading failed:', error.message);
   *     }
   *   });
   *
   *   if (!image) {
   *     return <Text>Image is loading...</Text>;
   *   }
   *
   *   return <Image source={image} style={{ width: image.width / 2, height: image.height / 2 }} />;
   * }
   * ```
   */
  function useImage(source, options = {}, dependencies = []) {
    const resolvedSource = (0, _resolveSources.resolveSource)(source);
    const [image, setImage] = (0, _react.useState)(null);

    // Since options are not dependencies of the below effect, we store them in a ref.
    // Once the image is asynchronously loaded, the effect will use the most recent options,
    // instead of the captured ones (especially important for callbacks that may change in subsequent renders).
    const optionsRef = (0, _react.useRef)(options);
    optionsRef.current = options;
    (0, _react.useEffect)(() => {
      // We're doing some asynchronous action in this effect, so we should keep track
      // if the effect was already cleaned up. In that case, the async action shouldn't change the state.
      let isEffectValid = true;
      function loadImage() {
        _Image.Image.loadAsync(resolvedSource, options).then(image => {
          if (isEffectValid) {
            setImage(image);
          }
        }).catch(error => {
          if (!isEffectValid) {
            return;
          }
          if (optionsRef.current.onError) {
            optionsRef.current.onError(error, loadImage);
          } else {
            // Print unhandled errors to the console.
            console.error(`Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`);
            console.error(error);
          }
        });
      }
      loadImage();
      return () => {
        // Invalidate the effect and release the shared object to free up memory.
        isEffectValid = false;
        image?.release();
      };
    }, [resolvedSource.uri, ...dependencies]);
    return image;
  }
},800,[3,776,782],"node_modules\\expo-image\\src\\useImage.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Ionicons = _interopRequireDefault(require(_dependencyMap[1], "./build/Ionicons"));
  var _default = exports.default = _Ionicons.default;
},801,[17,802],"node_modules\\@expo\\vector-icons\\Ionicons.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use client";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createIconSet = _interopRequireDefault(require(_dependencyMap[1], "./createIconSet"));
  var _Ionicons = _interopRequireDefault(require(_dependencyMap[2], "./vendor/react-native-vector-icons/Fonts/Ionicons.ttf"));
  var _Ionicons2 = _interopRequireDefault(require(_dependencyMap[3], "./vendor/react-native-vector-icons/glyphmaps/Ionicons.json"));
  var _default = exports.default = (0, _createIconSet.default)(_Ionicons2.default, 'ionicons', _Ionicons.default);
},802,[17,803,815,816],"node_modules\\@expo\\vector-icons\\build\\Ionicons.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "DEFAULT_ICON_COLOR", {
    enumerable: true,
    get: function () {
      return _createIconSet.DEFAULT_ICON_COLOR;
    }
  });
  Object.defineProperty(exports, "DEFAULT_ICON_SIZE", {
    enumerable: true,
    get: function () {
      return _createIconSet.DEFAULT_ICON_SIZE;
    }
  });
  exports.default = _default;
  var Font = _interopRequireWildcard(require(_dependencyMap[1], "expo-font"));
  var _react = _interopRequireDefault(require(_dependencyMap[2], "react"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _createIconSet = _interopRequireWildcard(require(_dependencyMap[4], "./vendor/react-native-vector-icons/lib/create-icon-set"));
  var _iconButton = _interopRequireDefault(require(_dependencyMap[5], "./vendor/react-native-vector-icons/lib/icon-button"));
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\vector-icons\\build\\createIconSet.js";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _default(glyphMap, fontName, expoAssetId, fontStyle) {
    const font = {
      [fontName]: expoAssetId
    };
    const RNVIconComponent = (0, _createIconSet.default)(glyphMap, fontName, null, fontStyle);
    return class Icon extends _react.default.Component {
      static defaultProps = RNVIconComponent.defaultProps;
      static Button = (0, _iconButton.default)(Icon);
      static glyphMap = glyphMap;
      static getRawGlyphMap = () => glyphMap;
      static getFontFamily = () => fontName;
      static loadFont = () => Font.loadAsync(font);
      static font = font;
      _mounted = false;
      state = {
        fontIsLoaded: Font.isLoaded(fontName)
      };
      async componentDidMount() {
        this._mounted = true;
        if (!this.state.fontIsLoaded) {
          await Font.loadAsync(font);
          /* eslint-disable react/no-did-mount-set-state */
          this._mounted && this.setState({
            fontIsLoaded: true
          });
        }
      }
      componentWillUnmount() {
        this._mounted = false;
      }
      setNativeProps(props) {
        if (this._icon) {
          this._icon.setNativeProps(props);
        }
      }
      render() {
        if (__DEV__ && this.props.name && !(this.props.name in glyphMap)) {
          console.warn(`"${this.props.name}" is not a valid icon name for family "${fontName}"`);
        }
        if (!this.state.fontIsLoaded) {
          return (0, _jsxRuntime.jsx)(_Text.default, {});
        }
        return (0, _jsxRuntime.jsx)(RNVIconComponent, Object.assign({
          ref: view => {
            this._icon = view;
          }
        }, this.props));
      }
    };
  }
},803,[17,804,3,190,810,813,2],"node_modules\\@expo\\vector-icons\\build\\createIconSet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    useFonts: true
  };
  Object.defineProperty(exports, "useFonts", {
    enumerable: true,
    get: function () {
      return _FontHooks.useFonts;
    }
  });
  var _Font = require(_dependencyMap[0], "./Font");
  Object.keys(_Font).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Font[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Font[key];
      }
    });
  });
  var _FontUtils = require(_dependencyMap[1], "./FontUtils");
  Object.keys(_FontUtils).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _FontUtils[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _FontUtils[key];
      }
    });
  });
  var _FontHooks = require(_dependencyMap[2], "./FontHooks");
},804,[805,807,809],"node_modules\\expo-font\\build\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "FontDisplay", {
    enumerable: true,
    get: function () {
      return _Font.FontDisplay;
    }
  });
  exports.getLoadedFonts = getLoadedFonts;
  exports.isLoaded = isLoaded;
  exports.isLoading = isLoading;
  exports.loadAsync = loadAsync;
  exports.unloadAllAsync = unloadAllAsync;
  exports.unloadAsync = unloadAsync;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ExpoFontLoader = _interopRequireDefault(require(_dependencyMap[2], "./ExpoFontLoader"));
  var _Font = require(_dependencyMap[3], "./Font.types");
  var _FontLoader = require(_dependencyMap[4], "./FontLoader");
  var _memory = require(_dependencyMap[5], "./memory");
  var _server = require(_dependencyMap[6], "./server");
  // @needsAudit
  /**
   * Synchronously detect if the font for `fontFamily` has finished loading.
   *
   * @param fontFamily The name used to load the `FontResource`.
   * @return Returns `true` if the font has fully loaded.
   */
  function isLoaded(fontFamily) {
    if (_expoModulesCore.Platform.OS === 'web') {
      return (0, _memory.isLoadedInCache)(fontFamily) || !!_ExpoFontLoader.default.isLoaded(fontFamily);
    }
    return (0, _memory.isLoadedNative)(fontFamily);
  }
  /**
   * Synchronously get all the fonts that have been loaded.
   * This includes fonts that were bundled at build time using the config plugin, as well as those loaded at runtime using `loadAsync`.
   *
   * @returns Returns array of strings which you can use as `fontFamily` [style prop](https://reactnative.dev/docs/text#style).
   */
  function getLoadedFonts() {
    return _ExpoFontLoader.default.getLoadedFonts();
  }
  // @needsAudit
  /**
   * Synchronously detect if the font for `fontFamily` is still being loaded.
   *
   * @param fontFamily The name used to load the `FontResource`.
   * @returns Returns `true` if the font is still loading.
   */
  function isLoading(fontFamily) {
    return fontFamily in _memory.loadPromises;
  }
  // @needsAudit
  /**
   * An efficient method for loading fonts from static or remote resources which can then be used
   * with the platform's native text elements. In the browser, this generates a `@font-face` block in
   * a shared style sheet for fonts. No CSS is needed to use this method.
   *
   * > **Note**: We recommend using the [config plugin](#configuration-in-appjsonappconfigjs) instead whenever possible.
   *
   * @param fontFamilyOrFontMap String or map of values that can be used as the `fontFamily` [style prop](https://reactnative.dev/docs/text#style)
   * with React Native `Text` elements.
   * @param source The font asset that should be loaded into the `fontFamily` namespace.
   *
   * @return Returns a promise that fulfils when the font has loaded. Often you may want to wrap the
   * method in a `try/catch/finally` to ensure the app continues if the font fails to load.
   */
  function loadAsync(fontFamilyOrFontMap, source) {
    // NOTE(EvanBacon): Static render pass on web must be synchronous to collect all fonts.
    // Because of this, `loadAsync` doesn't use the `async` keyword and deviates from the
    // standard Expo SDK style guide.
    const isServer = _expoModulesCore.Platform.OS === 'web' && typeof window === 'undefined';
    if (typeof fontFamilyOrFontMap === 'object') {
      if (source) {
        return Promise.reject(new _expoModulesCore.CodedError(`ERR_FONT_API`, `No fontFamily can be used for the provided source: ${source}. The second argument of \`loadAsync()\` can only be used with a \`string\` value as the first argument.`));
      }
      const fontMap = fontFamilyOrFontMap;
      const names = Object.keys(fontMap);
      if (isServer) {
        names.map(name => (0, _server.registerStaticFont)(name, fontMap[name]));
        return Promise.resolve();
      }
      return Promise.all(names.map(name => loadFontInNamespaceAsync(name, fontMap[name]))).then(() => {});
    }
    if (isServer) {
      (0, _server.registerStaticFont)(fontFamilyOrFontMap, source);
      return Promise.resolve();
    }
    return loadFontInNamespaceAsync(fontFamilyOrFontMap, source);
  }
  async function loadFontInNamespaceAsync(fontFamily, source) {
    if (!source) {
      throw new _expoModulesCore.CodedError(`ERR_FONT_SOURCE`, `Cannot load null or undefined font source: { "${fontFamily}": ${source} }. Expected asset of type \`FontSource\` for fontFamily of name: "${fontFamily}"`);
    }
    // we consult the native module to see if the font is already loaded
    // this is slower than checking the cache but can help avoid loading the same font n times
    if (isLoaded(fontFamily)) {
      return;
    }
    if (_memory.loadPromises.hasOwnProperty(fontFamily)) {
      return _memory.loadPromises[fontFamily];
    }
    // Important: we want all callers that concurrently try to load the same font to await the same
    // promise. If we're here, we haven't created the promise yet. To ensure we create only one
    // promise in the program, we need to create the promise synchronously without yielding the event
    // loop from this point.
    const asset = (0, _FontLoader.getAssetForSource)(source);
    _memory.loadPromises[fontFamily] = (async () => {
      try {
        await (0, _FontLoader.loadSingleFontAsync)(fontFamily, asset);
        (0, _memory.markLoaded)(fontFamily);
      } finally {
        delete _memory.loadPromises[fontFamily];
      }
    })();
    await _memory.loadPromises[fontFamily];
  }
  // @needsAudit
  /**
   * Unloads all the custom fonts. This is used for testing.
   * @hidden
   */
  async function unloadAllAsync() {
    if (!_ExpoFontLoader.default.unloadAllAsync) {
      throw new _expoModulesCore.UnavailabilityError('expo-font', 'unloadAllAsync');
    }
    if (Object.keys(_memory.loadPromises).length) {
      throw new _expoModulesCore.CodedError(`ERR_UNLOAD`, `Cannot unload fonts while they're still loading: ${Object.keys(_memory.loadPromises).join(', ')}`);
    }
    (0, _memory.purgeCache)();
    await _ExpoFontLoader.default.unloadAllAsync();
  }
  // @needsAudit
  /**
   * Unload custom fonts matching the `fontFamily`s and display values provided.
   * This is used for testing.
   *
   * @param fontFamilyOrFontMap The name or names of the custom fonts that will be unloaded.
   * @param options When `fontFamilyOrFontMap` is a string, this should be the font source used to load
   * the custom font originally.
   * @hidden
   */
  async function unloadAsync(fontFamilyOrFontMap, options) {
    if (!_ExpoFontLoader.default.unloadAsync) {
      throw new _expoModulesCore.UnavailabilityError('expo-font', 'unloadAsync');
    }
    if (typeof fontFamilyOrFontMap === 'object') {
      if (options) {
        throw new _expoModulesCore.CodedError(`ERR_FONT_API`, `No fontFamily can be used for the provided options: ${options}. The second argument of \`unloadAsync()\` can only be used with a \`string\` value as the first argument.`);
      }
      const fontMap = fontFamilyOrFontMap;
      const names = Object.keys(fontMap);
      await Promise.all(names.map(name => unloadFontInNamespaceAsync(name, fontMap[name])));
      return;
    }
    return await unloadFontInNamespaceAsync(fontFamilyOrFontMap, options);
  }
  async function unloadFontInNamespaceAsync(fontFamily, options) {
    if (!isLoaded(fontFamily)) {
      return;
    } else {
      (0, _memory.purgeFontFamilyFromCache)(fontFamily);
    }
    // Important: we want all callers that concurrently try to load the same font to await the same
    // promise. If we're here, we haven't created the promise yet. To ensure we create only one
    // promise in the program, we need to create the promise synchronously without yielding the event
    // loop from this point.
    if (!fontFamily) {
      throw new _expoModulesCore.CodedError(`ERR_FONT_FAMILY`, `Cannot unload an empty name`);
    }
    await _ExpoFontLoader.default.unloadAsync(fontFamily, options);
  }
},805,[17,473,505,507,508,806,472],"node_modules\\expo-font\\build\\Font.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isLoadedInCache = isLoadedInCache;
  exports.isLoadedNative = isLoadedNative;
  exports.loadPromises = void 0;
  exports.markLoaded = markLoaded;
  exports.purgeCache = purgeCache;
  exports.purgeFontFamilyFromCache = purgeFontFamilyFromCache;
  var _ExpoFontLoader = _interopRequireDefault(require(_dependencyMap[1], "./ExpoFontLoader"));
  const loadPromises = exports.loadPromises = {};
  // cache the value on the js side for fast access to the fonts that are loaded
  let cache = {};
  function markLoaded(fontFamily) {
    cache[fontFamily] = true;
  }
  function isLoadedInCache(fontFamily) {
    return fontFamily in cache;
  }
  function isLoadedNative(fontFamily) {
    if (isLoadedInCache(fontFamily)) {
      return true;
    } else {
      const loadedNativeFonts = _ExpoFontLoader.default.getLoadedFonts();
      // NOTE(brentvatne): Bail out here if there are no loaded fonts. This
      // is functionally equivalent to the behavior below if the returned array
      // is empty, but this handles improper mocking of `getLoadedFonts`.
      if (!loadedNativeFonts?.length) {
        return false;
      }
      loadedNativeFonts.forEach(font => {
        cache[font] = true;
      });
      return fontFamily in cache;
    }
  }
  function purgeFontFamilyFromCache(fontFamily) {
    delete cache[fontFamily];
  }
  function purgeCache() {
    cache = {};
  }
},806,[17,505],"node_modules\\expo-font\\build\\memory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.renderToImageAsync = renderToImageAsync;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _processColor = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/processColor"));
  var _ExpoFontUtils = _interopRequireDefault(require(_dependencyMap[3], "./ExpoFontUtils"));
  /**
   * Creates an image with provided text.
   * @param glyphs Text to be exported.
   * @param options RenderToImageOptions.
   * @return Promise which fulfils with uri to image.
   * @platform android
   * @platform ios
   */
  async function renderToImageAsync(glyphs, options) {
    if (!_ExpoFontUtils.default) {
      throw new _expoModulesCore.UnavailabilityError('expo-font', 'ExpoFontUtils.renderToImageAsync');
    }
    return await _ExpoFontUtils.default.renderToImageAsync(glyphs, Object.assign({}, options, {
      color: options?.color ? (0, _processColor.default)(options.color) : undefined
    }));
  }
},807,[17,473,37,808],"node_modules\\expo-font\\build\\FontUtils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  class ExpoFontUtils extends _expoModulesCore.NativeModule {
    async renderToImageAsync(glyphs, options) {
      throw new _expoModulesCore.UnavailabilityError('expo-font', 'renderToImageAsync');
    }
  }
  var _default = exports.default = (0, _expoModulesCore.registerWebModule)(ExpoFontUtils, 'ExpoFontUtils');
},808,[473],"node_modules\\expo-font\\build\\ExpoFontUtils.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFonts = void 0;
  var _react = require(_dependencyMap[0], "react");
  var _Font = require(_dependencyMap[1], "./Font");
  function isMapLoaded(map) {
    if (typeof map === 'string') {
      return (0, _Font.isLoaded)(map);
    } else {
      return Object.keys(map).every(fontFamily => (0, _Font.isLoaded)(fontFamily));
    }
  }
  function useRuntimeFonts(map) {
    const [loaded, setLoaded] = (0, _react.useState)(
    // For web rehydration, we need to check if the fonts are already loaded during the static render.
    // Native will also benefit from this optimization.
    isMapLoaded(map));
    const [error, setError] = (0, _react.useState)(null);
    (0, _react.useEffect)(() => {
      let isMounted = true;
      (0, _Font.loadAsync)(map).then(() => {
        if (isMounted) {
          setLoaded(true);
        }
      }).catch(error => {
        if (isMounted) {
          setError(error);
        }
      });
      return () => {
        isMounted = false;
      };
    }, []);
    return [loaded, error];
  }
  function useStaticFonts(map) {
    (0, _Font.loadAsync)(map);
    return [true, null];
  }
  // @needsAudit
  /**
   * Load a map of fonts with [`loadAsync`](#loadasyncfontfamilyorfontmap-source). This returns a `boolean` if the fonts are
   * loaded and ready to use. It also returns an error if something went wrong, to use in development.
   *
   * > Note, the fonts are not "reloaded" when you dynamically change the font map.
   *
   * @param map A map of `fontFamily`s to [`FontSource`](#fontsource)s. After loading the font you can
   * use the key in the `fontFamily` style prop of a `Text` element.
   *
   * @return
   * - __loaded__ (`boolean`) - A boolean to detect if the font for `fontFamily` has finished
   * loading.
   * - __error__ (`Error | null`) - An error encountered when loading the fonts.
   *
   * @example
   * ```tsx
   * const [loaded, error] = useFonts({ ... });
   * ```
   */
  const useFonts = exports.useFonts = typeof window === 'undefined' ? useStaticFonts : useRuntimeFonts;
},809,[3,805],"node_modules\\expo-font\\build\\FontHooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeIconAPI = exports.DEFAULT_ICON_SIZE = exports.DEFAULT_ICON_COLOR = void 0;
  exports.default = createIconSet;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/PixelRatio"));
  var _processColor = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/processColor"));
  var _Text = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Text"));
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/NativeModules"));
  var _ensureNativeModuleAvailable = _interopRequireDefault(require(_dependencyMap[8], "./ensure-native-module-available"));
  var _createIconSourceCache = _interopRequireDefault(require(_dependencyMap[9], "./create-icon-source-cache"));
  var _iconButton = _interopRequireDefault(require(_dependencyMap[10], "./icon-button"));
  var _jsxRuntime = require(_dependencyMap[11], "react-native-css-interop/jsx-runtime");
  const _excluded = ["name", "size", "color", "style", "children"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\create-icon-set.js";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const NativeIconAPI = exports.NativeIconAPI = _NativeModules.default.RNVectorIconsManager || _NativeModules.default.RNVectorIconsModule;
  const DEFAULT_ICON_SIZE = exports.DEFAULT_ICON_SIZE = 12;
  const DEFAULT_ICON_COLOR = exports.DEFAULT_ICON_COLOR = 'black';
  function createIconSet(glyphMap, fontFamily, fontFile, fontStyle) {
    // Android doesn't care about actual fontFamily name, it will only look in fonts folder.
    const fontBasename = fontFile ? fontFile.replace(/\.(otf|ttf)$/, '') : fontFamily;
    const fontReference = _Platform.default.select({
      windows: `/Assets/${fontFile}#${fontFamily}`,
      android: fontBasename,
      web: fontBasename,
      default: fontFamily
    });
    class Icon extends _react.PureComponent {
      root = null;
      static defaultProps = {
        size: DEFAULT_ICON_SIZE,
        allowFontScaling: false
      };
      render() {
        const _this$props = this.props,
          {
            name,
            size,
            color,
            style,
            children
          } = _this$props,
          props = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
        let glyph = name ? glyphMap[name] || '?' : '';
        if (typeof glyph === 'number') {
          glyph = String.fromCodePoint(glyph);
        }
        const styleDefaults = {
          fontSize: size,
          color
        };
        const styleOverrides = {
          fontFamily: fontReference,
          fontWeight: 'normal',
          fontStyle: 'normal'
        };
        props.style = [styleDefaults, style, styleOverrides, fontStyle || {}];
        return (0, _jsxRuntime.jsxs)(_Text.default, Object.assign({
          selectable: false
        }, props, {
          children: [glyph, children]
        }));
      }
    }
    const imageSourceCache = (0, _createIconSourceCache.default)();
    function resolveGlyph(name) {
      const glyph = glyphMap[name] || '?';
      if (typeof glyph === 'number') {
        return String.fromCodePoint(glyph);
      }
      return glyph;
    }
    function getImageSourceSync(name, size = DEFAULT_ICON_SIZE, color = DEFAULT_ICON_COLOR) {
      (0, _ensureNativeModuleAvailable.default)();
      const glyph = resolveGlyph(name);
      const processedColor = (0, _processColor.default)(color);
      const cacheKey = `${glyph}:${size}:${processedColor}`;
      if (imageSourceCache.has(cacheKey)) {
        return imageSourceCache.get(cacheKey);
      }
      try {
        const imagePath = NativeIconAPI.getImageForFontSync(fontReference, glyph, size, processedColor);
        const value = {
          uri: imagePath,
          scale: _PixelRatio.default.get()
        };
        imageSourceCache.setValue(cacheKey, value);
        return value;
      } catch (error) {
        imageSourceCache.setError(cacheKey, error);
        throw error;
      }
    }
    async function getImageSource(name, size = DEFAULT_ICON_SIZE, color = DEFAULT_ICON_COLOR) {
      (0, _ensureNativeModuleAvailable.default)();
      const glyph = resolveGlyph(name);
      const processedColor = (0, _processColor.default)(color);
      const cacheKey = `${glyph}:${size}:${processedColor}`;
      if (imageSourceCache.has(cacheKey)) {
        return imageSourceCache.get(cacheKey);
      }
      try {
        const imagePath = await NativeIconAPI.getImageForFont(fontReference, glyph, size, processedColor);
        const value = {
          uri: imagePath,
          scale: _PixelRatio.default.get()
        };
        imageSourceCache.setValue(cacheKey, value);
        return value;
      } catch (error) {
        imageSourceCache.setError(cacheKey, error);
        throw error;
      }
    }
    async function loadFont(file = fontFile) {
      if (_Platform.default.OS === 'ios') {
        (0, _ensureNativeModuleAvailable.default)();
        if (!file) {
          throw new Error('Unable to load font, because no file was specified. ');
        }
        await NativeIconAPI.loadFontWithFileName(...file.split('.'));
      }
    }
    function hasIcon(name) {
      return Object.prototype.hasOwnProperty.call(glyphMap, name);
    }
    function getRawGlyphMap() {
      return glyphMap;
    }
    function getFontFamily() {
      return fontReference;
    }
    Icon.Button = (0, _iconButton.default)(Icon);
    Icon.getImageSource = getImageSource;
    Icon.getImageSourceSync = getImageSourceSync;
    Icon.loadFont = loadFont;
    Icon.hasIcon = hasIcon;
    Icon.getRawGlyphMap = getRawGlyphMap;
    Icon.getFontFamily = getFontFamily;
    return Icon;
  }
},810,[17,29,3,106,183,37,190,96,811,812,813,2],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\create-icon-set.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ensureNativeModuleAvailable;
  var _NativeModules = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/NativeModules"));
  const NativeIconAPI = _NativeModules.default.RNVectorIconsManager || _NativeModules.default.RNVectorIconsModule;
  function ensureNativeModuleAvailable() {
    if (!NativeIconAPI) {
      throw new Error('The native RNVectorIcons API is not available, did you properly integrate the module? Please verify your autolinking setup and recompile.');
    }
  }
},811,[17,96],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\ensure-native-module-available.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIconSourceCache;
  const TYPE_VALUE = 'value';
  const TYPE_ERROR = 'error';
  function createIconSourceCache() {
    const cache = new Map();
    const setValue = (key, value) => cache.set(key, {
      type: TYPE_VALUE,
      data: value
    });
    const setError = (key, error) => cache.set(key, {
      type: TYPE_ERROR,
      data: error
    });
    const has = key => cache.has(key);
    const get = key => {
      if (!cache.has(key)) {
        return undefined;
      }
      const {
        type,
        data
      } = cache.get(key);
      if (type === TYPE_ERROR) {
        throw data;
      }
      return data;
    };
    return {
      setValue,
      setError,
      has,
      get
    };
  }
},812,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\create-icon-source-cache.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIconButtonComponent;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _react = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Text"));
  var _TouchableHighlight = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/TouchableHighlight"));
  var _View = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/View"));
  var _objectUtils = require(_dependencyMap[7], "./object-utils");
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  const _excluded = ["style", "iconStyle", "children"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\icon-button.js";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const styles = _StyleSheet.default.create({
    container: {
      flexDirection: 'row',
      justifyContent: 'flex-start',
      alignItems: 'center',
      padding: 8
    },
    touchable: {
      overflow: 'hidden'
    },
    icon: {
      marginRight: 10
    },
    text: {
      fontWeight: '600',
      backgroundColor: 'transparent'
    }
  });
  const IOS7_BLUE = '#007AFF';
  const TEXT_PROP_NAMES = ['ellipsizeMode', 'numberOfLines', 'textBreakStrategy', 'selectable', 'suppressHighlighting', 'allowFontScaling', 'adjustsFontSizeToFit', 'minimumFontScale'];
  const TOUCHABLE_PROP_NAMES = ['accessible', 'accessibilityLabel', 'accessibilityHint', 'accessibilityComponentType', 'accessibilityRole', 'accessibilityStates', 'accessibilityTraits', 'onFocus', 'onBlur', 'disabled', 'onPress', 'onPressIn', 'onPressOut', 'onLayout', 'onLongPress', 'nativeID', 'testID', 'delayPressIn', 'delayPressOut', 'delayLongPress', 'activeOpacity', 'underlayColor', 'selectionColor', 'onShowUnderlay', 'onHideUnderlay', 'hasTVPreferredFocus', 'tvParallaxProperties'];
  function createIconButtonComponent(Icon) {
    return class IconButton extends _react.PureComponent {
      // NOTE(@expo/vector-icons): Modified to remove propTypes

      static defaultProps = {
        backgroundColor: IOS7_BLUE,
        borderRadius: 5,
        color: 'white',
        size: 20
      };
      render() {
        const _this$props = this.props,
          {
            style,
            iconStyle,
            children
          } = _this$props,
          restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
        const iconProps = (0, _objectUtils.pick)(restProps, TEXT_PROP_NAMES, 'style', 'name', 'size', 'color');
        const touchableProps = (0, _objectUtils.pick)(restProps, TOUCHABLE_PROP_NAMES);
        const props = (0, _objectUtils.omit)(restProps, Object.keys(iconProps), Object.keys(touchableProps), 'iconStyle', 'borderRadius', 'backgroundColor');
        iconProps.style = iconStyle ? [styles.icon, iconStyle] : styles.icon;
        const colorStyle = (0, _objectUtils.pick)(this.props, 'color');
        const blockStyle = (0, _objectUtils.pick)(this.props, 'backgroundColor', 'borderRadius');
        return (0, _jsxRuntime.jsx)(_TouchableHighlight.default, Object.assign({
          style: [styles.touchable, blockStyle]
        }, touchableProps, {
          children: (0, _jsxRuntime.jsxs)(_View.default, Object.assign({
            style: [styles.container, blockStyle, style]
          }, props, {
            children: [(0, _jsxRuntime.jsx)(Icon, Object.assign({}, iconProps)), typeof children === 'string' ? (0, _jsxRuntime.jsx)(_Text.default, {
              style: [styles.text, colorStyle],
              selectable: false,
              children: children
            }) : children]
          }))
        }));
      }
    };
  }
},813,[17,29,3,30,190,259,111,814,2],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\icon-button.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const pick = (obj, ...keys) => keys.flat().filter(key => Object.prototype.hasOwnProperty.call(obj, key)).reduce((acc, key) => {
    acc[key] = obj[key];
    return acc;
  }, {});
  const omit = (obj, ...keysToOmit) => {
    const keysToOmitSet = new Set(keysToOmit.flat());
    return Object.getOwnPropertyNames(obj).filter(key => !keysToOmitSet.has(key)).reduce((acc, key) => {
      acc[key] = obj[key];
      return acc;
    }, {});
  };
  module.exports = {
    pick,
    omit
  };
},814,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\lib\\object-utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fvector-icons%2Fbuild%2Fvendor%2Freact-native-vector-icons%2FFonts/Ionicons.ttf";
},815,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Ionicons.ttf");
__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {
  module.exports = {
  "accessibility": 59905,
  "accessibility-outline": 59906,
  "accessibility-sharp": 59907,
  "add": 59908,
  "add-circle": 59909,
  "add-circle-outline": 59910,
  "add-circle-sharp": 59911,
  "add-outline": 59912,
  "add-sharp": 59913,
  "airplane": 59914,
  "airplane-outline": 59915,
  "airplane-sharp": 59916,
  "alarm": 59917,
  "alarm-outline": 59918,
  "alarm-sharp": 59919,
  "albums": 59920,
  "albums-outline": 59921,
  "albums-sharp": 59922,
  "alert": 59923,
  "alert-circle": 59924,
  "alert-circle-outline": 59925,
  "alert-circle-sharp": 59926,
  "alert-outline": 59927,
  "alert-sharp": 59928,
  "american-football": 59929,
  "american-football-outline": 59930,
  "american-football-sharp": 59931,
  "analytics": 59932,
  "analytics-outline": 59933,
  "analytics-sharp": 59934,
  "aperture": 59935,
  "aperture-outline": 59936,
  "aperture-sharp": 59937,
  "apps": 59938,
  "apps-outline": 59939,
  "apps-sharp": 59940,
  "archive": 59941,
  "archive-outline": 59942,
  "archive-sharp": 59943,
  "arrow-back": 59944,
  "arrow-back-circle": 59945,
  "arrow-back-circle-outline": 59946,
  "arrow-back-circle-sharp": 59947,
  "arrow-back-outline": 59948,
  "arrow-back-sharp": 59949,
  "arrow-down": 59950,
  "arrow-down-circle": 59951,
  "arrow-down-circle-outline": 59952,
  "arrow-down-circle-sharp": 59953,
  "arrow-down-outline": 59954,
  "arrow-down-sharp": 59955,
  "arrow-forward": 59956,
  "arrow-forward-circle": 59957,
  "arrow-forward-circle-outline": 59958,
  "arrow-forward-circle-sharp": 59959,
  "arrow-forward-outline": 59960,
  "arrow-forward-sharp": 59961,
  "arrow-redo": 59962,
  "arrow-redo-circle": 59963,
  "arrow-redo-circle-outline": 59964,
  "arrow-redo-circle-sharp": 59965,
  "arrow-redo-outline": 59966,
  "arrow-redo-sharp": 59967,
  "arrow-undo": 59968,
  "arrow-undo-circle": 59969,
  "arrow-undo-circle-outline": 59970,
  "arrow-undo-circle-sharp": 59971,
  "arrow-undo-outline": 59972,
  "arrow-undo-sharp": 59973,
  "arrow-up": 59974,
  "arrow-up-circle": 59975,
  "arrow-up-circle-outline": 59976,
  "arrow-up-circle-sharp": 59977,
  "arrow-up-outline": 59978,
  "arrow-up-sharp": 59979,
  "at": 59980,
  "at-circle": 59981,
  "at-circle-outline": 59982,
  "at-circle-sharp": 59983,
  "at-outline": 59984,
  "at-sharp": 59985,
  "attach": 59986,
  "attach-outline": 59987,
  "attach-sharp": 59988,
  "backspace": 59989,
  "backspace-outline": 59990,
  "backspace-sharp": 59991,
  "bag": 59992,
  "bag-add": 59993,
  "bag-add-outline": 59994,
  "bag-add-sharp": 59995,
  "bag-check": 59996,
  "bag-check-outline": 59997,
  "bag-check-sharp": 59998,
  "bag-handle": 59999,
  "bag-handle-outline": 60000,
  "bag-handle-sharp": 60001,
  "bag-outline": 60002,
  "bag-remove": 60003,
  "bag-remove-outline": 60004,
  "bag-remove-sharp": 60005,
  "bag-sharp": 60006,
  "balloon": 60007,
  "balloon-outline": 60008,
  "balloon-sharp": 60009,
  "ban": 60010,
  "ban-outline": 60011,
  "ban-sharp": 60012,
  "bandage": 60013,
  "bandage-outline": 60014,
  "bandage-sharp": 60015,
  "bar-chart": 60016,
  "bar-chart-outline": 60017,
  "bar-chart-sharp": 60018,
  "barbell": 60019,
  "barbell-outline": 60020,
  "barbell-sharp": 60021,
  "barcode": 60022,
  "barcode-outline": 60023,
  "barcode-sharp": 60024,
  "baseball": 60025,
  "baseball-outline": 60026,
  "baseball-sharp": 60027,
  "basket": 60028,
  "basket-outline": 60029,
  "basket-sharp": 60030,
  "basketball": 60031,
  "basketball-outline": 60032,
  "basketball-sharp": 60033,
  "battery-charging": 60034,
  "battery-charging-outline": 60035,
  "battery-charging-sharp": 60036,
  "battery-dead": 60037,
  "battery-dead-outline": 60038,
  "battery-dead-sharp": 60039,
  "battery-full": 60040,
  "battery-full-outline": 60041,
  "battery-full-sharp": 60042,
  "battery-half": 60043,
  "battery-half-outline": 60044,
  "battery-half-sharp": 60045,
  "beaker": 60046,
  "beaker-outline": 60047,
  "beaker-sharp": 60048,
  "bed": 60049,
  "bed-outline": 60050,
  "bed-sharp": 60051,
  "beer": 60052,
  "beer-outline": 60053,
  "beer-sharp": 60054,
  "bicycle": 60055,
  "bicycle-outline": 60056,
  "bicycle-sharp": 60057,
  "bluetooth": 60058,
  "bluetooth-outline": 60059,
  "bluetooth-sharp": 60060,
  "boat": 60061,
  "boat-outline": 60062,
  "boat-sharp": 60063,
  "body": 60064,
  "body-outline": 60065,
  "body-sharp": 60066,
  "bonfire": 60067,
  "bonfire-outline": 60068,
  "bonfire-sharp": 60069,
  "book": 60070,
  "book-outline": 60071,
  "book-sharp": 60072,
  "bookmark": 60073,
  "bookmark-outline": 60074,
  "bookmark-sharp": 60075,
  "bookmarks": 60076,
  "bookmarks-outline": 60077,
  "bookmarks-sharp": 60078,
  "bowling-ball": 60079,
  "bowling-ball-outline": 60080,
  "bowling-ball-sharp": 60081,
  "briefcase": 60082,
  "briefcase-outline": 60083,
  "briefcase-sharp": 60084,
  "browsers": 60085,
  "browsers-outline": 60086,
  "browsers-sharp": 60087,
  "brush": 60088,
  "brush-outline": 60089,
  "brush-sharp": 60090,
  "bug": 60091,
  "bug-outline": 60092,
  "bug-sharp": 60093,
  "build": 60094,
  "build-outline": 60095,
  "build-sharp": 60096,
  "bulb": 60097,
  "bulb-outline": 60098,
  "bulb-sharp": 60099,
  "bus": 60100,
  "bus-outline": 60101,
  "bus-sharp": 60102,
  "business": 60103,
  "business-outline": 60104,
  "business-sharp": 60105,
  "cafe": 60106,
  "cafe-outline": 60107,
  "cafe-sharp": 60108,
  "calculator": 60109,
  "calculator-outline": 60110,
  "calculator-sharp": 60111,
  "calendar": 60112,
  "calendar-clear": 60113,
  "calendar-clear-outline": 60114,
  "calendar-clear-sharp": 60115,
  "calendar-number": 60116,
  "calendar-number-outline": 60117,
  "calendar-number-sharp": 60118,
  "calendar-outline": 60119,
  "calendar-sharp": 60120,
  "call": 60121,
  "call-outline": 60122,
  "call-sharp": 60123,
  "camera": 60124,
  "camera-outline": 60125,
  "camera-reverse": 60126,
  "camera-reverse-outline": 60127,
  "camera-reverse-sharp": 60128,
  "camera-sharp": 60129,
  "car": 60130,
  "car-outline": 60131,
  "car-sharp": 60132,
  "car-sport": 60133,
  "car-sport-outline": 60134,
  "car-sport-sharp": 60135,
  "card": 60136,
  "card-outline": 60137,
  "card-sharp": 60138,
  "caret-back": 60139,
  "caret-back-circle": 60140,
  "caret-back-circle-outline": 60141,
  "caret-back-circle-sharp": 60142,
  "caret-back-outline": 60143,
  "caret-back-sharp": 60144,
  "caret-down": 60145,
  "caret-down-circle": 60146,
  "caret-down-circle-outline": 60147,
  "caret-down-circle-sharp": 60148,
  "caret-down-outline": 60149,
  "caret-down-sharp": 60150,
  "caret-forward": 60151,
  "caret-forward-circle": 60152,
  "caret-forward-circle-outline": 60153,
  "caret-forward-circle-sharp": 60154,
  "caret-forward-outline": 60155,
  "caret-forward-sharp": 60156,
  "caret-up": 60157,
  "caret-up-circle": 60158,
  "caret-up-circle-outline": 60159,
  "caret-up-circle-sharp": 60160,
  "caret-up-outline": 60161,
  "caret-up-sharp": 60162,
  "cart": 60163,
  "cart-outline": 60164,
  "cart-sharp": 60165,
  "cash": 60166,
  "cash-outline": 60167,
  "cash-sharp": 60168,
  "cellular": 60169,
  "cellular-outline": 60170,
  "cellular-sharp": 60171,
  "chatbox": 60172,
  "chatbox-ellipses": 60173,
  "chatbox-ellipses-outline": 60174,
  "chatbox-ellipses-sharp": 60175,
  "chatbox-outline": 60176,
  "chatbox-sharp": 60177,
  "chatbubble": 60178,
  "chatbubble-ellipses": 60179,
  "chatbubble-ellipses-outline": 60180,
  "chatbubble-ellipses-sharp": 60181,
  "chatbubble-outline": 60182,
  "chatbubble-sharp": 60183,
  "chatbubbles": 60184,
  "chatbubbles-outline": 60185,
  "chatbubbles-sharp": 60186,
  "checkbox": 60187,
  "checkbox-outline": 60188,
  "checkbox-sharp": 60189,
  "checkmark": 60190,
  "checkmark-circle": 60191,
  "checkmark-circle-outline": 60192,
  "checkmark-circle-sharp": 60193,
  "checkmark-done": 60194,
  "checkmark-done-circle": 60195,
  "checkmark-done-circle-outline": 60196,
  "checkmark-done-circle-sharp": 60197,
  "checkmark-done-outline": 60198,
  "checkmark-done-sharp": 60199,
  "checkmark-outline": 60200,
  "checkmark-sharp": 60201,
  "chevron-back": 60202,
  "chevron-back-circle": 60203,
  "chevron-back-circle-outline": 60204,
  "chevron-back-circle-sharp": 60205,
  "chevron-back-outline": 60206,
  "chevron-back-sharp": 60207,
  "chevron-collapse": 60208,
  "chevron-collapse-outline": 60209,
  "chevron-collapse-sharp": 60210,
  "chevron-down": 60211,
  "chevron-down-circle": 60212,
  "chevron-down-circle-outline": 60213,
  "chevron-down-circle-sharp": 60214,
  "chevron-down-outline": 60215,
  "chevron-down-sharp": 60216,
  "chevron-expand": 60217,
  "chevron-expand-outline": 60218,
  "chevron-expand-sharp": 60219,
  "chevron-forward": 60220,
  "chevron-forward-circle": 60221,
  "chevron-forward-circle-outline": 60222,
  "chevron-forward-circle-sharp": 60223,
  "chevron-forward-outline": 60224,
  "chevron-forward-sharp": 60225,
  "chevron-up": 60226,
  "chevron-up-circle": 60227,
  "chevron-up-circle-outline": 60228,
  "chevron-up-circle-sharp": 60229,
  "chevron-up-outline": 60230,
  "chevron-up-sharp": 60231,
  "clipboard": 60232,
  "clipboard-outline": 60233,
  "clipboard-sharp": 60234,
  "close": 60235,
  "close-circle": 60236,
  "close-circle-outline": 60237,
  "close-circle-sharp": 60238,
  "close-outline": 60239,
  "close-sharp": 60240,
  "cloud": 60241,
  "cloud-circle": 60242,
  "cloud-circle-outline": 60243,
  "cloud-circle-sharp": 60244,
  "cloud-done": 60245,
  "cloud-done-outline": 60246,
  "cloud-done-sharp": 60247,
  "cloud-download": 60248,
  "cloud-download-outline": 60249,
  "cloud-download-sharp": 60250,
  "cloud-offline": 60251,
  "cloud-offline-outline": 60252,
  "cloud-offline-sharp": 60253,
  "cloud-outline": 60254,
  "cloud-sharp": 60255,
  "cloud-upload": 60256,
  "cloud-upload-outline": 60257,
  "cloud-upload-sharp": 60258,
  "cloudy": 60259,
  "cloudy-night": 60260,
  "cloudy-night-outline": 60261,
  "cloudy-night-sharp": 60262,
  "cloudy-outline": 60263,
  "cloudy-sharp": 60264,
  "code": 60265,
  "code-download": 60266,
  "code-download-outline": 60267,
  "code-download-sharp": 60268,
  "code-outline": 60269,
  "code-sharp": 60270,
  "code-slash": 60271,
  "code-slash-outline": 60272,
  "code-slash-sharp": 60273,
  "code-working": 60274,
  "code-working-outline": 60275,
  "code-working-sharp": 60276,
  "cog": 60277,
  "cog-outline": 60278,
  "cog-sharp": 60279,
  "color-fill": 60280,
  "color-fill-outline": 60281,
  "color-fill-sharp": 60282,
  "color-filter": 60283,
  "color-filter-outline": 60284,
  "color-filter-sharp": 60285,
  "color-palette": 60286,
  "color-palette-outline": 60287,
  "color-palette-sharp": 60288,
  "color-wand": 60289,
  "color-wand-outline": 60290,
  "color-wand-sharp": 60291,
  "compass": 60292,
  "compass-outline": 60293,
  "compass-sharp": 60294,
  "construct": 60295,
  "construct-outline": 60296,
  "construct-sharp": 60297,
  "contract": 60298,
  "contract-outline": 60299,
  "contract-sharp": 60300,
  "contrast": 60301,
  "contrast-outline": 60302,
  "contrast-sharp": 60303,
  "copy": 60304,
  "copy-outline": 60305,
  "copy-sharp": 60306,
  "create": 60307,
  "create-outline": 60308,
  "create-sharp": 60309,
  "crop": 60310,
  "crop-outline": 60311,
  "crop-sharp": 60312,
  "cube": 60313,
  "cube-outline": 60314,
  "cube-sharp": 60315,
  "cut": 60316,
  "cut-outline": 60317,
  "cut-sharp": 60318,
  "desktop": 60319,
  "desktop-outline": 60320,
  "desktop-sharp": 60321,
  "diamond": 60322,
  "diamond-outline": 60323,
  "diamond-sharp": 60324,
  "dice": 60325,
  "dice-outline": 60326,
  "dice-sharp": 60327,
  "disc": 60328,
  "disc-outline": 60329,
  "disc-sharp": 60330,
  "document": 60331,
  "document-attach": 60332,
  "document-attach-outline": 60333,
  "document-attach-sharp": 60334,
  "document-lock": 60335,
  "document-lock-outline": 60336,
  "document-lock-sharp": 60337,
  "document-outline": 60338,
  "document-sharp": 60339,
  "document-text": 60340,
  "document-text-outline": 60341,
  "document-text-sharp": 60342,
  "documents": 60343,
  "documents-outline": 60344,
  "documents-sharp": 60345,
  "download": 60346,
  "download-outline": 60347,
  "download-sharp": 60348,
  "duplicate": 60349,
  "duplicate-outline": 60350,
  "duplicate-sharp": 60351,
  "ear": 60352,
  "ear-outline": 60353,
  "ear-sharp": 60354,
  "earth": 60355,
  "earth-outline": 60356,
  "earth-sharp": 60357,
  "easel": 60358,
  "easel-outline": 60359,
  "easel-sharp": 60360,
  "egg": 60361,
  "egg-outline": 60362,
  "egg-sharp": 60363,
  "ellipse": 60364,
  "ellipse-outline": 60365,
  "ellipse-sharp": 60366,
  "ellipsis-horizontal": 60367,
  "ellipsis-horizontal-circle": 60368,
  "ellipsis-horizontal-circle-outline": 60369,
  "ellipsis-horizontal-circle-sharp": 60370,
  "ellipsis-horizontal-outline": 60371,
  "ellipsis-horizontal-sharp": 60372,
  "ellipsis-vertical": 60373,
  "ellipsis-vertical-circle": 60374,
  "ellipsis-vertical-circle-outline": 60375,
  "ellipsis-vertical-circle-sharp": 60376,
  "ellipsis-vertical-outline": 60377,
  "ellipsis-vertical-sharp": 60378,
  "enter": 60379,
  "enter-outline": 60380,
  "enter-sharp": 60381,
  "exit": 60382,
  "exit-outline": 60383,
  "exit-sharp": 60384,
  "expand": 60385,
  "expand-outline": 60386,
  "expand-sharp": 60387,
  "extension-puzzle": 60388,
  "extension-puzzle-outline": 60389,
  "extension-puzzle-sharp": 60390,
  "eye": 60391,
  "eye-off": 60392,
  "eye-off-outline": 60393,
  "eye-off-sharp": 60394,
  "eye-outline": 60395,
  "eye-sharp": 60396,
  "eyedrop": 60397,
  "eyedrop-outline": 60398,
  "eyedrop-sharp": 60399,
  "fast-food": 60400,
  "fast-food-outline": 60401,
  "fast-food-sharp": 60402,
  "female": 60403,
  "female-outline": 60404,
  "female-sharp": 60405,
  "file-tray": 60406,
  "file-tray-full": 60407,
  "file-tray-full-outline": 60408,
  "file-tray-full-sharp": 60409,
  "file-tray-outline": 60410,
  "file-tray-sharp": 60411,
  "file-tray-stacked": 60412,
  "file-tray-stacked-outline": 60413,
  "file-tray-stacked-sharp": 60414,
  "film": 60415,
  "film-outline": 60416,
  "film-sharp": 60417,
  "filter": 60418,
  "filter-circle": 60419,
  "filter-circle-outline": 60420,
  "filter-circle-sharp": 60421,
  "filter-outline": 60422,
  "filter-sharp": 60423,
  "finger-print": 60424,
  "finger-print-outline": 60425,
  "finger-print-sharp": 60426,
  "fish": 60427,
  "fish-outline": 60428,
  "fish-sharp": 60429,
  "fitness": 60430,
  "fitness-outline": 60431,
  "fitness-sharp": 60432,
  "flag": 60433,
  "flag-outline": 60434,
  "flag-sharp": 60435,
  "flame": 60436,
  "flame-outline": 60437,
  "flame-sharp": 60438,
  "flash": 60439,
  "flash-off": 60440,
  "flash-off-outline": 60441,
  "flash-off-sharp": 60442,
  "flash-outline": 60443,
  "flash-sharp": 60444,
  "flashlight": 60445,
  "flashlight-outline": 60446,
  "flashlight-sharp": 60447,
  "flask": 60448,
  "flask-outline": 60449,
  "flask-sharp": 60450,
  "flower": 60451,
  "flower-outline": 60452,
  "flower-sharp": 60453,
  "folder": 60454,
  "folder-open": 60455,
  "folder-open-outline": 60456,
  "folder-open-sharp": 60457,
  "folder-outline": 60458,
  "folder-sharp": 60459,
  "football": 60460,
  "football-outline": 60461,
  "football-sharp": 60462,
  "footsteps": 60463,
  "footsteps-outline": 60464,
  "footsteps-sharp": 60465,
  "funnel": 60466,
  "funnel-outline": 60467,
  "funnel-sharp": 60468,
  "game-controller": 60469,
  "game-controller-outline": 60470,
  "game-controller-sharp": 60471,
  "gift": 60472,
  "gift-outline": 60473,
  "gift-sharp": 60474,
  "git-branch": 60475,
  "git-branch-outline": 60476,
  "git-branch-sharp": 60477,
  "git-commit": 60478,
  "git-commit-outline": 60479,
  "git-commit-sharp": 60480,
  "git-compare": 60481,
  "git-compare-outline": 60482,
  "git-compare-sharp": 60483,
  "git-merge": 60484,
  "git-merge-outline": 60485,
  "git-merge-sharp": 60486,
  "git-network": 60487,
  "git-network-outline": 60488,
  "git-network-sharp": 60489,
  "git-pull-request": 60490,
  "git-pull-request-outline": 60491,
  "git-pull-request-sharp": 60492,
  "glasses": 60493,
  "glasses-outline": 60494,
  "glasses-sharp": 60495,
  "globe": 60496,
  "globe-outline": 60497,
  "globe-sharp": 60498,
  "golf": 60499,
  "golf-outline": 60500,
  "golf-sharp": 60501,
  "grid": 60502,
  "grid-outline": 60503,
  "grid-sharp": 60504,
  "hammer": 60505,
  "hammer-outline": 60506,
  "hammer-sharp": 60507,
  "hand-left": 60508,
  "hand-left-outline": 60509,
  "hand-left-sharp": 60510,
  "hand-right": 60511,
  "hand-right-outline": 60512,
  "hand-right-sharp": 60513,
  "happy": 60514,
  "happy-outline": 60515,
  "happy-sharp": 60516,
  "hardware-chip": 60517,
  "hardware-chip-outline": 60518,
  "hardware-chip-sharp": 60519,
  "headset": 60520,
  "headset-outline": 60521,
  "headset-sharp": 60522,
  "heart": 60523,
  "heart-circle": 60524,
  "heart-circle-outline": 60525,
  "heart-circle-sharp": 60526,
  "heart-dislike": 60527,
  "heart-dislike-circle": 60528,
  "heart-dislike-circle-outline": 60529,
  "heart-dislike-circle-sharp": 60530,
  "heart-dislike-outline": 60531,
  "heart-dislike-sharp": 60532,
  "heart-half": 60533,
  "heart-half-outline": 60534,
  "heart-half-sharp": 60535,
  "heart-outline": 60536,
  "heart-sharp": 60537,
  "help": 60538,
  "help-buoy": 60539,
  "help-buoy-outline": 60540,
  "help-buoy-sharp": 60541,
  "help-circle": 60542,
  "help-circle-outline": 60543,
  "help-circle-sharp": 60544,
  "help-outline": 60545,
  "help-sharp": 60546,
  "home": 60547,
  "home-outline": 60548,
  "home-sharp": 60549,
  "hourglass": 60550,
  "hourglass-outline": 60551,
  "hourglass-sharp": 60552,
  "ice-cream": 60553,
  "ice-cream-outline": 60554,
  "ice-cream-sharp": 60555,
  "id-card": 60556,
  "id-card-outline": 60557,
  "id-card-sharp": 60558,
  "image": 60559,
  "image-outline": 60560,
  "image-sharp": 60561,
  "images": 60562,
  "images-outline": 60563,
  "images-sharp": 60564,
  "infinite": 60565,
  "infinite-outline": 60566,
  "infinite-sharp": 60567,
  "information": 60568,
  "information-circle": 60569,
  "information-circle-outline": 60570,
  "information-circle-sharp": 60571,
  "information-outline": 60572,
  "information-sharp": 60573,
  "invert-mode": 60574,
  "invert-mode-outline": 60575,
  "invert-mode-sharp": 60576,
  "journal": 60577,
  "journal-outline": 60578,
  "journal-sharp": 60579,
  "key": 60580,
  "key-outline": 60581,
  "key-sharp": 60582,
  "keypad": 60583,
  "keypad-outline": 60584,
  "keypad-sharp": 60585,
  "language": 60586,
  "language-outline": 60587,
  "language-sharp": 60588,
  "laptop": 60589,
  "laptop-outline": 60590,
  "laptop-sharp": 60591,
  "layers": 60592,
  "layers-outline": 60593,
  "layers-sharp": 60594,
  "leaf": 60595,
  "leaf-outline": 60596,
  "leaf-sharp": 60597,
  "library": 60598,
  "library-outline": 60599,
  "library-sharp": 60600,
  "link": 60601,
  "link-outline": 60602,
  "link-sharp": 60603,
  "list": 60604,
  "list-circle": 60605,
  "list-circle-outline": 60606,
  "list-circle-sharp": 60607,
  "list-outline": 60608,
  "list-sharp": 60609,
  "locate": 60610,
  "locate-outline": 60611,
  "locate-sharp": 60612,
  "location": 60613,
  "location-outline": 60614,
  "location-sharp": 60615,
  "lock-closed": 60616,
  "lock-closed-outline": 60617,
  "lock-closed-sharp": 60618,
  "lock-open": 60619,
  "lock-open-outline": 60620,
  "lock-open-sharp": 60621,
  "log-in": 60622,
  "log-in-outline": 60623,
  "log-in-sharp": 60624,
  "log-out": 60625,
  "log-out-outline": 60626,
  "log-out-sharp": 60627,
  "logo-alipay": 60628,
  "logo-amazon": 60629,
  "logo-amplify": 60630,
  "logo-android": 60631,
  "logo-angular": 60632,
  "logo-apple": 60633,
  "logo-apple-appstore": 60634,
  "logo-apple-ar": 60635,
  "logo-behance": 60636,
  "logo-bitbucket": 60637,
  "logo-bitcoin": 60638,
  "logo-buffer": 60639,
  "logo-capacitor": 60640,
  "logo-chrome": 60641,
  "logo-closed-captioning": 60642,
  "logo-codepen": 60643,
  "logo-css3": 60644,
  "logo-designernews": 60645,
  "logo-deviantart": 60646,
  "logo-discord": 60647,
  "logo-docker": 60648,
  "logo-dribbble": 60649,
  "logo-dropbox": 60650,
  "logo-edge": 60651,
  "logo-electron": 60652,
  "logo-euro": 60653,
  "logo-facebook": 60654,
  "logo-figma": 60655,
  "logo-firebase": 60656,
  "logo-firefox": 60657,
  "logo-flickr": 60658,
  "logo-foursquare": 60659,
  "logo-github": 60660,
  "logo-gitlab": 60661,
  "logo-google": 60662,
  "logo-google-playstore": 60663,
  "logo-hackernews": 60664,
  "logo-html5": 60665,
  "logo-instagram": 60666,
  "logo-ionic": 60667,
  "logo-ionitron": 60668,
  "logo-javascript": 60669,
  "logo-laravel": 60670,
  "logo-linkedin": 60671,
  "logo-markdown": 60672,
  "logo-mastodon": 60673,
  "logo-medium": 60674,
  "logo-microsoft": 60675,
  "logo-no-smoking": 60676,
  "logo-nodejs": 60677,
  "logo-npm": 60678,
  "logo-octocat": 60679,
  "logo-paypal": 60680,
  "logo-pinterest": 60681,
  "logo-playstation": 60682,
  "logo-pwa": 60683,
  "logo-python": 60684,
  "logo-react": 60685,
  "logo-reddit": 60686,
  "logo-rss": 60687,
  "logo-sass": 60688,
  "logo-skype": 60689,
  "logo-slack": 60690,
  "logo-snapchat": 60691,
  "logo-soundcloud": 60692,
  "logo-stackoverflow": 60693,
  "logo-steam": 60694,
  "logo-stencil": 60695,
  "logo-tableau": 60696,
  "logo-tiktok": 60697,
  "logo-tumblr": 60698,
  "logo-tux": 60699,
  "logo-twitch": 60700,
  "logo-twitter": 60701,
  "logo-usd": 60702,
  "logo-venmo": 60703,
  "logo-vercel": 60704,
  "logo-vimeo": 60705,
  "logo-vk": 60706,
  "logo-vue": 60707,
  "logo-web-component": 60708,
  "logo-wechat": 60709,
  "logo-whatsapp": 60710,
  "logo-windows": 60711,
  "logo-wordpress": 60712,
  "logo-xbox": 60713,
  "logo-xing": 60714,
  "logo-yahoo": 60715,
  "logo-yen": 60716,
  "logo-youtube": 60717,
  "magnet": 60718,
  "magnet-outline": 60719,
  "magnet-sharp": 60720,
  "mail": 60721,
  "mail-open": 60722,
  "mail-open-outline": 60723,
  "mail-open-sharp": 60724,
  "mail-outline": 60725,
  "mail-sharp": 60726,
  "mail-unread": 60727,
  "mail-unread-outline": 60728,
  "mail-unread-sharp": 60729,
  "male": 60730,
  "male-female": 60731,
  "male-female-outline": 60732,
  "male-female-sharp": 60733,
  "male-outline": 60734,
  "male-sharp": 60735,
  "man": 60736,
  "man-outline": 60737,
  "man-sharp": 60738,
  "map": 60739,
  "map-outline": 60740,
  "map-sharp": 60741,
  "medal": 60742,
  "medal-outline": 60743,
  "medal-sharp": 60744,
  "medical": 60745,
  "medical-outline": 60746,
  "medical-sharp": 60747,
  "medkit": 60748,
  "medkit-outline": 60749,
  "medkit-sharp": 60750,
  "megaphone": 60751,
  "megaphone-outline": 60752,
  "megaphone-sharp": 60753,
  "menu": 60754,
  "menu-outline": 60755,
  "menu-sharp": 60756,
  "mic": 60757,
  "mic-circle": 60758,
  "mic-circle-outline": 60759,
  "mic-circle-sharp": 60760,
  "mic-off": 60761,
  "mic-off-circle": 60762,
  "mic-off-circle-outline": 60763,
  "mic-off-circle-sharp": 60764,
  "mic-off-outline": 60765,
  "mic-off-sharp": 60766,
  "mic-outline": 60767,
  "mic-sharp": 60768,
  "moon": 60769,
  "moon-outline": 60770,
  "moon-sharp": 60771,
  "move": 60772,
  "move-outline": 60773,
  "move-sharp": 60774,
  "musical-note": 60775,
  "musical-note-outline": 60776,
  "musical-note-sharp": 60777,
  "musical-notes": 60778,
  "musical-notes-outline": 60779,
  "musical-notes-sharp": 60780,
  "navigate": 60781,
  "navigate-circle": 60782,
  "navigate-circle-outline": 60783,
  "navigate-circle-sharp": 60784,
  "navigate-outline": 60785,
  "navigate-sharp": 60786,
  "newspaper": 60787,
  "newspaper-outline": 60788,
  "newspaper-sharp": 60789,
  "notifications": 60790,
  "notifications-circle": 60791,
  "notifications-circle-outline": 60792,
  "notifications-circle-sharp": 60793,
  "notifications-off": 60794,
  "notifications-off-circle": 60795,
  "notifications-off-circle-outline": 60796,
  "notifications-off-circle-sharp": 60797,
  "notifications-off-outline": 60798,
  "notifications-off-sharp": 60799,
  "notifications-outline": 60800,
  "notifications-sharp": 60801,
  "nuclear": 60802,
  "nuclear-outline": 60803,
  "nuclear-sharp": 60804,
  "nutrition": 60805,
  "nutrition-outline": 60806,
  "nutrition-sharp": 60807,
  "open": 60808,
  "open-outline": 60809,
  "open-sharp": 60810,
  "options": 60811,
  "options-outline": 60812,
  "options-sharp": 60813,
  "paper-plane": 60814,
  "paper-plane-outline": 60815,
  "paper-plane-sharp": 60816,
  "partly-sunny": 60817,
  "partly-sunny-outline": 60818,
  "partly-sunny-sharp": 60819,
  "pause": 60820,
  "pause-circle": 60821,
  "pause-circle-outline": 60822,
  "pause-circle-sharp": 60823,
  "pause-outline": 60824,
  "pause-sharp": 60825,
  "paw": 60826,
  "paw-outline": 60827,
  "paw-sharp": 60828,
  "pencil": 60829,
  "pencil-outline": 60830,
  "pencil-sharp": 60831,
  "people": 60832,
  "people-circle": 60833,
  "people-circle-outline": 60834,
  "people-circle-sharp": 60835,
  "people-outline": 60836,
  "people-sharp": 60837,
  "person": 60838,
  "person-add": 60839,
  "person-add-outline": 60840,
  "person-add-sharp": 60841,
  "person-circle": 60842,
  "person-circle-outline": 60843,
  "person-circle-sharp": 60844,
  "person-outline": 60845,
  "person-remove": 60846,
  "person-remove-outline": 60847,
  "person-remove-sharp": 60848,
  "person-sharp": 60849,
  "phone-landscape": 60850,
  "phone-landscape-outline": 60851,
  "phone-landscape-sharp": 60852,
  "phone-portrait": 60853,
  "phone-portrait-outline": 60854,
  "phone-portrait-sharp": 60855,
  "pie-chart": 60856,
  "pie-chart-outline": 60857,
  "pie-chart-sharp": 60858,
  "pin": 60859,
  "pin-outline": 60860,
  "pin-sharp": 60861,
  "pint": 60862,
  "pint-outline": 60863,
  "pint-sharp": 60864,
  "pizza": 60865,
  "pizza-outline": 60866,
  "pizza-sharp": 60867,
  "planet": 60868,
  "planet-outline": 60869,
  "planet-sharp": 60870,
  "play": 60871,
  "play-back": 60872,
  "play-back-circle": 60873,
  "play-back-circle-outline": 60874,
  "play-back-circle-sharp": 60875,
  "play-back-outline": 60876,
  "play-back-sharp": 60877,
  "play-circle": 60878,
  "play-circle-outline": 60879,
  "play-circle-sharp": 60880,
  "play-forward": 60881,
  "play-forward-circle": 60882,
  "play-forward-circle-outline": 60883,
  "play-forward-circle-sharp": 60884,
  "play-forward-outline": 60885,
  "play-forward-sharp": 60886,
  "play-outline": 60887,
  "play-sharp": 60888,
  "play-skip-back": 60889,
  "play-skip-back-circle": 60890,
  "play-skip-back-circle-outline": 60891,
  "play-skip-back-circle-sharp": 60892,
  "play-skip-back-outline": 60893,
  "play-skip-back-sharp": 60894,
  "play-skip-forward": 60895,
  "play-skip-forward-circle": 60896,
  "play-skip-forward-circle-outline": 60897,
  "play-skip-forward-circle-sharp": 60898,
  "play-skip-forward-outline": 60899,
  "play-skip-forward-sharp": 60900,
  "podium": 60901,
  "podium-outline": 60902,
  "podium-sharp": 60903,
  "power": 60904,
  "power-outline": 60905,
  "power-sharp": 60906,
  "pricetag": 60907,
  "pricetag-outline": 60908,
  "pricetag-sharp": 60909,
  "pricetags": 60910,
  "pricetags-outline": 60911,
  "pricetags-sharp": 60912,
  "print": 60913,
  "print-outline": 60914,
  "print-sharp": 60915,
  "prism": 60916,
  "prism-outline": 60917,
  "prism-sharp": 60918,
  "pulse": 60919,
  "pulse-outline": 60920,
  "pulse-sharp": 60921,
  "push": 60922,
  "push-outline": 60923,
  "push-sharp": 60924,
  "qr-code": 60925,
  "qr-code-outline": 60926,
  "qr-code-sharp": 60927,
  "radio": 60928,
  "radio-button-off": 60929,
  "radio-button-off-outline": 60930,
  "radio-button-off-sharp": 60931,
  "radio-button-on": 60932,
  "radio-button-on-outline": 60933,
  "radio-button-on-sharp": 60934,
  "radio-outline": 60935,
  "radio-sharp": 60936,
  "rainy": 60937,
  "rainy-outline": 60938,
  "rainy-sharp": 60939,
  "reader": 60940,
  "reader-outline": 60941,
  "reader-sharp": 60942,
  "receipt": 60943,
  "receipt-outline": 60944,
  "receipt-sharp": 60945,
  "recording": 60946,
  "recording-outline": 60947,
  "recording-sharp": 60948,
  "refresh": 60949,
  "refresh-circle": 60950,
  "refresh-circle-outline": 60951,
  "refresh-circle-sharp": 60952,
  "refresh-outline": 60953,
  "refresh-sharp": 60954,
  "reload": 60955,
  "reload-circle": 60956,
  "reload-circle-outline": 60957,
  "reload-circle-sharp": 60958,
  "reload-outline": 60959,
  "reload-sharp": 60960,
  "remove": 60961,
  "remove-circle": 60962,
  "remove-circle-outline": 60963,
  "remove-circle-sharp": 60964,
  "remove-outline": 60965,
  "remove-sharp": 60966,
  "reorder-four": 60967,
  "reorder-four-outline": 60968,
  "reorder-four-sharp": 60969,
  "reorder-three": 60970,
  "reorder-three-outline": 60971,
  "reorder-three-sharp": 60972,
  "reorder-two": 60973,
  "reorder-two-outline": 60974,
  "reorder-two-sharp": 60975,
  "repeat": 60976,
  "repeat-outline": 60977,
  "repeat-sharp": 60978,
  "resize": 60979,
  "resize-outline": 60980,
  "resize-sharp": 60981,
  "restaurant": 60982,
  "restaurant-outline": 60983,
  "restaurant-sharp": 60984,
  "return-down-back": 60985,
  "return-down-back-outline": 60986,
  "return-down-back-sharp": 60987,
  "return-down-forward": 60988,
  "return-down-forward-outline": 60989,
  "return-down-forward-sharp": 60990,
  "return-up-back": 60991,
  "return-up-back-outline": 60992,
  "return-up-back-sharp": 60993,
  "return-up-forward": 60994,
  "return-up-forward-outline": 60995,
  "return-up-forward-sharp": 60996,
  "ribbon": 60997,
  "ribbon-outline": 60998,
  "ribbon-sharp": 60999,
  "rocket": 61000,
  "rocket-outline": 61001,
  "rocket-sharp": 61002,
  "rose": 61003,
  "rose-outline": 61004,
  "rose-sharp": 61005,
  "sad": 61006,
  "sad-outline": 61007,
  "sad-sharp": 61008,
  "save": 61009,
  "save-outline": 61010,
  "save-sharp": 61011,
  "scale": 61012,
  "scale-outline": 61013,
  "scale-sharp": 61014,
  "scan": 61015,
  "scan-circle": 61016,
  "scan-circle-outline": 61017,
  "scan-circle-sharp": 61018,
  "scan-outline": 61019,
  "scan-sharp": 61020,
  "school": 61021,
  "school-outline": 61022,
  "school-sharp": 61023,
  "search": 61024,
  "search-circle": 61025,
  "search-circle-outline": 61026,
  "search-circle-sharp": 61027,
  "search-outline": 61028,
  "search-sharp": 61029,
  "send": 61030,
  "send-outline": 61031,
  "send-sharp": 61032,
  "server": 61033,
  "server-outline": 61034,
  "server-sharp": 61035,
  "settings": 61036,
  "settings-outline": 61037,
  "settings-sharp": 61038,
  "shapes": 61039,
  "shapes-outline": 61040,
  "shapes-sharp": 61041,
  "share": 61042,
  "share-outline": 61043,
  "share-sharp": 61044,
  "share-social": 61045,
  "share-social-outline": 61046,
  "share-social-sharp": 61047,
  "shield": 61048,
  "shield-checkmark": 61049,
  "shield-checkmark-outline": 61050,
  "shield-checkmark-sharp": 61051,
  "shield-half": 61052,
  "shield-half-outline": 61053,
  "shield-half-sharp": 61054,
  "shield-outline": 61055,
  "shield-sharp": 61056,
  "shirt": 61057,
  "shirt-outline": 61058,
  "shirt-sharp": 61059,
  "shuffle": 61060,
  "shuffle-outline": 61061,
  "shuffle-sharp": 61062,
  "skull": 61063,
  "skull-outline": 61064,
  "skull-sharp": 61065,
  "snow": 61066,
  "snow-outline": 61067,
  "snow-sharp": 61068,
  "sparkles": 61069,
  "sparkles-outline": 61070,
  "sparkles-sharp": 61071,
  "speedometer": 61072,
  "speedometer-outline": 61073,
  "speedometer-sharp": 61074,
  "square": 61075,
  "square-outline": 61076,
  "square-sharp": 61077,
  "star": 61078,
  "star-half": 61079,
  "star-half-outline": 61080,
  "star-half-sharp": 61081,
  "star-outline": 61082,
  "star-sharp": 61083,
  "stats-chart": 61084,
  "stats-chart-outline": 61085,
  "stats-chart-sharp": 61086,
  "stop": 61087,
  "stop-circle": 61088,
  "stop-circle-outline": 61089,
  "stop-circle-sharp": 61090,
  "stop-outline": 61091,
  "stop-sharp": 61092,
  "stopwatch": 61093,
  "stopwatch-outline": 61094,
  "stopwatch-sharp": 61095,
  "storefront": 61096,
  "storefront-outline": 61097,
  "storefront-sharp": 61098,
  "subway": 61099,
  "subway-outline": 61100,
  "subway-sharp": 61101,
  "sunny": 61102,
  "sunny-outline": 61103,
  "sunny-sharp": 61104,
  "swap-horizontal": 61105,
  "swap-horizontal-outline": 61106,
  "swap-horizontal-sharp": 61107,
  "swap-vertical": 61108,
  "swap-vertical-outline": 61109,
  "swap-vertical-sharp": 61110,
  "sync": 61111,
  "sync-circle": 61112,
  "sync-circle-outline": 61113,
  "sync-circle-sharp": 61114,
  "sync-outline": 61115,
  "sync-sharp": 61116,
  "tablet-landscape": 61117,
  "tablet-landscape-outline": 61118,
  "tablet-landscape-sharp": 61119,
  "tablet-portrait": 61120,
  "tablet-portrait-outline": 61121,
  "tablet-portrait-sharp": 61122,
  "telescope": 61123,
  "telescope-outline": 61124,
  "telescope-sharp": 61125,
  "tennisball": 61126,
  "tennisball-outline": 61127,
  "tennisball-sharp": 61128,
  "terminal": 61129,
  "terminal-outline": 61130,
  "terminal-sharp": 61131,
  "text": 61132,
  "text-outline": 61133,
  "text-sharp": 61134,
  "thermometer": 61135,
  "thermometer-outline": 61136,
  "thermometer-sharp": 61137,
  "thumbs-down": 61138,
  "thumbs-down-outline": 61139,
  "thumbs-down-sharp": 61140,
  "thumbs-up": 61141,
  "thumbs-up-outline": 61142,
  "thumbs-up-sharp": 61143,
  "thunderstorm": 61144,
  "thunderstorm-outline": 61145,
  "thunderstorm-sharp": 61146,
  "ticket": 61147,
  "ticket-outline": 61148,
  "ticket-sharp": 61149,
  "time": 61150,
  "time-outline": 61151,
  "time-sharp": 61152,
  "timer": 61153,
  "timer-outline": 61154,
  "timer-sharp": 61155,
  "today": 61156,
  "today-outline": 61157,
  "today-sharp": 61158,
  "toggle": 61159,
  "toggle-outline": 61160,
  "toggle-sharp": 61161,
  "trail-sign": 61162,
  "trail-sign-outline": 61163,
  "trail-sign-sharp": 61164,
  "train": 61165,
  "train-outline": 61166,
  "train-sharp": 61167,
  "transgender": 61168,
  "transgender-outline": 61169,
  "transgender-sharp": 61170,
  "trash": 61171,
  "trash-bin": 61172,
  "trash-bin-outline": 61173,
  "trash-bin-sharp": 61174,
  "trash-outline": 61175,
  "trash-sharp": 61176,
  "trending-down": 61177,
  "trending-down-outline": 61178,
  "trending-down-sharp": 61179,
  "trending-up": 61180,
  "trending-up-outline": 61181,
  "trending-up-sharp": 61182,
  "triangle": 61183,
  "triangle-outline": 61184,
  "triangle-sharp": 61185,
  "trophy": 61186,
  "trophy-outline": 61187,
  "trophy-sharp": 61188,
  "tv": 61189,
  "tv-outline": 61190,
  "tv-sharp": 61191,
  "umbrella": 61192,
  "umbrella-outline": 61193,
  "umbrella-sharp": 61194,
  "unlink": 61195,
  "unlink-outline": 61196,
  "unlink-sharp": 61197,
  "videocam": 61198,
  "videocam-off": 61199,
  "videocam-off-outline": 61200,
  "videocam-off-sharp": 61201,
  "videocam-outline": 61202,
  "videocam-sharp": 61203,
  "volume-high": 61204,
  "volume-high-outline": 61205,
  "volume-high-sharp": 61206,
  "volume-low": 61207,
  "volume-low-outline": 61208,
  "volume-low-sharp": 61209,
  "volume-medium": 61210,
  "volume-medium-outline": 61211,
  "volume-medium-sharp": 61212,
  "volume-mute": 61213,
  "volume-mute-outline": 61214,
  "volume-mute-sharp": 61215,
  "volume-off": 61216,
  "volume-off-outline": 61217,
  "volume-off-sharp": 61218,
  "walk": 61219,
  "walk-outline": 61220,
  "walk-sharp": 61221,
  "wallet": 61222,
  "wallet-outline": 61223,
  "wallet-sharp": 61224,
  "warning": 61225,
  "warning-outline": 61226,
  "warning-sharp": 61227,
  "watch": 61228,
  "watch-outline": 61229,
  "watch-sharp": 61230,
  "water": 61231,
  "water-outline": 61232,
  "water-sharp": 61233,
  "wifi": 61234,
  "wifi-outline": 61235,
  "wifi-sharp": 61236,
  "wine": 61237,
  "wine-outline": 61238,
  "wine-sharp": 61239,
  "woman": 61240,
  "woman-outline": 61241,
  "woman-sharp": 61242
}
;
},816,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\glyphmaps\\Ionicons.json");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Scan;
  var _react = require(_dependencyMap[1], "react");
  var _expoCamera = require(_dependencyMap[2], "expo-camera");
  var ImagePicker = _interopRequireWildcard(require(_dependencyMap[3], "expo-image-picker"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var _Text = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/Text"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Pressable"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/StyleSheet"));
  var _TouchableOpacity = _interopRequireDefault(require(_dependencyMap[8], "react-native-web/dist/exports/TouchableOpacity"));
  var _Modal = _interopRequireDefault(require(_dependencyMap[9], "react-native-web/dist/exports/Modal"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[10], "react-native-web/dist/exports/Platform"));
  var _expoRouter = require(_dependencyMap[11], "expo-router");
  var _AntDesign = _interopRequireDefault(require(_dependencyMap[12], "@expo/vector-icons/AntDesign"));
  var _FontAwesome = _interopRequireDefault(require(_dependencyMap[13], "@expo/vector-icons/FontAwesome6"));
  var _Ionicons = _interopRequireDefault(require(_dependencyMap[14], "@expo/vector-icons/Ionicons"));
  var _jsxRuntime = require(_dependencyMap[15], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\app\\scan.tsx",
    _s = $RefreshSig$();
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function Scan() {
    _s();
    const [permission, requestPermission] = (0, _expoCamera.useCameraPermissions)();
    const cameraRef = (0, _react.useRef)(null);
    const [facing, setFacing] = (0, _react.useState)("back");
    const [flash, setFlash] = (0, _react.useState)("off");
    const [modalVisible, setModalVisible] = (0, _react.useState)(false);
    const [isScreenFocused, setIsScreenFocused] = (0, _react.useState)(true);
    const router = (0, _expoRouter.useRouter)();
    (0, _expoRouter.useFocusEffect)((0, _react.useCallback)(() => {
      setIsScreenFocused(true);
      return () => setIsScreenFocused(false);
    }, []));
    if (!permission) return null;
    if (!permission.granted) {
      return (0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.container,
        children: [(0, _jsxRuntime.jsx)(_Text.default, {
          style: {
            textAlign: "center"
          },
          children: "We need permission to use camera"
        }), (0, _jsxRuntime.jsx)(_Pressable.default, {
          onPress: requestPermission,
          children: (0, _jsxRuntime.jsx)(_Text.default, {
            children: "Grant Permission"
          })
        })]
      });
    }
    const takePicture = async () => {
      const photo = await cameraRef.current?.takePictureAsync();
      const photoUri = photo?.uri ?? null;
      if (photoUri) {
        router.push({
          pathname: "/scan-result",
          params: {
            image: photoUri
          }
        });
      }
    };
    const openAlbum = async () => {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 1
      });
      if (!result.canceled && result.assets.length > 0) {
        const pickedUri = result.assets[0].uri;
        router.push({
          pathname: "/scan-result",
          params: {
            image: pickedUri
          }
        });
      }
    };
    const toggleFacing = () => setFacing(prev => prev === "back" ? "front" : "back");
    const toggleFlash = () => setFlash(prev => prev === "off" ? "on" : "off");
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.container,
      children: [isScreenFocused && (0, _jsxRuntime.jsx)(_expoCamera.CameraView, {
        style: _StyleSheet.default.absoluteFill,
        ref: cameraRef,
        facing: facing,
        flash: flash,
        mute: false
      }), (0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.topBar,
        children: [(0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: () => router.back(),
          children: (0, _jsxRuntime.jsx)(_Ionicons.default, {
            name: "close",
            size: 32,
            color: "white"
          })
        }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
          onPress: toggleFlash,
          children: (0, _jsxRuntime.jsx)(_Ionicons.default, {
            name: flash === "off" ? "flash-off" : "flash",
            size: 32,
            color: "white"
          })
        })]
      }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
        style: styles.lampIcon,
        onPress: () => setModalVisible(true),
        children: (0, _jsxRuntime.jsx)(_Ionicons.default, {
          name: "bulb-outline",
          size: 32,
          color: "white"
        })
      }), (0, _jsxRuntime.jsxs)(_View.default, {
        style: styles.shutterContainer,
        children: [(0, _jsxRuntime.jsx)(_Pressable.default, {
          onPress: openAlbum,
          children: (0, _jsxRuntime.jsx)(_AntDesign.default, {
            name: "picture",
            size: 32,
            color: "white"
          })
        }), (0, _jsxRuntime.jsx)(_Pressable.default, {
          onPress: takePicture,
          children: ({
            pressed
          }) => (0, _jsxRuntime.jsx)(_View.default, {
            style: [styles.shutterBtn, {
              opacity: pressed ? 0.5 : 1
            }],
            children: (0, _jsxRuntime.jsx)(_View.default, {
              style: styles.shutterBtnInner
            })
          })
        }), (0, _jsxRuntime.jsx)(_Pressable.default, {
          onPress: toggleFacing,
          children: (0, _jsxRuntime.jsx)(_FontAwesome.default, {
            name: "rotate-left",
            size: 32,
            color: "white"
          })
        })]
      }), (0, _jsxRuntime.jsx)(_Modal.default, {
        visible: modalVisible,
        transparent: true,
        animationType: "fade",
        onRequestClose: () => setModalVisible(false),
        children: (0, _jsxRuntime.jsx)(_View.default, {
          style: styles.modalOverlay,
          children: (0, _jsxRuntime.jsxs)(_View.default, {
            style: styles.modalContent,
            children: [(0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.modalTitle,
              children: "Camera Tips"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.modalText,
              children: "\u2022 Hold your phone steady"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.modalText,
              children: "\u2022 Ensure proper lighting"
            }), (0, _jsxRuntime.jsx)(_Text.default, {
              style: styles.modalText,
              children: "\u2022 Focus on the object"
            }), (0, _jsxRuntime.jsx)(_TouchableOpacity.default, {
              style: styles.closeBtn,
              onPress: () => setModalVisible(false),
              children: (0, _jsxRuntime.jsx)(_Text.default, {
                style: styles.closeBtnText,
                children: "Got it"
              })
            })]
          })
        })
      })]
    });
  }
  _s(Scan, "huL8uo8/wRqYZp3NjAib4GHi784=", false, function () {
    return [_expoCamera.useCameraPermissions, _expoRouter.useRouter, _expoRouter.useFocusEffect];
  });
  _c = Scan;
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1,
      backgroundColor: "#000"
    },
    topBar: {
      position: "absolute",
      top: 50,
      left: 20,
      right: 20,
      flexDirection: "row",
      justifyContent: "space-between"
    },
    lampIcon: {
      position: "absolute",
      bottom: 160,
      alignSelf: "center"
    },
    shutterContainer: {
      position: "absolute",
      bottom: _Platform.default.OS === "android" ? 60 : 44,
      // extra padding for Android buttons
      left: 0,
      width: "100%",
      flexDirection: "row",
      justifyContent: "space-between",
      paddingHorizontal: 30,
      alignItems: "center"
    },
    shutterBtn: {
      borderWidth: 5,
      borderColor: "white",
      width: 85,
      height: 85,
      borderRadius: 45,
      alignItems: "center",
      justifyContent: "center"
    },
    shutterBtnInner: {
      width: 70,
      height: 70,
      borderRadius: 50,
      backgroundColor: "white"
    },
    modalOverlay: {
      flex: 1,
      backgroundColor: "rgba(0,0,0,0.7)",
      justifyContent: "center",
      alignItems: "center"
    },
    modalContent: {
      backgroundColor: "#fff",
      padding: 20,
      borderRadius: 10,
      width: 300,
      alignItems: "center"
    },
    modalTitle: {
      fontSize: 20,
      fontWeight: "bold",
      marginBottom: 10
    },
    modalText: {
      fontSize: 16,
      marginVertical: 2
    },
    closeBtn: {
      marginTop: 20,
      backgroundColor: "#333",
      paddingVertical: 10,
      paddingHorizontal: 20,
      borderRadius: 8
    },
    closeBtnText: {
      color: "white",
      fontSize: 16
    }
  });
  var _c;
  $RefreshReg$(_c, "Scan");
},817,[17,3,818,831,111,190,244,30,231,237,106,535,835,839,801,2],"app\\scan.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    useCameraPermissions: true,
    useMicrophonePermissions: true,
    scanFromURLAsync: true,
    Camera: true,
    CameraView: true
  };
  exports.Camera = void 0;
  Object.defineProperty(exports, "CameraView", {
    enumerable: true,
    get: function () {
      return _CameraView.default;
    }
  });
  exports.scanFromURLAsync = scanFromURLAsync;
  exports.useMicrophonePermissions = exports.useCameraPermissions = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ExpoCameraManager = _interopRequireDefault(require(_dependencyMap[2], "./ExpoCameraManager"));
  var _CameraView = _interopRequireDefault(require(_dependencyMap[3], "./CameraView"));
  var _Camera = require(_dependencyMap[4], "./Camera.types");
  Object.keys(_Camera).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Camera[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _Camera[key];
      }
    });
  });
  var _PictureRef = require(_dependencyMap[5], "./PictureRef");
  Object.keys(_PictureRef).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _PictureRef[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _PictureRef[key];
      }
    });
  });
  // @needsAudit
  /**
   * Checks user's permissions for accessing camera.
   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).
   */
  async function getCameraPermissionsAsync() {
    return _ExpoCameraManager.default.getCameraPermissionsAsync();
  }
  // @needsAudit
  /**
   * Asks the user to grant permissions for accessing camera.
   * On iOS this will require apps to specify an `NSCameraUsageDescription` entry in the **Info.plist**.
   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).
   */
  async function requestCameraPermissionsAsync() {
    return _ExpoCameraManager.default.requestCameraPermissionsAsync();
  }
  // @needsAudit
  /**
   * Check or request permissions to access the camera.
   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.
   *
   * @example
   * ```ts
   * const [status, requestPermission] = useCameraPermissions();
   * ```
   */
  const useCameraPermissions = exports.useCameraPermissions = (0, _expoModulesCore.createPermissionHook)({
    getMethod: getCameraPermissionsAsync,
    requestMethod: requestCameraPermissionsAsync
  });
  // @needsAudit
  /**
   * Checks user's permissions for accessing microphone.
   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).
   */
  async function getMicrophonePermissionsAsync() {
    return _ExpoCameraManager.default.getMicrophonePermissionsAsync();
  }
  // @needsAudit
  /**
   * Asks the user to grant permissions for accessing the microphone.
   * On iOS this will require apps to specify an `NSMicrophoneUsageDescription` entry in the **Info.plist**.
   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).
   */
  async function requestMicrophonePermissionsAsync() {
    return _ExpoCameraManager.default.requestMicrophonePermissionsAsync();
  }
  // @needsAudit
  /**
   * Check or request permissions to access the microphone.
   * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.
   *
   * @example
   * ```ts
   * const [status, requestPermission] = Camera.useMicrophonePermissions();
   * ```
   */
  const useMicrophonePermissions = exports.useMicrophonePermissions = (0, _expoModulesCore.createPermissionHook)({
    getMethod: getMicrophonePermissionsAsync,
    requestMethod: requestMicrophonePermissionsAsync
  });
  /**
   * Scan bar codes from the image at the given URL.
   * @param url URL to get the image from.
   * @param barcodeTypes An array of bar code types. Defaults to all supported bar code types on
   * the platform.
   * > __Note:__ Only QR codes are supported on iOS.
   * On android, the barcode should take up the majority of the image for best results.
   * @return A possibly empty array of objects of the `BarcodeScanningResult` shape, where the type
   * refers to the barcode type that was scanned and the data is the information encoded in the barcode.
   */
  async function scanFromURLAsync(url, barcodeTypes = ['qr']) {
    return _ExpoCameraManager.default.scanFromURLAsync(url, barcodeTypes);
  }
  /**
   * @hidden
   */
  const Camera = exports.Camera = {
    getCameraPermissionsAsync,
    requestCameraPermissionsAsync,
    getMicrophonePermissionsAsync,
    requestMicrophonePermissionsAsync,
    scanFromURLAsync
  };
},818,[17,473,819,822,820,830],"node_modules\\expo-camera\\build\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  var _Camera = require(_dependencyMap[1], "./Camera.types");
  var _WebUserMediaManager = require(_dependencyMap[2], "./web/WebUserMediaManager");
  function getUserMedia(constraints) {
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      return navigator.mediaDevices.getUserMedia(constraints);
    }
    // Some browsers partially implement mediaDevices. We can't just assign an object
    // with getUserMedia as it would overwrite existing properties.
    // Here, we will just add the getUserMedia property if it's missing.
    // First get ahold of the legacy getUserMedia, if present
    const getUserMedia =
    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
    navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {
      const error = new Error('Permission unimplemented');
      error.code = 0;
      error.name = 'NotAllowedError';
      throw error;
    };
    return new Promise((resolve, reject) => {
      // TODO(@kitten): The types indicates that this is incorrect.
      // Please check whether this is correct!
      // @ts-expect-error: The `successCallback` doesn't match a `resolve` function
      getUserMedia.call(navigator, constraints, resolve, reject);
    });
  }
  function handleGetUserMediaError({
    message
  }) {
    // name: NotAllowedError
    // code: 0
    if (message === 'Permission dismissed') {
      return {
        status: _Camera.PermissionStatus.UNDETERMINED,
        expires: 'never',
        canAskAgain: true,
        granted: false
      };
    } else {
      // TODO: Bacon: [OSX] The system could deny access to chrome.
      // TODO: Bacon: add: { status: 'unimplemented' }
      return {
        status: _Camera.PermissionStatus.DENIED,
        expires: 'never',
        canAskAgain: true,
        granted: false
      };
    }
  }
  async function handleRequestPermissionsAsync() {
    try {
      const streams = await getUserMedia({
        video: true
      });
      // We need to close the media stream returned by getUserMedia
      // to avoid using the camera since we won't use these streams now
      // https://developer.mozilla.org/fr/docs/Web/API/MediaDevices/getUserMedia
      streams.getTracks().forEach(track => {
        track.stop();
        streams.removeTrack(track);
      });
      return {
        status: _Camera.PermissionStatus.GRANTED,
        expires: 'never',
        canAskAgain: true,
        granted: true
      };
    } catch (error) {
      return handleGetUserMediaError(error.message);
    }
  }
  async function handlePermissionsQueryAsync(query) {
    if (!navigator?.permissions?.query) {
      throw new _expoModulesCore.UnavailabilityError('expo-camera', 'navigator.permissions API is not available');
    }
    try {
      const {
        state
      } = await navigator.permissions.query({
        name: query
      });
      switch (state) {
        case 'prompt':
          return {
            status: _Camera.PermissionStatus.UNDETERMINED,
            expires: 'never',
            canAskAgain: true,
            granted: false
          };
        case 'granted':
          return {
            status: _Camera.PermissionStatus.GRANTED,
            expires: 'never',
            canAskAgain: true,
            granted: true
          };
        case 'denied':
          return {
            status: _Camera.PermissionStatus.DENIED,
            expires: 'never',
            canAskAgain: true,
            granted: false
          };
      }
    } catch (e) {
      // Firefox doesn't support querying for the camera permission, so return undetermined status
      if (e instanceof TypeError) {
        return {
          status: _Camera.PermissionStatus.UNDETERMINED,
          expires: 'never',
          canAskAgain: true,
          granted: false
        };
      }
      throw e;
    }
  }
  var _default = exports.default = {
    get Type() {
      return {
        back: 'back',
        front: 'front'
      };
    },
    get FlashMode() {
      return {
        on: 'on',
        off: 'off',
        auto: 'auto',
        torch: 'torch'
      };
    },
    get AutoFocus() {
      return {
        on: 'on',
        off: 'off',
        auto: 'auto',
        singleShot: 'singleShot'
      };
    },
    get WhiteBalance() {
      return {
        auto: 'auto',
        continuous: 'continuous',
        manual: 'manual'
      };
    },
    get VideoQuality() {
      return {};
    },
    get VideoStabilization() {
      return {};
    },
    async isAvailableAsync() {
      return (0, _WebUserMediaManager.canGetUserMedia)();
    },
    async takePicture(options, camera) {
      return await camera.takePicture(options);
    },
    async pausePreview(camera) {
      await camera.pausePreview();
    },
    async resumePreview(camera) {
      return await camera.resumePreview();
    },
    async getAvailableCameraTypesAsync() {
      if (!(0, _WebUserMediaManager.canGetUserMedia)() || !navigator.mediaDevices.enumerateDevices) return [];
      const devices = await navigator.mediaDevices.enumerateDevices();
      const types = await Promise.all([(await (0, _WebUserMediaManager.isFrontCameraAvailableAsync)(devices)) && 'front', (await (0, _WebUserMediaManager.isBackCameraAvailableAsync)()) && 'back']);
      return types.filter(Boolean);
    },
    async getAvailablePictureSizes(ratio, camera) {
      return await camera.getAvailablePictureSizes(ratio);
    },
    /*
    async record(
      options?: CameraRecordingOptions,
      camera: ExponentCameraRef
    ): Promise<{ uri: string }> {
      // TODO: Support on web
    },
    async stopRecording(camera: ExponentCameraRef): Promise<void> {
      // TODO: Support on web
    }, */
    async getPermissionsAsync() {
      return handlePermissionsQueryAsync('camera');
    },
    async requestPermissionsAsync() {
      return handleRequestPermissionsAsync();
    },
    async getCameraPermissionsAsync() {
      return handlePermissionsQueryAsync('camera');
    },
    async requestCameraPermissionsAsync() {
      return handleRequestPermissionsAsync();
    },
    async getMicrophonePermissionsAsync() {
      return handlePermissionsQueryAsync('microphone');
    },
    async requestMicrophonePermissionsAsync() {
      try {
        await getUserMedia({
          audio: true
        });
        return {
          status: _Camera.PermissionStatus.GRANTED,
          expires: 'never',
          canAskAgain: true,
          granted: true
        };
      } catch (error) {
        return handleGetUserMediaError(error.message);
      }
    }
  };
},819,[473,820,821],"node_modules\\expo-camera\\build\\ExpoCameraManager.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "PermissionStatus", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.PermissionStatus;
    }
  });
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
},820,[473],"node_modules\\expo-camera\\build\\Camera.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.canGetUserMedia = canGetUserMedia;
  exports.getAnyUserMediaAsync = getAnyUserMediaAsync;
  exports.getUserMediaAsync = getUserMediaAsync;
  exports.isBackCameraAvailableAsync = isBackCameraAvailableAsync;
  exports.isFrontCameraAvailableAsync = isFrontCameraAvailableAsync;
  exports.mountedInstances = void 0;
  exports.requestUserMediaAsync = requestUserMediaAsync;
  exports.userMediaRequested = void 0;
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  /* eslint-env browser */
  /**
   * A web-only module for ponyfilling the UserMedia API.
   */

  const userMediaRequested = exports.userMediaRequested = false;
  const mountedInstances = exports.mountedInstances = [];
  async function requestLegacyUserMediaAsync(
  // TODO(@kitten): Type this properly
  props) {
    // TODO(@kitten): This is never type checked against DOM types
    const optionalSource = id => ({
      optional: [{
        sourceId: id
      }]
    });
    const constraintToSourceId = constraint => {
      const {
        deviceId
      } = constraint;
      if (typeof deviceId === 'string') {
        return deviceId;
      }
      if (Array.isArray(deviceId)) {
        return deviceId[0] ?? null;
      } else if (typeof deviceId === 'object' && deviceId.ideal) {
        return deviceId.ideal;
      }
      return null;
    };
    const sources = await new Promise(resolve =>
    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this
    MediaStreamTrack.getSources(sources => resolve(sources)));
    let audioSource = null;
    let videoSource = null;
    sources.forEach(source => {
      if (source.kind === 'audio') {
        audioSource = source.id;
      } else if (source.kind === 'video') {
        videoSource = source.id;
      }
    });
    // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `audioConstraints`
    // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path
    const audioSourceId = constraintToSourceId(props.audioConstraints);
    if (audioSourceId) {
      audioSource = audioSourceId;
    }
    // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`
    // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path
    const videoSourceId = constraintToSourceId(props.videoConstraints);
    if (videoSourceId) {
      videoSource = videoSourceId;
    }
    return [optionalSource(audioSource), optionalSource(videoSource)];
  }
  async function sourceSelectedAsync(isMuted, audioConstraints, videoConstraints) {
    const constraints = {
      video: typeof videoConstraints !== 'undefined' ? videoConstraints : true
    };
    if (!isMuted) {
      constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;
    }
    return await getAnyUserMediaAsync(constraints);
  }
  async function requestUserMediaAsync(
  // TODO(@kitten): Type this properly
  props, isMuted = true) {
    if (canGetUserMedia()) {
      return await sourceSelectedAsync(isMuted, props.audio, props.video);
    }
    // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`
    // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path
    const [audio, video] = await requestLegacyUserMediaAsync(props);
    return await sourceSelectedAsync(isMuted, audio, video);
  }
  async function getAnyUserMediaAsync(constraints, ignoreConstraints = false) {
    try {
      return await getUserMediaAsync(Object.assign({}, constraints, {
        video: ignoreConstraints || constraints.video
      }));
    } catch (error) {
      if (!ignoreConstraints && typeof error === 'object' && error?.name === 'ConstraintNotSatisfiedError') {
        return await getAnyUserMediaAsync(constraints, true);
      }
      throw error;
    }
  }
  async function getUserMediaAsync(constraints) {
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      return navigator.mediaDevices.getUserMedia(constraints);
    }
    const _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] ||
    // @ts-expect-error: TODO(@kitten): Remove / Drop IE support
    navigator['msGetUserMedia'];
    return new Promise((resolve, reject) => _getUserMedia.call(navigator, constraints, resolve, reject));
  }
  function canGetUserMedia() {
    // TODO(@kitten): This is misaligned with the implementations in `expo-audio/src/AudioModule.web.ts` and `expo-av`
    return (
      // SSR
      _expoModulesCore.Platform.isDOMAvailable &&
      // Has any form of media API
      !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] ||
      // @ts-expect-error: TODO(@kitten): Remove / Drop IE support
      navigator['msGetUserMedia'])
    );
  }
  async function isFrontCameraAvailableAsync(devices) {
    return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);
  }
  async function isBackCameraAvailableAsync(devices) {
    return await supportsCameraType(['back', 'rear'], 'environment', devices);
  }
  async function supportsCameraType(labels, type, devices) {
    if (!devices) {
      if (!navigator.mediaDevices.enumerateDevices) {
        return null;
      }
      devices = await navigator.mediaDevices.enumerateDevices();
    }
    const cameras = devices.filter(t => t.kind === 'videoinput');
    const [hasCamera] = cameras.filter(camera => labels.some(label => camera.label.toLowerCase().includes(label)));
    const [isCapable] = cameras.filter(camera => {
      if (!('getCapabilities' in camera)) {
        return null;
      }
      const capabilities = camera.getCapabilities();
      if (!capabilities.facingMode) {
        return null;
      }
      return capabilities.facingMode.find(_ => type);
    });
    return isCapable?.deviceId || hasCamera?.deviceId || null;
  }
},821,[473],"node_modules\\expo-camera\\build\\web\\WebUserMediaManager.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _react = require(_dependencyMap[2], "react");
  var _ExpoCamera = _interopRequireDefault(require(_dependencyMap[3], "./ExpoCamera"));
  var _ExpoCameraManager = _interopRequireDefault(require(_dependencyMap[4], "./ExpoCameraManager"));
  var _props = require(_dependencyMap[5], "./utils/props");
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-camera\\build\\CameraView.js";
  const EventThrottleMs = 500;
  const _PICTURE_SAVED_CALLBACKS = {};
  let loggedRenderingChildrenWarning = false;
  let _GLOBAL_PICTURE_ID = 1;
  function ensurePictureOptions(options) {
    if (!options || typeof options !== 'object') {
      return {};
    }
    if (options.quality === undefined) {
      options.quality = 1;
    }
    if (options.mirror) {
      console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');
    }
    if (options.onPictureSaved) {
      const id = _GLOBAL_PICTURE_ID++;
      _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;
      options.id = id;
      options.fastMode = true;
    }
    return options;
  }
  function ensureRecordingOptions(options = {}) {
    if (!options || typeof options !== 'object') {
      return {};
    }
    if (options.mirror) {
      console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');
    }
    return options;
  }
  function _onPictureSaved({
    nativeEvent
  }) {
    const {
      id,
      data
    } = nativeEvent;
    const callback = _PICTURE_SAVED_CALLBACKS[id];
    if (callback) {
      callback(data);
      delete _PICTURE_SAVED_CALLBACKS[id];
    }
  }
  class CameraView extends _react.Component {
    /**
     * Property that determines if the current device has the ability to use `DataScannerViewController` (iOS 16+).
     */
    static isModernBarcodeScannerAvailable = _ExpoCameraManager.default.isModernBarcodeScannerAvailable;
    /**
     * Check whether the current device has a camera. This is useful for web and simulators cases.
     * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).
     * You will still need to check if the native permission has been accepted.
     * @platform web
     */
    static async isAvailableAsync() {
      if (!_ExpoCameraManager.default.isAvailableAsync) {
        throw new _expoModulesCore.UnavailabilityError('expo-camera', 'isAvailableAsync');
      }
      return _ExpoCameraManager.default.isAvailableAsync();
    }
    // @needsAudit
    /**
     * Queries the device for the available video codecs that can be used in video recording.
     * @return A promise that resolves to a list of strings that represents available codecs.
     * @platform ios
     */
    static async getAvailableVideoCodecsAsync() {
      if (!_ExpoCameraManager.default.getAvailableVideoCodecsAsync) {
        throw new _expoModulesCore.UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');
      }
      return _ExpoCameraManager.default.getAvailableVideoCodecsAsync();
    }
    /**
     * Get picture sizes that are supported by the device.
     * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.
     * The list varies across Android devices but is the same for every iOS.
     */
    async getAvailablePictureSizesAsync() {
      return (await this._cameraRef.current?.getAvailablePictureSizes()) ?? [];
    }
    /**
     * Returns the available lenses for the currently selected camera.
     *
     * @return Returns a Promise that resolves to an array of strings representing the lens type that can be passed to `selectedLens` prop.
     * @platform ios
     */
    async getAvailableLensesAsync() {
      return (await this._cameraRef.current?.getAvailableLenses()) ?? [];
    }
    /**
     * Returns an object with the supported features of the camera on the current device.
     */
    getSupportedFeatures() {
      return {
        isModernBarcodeScannerAvailable: _ExpoCameraManager.default.isModernBarcodeScannerAvailable,
        toggleRecordingAsyncAvailable: _ExpoCameraManager.default.toggleRecordingAsyncAvailable
      };
    }
    /**
     * Resumes the camera preview.
     */
    async resumePreview() {
      return this._cameraRef.current?.resumePreview();
    }
    /**
     * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.
     */
    async pausePreview() {
      return this._cameraRef.current?.pausePreview();
    }
    // Values under keys from this object will be transformed to native options
    static ConversionTables = _props.ConversionTables;
    static defaultProps = {
      zoom: 0,
      facing: 'back',
      enableTorch: false,
      mode: 'picture',
      flash: 'off'
    };
    _cameraRef = /*#__PURE__*/(0, _react.createRef)();
    _lastEvents = {};
    _lastEventsTimes = {};
    async takePictureAsync(options) {
      const pictureOptions = ensurePictureOptions(options);
      return this._cameraRef.current?.takePicture(pictureOptions);
    }
    /**
     * On Android, we will use the [Google code scanner](https://developers.google.com/ml-kit/vision/barcode-scanning/code-scanner).
     * On iOS, presents a modal view controller that uses the [`DataScannerViewController`](https://developer.apple.com/documentation/visionkit/scanning_data_with_the_camera) available on iOS 16+.
     * @platform android
     * @platform ios
     */
    static async launchScanner(options) {
      if (!options) {
        options = {
          barcodeTypes: []
        };
      }
      if (_expoModulesCore.Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {
        await _ExpoCameraManager.default.launchScanner(options);
      }
    }
    /**
     * Dismiss the scanner presented by `launchScanner`.
     * > **info** On Android, the scanner is dismissed automatically when a barcode is scanned.
     * @platform ios
     */
    static async dismissScanner() {
      if (_expoModulesCore.Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {
        await _ExpoCameraManager.default.dismissScanner();
      }
    }
    /**
     * Invokes the `listener` function when a bar code has been successfully scanned. The callback is provided with
     * an object of the `ScanningResult` shape, where the `type` refers to the bar code type that was scanned and the `data` is the information encoded in the bar code
     * (in this case of QR codes, this is often a URL). See [`BarcodeType`](#barcodetype) for supported values.
     * @param listener Invoked with the [ScanningResult](#scanningresult) when a bar code has been successfully scanned.
     *
     * @platform ios
     * @platform android
     */
    static onModernBarcodeScanned(listener) {
      return _ExpoCameraManager.default.addListener('onModernBarcodeScanned', listener);
    }
    /**
     * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.
     * Flipping camera during a recording results in stopping it.
     * @param options A map of `CameraRecordingOptions` type.
     * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.
     * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.
     * @platform android
     * @platform ios
     */
    async recordAsync(options) {
      const recordingOptions = ensureRecordingOptions(options);
      return this._cameraRef.current?.record(recordingOptions);
    }
    /**
     * Pauses or resumes the video recording. Only has an effect if there is an active recording. On `iOS`, this method only supported on `iOS` 18.
     *
     * @example
     * ```ts
     * const { toggleRecordingAsyncAvailable } = getSupportedFeatures()
     *
     * return (
     *  {toggleRecordingAsyncAvailable && (
     *    <Button title="Toggle Recording" onPress={toggleRecordingAsync} />
     *  )}
     * )
     * ```
     */
    async toggleRecordingAsync() {
      return this._cameraRef.current?.toggleRecording();
    }
    /**
     * Stops recording if any is in progress.
     * @platform android
     * @platform ios
     */
    stopRecording() {
      this._cameraRef.current?.stopRecording();
    }
    _onCameraReady = () => {
      if (this.props.onCameraReady) {
        this.props.onCameraReady();
      }
    };
    _onAvailableLensesChanged = ({
      nativeEvent
    }) => {
      if (this.props.onAvailableLensesChanged) {
        this.props.onAvailableLensesChanged(nativeEvent);
      }
    };
    _onMountError = ({
      nativeEvent
    }) => {
      if (this.props.onMountError) {
        this.props.onMountError(nativeEvent);
      }
    };
    _onResponsiveOrientationChanged = ({
      nativeEvent
    }) => {
      if (this.props.onResponsiveOrientationChanged) {
        this.props.onResponsiveOrientationChanged(nativeEvent);
      }
    };
    _onObjectDetected = callback => ({
      nativeEvent
    }) => {
      const {
        type
      } = nativeEvent;
      if (this._lastEvents[type] && this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === this._lastEvents[type] && new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs) {
        return;
      }
      if (callback) {
        callback(nativeEvent);
        this._lastEventsTimes[type] = new Date();
        this._lastEvents[type] = JSON.stringify(nativeEvent);
      }
    };
    _setReference = ref => {
      if (ref) {
        // TODO(Bacon): Unify these - perhaps with hooks?
        if (_expoModulesCore.Platform.OS === 'web') {
          this._cameraHandle = ref;
        }
      }
    };
    render() {
      const nativeProps = (0, _props.ensureNativeProps)(this.props);
      const onBarcodeScanned = this.props.onBarcodeScanned ? this._onObjectDetected(this.props.onBarcodeScanned) : undefined;
      // @ts-expect-error
      if (nativeProps.children && !loggedRenderingChildrenWarning) {
        console.warn('The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.');
        loggedRenderingChildrenWarning = true;
      }
      return (0, _jsxRuntime.jsx)(_ExpoCamera.default, Object.assign({}, nativeProps, {
        ref: this._cameraRef,
        onCameraReady: this._onCameraReady,
        onMountError: this._onMountError,
        onBarcodeScanned: onBarcodeScanned,
        onAvailableLensesChanged: this._onAvailableLensesChanged,
        onPictureSaved: _onPictureSaved,
        onResponsiveOrientationChanged: this._onResponsiveOrientationChanged
      }));
    }
  }
  exports.default = CameraView;
},822,[17,473,3,823,819,829,2],"node_modules\\expo-camera\\build\\CameraView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _expoModulesCore = require(_dependencyMap[2], "expo-modules-core");
  var _react = require(_dependencyMap[3], "react");
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/createElement"));
  var _ExpoCameraManager = _interopRequireDefault(require(_dependencyMap[7], "./ExpoCameraManager.web"));
  var _WebCameraUtils = require(_dependencyMap[8], "./web/WebCameraUtils");
  var _WebConstants = require(_dependencyMap[9], "./web/WebConstants");
  var _useWebCameraStream = require(_dependencyMap[10], "./web/useWebCameraStream");
  var _useWebQRScanner = require(_dependencyMap[11], "./web/useWebQRScanner");
  var _jsxRuntime = require(_dependencyMap[12], "react-native-css-interop/jsx-runtime");
  const _excluded = ["facing", "poster", "ref"];
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-camera\\build\\ExpoCamera.web.js";
  const ExponentCamera = _ref => {
    let {
        facing,
        poster,
        ref
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const video = (0, _react.useRef)(null);
    const native = (0, _useWebCameraStream.useWebCameraStream)(video, facing, props, {
      onCameraReady() {
        if (props.onCameraReady) {
          props.onCameraReady();
        }
      },
      onMountError: props.onMountError
    });
    const isQRScannerEnabled = (0, _react.useMemo)(() => {
      return Boolean(props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned);
    }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);
    (0, _useWebQRScanner.useWebQRScanner)(video, {
      interval: 300,
      isEnabled: isQRScannerEnabled,
      captureOptions: {
        scale: 1,
        isImageMirror: native.type === 'front'
      },
      onScanned(event) {
        if (props.onBarcodeScanned) {
          props.onBarcodeScanned(event);
        }
      }
    });
    (0, _react.useImperativeHandle)(ref, () => ({
      async getAvailablePictureSizes() {
        return _WebConstants.PictureSizes;
      },
      async takePicture(options) {
        if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {
          throw new _expoModulesCore.CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');
        }
        const settings = native.mediaTrackSettings;
        if (!settings) {
          throw new _expoModulesCore.CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');
        }
        return (0, _WebCameraUtils.capture)(video.current, settings, Object.assign({}, options, {
          // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.
          onPictureSaved(picture) {
            if (options.onPictureSaved) {
              options.onPictureSaved(picture);
            }
            if (props.onPictureSaved) {
              props.onPictureSaved({
                nativeEvent: {
                  data: picture,
                  id: -1
                }
              });
            }
          }
        }));
      },
      async resumePreview() {
        if (video.current) {
          video.current.play();
        }
      },
      async pausePreview() {
        if (video.current) {
          video.current.pause();
        }
      },
      async stopRecording() {
        console.warn('stopRecording is not supported on web.');
      },
      async record() {
        console.warn('record is not supported on web.');
        return {
          uri: ''
        };
      },
      async toggleRecording() {
        console.warn('toggleRecording is not supported on web.');
      },
      async launchModernScanner() {
        console.warn('launchModernScanner is not supported on web.');
      },
      async getAvailableLenses() {
        console.warn('getAvailableLenses is not supported on web.');
        return [];
      }
    }), [native.mediaTrackSettings, props.onPictureSaved]);
    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.
    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.
    const isMuted = true;
    const style = (0, _react.useMemo)(() => {
      const isFrontFacingCamera = native.type === _ExpoCameraManager.default.Type.front;
      return [_StyleSheet.default.absoluteFill, styles.video, {
        // Flip the camera
        transform: isFrontFacingCamera ? [{
          scaleX: -1
        }] : undefined
      }];
    }, [native.type]);
    return (0, _jsxRuntime.jsxs)(_View.default, {
      pointerEvents: "box-none",
      style: [styles.videoWrapper, props.style],
      children: [(0, _jsxRuntime.jsx)(Video, {
        autoPlay: true,
        playsInline: true,
        muted: isMuted,
        poster: poster,
        pointerEvents: props.pointerEvents,
        ref: video,
        style: style
      }), props.children]
    });
  };
  var _default = exports.default = ExponentCamera;
  const Video = props => (0, _createElement.default)('video', Object.assign({}, props));
  const styles = _StyleSheet.default.create({
    videoWrapper: {
      flex: 1,
      alignItems: 'stretch'
    },
    video: {
      width: '100%',
      height: '100%',
      objectFit: 'cover'
    }
  });
},823,[17,29,473,3,30,111,18,819,824,826,827,828,2],"node_modules\\expo-camera\\build\\ExpoCamera.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.capture = capture;
  exports.captureImage = captureImage;
  exports.captureImageContext = captureImageContext;
  exports.captureImageData = captureImageData;
  exports.compareStreams = compareStreams;
  exports.getIdealConstraints = getIdealConstraints;
  exports.getImageSize = getImageSize;
  exports.getPreferredStreamDevice = getPreferredStreamDevice;
  exports.getStreamDevice = getStreamDevice;
  exports.hasValidConstraints = hasValidConstraints;
  exports.isCapabilityAvailable = isCapabilityAvailable;
  exports.isWebKit = isWebKit;
  exports.setVideoSource = setVideoSource;
  exports.stopMediaStream = stopMediaStream;
  exports.syncTrackCapabilities = syncTrackCapabilities;
  exports.toDataURL = toDataURL;
  var _invariant = _interopRequireDefault(require(_dependencyMap[1], "invariant"));
  var CapabilityUtils = _interopRequireWildcard(require(_dependencyMap[2], "./WebCapabilityUtils"));
  var _WebConstants = require(_dependencyMap[3], "./WebConstants");
  var _WebUserMediaManager = require(_dependencyMap[4], "./WebUserMediaManager");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /* eslint-env browser */

  function getImageSize(videoWidth, videoHeight, scale) {
    const width = videoWidth * scale;
    const ratio = videoWidth / width;
    const height = videoHeight / ratio;
    return {
      width,
      height
    };
  }
  function toDataURL(canvas, imageType, quality) {
    const types = ['png', 'jpg'];
    (0, _invariant.default)(types.includes(imageType), `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${types.join(', ')}`);
    const format = _WebConstants.ImageTypeFormat[imageType];
    if (imageType === 'jpg') {
      (0, _invariant.default)(quality <= 1 && quality >= 0, `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`);
      return canvas.toDataURL(format, quality);
    } else {
      return canvas.toDataURL(format);
    }
  }
  function hasValidConstraints(preferredCameraType, width, height) {
    return preferredCameraType !== undefined && width !== undefined && height !== undefined;
  }
  function ensureCameraPictureOptions(config) {
    const captureOptions = {
      scale: 1,
      imageType: 'png',
      isImageMirror: false
    };
    for (const key in config) {
      const prop = key;
      if (prop in config && config[prop] !== undefined && prop in captureOptions) {
        captureOptions[prop] = config[prop];
      }
    }
    return captureOptions;
  }
  const DEFAULT_QUALITY = 0.92;
  function captureImageData(video, pictureOptions = {}) {
    if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
      return null;
    }
    const canvas = captureImageContext(video, pictureOptions);
    const context = canvas.getContext('2d', {
      alpha: false
    });
    if (!context || !canvas.width || !canvas.height) {
      return null;
    }
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    return imageData;
  }
  function captureImageContext(video, {
    scale = 1,
    isImageMirror = false
  }) {
    const {
      videoWidth,
      videoHeight
    } = video;
    const {
      width,
      height
    } = getImageSize(videoWidth, videoHeight, scale);
    // Build the canvas size and draw the camera image to the context from video
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d', {
      alpha: false
    });
    if (!context) {
      // Should never be called
      throw new Error('Context is not defined');
    }
    // sharp image details
    // context.imageSmoothingEnabled = false;
    // Flip horizontally (as css transform: rotateY(180deg))
    if (isImageMirror) {
      context.setTransform(-1, 0, 0, 1, canvas.width, 0);
    }
    context.drawImage(video, 0, 0, width, height);
    return canvas;
  }
  function captureImage(video, pictureOptions) {
    const config = ensureCameraPictureOptions(pictureOptions);
    const canvas = captureImageContext(video, config);
    const {
      imageType,
      quality = DEFAULT_QUALITY
    } = config;
    return toDataURL(canvas, imageType, quality);
  }
  function getSupportedConstraints() {
    if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {
      return navigator.mediaDevices.getSupportedConstraints();
    }
    return null;
  }
  function getIdealConstraints(preferredCameraType, width, height) {
    const preferredConstraints = {
      audio: false,
      video: {}
    };
    if (hasValidConstraints(preferredCameraType, width, height)) {
      return _WebConstants.MinimumConstraints;
    }
    const supports = getSupportedConstraints();
    // TODO(Bacon): Test this
    if (!supports || !supports.facingMode || !supports.width || !supports.height) {
      return _WebConstants.MinimumConstraints;
    }
    const types = ['front', 'back'];
    if (preferredCameraType && types.includes(preferredCameraType)) {
      const facingMode = _WebConstants.CameraTypeToFacingMode[preferredCameraType];
      if (isWebKit()) {
        const key = facingMode === 'user' ? 'exact' : 'ideal';
        preferredConstraints.video.facingMode = {
          [key]: facingMode
        };
      } else {
        preferredConstraints.video.facingMode = {
          ideal: _WebConstants.CameraTypeToFacingMode[preferredCameraType]
        };
      }
    }
    if (isMediaTrackConstraints(preferredConstraints.video)) {
      preferredConstraints.video.width = width;
      preferredConstraints.video.height = height;
    }
    return preferredConstraints;
  }
  function isMediaTrackConstraints(input) {
    return input && typeof input.video !== 'boolean';
  }
  /**
   * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.
   *
   * @param preferredCameraType
   * @param preferredWidth
   * @param preferredHeight
   */
  async function getPreferredStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {
    try {
      return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);
    } catch (error) {
      // A hack on desktop browsers to ensure any camera is used.
      // eslint-disable-next-line no-undef
      if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {
        const nextCameraType = preferredCameraType === 'back' ? 'front' : 'back';
        return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);
      }
      throw error;
    }
  }
  async function getStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {
    const constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);
    const stream = await (0, _WebUserMediaManager.requestUserMediaAsync)(constraints);
    return stream;
  }
  function isWebKit() {
    return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
  }
  function compareStreams(a, b) {
    if (!a || !b) {
      return false;
    }
    const settingsA = a.getTracks()[0].getSettings();
    const settingsB = b.getTracks()[0].getSettings();
    return settingsA.deviceId === settingsB.deviceId;
  }
  function capture(video, settings, config) {
    const base64 = captureImage(video, config);
    const capturedPicture = {
      uri: base64,
      base64,
      width: 0,
      height: 0,
      format: config.imageType ?? 'jpg'
    };
    if (settings) {
      const {
        width = 0,
        height = 0
      } = settings;
      capturedPicture.width = width;
      capturedPicture.height = height;
      capturedPicture.exif = settings;
    }
    if (config.onPictureSaved) {
      config.onPictureSaved(capturedPicture);
    }
    return capturedPicture;
  }
  async function syncTrackCapabilities(cameraType, stream, settings = {}) {
    if (stream?.getVideoTracks) {
      await Promise.all(stream.getVideoTracks().map(track => onCapabilitiesReady(cameraType, track, settings)));
    }
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints
  async function onCapabilitiesReady(cameraType, track, settings = {}) {
    if (typeof track.getCapabilities !== 'function') {
      return;
    }
    const capabilities = track.getCapabilities();
    // Create an empty object because if you set a constraint that isn't available an error will be thrown.
    const constraints = {};
    // TODO(Bacon): Add `pointsOfInterest` support
    const clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];
    for (const property of clampedValues) {
      if (capabilities[property]) {
        constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);
      }
    }
    function validatedInternalConstrainedValue(constraintKey, settingsKey, converter) {
      const convertedSetting = converter(settings[settingsKey]);
      return validatedConstrainedValue({
        constraintKey,
        settingsKey,
        convertedSetting,
        capabilities,
        settings,
        cameraType
      });
    }
    if (capabilities.focusMode && settings.autoFocus !== undefined) {
      constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);
    }
    if (capabilities.torch && settings.flashMode !== undefined) {
      constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);
    }
    if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {
      constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);
    }
    try {
      await track.applyConstraints({
        advanced: [constraints]
      });
    } catch (error) {
      if (__DEV__) console.warn('Failed to apply constraints', error);
    }
  }
  function stopMediaStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.getAudioTracks) {
      stream.getAudioTracks().forEach(track => track.stop());
    }
    if (stream.getVideoTracks) {
      stream.getVideoTracks().forEach(track => track.stop());
    }
    if (isMediaStreamTrack(stream)) {
      stream.stop();
    }
  }
  function setVideoSource(video, stream) {
    const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;
    if (typeof video.srcObject !== 'undefined') {
      video.srcObject = stream;
    } else if (typeof video.mozSrcObject !== 'undefined') {
      video.mozSrcObject = stream;
    } else if (stream && createObjectURL) {
      video.src = createObjectURL(stream);
    }
    if (!stream) {
      const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;
      const source = video.src ?? video.srcObject ?? video.mozSrcObject;
      if (revokeObjectURL && typeof source === 'string') {
        revokeObjectURL(source);
      }
    }
  }
  function isCapabilityAvailable(video, keyName) {
    const stream = video.srcObject;
    if (stream instanceof MediaStream) {
      const videoTrack = stream.getVideoTracks()[0];
      return !!videoTrack.getCapabilities?.()?.[keyName];
    }
    return false;
  }
  function isMediaStreamTrack(input) {
    return typeof input.stop === 'function';
  }
  function convertNormalizedSetting(range, value) {
    if (!value) {
      return;
    }
    // convert the normalized incoming setting to the native camera zoom range
    const converted = convertRange(value, [range.min, range.max]);
    // clamp value so we don't get an error
    return Math.min(range.max, Math.max(range.min, converted));
  }
  function convertRange(value, r2, r1 = [0, 1]) {
    return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];
  }
  function validatedConstrainedValue(props) {
    const {
      constraintKey,
      settingsKey,
      convertedSetting,
      capabilities,
      settings,
      cameraType
    } = props;
    const setting = settings[settingsKey];
    if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {
      if (__DEV__) {
        // Only warn in dev mode.
        console.warn(` { ${settingsKey}: "${setting}" } (converted to "${convertedSetting}" in the browser) is not supported for camera type "${cameraType}" in your browser. Using the default value instead.`);
      }
      return undefined;
    }
    return convertedSetting;
  }
},824,[17,919,825,826,821],"node_modules\\expo-camera\\build\\web\\WebCameraUtils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.convertAutoFocusJSONToNative = convertAutoFocusJSONToNative;
  exports.convertFlashModeJSONToNative = convertFlashModeJSONToNative;
  exports.convertWhiteBalanceJSONToNative = convertWhiteBalanceJSONToNative;
  /*
   * Native web camera (Android) has a torch: boolean
   */
  function convertFlashModeJSONToNative(input) {
    switch (input) {
      case 'torch':
        return true;
      case 'on':
      case 'off':
      case 'auto':
      default:
        return false;
    }
  }
  function convertWhiteBalanceJSONToNative(input) {
    switch (input) {
      case 'on':
      case 'auto':
        return 'continuous';
      case 'off':
        return 'none';
      case 'singleShot':
        return 'single-shot';
      default:
        return undefined;
    }
  }
  function convertAutoFocusJSONToNative(input) {
    switch (input) {
      case 'on':
      case 'auto':
        return 'continuous';
      case 'off':
        return 'manual';
      case 'singleShot':
        return 'single-shot';
      default:
        return undefined;
    }
  }
},825,[],"node_modules\\expo-camera\\build\\web\\WebCapabilityUtils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VIDEO_ASPECT_RATIOS = exports.PictureSizes = exports.MinimumConstraints = exports.ImageTypeFormat = exports.FacingModeToCameraType = exports.CameraTypeToFacingMode = void 0;
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/aspectRatio
  const VIDEO_ASPECT_RATIOS = exports.VIDEO_ASPECT_RATIOS = {
    '3840x2160': 3840 / 2160,
    '1920x1080': 1920 / 1080,
    '1280x720': 1280 / 720,
    '640x480': 640 / 480,
    '352x288': 352 / 288
  };
  const PictureSizes = exports.PictureSizes = Object.keys(VIDEO_ASPECT_RATIOS);
  const ImageTypeFormat = exports.ImageTypeFormat = {
    jpg: 'image/jpeg',
    png: 'image/png'
  };
  const MinimumConstraints = exports.MinimumConstraints = {
    audio: false,
    video: true
  };
  const CameraTypeToFacingMode = exports.CameraTypeToFacingMode = {
    front: 'user',
    back: 'environment'
  };
  const FacingModeToCameraType = exports.FacingModeToCameraType = {
    user: 'front',
    environment: 'back'
  };
},826,[],"node_modules\\expo-camera\\build\\web\\WebConstants.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useWebCameraStream = useWebCameraStream;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var Utils = _interopRequireWildcard(require(_dependencyMap[1], "./WebCameraUtils"));
  var _WebConstants = require(_dependencyMap[2], "./WebConstants");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /* eslint-env browser */

  const VALID_SETTINGS_KEYS = ['autoFocus', 'flashMode', 'exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'whiteBalance', 'zoom'];
  function useLoadedVideo(video, onLoaded) {
    React.useEffect(() => {
      if (video) {
        video.addEventListener('loadedmetadata', () => {
          // without this async block the constraints aren't properly applied to the camera,
          // this means that if you were to turn on the torch and swap to the front camera,
          // then swap back to the rear camera the torch setting wouldn't be applied.
          requestAnimationFrame(() => {
            onLoaded();
          });
        });
      }
    }, [video]);
  }
  function useWebCameraStream(video, preferredType, settings, {
    onCameraReady,
    onMountError
  }) {
    const isStartingCamera = React.useRef(false);
    const activeStreams = React.useRef([]);
    const capabilities = React.useRef({
      autoFocus: 'continuous',
      flashMode: 'off',
      whiteBalance: 'continuous',
      zoom: 1
    });
    const [stream, setStream] = React.useState(null);
    const mediaTrackSettings = React.useMemo(() => {
      return stream ? stream.getTracks()[0].getSettings() : null;
    }, [stream]);
    // The actual camera type - this can be different from the incoming camera type.
    const type = React.useMemo(() => {
      if (!mediaTrackSettings) {
        return null;
      }
      // On desktop no value will be returned, in this case we should assume the cameraType is 'front'
      const {
        facingMode = 'user'
      } = mediaTrackSettings;
      return _WebConstants.FacingModeToCameraType[facingMode];
    }, [mediaTrackSettings]);
    const getStreamDeviceAsync = React.useCallback(async () => {
      try {
        return await Utils.getPreferredStreamDevice(preferredType);
      } catch (nativeEvent) {
        if (__DEV__) {
          console.warn(`Error requesting UserMedia for type "${preferredType}":`, nativeEvent);
        }
        if (onMountError) {
          onMountError({
            nativeEvent
          });
        }
        return null;
      }
    }, [preferredType, onMountError]);
    const resumeAsync = React.useCallback(async () => {
      const nextStream = await getStreamDeviceAsync();
      if (Utils.compareStreams(nextStream, stream)) {
        // Do nothing if the streams are the same.
        // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.
        // Without this check there is a screen flash while the video switches.
        return false;
      }
      // Save a history of all active streams (usually 2+) so we can close them later.
      // Keeping them open makes swapping camera types much faster.
      if (!activeStreams.current.some(value => value.id === nextStream?.id)) {
        activeStreams.current.push(nextStream);
      }
      // Set the new stream -> update the video, settings, and actual camera type.
      setStream(nextStream);
      if (onCameraReady) {
        onCameraReady();
      }
      return false;
    }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);
    React.useEffect(() => {
      // Restart the camera and guard concurrent actions.
      if (isStartingCamera.current) {
        return;
      }
      isStartingCamera.current = true;
      resumeAsync().then(isStarting => {
        isStartingCamera.current = isStarting;
      }).catch(() => {
        // ensure the camera can be started again.
        isStartingCamera.current = false;
      });
    }, [preferredType]);
    // Update the native camera with any custom capabilities.
    React.useEffect(() => {
      const changes = {};
      for (const key of VALID_SETTINGS_KEYS) {
        if (key in settings) {
          const nextValue = settings[key];
          if (nextValue !== capabilities.current[key]) {
            changes[key] = nextValue;
          }
        }
      }
      // Only update the native camera if changes were found
      const hasChanges = !!Object.keys(changes).length;
      const nextWebCameraSettings = Object.assign({}, capabilities.current, changes);
      if (hasChanges) {
        Utils.syncTrackCapabilities(preferredType, stream, changes);
      }
      capabilities.current = nextWebCameraSettings;
    }, [settings.autoFocus, settings.flashMode, settings.exposureCompensation, settings.colorTemperature, settings.iso, settings.brightness, settings.contrast, settings.saturation, settings.sharpness, settings.focusDistance, settings.whiteBalance, settings.zoom]);
    React.useEffect(() => {
      // set or unset the video source.
      if (!video.current) {
        return;
      }
      Utils.setVideoSource(video.current, stream);
    }, [video.current, stream]);
    React.useEffect(() => {
      return () => {
        // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.
        for (const stream of activeStreams.current) {
          // Close all open streams.
          Utils.stopMediaStream(stream);
        }
        if (video.current) {
          // Invalidate the video source.
          Utils.setVideoSource(video.current, stream);
        }
      };
    }, []);
    // Update props when the video loads.
    useLoadedVideo(video.current, () => {
      Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);
    });
    return {
      type,
      mediaTrackSettings
    };
  }
},827,[3,824,826],"node_modules\\expo-camera\\build\\web\\useWebCameraStream.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useWebQRScanner = useWebQRScanner;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  var _WebCameraUtils = require(_dependencyMap[1], "./WebCameraUtils");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const qrWorkerMethod = ({
    data,
    width,
    height
  }) => {
    // eslint-disable-next-line no-undef
    const decoded = self.jsQR(data, width, height, {
      inversionAttempts: 'attemptBoth'
    });
    let parsed;
    try {
      parsed = JSON.parse(decoded);
    } catch {
      parsed = decoded;
    }
    if (parsed?.data) {
      const nativeEvent = {
        type: 'qr',
        data: parsed.data,
        cornerPoints: [],
        bounds: {
          origin: {
            x: 0,
            y: 0
          },
          size: {
            width: 0,
            height: 0
          }
        }
      };
      if (parsed.location) {
        nativeEvent.cornerPoints = [parsed.location.topLeftCorner, parsed.location.bottomLeftCorner, parsed.location.topRightCorner, parsed.location.bottomRightCorner];
      }
      return nativeEvent;
    }
    return parsed;
  };
  const createWorkerAsyncFunction = (fn, deps) => {
    if (typeof window === 'undefined') {
      return async () => {
        throw new Error('Cannot use createWorkerAsyncFunction in a non-browser environment');
      };
    }
    const stringifiedFn = [`self.func = ${fn.toString()};`, 'self.onmessage = (e) => {', '  const result = self.func(e.data);', '  self.postMessage(result);', '};'];
    if (deps.length > 0) {
      stringifiedFn.unshift(`importScripts(${deps.map(dep => `'${dep}'`).join(', ')});`);
    }
    const blob = new Blob(stringifiedFn, {
      type: 'text/javascript'
    });
    const worker = new Worker(URL.createObjectURL(blob));
    // First-In First-Out queue of promises
    const promises = [];
    worker.onmessage = e => promises.shift()?.resolve(e.data);
    return data => {
      return new Promise((resolve, reject) => {
        promises.push({
          resolve,
          reject
        });
        worker.postMessage(data);
      });
    };
  };
  const decode = createWorkerAsyncFunction(qrWorkerMethod, ['https://cdn.jsdelivr.net/npm/jsqr@1.2.0/dist/jsQR.min.js']);
  function useWebQRScanner(video, {
    isEnabled,
    captureOptions,
    interval,
    onScanned,
    onError
  }) {
    const isRunning = React.useRef(false);
    const timeout = React.useRef(undefined);
    async function scanAsync() {
      // If interval is 0 then only scan once.
      if (!isRunning.current || !onScanned) {
        stop();
        return;
      }
      try {
        const data = (0, _WebCameraUtils.captureImageData)(video.current, captureOptions);
        if (data) {
          const nativeEvent = await decode(data);
          if (nativeEvent?.data) {
            onScanned({
              nativeEvent
            });
          }
        }
      } catch (error) {
        if (onError) {
          onError({
            nativeEvent: error
          });
        }
      } finally {
        // If interval is 0 then only scan once.
        if (interval === 0) {
          stop();
          return;
        }
        const intervalToUse = !interval || interval < 0 ? 16 : interval;
        // @ts-ignore: Type 'Timeout' is not assignable to type 'number'
        timeout.current = setTimeout(() => {
          scanAsync();
        }, intervalToUse);
      }
    }
    function stop() {
      isRunning.current = false;
      clearTimeout(timeout.current);
    }
    React.useEffect(() => {
      if (isEnabled) {
        isRunning.current = true;
        scanAsync();
      }
      return () => {
        if (isEnabled) {
          stop();
        }
      };
    }, [isEnabled]);
  }
},828,[3,824],"node_modules\\expo-camera\\build\\web\\useWebQRScanner.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ConversionTables = void 0;
  exports.convertNativeProps = convertNativeProps;
  exports.ensureNativeProps = ensureNativeProps;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ExpoCameraManager = _interopRequireDefault(require(_dependencyMap[2], "../ExpoCameraManager"));
  // Values under keys from this object will be transformed to native options
  const ConversionTables = exports.ConversionTables = {
    type: _ExpoCameraManager.default.Type,
    flash: _ExpoCameraManager.default.FlashMode
  };
  function convertNativeProps(props) {
    if (!props || typeof props !== 'object') {
      return {};
    }
    const nativeProps = {};
    for (const [key, value] of Object.entries(props)) {
      const prop = key;
      if (typeof value === 'string' && ConversionTables[prop]) {
        nativeProps[key] = ConversionTables[prop][value];
      } else {
        nativeProps[key] = value;
      }
    }
    return nativeProps;
  }
  function ensureNativeProps(props) {
    const newProps = convertNativeProps(props);
    newProps.barcodeScannerEnabled = !!props?.onBarcodeScanned;
    newProps.flashMode = props?.flash ?? 'off';
    newProps.mute = props?.mute ?? false;
    newProps.autoFocus = props?.autofocus ?? 'off';
    if (_expoModulesCore.Platform.OS !== 'web') {
      delete newProps.poster;
    }
    return newProps;
  }
},829,[17,473,819],"node_modules\\expo-camera\\build\\utils\\props.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ExpoCameraManager = _interopRequireDefault(require(_dependencyMap[1], "./ExpoCameraManager"));
  var _default = exports.default = _ExpoCameraManager.default.Picture;
},830,[17,819],"node_modules\\expo-camera\\build\\PictureRef.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    getCameraPermissionsAsync: true,
    getMediaLibraryPermissionsAsync: true,
    requestCameraPermissionsAsync: true,
    requestMediaLibraryPermissionsAsync: true,
    useMediaLibraryPermissions: true,
    useCameraPermissions: true,
    getPendingResultAsync: true,
    launchCameraAsync: true,
    launchImageLibraryAsync: true,
    PermissionStatus: true
  };
  Object.defineProperty(exports, "PermissionStatus", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.PermissionStatus;
    }
  });
  exports.getCameraPermissionsAsync = getCameraPermissionsAsync;
  exports.getMediaLibraryPermissionsAsync = getMediaLibraryPermissionsAsync;
  exports.getPendingResultAsync = getPendingResultAsync;
  exports.launchCameraAsync = launchCameraAsync;
  exports.launchImageLibraryAsync = launchImageLibraryAsync;
  exports.requestCameraPermissionsAsync = requestCameraPermissionsAsync;
  exports.requestMediaLibraryPermissionsAsync = requestMediaLibraryPermissionsAsync;
  exports.useMediaLibraryPermissions = exports.useCameraPermissions = void 0;
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _ExponentImagePicker = _interopRequireDefault(require(_dependencyMap[2], "./ExponentImagePicker"));
  var _utils = require(_dependencyMap[3], "./utils");
  var _ImagePicker = require(_dependencyMap[4], "./ImagePicker.types");
  Object.keys(_ImagePicker).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _ImagePicker[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _ImagePicker[key];
      }
    });
  });
  function validateOptions(options) {
    const {
      aspect,
      quality,
      videoMaxDuration
    } = options;
    if (aspect != null) {
      const [x, y] = aspect;
      if (x <= 0 || y <= 0) {
        throw new _expoModulesCore.CodedError('ERR_INVALID_ARGUMENT', `Invalid aspect ratio values ${x}:${y}. Provide positive numbers.`);
      }
    }
    if (quality && (quality < 0 || quality > 1)) {
      throw new _expoModulesCore.CodedError('ERR_INVALID_ARGUMENT', `Invalid 'quality' value ${quality}. Provide a value between 0 and 1.`);
    }
    if (videoMaxDuration && videoMaxDuration < 0) {
      throw new _expoModulesCore.CodedError('ERR_INVALID_ARGUMENT', `Invalid 'videoMaxDuration' value ${videoMaxDuration}. Provide a non-negative number.`);
    }
    return options;
  }
  // @needsAudit
  /**
   * Checks user's permissions for accessing camera.
   * @return A promise that fulfills with an object of type [CameraPermissionResponse](#camerapermissionresponse).
   */
  async function getCameraPermissionsAsync() {
    return _ExponentImagePicker.default.getCameraPermissionsAsync();
  }
  // @needsAudit
  /**
   * Checks user's permissions for accessing photos.
   * @param writeOnly Whether to request write or read and write permissions. Defaults to `false`
   * @return A promise that fulfills with an object of type [MediaLibraryPermissionResponse](#medialibrarypermissionresponse).
   */
  async function getMediaLibraryPermissionsAsync(writeOnly = false) {
    return _ExponentImagePicker.default.getMediaLibraryPermissionsAsync(writeOnly);
  }
  // @needsAudit
  /**
   * Asks the user to grant permissions for accessing camera. This does nothing on web because the
   * browser camera is not used.
   * @return A promise that fulfills with an object of type [CameraPermissionResponse](#camerarollpermissionresponse).
   */
  async function requestCameraPermissionsAsync() {
    return _ExponentImagePicker.default.requestCameraPermissionsAsync();
  }
  // @needsAudit
  /**
   * Asks the user to grant permissions for accessing user's photo. This method does nothing on web.
   * @param writeOnly Whether to request write or read and write permissions. Defaults to `false`
   * @return A promise that fulfills with an object of type [MediaLibraryPermissionResponse](#medialibrarypermissionresponse).
   */
  async function requestMediaLibraryPermissionsAsync(writeOnly = false) {
    const imagePickerMethod = _ExponentImagePicker.default.requestMediaLibraryPermissionsAsync;
    return imagePickerMethod(writeOnly);
  }
  // @needsAudit
  /**
   * Check or request permissions to access the media library.
   * This uses both `requestMediaLibraryPermissionsAsync` and `getMediaLibraryPermissionsAsync` to interact with the permissions.
   *
   * @example
   * ```ts
   * const [status, requestPermission] = ImagePicker.useMediaLibraryPermissions();
   * ```
   */
  const useMediaLibraryPermissions = exports.useMediaLibraryPermissions = (0, _expoModulesCore.createPermissionHook)({
    // TODO(cedric): permission requesters should have an options param or a different requester
    getMethod: options => getMediaLibraryPermissionsAsync(options?.writeOnly),
    requestMethod: options => requestMediaLibraryPermissionsAsync(options?.writeOnly)
  });
  // @needsAudit
  /**
   * Check or request permissions to access the camera.
   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.
   *
   * @example
   * ```ts
   * const [status, requestPermission] = ImagePicker.useCameraPermissions();
   * ```
   */
  const useCameraPermissions = exports.useCameraPermissions = (0, _expoModulesCore.createPermissionHook)({
    getMethod: getCameraPermissionsAsync,
    requestMethod: requestCameraPermissionsAsync
  });
  // @needsAudit
  /**
   * Android system sometimes kills the `MainActivity` after the `ImagePicker` finishes. When this
   * happens, we lose the data selected using the `ImagePicker`. However, you can retrieve the lost
   * data by calling `getPendingResultAsync`. You can test this functionality by turning on
   * `Don't keep activities` in the developer options.
   * @return
   * - **On Android:** a promise that resolves to an object of exactly same type as in
   * `ImagePicker.launchImageLibraryAsync` or `ImagePicker.launchCameraAsync` if the `ImagePicker`
   * finished successfully. Otherwise, an object of type [`ImagePickerErrorResult`](#imagepickerimagepickererrorresult).
   * - **On other platforms:** `null`
   */
  async function getPendingResultAsync() {
    if (_ExponentImagePicker.default.getPendingResultAsync) {
      return _ExponentImagePicker.default.getPendingResultAsync();
    }
    return null;
  }
  // @needsAudit
  /**
   * Display the system UI for taking a photo with the camera. Requires `Permissions.CAMERA`.
   * On Android and iOS 10 `Permissions.CAMERA_ROLL` is also required. On mobile web, this must be
   * called immediately in a user interaction like a button press, otherwise the browser will block
   * the request without a warning.
   * > **Note:** Make sure that you handle `MainActivity` destruction on **Android**. See [ImagePicker.getPendingResultAsync](#imagepickergetpendingresultasync).
   * > **Notes for Web:** The system UI can only be shown after user activation (e.g. a `Button` press).
   * Therefore, calling `launchCameraAsync` in `componentDidMount`, for example, will **not** work as
   * intended. The `cancelled` event will not be returned in the browser due to platform restrictions
   * and inconsistencies across browsers.
   * @param options An `ImagePickerOptions` object.
   * @return A promise that resolves to an object with `canceled` and `assets` fields.
   * When the user canceled the action the `assets` is always `null`, otherwise it's an array of
   * the selected media assets which have a form of [`ImagePickerAsset`](#imagepickerasset).
   */
  async function launchCameraAsync(options = {}) {
    if (!_ExponentImagePicker.default.launchCameraAsync) {
      throw new _expoModulesCore.UnavailabilityError('ImagePicker', 'launchCameraAsync');
    }
    const mappedOptions = (0, _utils.mapDeprecatedOptions)(options);
    return await _ExponentImagePicker.default.launchCameraAsync(validateOptions(mappedOptions));
  }
  // @needsAudit
  /**
   * Display the system UI for choosing an image or a video from the phone's library.
   * Requires `Permissions.MEDIA_LIBRARY` on iOS 10 only. On mobile web, this must be     called
   * immediately in a user interaction like a button press, otherwise the browser will block the
   * request without a warning.
   *
   * **Animated GIFs support:** On Android, if the selected image is an animated GIF, the result image will be an
   * animated GIF too if and only if `quality` is explicitly set to `1.0` and `allowsEditing` is set to `false`.
   * Otherwise compression and/or cropper will pick the first frame of the GIF and return it as the
   * result (on Android the result will be a PNG). On iOS, both quality and cropping are supported.
   *
   * > **Notes for Web:** The system UI can only be shown after user activation (e.g. a `Button` press).
   * Therefore, calling `launchImageLibraryAsync` in `componentDidMount`, for example, will **not**
   * work as intended. The `cancelled` event will not be returned in the browser due to platform
   * restrictions and inconsistencies across browsers.
   * @param options An object extended by [`ImagePickerOptions`](#imagepickeroptions).
   * @return A promise that resolves to an object with `canceled` and `assets` fields.
   * When the user canceled the action the `assets` is always `null`, otherwise it's an array of
   * the selected media assets which have a form of [`ImagePickerAsset`](#imagepickerasset).
   */
  async function launchImageLibraryAsync(options = {}) {
    const mappedOptions = (0, _utils.mapDeprecatedOptions)(options);
    if (!_ExponentImagePicker.default.launchImageLibraryAsync) {
      throw new _expoModulesCore.UnavailabilityError('ImagePicker', 'launchImageLibraryAsync');
    }
    if (mappedOptions?.allowsEditing && mappedOptions.allowsMultipleSelection) {
      console.warn('[expo-image-picker] `allowsEditing` is not supported when `allowsMultipleSelection` is enabled and will be ignored.' + "Disable either 'allowsEditing' or 'allowsMultipleSelection' in 'launchImageLibraryAsync' " + 'to fix this warning.');
    }
    return await _ExponentImagePicker.default.launchImageLibraryAsync(mappedOptions);
  }
},831,[17,473,832,834,833],"node_modules\\expo-image-picker\\build\\ImagePicker.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  var _ImagePicker = require(_dependencyMap[1], "./ImagePicker.types");
  var _utils = require(_dependencyMap[2], "./utils");
  const MediaTypeInput = {
    images: 'image/*',
    videos: 'video/mp4,video/quicktime,video/x-m4v,video/*',
    livePhotos: ''
  };
  var _default = exports.default = {
    async launchImageLibraryAsync({
      mediaTypes = ['images'],
      allowsMultipleSelection = false,
      base64 = false
    }) {
      // SSR guard
      if (!_expoModulesCore.Platform.isDOMAvailable) {
        return {
          canceled: true,
          assets: null
        };
      }
      return await openFileBrowserAsync({
        mediaTypes,
        allowsMultipleSelection,
        base64
      });
    },
    async launchCameraAsync({
      mediaTypes = _ImagePicker.MediaTypeOptions.Images,
      allowsMultipleSelection = false,
      base64 = false,
      cameraType
    }) {
      // SSR guard
      if (!_expoModulesCore.Platform.isDOMAvailable) {
        return {
          canceled: true,
          assets: null
        };
      }
      return await openFileBrowserAsync({
        mediaTypes,
        allowsMultipleSelection,
        capture: cameraType ?? true,
        base64
      });
    },
    /*
     * Delegate to expo-permissions to request camera permissions
     */
    async getCameraPermissionsAsync() {
      return permissionGrantedResponse();
    },
    async requestCameraPermissionsAsync() {
      return permissionGrantedResponse();
    },
    /*
     * Camera roll permissions don't need to be requested on web, so we always
     * respond with granted.
     */
    async getMediaLibraryPermissionsAsync(_writeOnly) {
      return permissionGrantedResponse();
    },
    async requestMediaLibraryPermissionsAsync(_writeOnly) {
      return permissionGrantedResponse();
    }
  };
  function permissionGrantedResponse() {
    return {
      status: _expoModulesCore.PermissionStatus.GRANTED,
      expires: 'never',
      granted: true,
      canAskAgain: true
    };
  }
  function openFileBrowserAsync({
    mediaTypes,
    capture = false,
    allowsMultipleSelection = false,
    base64
  }) {
    const parsedMediaTypes = (0, _utils.parseMediaTypes)(mediaTypes);
    const mediaTypeFormat = createMediaTypeFormat(parsedMediaTypes);
    const input = document.createElement('input');
    input.style.display = 'none';
    input.setAttribute('type', 'file');
    input.setAttribute('accept', mediaTypeFormat);
    input.setAttribute('id', String(Math.random()));
    input.setAttribute('data-testid', 'file-input');
    if (allowsMultipleSelection) {
      input.setAttribute('multiple', 'multiple');
    }
    if (capture) {
      switch (capture) {
        case true:
          input.setAttribute('capture', 'camera');
          break;
        case _ImagePicker.CameraType.front:
          input.setAttribute('capture', 'environment');
          break;
        case _ImagePicker.CameraType.back:
          input.setAttribute('capture', 'user');
      }
    }
    document.body.appendChild(input);
    return new Promise(resolve => {
      input.addEventListener('change', async () => {
        if (input.files?.length) {
          const files = allowsMultipleSelection ? input.files : [input.files[0]];
          const assets = await Promise.all(Array.from(files).map(file => readFile(file, {
            base64
          })));
          resolve({
            canceled: false,
            assets
          });
        } else {
          resolve({
            canceled: true,
            assets: null
          });
        }
        document.body.removeChild(input);
      });
      input.addEventListener('cancel', () => {
        input.dispatchEvent(new Event('change'));
      });
      const event = new MouseEvent('click');
      input.dispatchEvent(event);
    });
  }
  function readFile(targetFile, options) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => {
        reject(new Error(`Failed to read the selected media because the operation failed.`));
      };
      reader.onload = ({
        target
      }) => {
        const uri = target.result;
        const returnRaw = () => resolve({
          uri,
          width: 0,
          height: 0
        });
        const returnMediaData = data => {
          resolve(Object.assign({}, data, options.base64 && {
            base64: uri.substr(uri.indexOf(',') + 1)
          }, {
            file: targetFile
          }));
        };
        if (typeof uri === 'string') {
          if (targetFile.type.startsWith('image/')) {
            const image = new Image();
            image.src = uri;
            image.onload = () => {
              returnMediaData({
                uri,
                width: image.naturalWidth ?? image.width,
                height: image.naturalHeight ?? image.height,
                type: 'image',
                mimeType: targetFile.type,
                fileName: targetFile.name,
                fileSize: targetFile.size
              });
            };
            image.onerror = () => returnRaw();
          } else if (targetFile.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.src = uri;
            video.onloadedmetadata = () => {
              returnMediaData({
                uri,
                width: video.videoWidth,
                height: video.videoHeight,
                type: 'video',
                mimeType: targetFile.type,
                fileName: targetFile.name,
                fileSize: targetFile.size,
                duration: video.duration
              });
            };
            video.onerror = () => returnRaw();
          } else {
            returnRaw();
          }
        } else {
          returnRaw();
        }
      };
      reader.readAsDataURL(targetFile);
    });
  }
  function createMediaTypeFormat(mediaTypes) {
    const filteredMediaTypes = mediaTypes.filter(mediaType => mediaType !== 'livePhotos');
    if (filteredMediaTypes.length === 0) {
      return 'image/*';
    }
    let result = '';
    for (const mediaType of filteredMediaTypes) {
      // Make sure the types don't repeat
      if (!result.includes(MediaTypeInput[mediaType])) {
        result = result.concat(',', MediaTypeInput[mediaType]);
      }
    }
    return result;
  }
},832,[473,833,834],"node_modules\\expo-image-picker\\build\\ExponentImagePicker.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoExportPreset = exports.UIImagePickerPresentationStyle = exports.UIImagePickerPreferredAssetRepresentationMode = exports.UIImagePickerControllerQualityType = exports.MediaTypeOptions = exports.CameraType = void 0;
  // @needsAudit
  /**
   * @deprecated To set media types available in the image picker use an array of [`MediaType`](#mediatype) instead.
   */
  var MediaTypeOptions;
  (function (MediaTypeOptions) {
    /**
     * Images and videos.
     */
    MediaTypeOptions["All"] = "All";
    /**
     * Only videos.
     */
    MediaTypeOptions["Videos"] = "Videos";
    /**
     * Only images.
     */
    MediaTypeOptions["Images"] = "Images";
  })(MediaTypeOptions || (exports.MediaTypeOptions = MediaTypeOptions = {}));
  // @needsAudit
  var VideoExportPreset;
  (function (VideoExportPreset) {
    /**
     * Resolution: __Unchanged__ 
     * Video compression: __None__ 
     * Audio compression: __None__
     */
    VideoExportPreset[VideoExportPreset["Passthrough"] = 0] = "Passthrough";
    /**
     * Resolution: __Depends on the device__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["LowQuality"] = 1] = "LowQuality";
    /**
     * Resolution: __Depends on the device__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["MediumQuality"] = 2] = "MediumQuality";
    /**
     * Resolution: __Depends on the device__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["HighestQuality"] = 3] = "HighestQuality";
    /**
     * Resolution: __640  480__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["H264_640x480"] = 4] = "H264_640x480";
    /**
     * Resolution: __960  540__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["H264_960x540"] = 5] = "H264_960x540";
    /**
     * Resolution: __1280  720__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["H264_1280x720"] = 6] = "H264_1280x720";
    /**
     * Resolution: __1920  1080__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["H264_1920x1080"] = 7] = "H264_1920x1080";
    /**
     * Resolution: __3840  2160__ 
     * Video compression: __H.264__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["H264_3840x2160"] = 8] = "H264_3840x2160";
    /**
     * Resolution: __1920  1080__ 
     * Video compression: __HEVC__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["HEVC_1920x1080"] = 9] = "HEVC_1920x1080";
    /**
     * Resolution: __3840  2160__ 
     * Video compression: __HEVC__ 
     * Audio compression: __AAC__
     */
    VideoExportPreset[VideoExportPreset["HEVC_3840x2160"] = 10] = "HEVC_3840x2160";
  })(VideoExportPreset || (exports.VideoExportPreset = VideoExportPreset = {}));
  // @needsAudit
  var UIImagePickerControllerQualityType;
  (function (UIImagePickerControllerQualityType) {
    /**
     * Highest available resolution.
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["High"] = 0] = "High";
    /**
     * Depends on the device.
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["Medium"] = 1] = "Medium";
    /**
     * Depends on the device.
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["Low"] = 2] = "Low";
    /**
     * 640  480
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["VGA640x480"] = 3] = "VGA640x480";
    /**
     * 1280  720
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["IFrame1280x720"] = 4] = "IFrame1280x720";
    /**
     * 960  540
     */
    UIImagePickerControllerQualityType[UIImagePickerControllerQualityType["IFrame960x540"] = 5] = "IFrame960x540";
  })(UIImagePickerControllerQualityType || (exports.UIImagePickerControllerQualityType = UIImagePickerControllerQualityType = {}));
  /**
   * Picker presentation style. Its values are directly mapped to the [`UIModalPresentationStyle`](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621355-modalpresentationstyle).
   *
   * @platform ios
   */
  var UIImagePickerPresentationStyle;
  (function (UIImagePickerPresentationStyle) {
    /**
     * A presentation style in which the presented picker covers the screen.
     */
    UIImagePickerPresentationStyle["FULL_SCREEN"] = "fullScreen";
    /**
     * A presentation style that partially covers the underlying content.
     */
    UIImagePickerPresentationStyle["PAGE_SHEET"] = "pageSheet";
    /**
     * A presentation style that displays the picker centered in the screen.
     */
    UIImagePickerPresentationStyle["FORM_SHEET"] = "formSheet";
    /**
     * A presentation style where the picker is displayed over the app's content.
     */
    UIImagePickerPresentationStyle["CURRENT_CONTEXT"] = "currentContext";
    /**
     * A presentation style in which the picker view covers the screen.
     */
    UIImagePickerPresentationStyle["OVER_FULL_SCREEN"] = "overFullScreen";
    /**
     * A presentation style where the picker is displayed over the app's content.
     */
    UIImagePickerPresentationStyle["OVER_CURRENT_CONTEXT"] = "overCurrentContext";
    /**
     * A presentation style where the picker is displayed in a popover view.
     */
    UIImagePickerPresentationStyle["POPOVER"] = "popover";
    /**
     * The default presentation style chosen by the system.
     * On older iOS versions, falls back to `WebBrowserPresentationStyle.FullScreen`.
     *
     * @platform ios
     */
    UIImagePickerPresentationStyle["AUTOMATIC"] = "automatic";
  })(UIImagePickerPresentationStyle || (exports.UIImagePickerPresentationStyle = UIImagePickerPresentationStyle = {}));
  /**
   * Picker preferred asset representation mode. Its values are directly mapped to the [`PHPickerConfigurationAssetRepresentationMode`](https://developer.apple.com/documentation/photokit/phpickerconfigurationassetrepresentationmode).
   *
   * @platform ios
   */
  var UIImagePickerPreferredAssetRepresentationMode;
  (function (UIImagePickerPreferredAssetRepresentationMode) {
    /**
     * A mode that indicates that the system chooses the appropriate asset representation.
     */
    UIImagePickerPreferredAssetRepresentationMode["Automatic"] = "automatic";
    /**
     * A mode that uses the most compatible asset representation.
     */
    UIImagePickerPreferredAssetRepresentationMode["Compatible"] = "compatible";
    /**
     * A mode that uses the current representation to avoid transcoding, if possible.
     */
    UIImagePickerPreferredAssetRepresentationMode["Current"] = "current";
  })(UIImagePickerPreferredAssetRepresentationMode || (exports.UIImagePickerPreferredAssetRepresentationMode = UIImagePickerPreferredAssetRepresentationMode = {}));
  var CameraType;
  (function (CameraType) {
    /**
     * Back/rear camera.
     */
    CameraType["back"] = "back";
    /**
     * Front camera
     */
    CameraType["front"] = "front";
  })(CameraType || (exports.CameraType = CameraType = {}));
},833,[],"node_modules\\expo-image-picker\\build\\ImagePicker.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapDeprecatedOptions = mapDeprecatedOptions;
  exports.parseMediaTypes = parseMediaTypes;
  var _ImagePicker = require(_dependencyMap[0], "./ImagePicker.types");
  // @hidden

  function parseMediaTypes(mediaTypes) {
    const mediaTypeOptionsToMediaType = {
      Images: ['images'],
      Videos: ['videos'],
      All: ['images', 'videos']
    };
    if (mediaTypes === _ImagePicker.MediaTypeOptions.Images || mediaTypes === _ImagePicker.MediaTypeOptions.Videos || mediaTypes === _ImagePicker.MediaTypeOptions.All) {
      console.warn('[expo-image-picker] `ImagePicker.MediaTypeOptions` have been deprecated. Use `ImagePicker.MediaType` or an array of `ImagePicker.MediaType` instead.');
      return mediaTypeOptionsToMediaType[mediaTypes];
    }
    // Unlike iOS, Android can't auto-cast to array
    if (typeof mediaTypes === 'string') {
      return [mediaTypes];
    }
    return mediaTypes;
  }
  // We deprecated the MediaTypeOptions in SDK52, we should remove it in future release.
  function mapDeprecatedOptions(options) {
    if (!options.mediaTypes) {
      return options;
    }
    return Object.assign({}, options, {
      mediaTypes: parseMediaTypes(options.mediaTypes ?? [])
    });
  }
},834,[833],"node_modules\\expo-image-picker\\build\\utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AntDesign = _interopRequireDefault(require(_dependencyMap[1], "./build/AntDesign"));
  var _default = exports.default = _AntDesign.default;
},835,[17,836],"node_modules\\@expo\\vector-icons\\AntDesign.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use client";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _createIconSet = _interopRequireDefault(require(_dependencyMap[1], "./createIconSet"));
  var _AntDesign = _interopRequireDefault(require(_dependencyMap[2], "./vendor/react-native-vector-icons/Fonts/AntDesign.ttf"));
  var _AntDesign2 = _interopRequireDefault(require(_dependencyMap[3], "./vendor/react-native-vector-icons/glyphmaps/AntDesign.json"));
  var _default = exports.default = (0, _createIconSet.default)(_AntDesign2.default, 'anticon', _AntDesign.default);
},836,[17,803,837,838],"node_modules\\@expo\\vector-icons\\build\\AntDesign.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fvector-icons%2Fbuild%2Fvendor%2Freact-native-vector-icons%2FFonts/AntDesign.ttf";
},837,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\AntDesign.ttf");
__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {
  module.exports = {
  "stepforward": 58880,
  "stepbackward": 58881,
  "forward": 58882,
  "banckward": 58883,
  "caretright": 58884,
  "caretleft": 58885,
  "caretdown": 58886,
  "caretup": 58887,
  "rightcircle": 58888,
  "leftcircle": 58889,
  "upcircle": 58890,
  "downcircle": 58891,
  "rightcircleo": 58892,
  "leftcircleo": 58893,
  "upcircleo": 58894,
  "downcircleo": 58895,
  "verticleleft": 58896,
  "verticleright": 58897,
  "back": 58898,
  "retweet": 58899,
  "shrink": 58900,
  "arrowsalt": 58901,
  "doubleright": 58903,
  "doubleleft": 58904,
  "arrowdown": 58905,
  "arrowup": 58906,
  "arrowright": 58907,
  "arrowleft": 58908,
  "down": 58909,
  "up": 58910,
  "right": 58911,
  "left": 58912,
  "minussquareo": 58913,
  "minuscircle": 58914,
  "minuscircleo": 58915,
  "minus": 58916,
  "pluscircleo": 58917,
  "pluscircle": 58918,
  "plus": 58919,
  "infocirlce": 58920,
  "infocirlceo": 58921,
  "info": 58922,
  "exclamation": 58923,
  "exclamationcircle": 58924,
  "exclamationcircleo": 58925,
  "closecircle": 58926,
  "closecircleo": 58927,
  "checkcircle": 58928,
  "checkcircleo": 58929,
  "check": 58930,
  "close": 58931,
  "customerservice": 58932,
  "creditcard": 58933,
  "codesquareo": 58934,
  "book": 58935,
  "barschart": 58936,
  "bars": 58937,
  "question": 58938,
  "questioncircle": 58939,
  "questioncircleo": 58940,
  "pause": 58941,
  "pausecircle": 58942,
  "pausecircleo": 58943,
  "clockcircle": 58944,
  "clockcircleo": 58945,
  "swap": 58946,
  "swapleft": 58947,
  "swapright": 58948,
  "plussquareo": 58949,
  "frown": 58950,
  "menufold": 58968,
  "mail": 58969,
  "link": 58971,
  "areachart": 58972,
  "linechart": 58973,
  "home": 58974,
  "laptop": 58975,
  "star": 58976,
  "staro": 58977,
  "filter": 58979,
  "meho": 58982,
  "meh": 58983,
  "shoppingcart": 58984,
  "save": 58985,
  "user": 58986,
  "videocamera": 58987,
  "totop": 58988,
  "team": 58989,
  "sharealt": 58993,
  "setting": 58994,
  "picture": 58996,
  "phone": 58997,
  "paperclip": 58998,
  "notification": 58999,
  "menuunfold": 59001,
  "inbox": 59002,
  "lock": 59003,
  "qrcode": 59004,
  "tags": 59005,
  "tagso": 59006,
  "cloudo": 59007,
  "cloud": 59008,
  "cloudupload": 59009,
  "clouddownload": 59010,
  "clouddownloado": 59011,
  "clouduploado": 59012,
  "enviroment": 59013,
  "enviromento": 59014,
  "eye": 59015,
  "eyeo": 59016,
  "camera": 59017,
  "camerao": 59018,
  "windows": 59019,
  "export2": 59024,
  "export": 59025,
  "circledowno": 59027,
  "circledown": 59028,
  "hdd": 59034,
  "ie": 59035,
  "delete": 59039,
  "enter": 59040,
  "pushpino": 59041,
  "pushpin": 59042,
  "heart": 59043,
  "hearto": 59044,
  "smile-circle": 59047,
  "smileo": 59048,
  "frowno": 59049,
  "calculator": 59050,
  "chrome": 59052,
  "github": 59053,
  "iconfontdesktop": 59060,
  "caretcircleoup": 59061,
  "upload": 59062,
  "download": 59063,
  "piechart": 59064,
  "lock1": 59065,
  "unlock": 59066,
  "windowso": 59068,
  "dotchart": 59069,
  "barchart": 59070,
  "codesquare": 59071,
  "plussquare": 59072,
  "minussquare": 59073,
  "closesquare": 59074,
  "closesquareo": 59075,
  "checksquare": 59076,
  "checksquareo": 59077,
  "fastbackward": 59078,
  "fastforward": 59079,
  "upsquare": 59080,
  "downsquare": 59081,
  "leftsquare": 59082,
  "rightsquare": 59083,
  "rightsquareo": 59084,
  "leftsquareo": 59085,
  "down-square-o": 59086,
  "up-square-o": 59087,
  "play": 59088,
  "playcircleo": 59089,
  "tag": 59090,
  "tago": 59091,
  "addfile": 59664,
  "folder1": 58978,
  "file1": 58980,
  "switcher": 59667,
  "addfolder": 59668,
  "folderopen": 59033,
  "search1": 58992,
  "ellipsis1": 58951,
  "calendar": 59067,
  "filetext1": 59032,
  "copy1": 58952,
  "jpgfile1": 59036,
  "pdffile1": 59059,
  "exclefile1": 59056,
  "pptfile1": 59057,
  "unknowfile1": 59055,
  "wordfile1": 59058,
  "dingding": 59683,
  "dingding-o": 59685,
  "mobile1": 59000,
  "tablet1": 58990,
  "bells": 58958,
  "disconnect": 58959,
  "database": 58960,
  "barcode": 58962,
  "hourglass": 58963,
  "key": 58964,
  "flag": 58965,
  "layout": 58966,
  "printer": 58995,
  "USB": 59095,
  "skin": 59096,
  "tool": 59097,
  "car": 59100,
  "addusergroup": 59101,
  "carryout": 59103,
  "deleteuser": 59104,
  "deleteusergroup": 59105,
  "man": 59106,
  "isv": 59107,
  "gift": 59108,
  "idcard": 59109,
  "medicinebox": 59110,
  "redenvelopes": 59111,
  "rest": 59112,
  "Safety": 59114,
  "wallet": 59115,
  "woman": 59116,
  "adduser": 59117,
  "bank": 59118,
  "Trophy": 59119,
  "loading1": 59054,
  "loading2": 58957,
  "like2": 59037,
  "dislike2": 59038,
  "like1": 58956,
  "dislike1": 58955,
  "bulb1": 58953,
  "rocket1": 59663,
  "select1": 58954,
  "apple1": 59020,
  "apple-o": 59092,
  "android1": 59704,
  "android": 59021,
  "aliwangwang-o1": 59023,
  "aliwangwang": 59022,
  "pay-circle1": 59045,
  "pay-circle-o1": 59046,
  "poweroff": 59093,
  "trademark": 58961,
  "find": 59099,
  "copyright": 59102,
  "sound": 59113,
  "earth": 59121,
  "wifi": 59094,
  "sync": 59098,
  "login": 58967,
  "logout": 58970,
  "reload1": 58902,
  "message1": 59051,
  "shake": 59727,
  "API": 59729,
  "appstore-o": 59029,
  "appstore1": 59030,
  "scan1": 59031,
  "exception1": 58981,
  "contacts": 59120,
  "solution1": 58991,
  "fork": 59122,
  "edit": 59026,
  "form": 59798,
  "warning": 59799,
  "table": 59800,
  "profile": 59801,
  "dashboard": 59802,
  "indent-left": 59814,
  "indent-right": 59815,
  "menu-unfold": 59820,
  "menu-fold": 59821,
  "antdesign": 59826,
  "alipay-square": 59827,
  "codepen-circle": 59828,
  "google": 59829,
  "amazon": 59830,
  "codepen": 59831,
  "facebook-square": 59832,
  "dropbox": 59833,
  "googleplus": 59834,
  "linkedin-square": 59835,
  "medium-monogram": 59836,
  "gitlab": 59837,
  "medium-wordmark": 59838,
  "QQ": 59839,
  "skype": 59840,
  "taobao-square": 59841,
  "alipay-circle": 59842,
  "youtube": 59843,
  "wechat": 59844,
  "twitter": 59845,
  "weibo": 59846,
  "HTML": 59847,
  "taobao-circle": 59123,
  "weibo-circle": 59124,
  "weibo-square": 59125,
  "CodeSandbox": 59860,
  "aliyun": 59892,
  "zhihu": 59139,
  "behance": 59143,
  "dribbble": 59145,
  "dribbble-square": 59146,
  "behance-square": 59144,
  "file-markdown": 59140,
  "instagram": 59147,
  "yuque": 59148,
  "slack": 59141,
  "slack-square": 59142
};
},838,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\glyphmaps\\AntDesign.json");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _FontAwesome = _interopRequireDefault(require(_dependencyMap[1], "./build/FontAwesome6"));
  var _default = exports.default = _FontAwesome.default;
},839,[17,840],"node_modules\\@expo\\vector-icons\\FontAwesome6.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use client";

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.FA6Style = void 0;
  var _createIconSetFromFontAwesome = require(_dependencyMap[1], "./createIconSetFromFontAwesome6");
  var _FontAwesome6Free = _interopRequireDefault(require(_dependencyMap[2], "./vendor/react-native-vector-icons/glyphmaps/FontAwesome6Free.json"));
  var _FontAwesome6Free_meta = _interopRequireDefault(require(_dependencyMap[3], "./vendor/react-native-vector-icons/glyphmaps/FontAwesome6Free_meta.json"));
  const fontMap = {
    Regular: require(_dependencyMap[4], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Regular.ttf"),
    Light: require(_dependencyMap[4], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Regular.ttf"),
    Solid: require(_dependencyMap[5], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Solid.ttf"),
    Brands: require(_dependencyMap[6], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Brands.ttf"),
    Sharp_Regular: require(_dependencyMap[4], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Regular.ttf"),
    Sharp_Light: require(_dependencyMap[4], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Regular.ttf"),
    Sharp_Solid: require(_dependencyMap[5], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Solid.ttf"),
    Duotone: require(_dependencyMap[5], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Solid.ttf"),
    Thin: require(_dependencyMap[4], "./vendor/react-native-vector-icons/Fonts/FontAwesome6_Regular.ttf")
  };
  const FA6Style = exports.FA6Style = {
    regular: 'regular',
    light: 'light',
    solid: 'solid',
    brand: 'brand',
    sharp: 'sharp',
    sharpLight: 'sharpLight',
    sharpSolid: 'sharpSolid',
    duotone: 'duotone',
    thin: 'thin'
  };
  const iconSet = (0, _createIconSetFromFontAwesome.createFA6iconSet)(_FontAwesome6Free.default, _FontAwesome6Free_meta.default, fontMap, false);
  var _default = exports.default = iconSet;
},840,[17,841,843,844,845,846,847],"node_modules\\@expo\\vector-icons\\build\\FontAwesome6.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FA6Style = void 0;
  exports.createFA6iconSet = createFA6iconSet;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Platform"));
  var _createMultiStyleIconSet = _interopRequireDefault(require(_dependencyMap[2], "./createMultiStyleIconSet"));
  const FA6Style = exports.FA6Style = {
    regular: 'regular',
    light: 'light',
    solid: 'solid',
    brand: 'brand',
    sharp: 'sharp',
    sharpLight: 'sharpLight',
    sharpSolid: 'sharpSolid',
    duotone: 'duotone',
    thin: 'thin'
  };
  function createFA6iconSet(glyphMap, metadata = {}, fonts, pro = false) {
    const metadataKeys = Object.keys(metadata);
    const fontFamily = `FontAwesome6${pro ? 'Pro' : 'Free'}`;
    function fallbackFamily(glyph) {
      for (let i = 0; i < metadataKeys.length; i += 1) {
        const family = metadataKeys[i];
        if (metadata[family].indexOf(glyph) !== -1) {
          return family === 'brands' ? 'brand' : family;
        }
      }
      return 'regular';
    }
    function glyphValidator(glyph, style) {
      let family = style === 'brand' ? 'brands' : style;
      family = style === 'sharpSolid' ? 'sharp-solid' : family;
      if (metadataKeys.indexOf(family) === -1) return false;
      return metadata[family].indexOf(glyph) !== -1;
    }
    function createFontAwesomeStyle(style, fontWeight, family = fontFamily) {
      let styleName = style;
      const fontFile = fonts[styleName];
      if (styleName === 'Brands') {
        styleName = 'Regular';
      }
      if (styleName === 'Duotone') {
        styleName = 'Solid';
      }
      styleName = styleName.replace('Sharp_', '');
      return {
        fontFamily: `${family}-${styleName}`,
        fontFile,
        fontStyle: _Platform.default.select({
          ios: {
            fontWeight
          },
          default: {}
        }),
        glyphMap
      };
    }
    const brandIcons = createFontAwesomeStyle('Brands', '400', 'FontAwesome6Brands');
    const lightIcons = createFontAwesomeStyle('Light', '300');
    const regularIcons = createFontAwesomeStyle('Regular', '400');
    const solidIcons = createFontAwesomeStyle('Solid', '900');
    const sharpLightIcons = createFontAwesomeStyle('Sharp_Light', '300', 'FontAwesome6Sharp');
    const sharpIcons = createFontAwesomeStyle('Sharp_Regular', '400', 'FontAwesome6Sharp');
    const sharpSolidIcons = createFontAwesomeStyle('Sharp_Solid', '900', 'FontAwesome6Sharp');
    const duotoneIcons = createFontAwesomeStyle('Duotone', '900', 'FontAwesome6Duotone');
    const thinIcons = createFontAwesomeStyle('Thin', '100');
    const Icon = (0, _createMultiStyleIconSet.default)({
      brand: brandIcons,
      light: lightIcons,
      regular: regularIcons,
      solid: solidIcons,
      sharp: sharpIcons,
      sharpLight: sharpLightIcons,
      sharpSolid: sharpSolidIcons,
      duotone: duotoneIcons,
      thin: thinIcons
    }, {
      defaultStyle: 'regular',
      fallbackFamily,
      glyphValidator
    });
    return Icon;
  }
},841,[17,106,842],"node_modules\\@expo\\vector-icons\\build\\createIconSetFromFontAwesome6.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createMultiStyleIconSet;
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[1], "react-native-css-interop"));
  var _react = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _createIconSet = _interopRequireDefault(require(_dependencyMap[3], "./createIconSet"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function createMultiStyleIconSet(styles, optionsInput = {}) {
    const styleNames = Object.keys(styles);
    if (styleNames.length === 0) {
      throw new Error('You need to add at least one style');
    }
    const options = Object.assign({
      defaultStyle: styleNames[0],
      fallbackFamily: _unused => styleNames[0],
      glyphValidator: (_unused, __unused) => true
    }, optionsInput);
    const iconSets = styleNames.reduce((acc, name) => {
      const style = styles[name];
      acc[name] = (0, _createIconSet.default)(style.glyphMap || {}, style.fontFamily || '', style.fontFile || '', style.fontStyle || {});
      return acc;
    }, {});
    function styleFromProps(props) {
      return Object.keys(props).reduce((result, propName) => styleNames.indexOf(propName) !== -1 && props[propName] === true ? propName : result, options.defaultStyle);
    }
    function getIconSetForProps(props) {
      const {
        name
      } = props;
      const style = styleFromProps(props);
      if (options.glyphValidator(name, style)) return iconSets[style];
      const family = options.fallbackFamily(name);
      if (styleNames.indexOf(family) === -1) {
        return options.defaultStyle;
      }
      return iconSets[family];
    }
    function selectIconClass(iconSet, iconClass) {
      return iconClass.length > 0 ? iconSet[iconClass] : iconSet;
    }
    function reduceProps(props) {
      return Object.keys(props).reduce((acc, prop) => {
        if (styleNames.indexOf(prop) === -1) {
          acc[prop] = props[prop];
        }
        return acc;
      }, {});
    }
    function getStyledIconSet(style, name = '') {
      if (styleNames.indexOf(style) === -1) {
        return iconSets[options.defaultStyle];
      }
      return !name ? iconSets[styleFromProps({
        [style]: true
      })] : getIconSetForProps({
        name,
        [style]: true
      });
    }
    function getFontFamily(style = options.defaultStyle) {
      return getStyledIconSet(style).getFontFamily();
    }
    function getRawGlyphMap(style = options.defaultStyle) {
      return getStyledIconSet(style).getRawGlyphMap();
    }
    function hasIcon(name, style = options.defaultStyle) {
      return options.glyphValidator(name, style);
    }
    function createStyledIconClass(selectClass = '') {
      class IconClass extends _react.PureComponent {
        static defaultProps = styleNames.reduce((acc, name) => {
          acc[name] = false;
          return acc;
        }, {});
        static font = Object.values(styles).reduce((acc, style) => {
          acc[style.fontFamily] = style.fontFile;
          return acc;
        }, {});
        static StyledIconSet = getStyledIconSet;
        static getFontFamily = getFontFamily;
        static getRawGlyphMap = getRawGlyphMap;
        static hasIcon = hasIcon;
        render() {
          const selectedIconSet = getIconSetForProps(this.props);
          const SelectedIconClass = selectIconClass(selectedIconSet, selectClass);
          const props = reduceProps(this.props);
          return _ReactNativeCSSInterop.createInteropElement(SelectedIconClass, props);
        }
      }
      return IconClass;
    }
    const Icon = createStyledIconClass();
    Icon.Button = createStyledIconClass('Button');
    return Icon;
  }
},842,[17,412,3,803],"node_modules\\@expo\\vector-icons\\build\\createMultiStyleIconSet.js");
__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {
  module.exports = {
  "0": 48,
  "1": 49,
  "2": 50,
  "3": 51,
  "4": 52,
  "5": 53,
  "6": 54,
  "7": 55,
  "8": 56,
  "9": 57,
  "fill-drip": 62838,
  "arrows-to-circle": 58557,
  "circle-chevron-right": 61752,
  "chevron-circle-right": 61752,
  "at": 64,
  "trash-can": 62189,
  "trash-alt": 62189,
  "text-height": 61492,
  "user-xmark": 62005,
  "user-times": 62005,
  "stethoscope": 61681,
  "message": 62074,
  "comment-alt": 62074,
  "info": 61737,
  "down-left-and-up-right-to-center": 62498,
  "compress-alt": 62498,
  "explosion": 58601,
  "file-lines": 61788,
  "file-alt": 61788,
  "file-text": 61788,
  "wave-square": 63550,
  "ring": 63243,
  "building-un": 58585,
  "dice-three": 62759,
  "calendar-days": 61555,
  "calendar-alt": 61555,
  "anchor-circle-check": 58538,
  "building-circle-arrow-right": 58577,
  "volleyball": 62559,
  "volleyball-ball": 62559,
  "arrows-up-to-line": 58562,
  "sort-down": 61661,
  "sort-desc": 61661,
  "circle-minus": 61526,
  "minus-circle": 61526,
  "door-open": 62763,
  "right-from-bracket": 62197,
  "sign-out-alt": 62197,
  "atom": 62930,
  "soap": 57454,
  "icons": 63597,
  "heart-music-camera-bolt": 63597,
  "microphone-lines-slash": 62777,
  "microphone-alt-slash": 62777,
  "bridge-circle-check": 58569,
  "pump-medical": 57450,
  "fingerprint": 62839,
  "hand-point-right": 61604,
  "magnifying-glass-location": 63113,
  "search-location": 63113,
  "forward-step": 61521,
  "step-forward": 61521,
  "face-smile-beam": 62904,
  "smile-beam": 62904,
  "flag-checkered": 61726,
  "football": 62542,
  "football-ball": 62542,
  "school-circle-exclamation": 58732,
  "crop": 61733,
  "angles-down": 61699,
  "angle-double-down": 61699,
  "users-rectangle": 58772,
  "people-roof": 58679,
  "people-line": 58676,
  "beer-mug-empty": 61692,
  "beer": 61692,
  "diagram-predecessor": 58487,
  "arrow-up-long": 61814,
  "long-arrow-up": 61814,
  "fire-flame-simple": 62570,
  "burn": 62570,
  "person": 61827,
  "male": 61827,
  "laptop": 61705,
  "file-csv": 63197,
  "menorah": 63094,
  "truck-plane": 58767,
  "record-vinyl": 63705,
  "face-grin-stars": 62855,
  "grin-stars": 62855,
  "bong": 62812,
  "spaghetti-monster-flying": 63099,
  "pastafarianism": 63099,
  "arrow-down-up-across-line": 58543,
  "spoon": 62181,
  "utensil-spoon": 62181,
  "jar-wheat": 58647,
  "envelopes-bulk": 63092,
  "mail-bulk": 63092,
  "file-circle-exclamation": 58603,
  "circle-h": 62590,
  "hospital-symbol": 62590,
  "pager": 63509,
  "address-book": 62137,
  "contact-book": 62137,
  "strikethrough": 61644,
  "k": 75,
  "landmark-flag": 58652,
  "pencil": 62211,
  "pencil-alt": 62211,
  "backward": 61514,
  "caret-right": 61658,
  "comments": 61574,
  "paste": 61674,
  "file-clipboard": 61674,
  "code-pull-request": 57660,
  "clipboard-list": 62573,
  "truck-ramp-box": 62686,
  "truck-loading": 62686,
  "user-check": 62716,
  "vial-virus": 58775,
  "sheet-plastic": 58737,
  "blog": 63361,
  "user-ninja": 62724,
  "person-arrow-up-from-line": 58681,
  "scroll-torah": 63136,
  "torah": 63136,
  "broom-ball": 62552,
  "quidditch": 62552,
  "quidditch-broom-ball": 62552,
  "toggle-off": 61956,
  "box-archive": 61831,
  "archive": 61831,
  "person-drowning": 58693,
  "arrow-down-9-1": 63622,
  "sort-numeric-desc": 63622,
  "sort-numeric-down-alt": 63622,
  "face-grin-tongue-squint": 62858,
  "grin-tongue-squint": 62858,
  "spray-can": 62909,
  "truck-monster": 63035,
  "w": 87,
  "earth-africa": 62844,
  "globe-africa": 62844,
  "rainbow": 63323,
  "circle-notch": 61902,
  "tablet-screen-button": 62458,
  "tablet-alt": 62458,
  "paw": 61872,
  "cloud": 61634,
  "trowel-bricks": 58762,
  "face-flushed": 62841,
  "flushed": 62841,
  "hospital-user": 63501,
  "tent-arrow-left-right": 58751,
  "gavel": 61667,
  "legal": 61667,
  "binoculars": 61925,
  "microphone-slash": 61745,
  "box-tissue": 57435,
  "motorcycle": 61980,
  "bell-concierge": 62818,
  "concierge-bell": 62818,
  "pen-ruler": 62894,
  "pencil-ruler": 62894,
  "people-arrows": 57448,
  "people-arrows-left-right": 57448,
  "mars-and-venus-burst": 58659,
  "square-caret-right": 61778,
  "caret-square-right": 61778,
  "scissors": 61636,
  "cut": 61636,
  "sun-plant-wilt": 58746,
  "toilets-portable": 58756,
  "hockey-puck": 62547,
  "table": 61646,
  "magnifying-glass-arrow-right": 58657,
  "tachograph-digital": 62822,
  "digital-tachograph": 62822,
  "users-slash": 57459,
  "clover": 57657,
  "reply": 62437,
  "mail-reply": 62437,
  "star-and-crescent": 63129,
  "house-fire": 58636,
  "square-minus": 61766,
  "minus-square": 61766,
  "helicopter": 62771,
  "compass": 61774,
  "square-caret-down": 61776,
  "caret-square-down": 61776,
  "file-circle-question": 58607,
  "laptop-code": 62972,
  "swatchbook": 62915,
  "prescription-bottle": 62597,
  "bars": 61641,
  "navicon": 61641,
  "people-group": 58675,
  "hourglass-end": 62035,
  "hourglass-3": 62035,
  "heart-crack": 63401,
  "heart-broken": 63401,
  "square-up-right": 62304,
  "external-link-square-alt": 62304,
  "face-kiss-beam": 62871,
  "kiss-beam": 62871,
  "film": 61448,
  "ruler-horizontal": 62791,
  "people-robbery": 58678,
  "lightbulb": 61675,
  "caret-left": 61657,
  "circle-exclamation": 61546,
  "exclamation-circle": 61546,
  "school-circle-xmark": 58733,
  "arrow-right-from-bracket": 61579,
  "sign-out": 61579,
  "circle-chevron-down": 61754,
  "chevron-circle-down": 61754,
  "unlock-keyhole": 61758,
  "unlock-alt": 61758,
  "cloud-showers-heavy": 63296,
  "headphones-simple": 62863,
  "headphones-alt": 62863,
  "sitemap": 61672,
  "circle-dollar-to-slot": 62649,
  "donate": 62649,
  "memory": 62776,
  "road-spikes": 58728,
  "fire-burner": 58609,
  "flag": 61476,
  "hanukiah": 63206,
  "feather": 62765,
  "volume-low": 61479,
  "volume-down": 61479,
  "comment-slash": 62643,
  "cloud-sun-rain": 63299,
  "compress": 61542,
  "wheat-awn": 58061,
  "wheat-alt": 58061,
  "ankh": 63044,
  "hands-holding-child": 58618,
  "asterisk": 42,
  "square-check": 61770,
  "check-square": 61770,
  "peseta-sign": 57889,
  "heading": 61916,
  "header": 61916,
  "ghost": 63202,
  "list": 61498,
  "list-squares": 61498,
  "square-phone-flip": 63611,
  "phone-square-alt": 63611,
  "cart-plus": 61975,
  "gamepad": 61723,
  "circle-dot": 61842,
  "dot-circle": 61842,
  "face-dizzy": 62823,
  "dizzy": 62823,
  "egg": 63483,
  "house-medical-circle-xmark": 58643,
  "campground": 63163,
  "folder-plus": 63070,
  "futbol": 61923,
  "futbol-ball": 61923,
  "soccer-ball": 61923,
  "paintbrush": 61948,
  "paint-brush": 61948,
  "lock": 61475,
  "gas-pump": 62767,
  "hot-tub-person": 62867,
  "hot-tub": 62867,
  "map-location": 62879,
  "map-marked": 62879,
  "house-flood-water": 58638,
  "tree": 61883,
  "bridge-lock": 58572,
  "sack-dollar": 63517,
  "pen-to-square": 61508,
  "edit": 61508,
  "car-side": 62948,
  "share-nodes": 61920,
  "share-alt": 61920,
  "heart-circle-minus": 58623,
  "hourglass-half": 62034,
  "hourglass-2": 62034,
  "microscope": 62992,
  "sink": 57453,
  "bag-shopping": 62096,
  "shopping-bag": 62096,
  "arrow-down-z-a": 63617,
  "sort-alpha-desc": 63617,
  "sort-alpha-down-alt": 63617,
  "mitten": 63413,
  "person-rays": 58701,
  "users": 61632,
  "eye-slash": 61552,
  "flask-vial": 58611,
  "hand": 62038,
  "hand-paper": 62038,
  "om": 63097,
  "worm": 58777,
  "house-circle-xmark": 58635,
  "plug": 61926,
  "chevron-up": 61559,
  "hand-spock": 62041,
  "stopwatch": 62194,
  "face-kiss": 62870,
  "kiss": 62870,
  "bridge-circle-xmark": 58571,
  "face-grin-tongue": 62857,
  "grin-tongue": 62857,
  "chess-bishop": 62522,
  "face-grin-wink": 62860,
  "grin-wink": 62860,
  "ear-deaf": 62116,
  "deaf": 62116,
  "deafness": 62116,
  "hard-of-hearing": 62116,
  "road-circle-check": 58724,
  "dice-five": 62755,
  "square-rss": 61763,
  "rss-square": 61763,
  "land-mine-on": 58651,
  "i-cursor": 62022,
  "stamp": 62911,
  "stairs": 57993,
  "i": 73,
  "hryvnia-sign": 63218,
  "hryvnia": 63218,
  "pills": 62596,
  "face-grin-wide": 62849,
  "grin-alt": 62849,
  "tooth": 62921,
  "v": 86,
  "bangladeshi-taka-sign": 58086,
  "bicycle": 61958,
  "staff-snake": 58745,
  "rod-asclepius": 58745,
  "rod-snake": 58745,
  "staff-aesculapius": 58745,
  "head-side-cough-slash": 57442,
  "truck-medical": 61689,
  "ambulance": 61689,
  "wheat-awn-circle-exclamation": 58776,
  "snowman": 63440,
  "mortar-pestle": 62887,
  "road-barrier": 58722,
  "school": 62793,
  "igloo": 63406,
  "joint": 62869,
  "angle-right": 61701,
  "horse": 63216,
  "q": 81,
  "g": 71,
  "notes-medical": 62593,
  "temperature-half": 62153,
  "temperature-2": 62153,
  "thermometer-2": 62153,
  "thermometer-half": 62153,
  "dong-sign": 57705,
  "capsules": 62571,
  "poo-storm": 63322,
  "poo-bolt": 63322,
  "face-frown-open": 62842,
  "frown-open": 62842,
  "hand-point-up": 61606,
  "money-bill": 61654,
  "bookmark": 61486,
  "align-justify": 61497,
  "umbrella-beach": 62922,
  "helmet-un": 58627,
  "bullseye": 61760,
  "bacon": 63461,
  "hand-point-down": 61607,
  "arrow-up-from-bracket": 57498,
  "folder": 61563,
  "folder-blank": 61563,
  "file-waveform": 62584,
  "file-medical-alt": 62584,
  "radiation": 63417,
  "chart-simple": 58483,
  "mars-stroke": 61993,
  "vial": 62610,
  "gauge": 63012,
  "dashboard": 63012,
  "gauge-med": 63012,
  "tachometer-alt-average": 63012,
  "wand-magic-sparkles": 58058,
  "magic-wand-sparkles": 58058,
  "e": 69,
  "pen-clip": 62213,
  "pen-alt": 62213,
  "bridge-circle-exclamation": 58570,
  "user": 61447,
  "school-circle-check": 58731,
  "dumpster": 63379,
  "van-shuttle": 62902,
  "shuttle-van": 62902,
  "building-user": 58586,
  "square-caret-left": 61841,
  "caret-square-left": 61841,
  "highlighter": 62865,
  "key": 61572,
  "bullhorn": 61601,
  "globe": 61612,
  "synagogue": 63131,
  "person-half-dress": 58696,
  "road-bridge": 58723,
  "location-arrow": 61732,
  "c": 67,
  "tablet-button": 61706,
  "building-lock": 58582,
  "pizza-slice": 63512,
  "money-bill-wave": 62778,
  "chart-area": 61950,
  "area-chart": 61950,
  "house-flag": 58637,
  "person-circle-minus": 58688,
  "ban": 61534,
  "cancel": 61534,
  "camera-rotate": 57560,
  "spray-can-sparkles": 62928,
  "air-freshener": 62928,
  "star": 61445,
  "repeat": 62307,
  "cross": 63060,
  "box": 62566,
  "venus-mars": 61992,
  "arrow-pointer": 62021,
  "mouse-pointer": 62021,
  "maximize": 62238,
  "expand-arrows-alt": 62238,
  "charging-station": 62951,
  "shapes": 63007,
  "triangle-circle-square": 63007,
  "shuffle": 61556,
  "random": 61556,
  "person-running": 63244,
  "running": 63244,
  "mobile-retro": 58663,
  "grip-lines-vertical": 63397,
  "spider": 63255,
  "hands-bound": 58617,
  "file-invoice-dollar": 62833,
  "plane-circle-exclamation": 58710,
  "x-ray": 62615,
  "spell-check": 63633,
  "slash": 63253,
  "computer-mouse": 63692,
  "mouse": 63692,
  "arrow-right-to-bracket": 61584,
  "sign-in": 61584,
  "shop-slash": 57456,
  "store-alt-slash": 57456,
  "server": 62003,
  "virus-covid-slash": 58537,
  "shop-lock": 58533,
  "hourglass-start": 62033,
  "hourglass-1": 62033,
  "blender-phone": 63158,
  "building-wheat": 58587,
  "person-breastfeeding": 58682,
  "right-to-bracket": 62198,
  "sign-in-alt": 62198,
  "venus": 61985,
  "passport": 62891,
  "thumbtack-slash": 59023,
  "thumb-tack-slash": 59023,
  "heart-pulse": 61982,
  "heartbeat": 61982,
  "people-carry-box": 62670,
  "people-carry": 62670,
  "temperature-high": 63337,
  "microchip": 62171,
  "crown": 62753,
  "weight-hanging": 62925,
  "xmarks-lines": 58778,
  "file-prescription": 62834,
  "weight-scale": 62614,
  "weight": 62614,
  "user-group": 62720,
  "user-friends": 62720,
  "arrow-up-a-z": 61790,
  "sort-alpha-up": 61790,
  "chess-knight": 62529,
  "face-laugh-squint": 62875,
  "laugh-squint": 62875,
  "wheelchair": 61843,
  "circle-arrow-up": 61610,
  "arrow-circle-up": 61610,
  "toggle-on": 61957,
  "person-walking": 62804,
  "walking": 62804,
  "l": 76,
  "fire": 61549,
  "bed-pulse": 62599,
  "procedures": 62599,
  "shuttle-space": 61847,
  "space-shuttle": 61847,
  "face-laugh": 62873,
  "laugh": 62873,
  "folder-open": 61564,
  "heart-circle-plus": 58624,
  "code-fork": 57659,
  "city": 63055,
  "microphone-lines": 62409,
  "microphone-alt": 62409,
  "pepper-hot": 63510,
  "unlock": 61596,
  "colon-sign": 57664,
  "headset": 62864,
  "store-slash": 57457,
  "road-circle-xmark": 58726,
  "user-minus": 62723,
  "mars-stroke-up": 61994,
  "mars-stroke-v": 61994,
  "champagne-glasses": 63391,
  "glass-cheers": 63391,
  "clipboard": 62248,
  "house-circle-exclamation": 58634,
  "file-arrow-up": 62836,
  "file-upload": 62836,
  "wifi": 61931,
  "wifi-3": 61931,
  "wifi-strong": 61931,
  "bath": 62157,
  "bathtub": 62157,
  "underline": 61645,
  "user-pen": 62719,
  "user-edit": 62719,
  "signature": 62903,
  "stroopwafel": 62801,
  "bold": 61490,
  "anchor-lock": 58541,
  "building-ngo": 58583,
  "manat-sign": 57813,
  "not-equal": 62782,
  "border-top-left": 63571,
  "border-style": 63571,
  "map-location-dot": 62880,
  "map-marked-alt": 62880,
  "jedi": 63081,
  "square-poll-vertical": 63105,
  "poll": 63105,
  "mug-hot": 63414,
  "car-battery": 62943,
  "battery-car": 62943,
  "gift": 61547,
  "dice-two": 62760,
  "chess-queen": 62533,
  "glasses": 62768,
  "chess-board": 62524,
  "building-circle-check": 58578,
  "person-chalkboard": 58685,
  "mars-stroke-right": 61995,
  "mars-stroke-h": 61995,
  "hand-back-fist": 62037,
  "hand-rock": 62037,
  "square-caret-up": 61777,
  "caret-square-up": 61777,
  "cloud-showers-water": 58596,
  "chart-bar": 61568,
  "bar-chart": 61568,
  "hands-bubbles": 57438,
  "hands-wash": 57438,
  "less-than-equal": 62775,
  "train": 62008,
  "eye-low-vision": 62120,
  "low-vision": 62120,
  "crow": 62752,
  "sailboat": 58437,
  "window-restore": 62162,
  "square-plus": 61694,
  "plus-square": 61694,
  "torii-gate": 63137,
  "frog": 62766,
  "bucket": 58575,
  "image": 61502,
  "microphone": 61744,
  "cow": 63176,
  "caret-up": 61656,
  "screwdriver": 62794,
  "folder-closed": 57733,
  "house-tsunami": 58645,
  "square-nfi": 58742,
  "arrow-up-from-ground-water": 58549,
  "martini-glass": 62843,
  "glass-martini-alt": 62843,
  "rotate-left": 62186,
  "rotate-back": 62186,
  "rotate-backward": 62186,
  "undo-alt": 62186,
  "table-columns": 61659,
  "columns": 61659,
  "lemon": 61588,
  "head-side-mask": 57443,
  "handshake": 62133,
  "gem": 62373,
  "dolly": 62578,
  "dolly-box": 62578,
  "smoking": 62605,
  "minimize": 63372,
  "compress-arrows-alt": 63372,
  "monument": 62886,
  "snowplow": 63442,
  "angles-right": 61697,
  "angle-double-right": 61697,
  "cannabis": 62815,
  "circle-play": 61764,
  "play-circle": 61764,
  "tablets": 62608,
  "ethernet": 63382,
  "euro-sign": 61779,
  "eur": 61779,
  "euro": 61779,
  "chair": 63168,
  "circle-check": 61528,
  "check-circle": 61528,
  "circle-stop": 62093,
  "stop-circle": 62093,
  "compass-drafting": 62824,
  "drafting-compass": 62824,
  "plate-wheat": 58714,
  "icicles": 63405,
  "person-shelter": 58703,
  "neuter": 61996,
  "id-badge": 62145,
  "marker": 62881,
  "face-laugh-beam": 62874,
  "laugh-beam": 62874,
  "helicopter-symbol": 58626,
  "universal-access": 62106,
  "circle-chevron-up": 61753,
  "chevron-circle-up": 61753,
  "lari-sign": 57800,
  "volcano": 63344,
  "person-walking-dashed-line-arrow-right": 58707,
  "sterling-sign": 61780,
  "gbp": 61780,
  "pound-sign": 61780,
  "viruses": 57462,
  "square-person-confined": 58743,
  "user-tie": 62728,
  "arrow-down-long": 61813,
  "long-arrow-down": 61813,
  "tent-arrow-down-to-line": 58750,
  "certificate": 61603,
  "reply-all": 61730,
  "mail-reply-all": 61730,
  "suitcase": 61682,
  "person-skating": 63429,
  "skating": 63429,
  "filter-circle-dollar": 63074,
  "funnel-dollar": 63074,
  "camera-retro": 61571,
  "circle-arrow-down": 61611,
  "arrow-circle-down": 61611,
  "file-import": 62831,
  "arrow-right-to-file": 62831,
  "square-arrow-up-right": 61772,
  "external-link-square": 61772,
  "box-open": 62622,
  "scroll": 63246,
  "spa": 62907,
  "location-pin-lock": 58655,
  "pause": 61516,
  "hill-avalanche": 58631,
  "temperature-empty": 62155,
  "temperature-0": 62155,
  "thermometer-0": 62155,
  "thermometer-empty": 62155,
  "bomb": 61922,
  "registered": 62045,
  "address-card": 62139,
  "contact-card": 62139,
  "vcard": 62139,
  "scale-unbalanced-flip": 62742,
  "balance-scale-right": 62742,
  "subscript": 61740,
  "diamond-turn-right": 62955,
  "directions": 62955,
  "burst": 58588,
  "house-laptop": 57446,
  "laptop-house": 57446,
  "face-tired": 62920,
  "tired": 62920,
  "money-bills": 57843,
  "smog": 63327,
  "crutch": 63479,
  "cloud-arrow-up": 61678,
  "cloud-upload": 61678,
  "cloud-upload-alt": 61678,
  "palette": 62783,
  "arrows-turn-right": 58560,
  "vest": 57477,
  "ferry": 58602,
  "arrows-down-to-people": 58553,
  "seedling": 62680,
  "sprout": 62680,
  "left-right": 62263,
  "arrows-alt-h": 62263,
  "boxes-packing": 58567,
  "circle-arrow-left": 61608,
  "arrow-circle-left": 61608,
  "group-arrows-rotate": 58614,
  "bowl-food": 58566,
  "candy-cane": 63366,
  "arrow-down-wide-short": 61792,
  "sort-amount-asc": 61792,
  "sort-amount-down": 61792,
  "cloud-bolt": 63340,
  "thunderstorm": 63340,
  "text-slash": 63613,
  "remove-format": 63613,
  "face-smile-wink": 62682,
  "smile-wink": 62682,
  "file-word": 61890,
  "file-powerpoint": 61892,
  "arrows-left-right": 61566,
  "arrows-h": 61566,
  "house-lock": 58640,
  "cloud-arrow-down": 61677,
  "cloud-download": 61677,
  "cloud-download-alt": 61677,
  "children": 58593,
  "chalkboard": 62747,
  "blackboard": 62747,
  "user-large-slash": 62714,
  "user-alt-slash": 62714,
  "envelope-open": 62134,
  "handshake-simple-slash": 57439,
  "handshake-alt-slash": 57439,
  "mattress-pillow": 58661,
  "guarani-sign": 57754,
  "arrows-rotate": 61473,
  "refresh": 61473,
  "sync": 61473,
  "fire-extinguisher": 61748,
  "cruzeiro-sign": 57682,
  "greater-than-equal": 62770,
  "shield-halved": 62445,
  "shield-alt": 62445,
  "book-atlas": 62808,
  "atlas": 62808,
  "virus": 57460,
  "envelope-circle-check": 58600,
  "layer-group": 62973,
  "arrows-to-dot": 58558,
  "archway": 62807,
  "heart-circle-check": 58621,
  "house-chimney-crack": 63217,
  "house-damage": 63217,
  "file-zipper": 61894,
  "file-archive": 61894,
  "square": 61640,
  "martini-glass-empty": 61440,
  "glass-martini": 61440,
  "couch": 62648,
  "cedi-sign": 57567,
  "italic": 61491,
  "table-cells-column-lock": 59000,
  "church": 62749,
  "comments-dollar": 63059,
  "democrat": 63303,
  "z": 90,
  "person-skiing": 63433,
  "skiing": 63433,
  "road-lock": 58727,
  "a": 65,
  "temperature-arrow-down": 57407,
  "temperature-down": 57407,
  "feather-pointed": 62827,
  "feather-alt": 62827,
  "p": 80,
  "snowflake": 62172,
  "newspaper": 61930,
  "rectangle-ad": 63041,
  "ad": 63041,
  "circle-arrow-right": 61609,
  "arrow-circle-right": 61609,
  "filter-circle-xmark": 57723,
  "locust": 58656,
  "sort": 61660,
  "unsorted": 61660,
  "list-ol": 61643,
  "list-1-2": 61643,
  "list-numeric": 61643,
  "person-dress-burst": 58692,
  "money-check-dollar": 62781,
  "money-check-alt": 62781,
  "vector-square": 62923,
  "bread-slice": 63468,
  "language": 61867,
  "face-kiss-wink-heart": 62872,
  "kiss-wink-heart": 62872,
  "filter": 61616,
  "question": 63,
  "file-signature": 62835,
  "up-down-left-right": 61618,
  "arrows-alt": 61618,
  "house-chimney-user": 57445,
  "hand-holding-heart": 62654,
  "puzzle-piece": 61742,
  "money-check": 62780,
  "star-half-stroke": 62912,
  "star-half-alt": 62912,
  "code": 61729,
  "whiskey-glass": 63392,
  "glass-whiskey": 63392,
  "building-circle-exclamation": 58579,
  "magnifying-glass-chart": 58658,
  "arrow-up-right-from-square": 61582,
  "external-link": 61582,
  "cubes-stacked": 58598,
  "won-sign": 61785,
  "krw": 61785,
  "won": 61785,
  "virus-covid": 58536,
  "austral-sign": 57513,
  "f": 70,
  "leaf": 61548,
  "road": 61464,
  "taxi": 61882,
  "cab": 61882,
  "person-circle-plus": 58689,
  "chart-pie": 61952,
  "pie-chart": 61952,
  "bolt-lightning": 57527,
  "sack-xmark": 58730,
  "file-excel": 61891,
  "file-contract": 62828,
  "fish-fins": 58610,
  "building-flag": 58581,
  "face-grin-beam": 62850,
  "grin-beam": 62850,
  "object-ungroup": 62024,
  "poop": 63001,
  "location-pin": 61505,
  "map-marker": 61505,
  "kaaba": 63083,
  "toilet-paper": 63262,
  "helmet-safety": 63495,
  "hard-hat": 63495,
  "hat-hard": 63495,
  "eject": 61522,
  "circle-right": 62298,
  "arrow-alt-circle-right": 62298,
  "plane-circle-check": 58709,
  "face-rolling-eyes": 62885,
  "meh-rolling-eyes": 62885,
  "object-group": 62023,
  "chart-line": 61953,
  "line-chart": 61953,
  "mask-ventilator": 58660,
  "arrow-right": 61537,
  "signs-post": 62071,
  "map-signs": 62071,
  "cash-register": 63368,
  "person-circle-question": 58690,
  "h": 72,
  "tarp": 58747,
  "screwdriver-wrench": 63449,
  "tools": 63449,
  "arrows-to-eye": 58559,
  "plug-circle-bolt": 58715,
  "heart": 61444,
  "mars-and-venus": 61988,
  "house-user": 57776,
  "home-user": 57776,
  "dumpster-fire": 63380,
  "house-crack": 58289,
  "martini-glass-citrus": 62817,
  "cocktail": 62817,
  "face-surprise": 62914,
  "surprise": 62914,
  "bottle-water": 58565,
  "circle-pause": 62091,
  "pause-circle": 62091,
  "toilet-paper-slash": 57458,
  "apple-whole": 62929,
  "apple-alt": 62929,
  "kitchen-set": 58650,
  "r": 82,
  "temperature-quarter": 62154,
  "temperature-1": 62154,
  "thermometer-1": 62154,
  "thermometer-quarter": 62154,
  "cube": 61874,
  "bitcoin-sign": 57524,
  "shield-dog": 58739,
  "solar-panel": 62906,
  "lock-open": 62401,
  "elevator": 57709,
  "money-bill-transfer": 58664,
  "money-bill-trend-up": 58665,
  "house-flood-water-circle-arrow-right": 58639,
  "square-poll-horizontal": 63106,
  "poll-h": 63106,
  "circle": 61713,
  "backward-fast": 61513,
  "fast-backward": 61513,
  "recycle": 61880,
  "user-astronaut": 62715,
  "plane-slash": 57449,
  "trademark": 62044,
  "basketball": 62516,
  "basketball-ball": 62516,
  "satellite-dish": 63424,
  "circle-up": 62299,
  "arrow-alt-circle-up": 62299,
  "mobile-screen-button": 62413,
  "mobile-alt": 62413,
  "volume-high": 61480,
  "volume-up": 61480,
  "users-rays": 58771,
  "wallet": 62805,
  "clipboard-check": 62572,
  "file-audio": 61895,
  "burger": 63493,
  "hamburger": 63493,
  "wrench": 61613,
  "bugs": 58576,
  "rupee-sign": 61782,
  "rupee": 61782,
  "file-image": 61893,
  "circle-question": 61529,
  "question-circle": 61529,
  "plane-departure": 62896,
  "handshake-slash": 57440,
  "book-bookmark": 57531,
  "code-branch": 61734,
  "hat-cowboy": 63680,
  "bridge": 58568,
  "phone-flip": 63609,
  "phone-alt": 63609,
  "truck-front": 58039,
  "cat": 63166,
  "anchor-circle-exclamation": 58539,
  "truck-field": 58765,
  "route": 62679,
  "clipboard-question": 58595,
  "panorama": 57865,
  "comment-medical": 63477,
  "teeth-open": 63023,
  "file-circle-minus": 58605,
  "tags": 61484,
  "wine-glass": 62691,
  "forward-fast": 61520,
  "fast-forward": 61520,
  "face-meh-blank": 62884,
  "meh-blank": 62884,
  "square-parking": 62784,
  "parking": 62784,
  "house-signal": 57362,
  "bars-progress": 63528,
  "tasks-alt": 63528,
  "faucet-drip": 57350,
  "cart-flatbed": 62580,
  "dolly-flatbed": 62580,
  "ban-smoking": 62797,
  "smoking-ban": 62797,
  "terminal": 61728,
  "mobile-button": 61707,
  "house-medical-flag": 58644,
  "basket-shopping": 62097,
  "shopping-basket": 62097,
  "tape": 62683,
  "bus-simple": 62814,
  "bus-alt": 62814,
  "eye": 61550,
  "face-sad-cry": 62899,
  "sad-cry": 62899,
  "audio-description": 62110,
  "person-military-to-person": 58700,
  "file-shield": 58608,
  "user-slash": 62726,
  "pen": 62212,
  "tower-observation": 58758,
  "file-code": 61897,
  "signal": 61458,
  "signal-5": 61458,
  "signal-perfect": 61458,
  "bus": 61959,
  "heart-circle-xmark": 58625,
  "house-chimney": 58287,
  "home-lg": 58287,
  "window-maximize": 62160,
  "face-frown": 61721,
  "frown": 61721,
  "prescription": 62897,
  "shop": 62799,
  "store-alt": 62799,
  "floppy-disk": 61639,
  "save": 61639,
  "vihara": 63143,
  "scale-unbalanced": 62741,
  "balance-scale-left": 62741,
  "sort-up": 61662,
  "sort-asc": 61662,
  "comment-dots": 62637,
  "commenting": 62637,
  "plant-wilt": 58794,
  "diamond": 61977,
  "face-grin-squint": 62853,
  "grin-squint": 62853,
  "hand-holding-dollar": 62656,
  "hand-holding-usd": 62656,
  "bacterium": 57434,
  "hand-pointer": 62042,
  "drum-steelpan": 62826,
  "hand-scissors": 62039,
  "hands-praying": 63108,
  "praying-hands": 63108,
  "arrow-rotate-right": 61470,
  "arrow-right-rotate": 61470,
  "arrow-rotate-forward": 61470,
  "redo": 61470,
  "biohazard": 63360,
  "location-crosshairs": 62977,
  "location": 62977,
  "mars-double": 61991,
  "child-dress": 58780,
  "users-between-lines": 58769,
  "lungs-virus": 57447,
  "face-grin-tears": 62856,
  "grin-tears": 62856,
  "phone": 61589,
  "calendar-xmark": 62067,
  "calendar-times": 62067,
  "child-reaching": 58781,
  "head-side-virus": 57444,
  "user-gear": 62718,
  "user-cog": 62718,
  "arrow-up-1-9": 61795,
  "sort-numeric-up": 61795,
  "door-closed": 62762,
  "shield-virus": 57452,
  "dice-six": 62758,
  "mosquito-net": 58668,
  "bridge-water": 58574,
  "person-booth": 63318,
  "text-width": 61493,
  "hat-wizard": 63208,
  "pen-fancy": 62892,
  "person-digging": 63582,
  "digging": 63582,
  "trash": 61944,
  "gauge-simple": 63017,
  "gauge-simple-med": 63017,
  "tachometer-average": 63017,
  "book-medical": 63462,
  "poo": 62206,
  "quote-right": 61710,
  "quote-right-alt": 61710,
  "shirt": 62803,
  "t-shirt": 62803,
  "tshirt": 62803,
  "cubes": 61875,
  "divide": 62761,
  "tenge-sign": 63447,
  "tenge": 63447,
  "headphones": 61477,
  "hands-holding": 62658,
  "hands-clapping": 57768,
  "republican": 63326,
  "arrow-left": 61536,
  "person-circle-xmark": 58691,
  "ruler": 62789,
  "align-left": 61494,
  "dice-d6": 63185,
  "restroom": 63421,
  "j": 74,
  "users-viewfinder": 58773,
  "file-video": 61896,
  "up-right-from-square": 62301,
  "external-link-alt": 62301,
  "table-cells": 61450,
  "th": 61450,
  "file-pdf": 61889,
  "book-bible": 63047,
  "bible": 63047,
  "o": 79,
  "suitcase-medical": 61690,
  "medkit": 61690,
  "user-secret": 61979,
  "otter": 63232,
  "person-dress": 61826,
  "female": 61826,
  "comment-dollar": 63057,
  "business-time": 63050,
  "briefcase-clock": 63050,
  "table-cells-large": 61449,
  "th-large": 61449,
  "book-tanakh": 63527,
  "tanakh": 63527,
  "phone-volume": 62112,
  "volume-control-phone": 62112,
  "hat-cowboy-side": 63681,
  "clipboard-user": 63475,
  "child": 61870,
  "lira-sign": 61845,
  "satellite": 63423,
  "plane-lock": 58712,
  "tag": 61483,
  "comment": 61557,
  "cake-candles": 61949,
  "birthday-cake": 61949,
  "cake": 61949,
  "envelope": 61664,
  "angles-up": 61698,
  "angle-double-up": 61698,
  "paperclip": 61638,
  "arrow-right-to-city": 58547,
  "ribbon": 62678,
  "lungs": 62980,
  "arrow-up-9-1": 63623,
  "sort-numeric-up-alt": 63623,
  "litecoin-sign": 57811,
  "border-none": 63568,
  "circle-nodes": 58594,
  "parachute-box": 62669,
  "indent": 61500,
  "truck-field-un": 58766,
  "hourglass": 62036,
  "hourglass-empty": 62036,
  "mountain": 63228,
  "user-doctor": 61680,
  "user-md": 61680,
  "circle-info": 61530,
  "info-circle": 61530,
  "cloud-meatball": 63291,
  "camera": 61488,
  "camera-alt": 61488,
  "square-virus": 58744,
  "meteor": 63315,
  "car-on": 58589,
  "sleigh": 63436,
  "arrow-down-1-9": 61794,
  "sort-numeric-asc": 61794,
  "sort-numeric-down": 61794,
  "hand-holding-droplet": 62657,
  "hand-holding-water": 62657,
  "water": 63347,
  "calendar-check": 62068,
  "braille": 62113,
  "prescription-bottle-medical": 62598,
  "prescription-bottle-alt": 62598,
  "landmark": 63087,
  "truck": 61649,
  "crosshairs": 61531,
  "person-cane": 58684,
  "tent": 58749,
  "vest-patches": 57478,
  "check-double": 62816,
  "arrow-down-a-z": 61789,
  "sort-alpha-asc": 61789,
  "sort-alpha-down": 61789,
  "money-bill-wheat": 58666,
  "cookie": 62819,
  "arrow-rotate-left": 61666,
  "arrow-left-rotate": 61666,
  "arrow-rotate-back": 61666,
  "arrow-rotate-backward": 61666,
  "undo": 61666,
  "hard-drive": 61600,
  "hdd": 61600,
  "face-grin-squint-tears": 62854,
  "grin-squint-tears": 62854,
  "dumbbell": 62539,
  "rectangle-list": 61474,
  "list-alt": 61474,
  "tarp-droplet": 58748,
  "house-medical-circle-check": 58641,
  "person-skiing-nordic": 63434,
  "skiing-nordic": 63434,
  "calendar-plus": 62065,
  "plane-arrival": 62895,
  "circle-left": 62297,
  "arrow-alt-circle-left": 62297,
  "train-subway": 62009,
  "subway": 62009,
  "chart-gantt": 57572,
  "indian-rupee-sign": 57788,
  "indian-rupee": 57788,
  "inr": 57788,
  "crop-simple": 62821,
  "crop-alt": 62821,
  "money-bill-1": 62417,
  "money-bill-alt": 62417,
  "left-long": 62218,
  "long-arrow-alt-left": 62218,
  "dna": 62577,
  "virus-slash": 57461,
  "minus": 61544,
  "subtract": 61544,
  "chess": 62521,
  "arrow-left-long": 61815,
  "long-arrow-left": 61815,
  "plug-circle-check": 58716,
  "street-view": 61981,
  "franc-sign": 57743,
  "volume-off": 61478,
  "hands-asl-interpreting": 62115,
  "american-sign-language-interpreting": 62115,
  "asl-interpreting": 62115,
  "hands-american-sign-language-interpreting": 62115,
  "gear": 61459,
  "cog": 61459,
  "droplet-slash": 62919,
  "tint-slash": 62919,
  "mosque": 63096,
  "mosquito": 58667,
  "star-of-david": 63130,
  "person-military-rifle": 58699,
  "cart-shopping": 61562,
  "shopping-cart": 61562,
  "vials": 62611,
  "plug-circle-plus": 58719,
  "place-of-worship": 63103,
  "grip-vertical": 62862,
  "arrow-turn-up": 61768,
  "level-up": 61768,
  "u": 85,
  "square-root-variable": 63128,
  "square-root-alt": 63128,
  "clock": 61463,
  "clock-four": 61463,
  "backward-step": 61512,
  "step-backward": 61512,
  "pallet": 62594,
  "faucet": 57349,
  "baseball-bat-ball": 62514,
  "s": 83,
  "timeline": 58012,
  "keyboard": 61724,
  "caret-down": 61655,
  "house-chimney-medical": 63474,
  "clinic-medical": 63474,
  "temperature-three-quarters": 62152,
  "temperature-3": 62152,
  "thermometer-3": 62152,
  "thermometer-three-quarters": 62152,
  "mobile-screen": 62415,
  "mobile-android-alt": 62415,
  "plane-up": 57901,
  "piggy-bank": 62675,
  "battery-half": 62018,
  "battery-3": 62018,
  "mountain-city": 58670,
  "coins": 62750,
  "khanda": 63085,
  "sliders": 61918,
  "sliders-h": 61918,
  "folder-tree": 63490,
  "network-wired": 63231,
  "map-pin": 62070,
  "hamsa": 63077,
  "cent-sign": 58357,
  "flask": 61635,
  "person-pregnant": 58142,
  "wand-sparkles": 63275,
  "ellipsis-vertical": 61762,
  "ellipsis-v": 61762,
  "ticket": 61765,
  "power-off": 61457,
  "right-long": 62219,
  "long-arrow-alt-right": 62219,
  "flag-usa": 63309,
  "laptop-file": 58653,
  "tty": 61924,
  "teletype": 61924,
  "diagram-next": 58486,
  "person-rifle": 58702,
  "house-medical-circle-exclamation": 58642,
  "closed-captioning": 61962,
  "person-hiking": 63212,
  "hiking": 63212,
  "venus-double": 61990,
  "images": 62210,
  "calculator": 61932,
  "people-pulling": 58677,
  "n": 78,
  "cable-car": 63450,
  "tram": 63450,
  "cloud-rain": 63293,
  "building-circle-xmark": 58580,
  "ship": 61978,
  "arrows-down-to-line": 58552,
  "download": 61465,
  "face-grin": 62848,
  "grin": 62848,
  "delete-left": 62810,
  "backspace": 62810,
  "eye-dropper": 61947,
  "eye-dropper-empty": 61947,
  "eyedropper": 61947,
  "file-circle-check": 58784,
  "forward": 61518,
  "mobile": 62414,
  "mobile-android": 62414,
  "mobile-phone": 62414,
  "face-meh": 61722,
  "meh": 61722,
  "align-center": 61495,
  "book-skull": 63159,
  "book-dead": 63159,
  "id-card": 62146,
  "drivers-license": 62146,
  "outdent": 61499,
  "dedent": 61499,
  "heart-circle-exclamation": 58622,
  "house": 61461,
  "home": 61461,
  "home-alt": 61461,
  "home-lg-alt": 61461,
  "calendar-week": 63364,
  "laptop-medical": 63506,
  "b": 66,
  "file-medical": 62583,
  "dice-one": 62757,
  "kiwi-bird": 62773,
  "arrow-right-arrow-left": 61676,
  "exchange": 61676,
  "rotate-right": 62201,
  "redo-alt": 62201,
  "rotate-forward": 62201,
  "utensils": 62183,
  "cutlery": 62183,
  "arrow-up-wide-short": 61793,
  "sort-amount-up": 61793,
  "mill-sign": 57837,
  "bowl-rice": 58091,
  "skull": 62796,
  "tower-broadcast": 62745,
  "broadcast-tower": 62745,
  "truck-pickup": 63036,
  "up-long": 62220,
  "long-arrow-alt-up": 62220,
  "stop": 61517,
  "code-merge": 62343,
  "upload": 61587,
  "hurricane": 63313,
  "mound": 58669,
  "toilet-portable": 58755,
  "compact-disc": 62751,
  "file-arrow-down": 62829,
  "file-download": 62829,
  "caravan": 63743,
  "shield-cat": 58738,
  "bolt": 61671,
  "zap": 61671,
  "glass-water": 58612,
  "oil-well": 58674,
  "vault": 58053,
  "mars": 61986,
  "toilet": 63448,
  "plane-circle-xmark": 58711,
  "yen-sign": 61783,
  "cny": 61783,
  "jpy": 61783,
  "rmb": 61783,
  "yen": 61783,
  "ruble-sign": 61784,
  "rouble": 61784,
  "rub": 61784,
  "ruble": 61784,
  "sun": 61829,
  "guitar": 63398,
  "face-laugh-wink": 62876,
  "laugh-wink": 62876,
  "horse-head": 63403,
  "bore-hole": 58563,
  "industry": 62069,
  "circle-down": 62296,
  "arrow-alt-circle-down": 62296,
  "arrows-turn-to-dots": 58561,
  "florin-sign": 57732,
  "arrow-down-short-wide": 63620,
  "sort-amount-desc": 63620,
  "sort-amount-down-alt": 63620,
  "less-than": 60,
  "angle-down": 61703,
  "car-tunnel": 58590,
  "head-side-cough": 57441,
  "grip-lines": 63396,
  "thumbs-down": 61797,
  "user-lock": 62722,
  "arrow-right-long": 61816,
  "long-arrow-right": 61816,
  "anchor-circle-xmark": 58540,
  "ellipsis": 61761,
  "ellipsis-h": 61761,
  "chess-pawn": 62531,
  "kit-medical": 62585,
  "first-aid": 62585,
  "person-through-window": 58793,
  "toolbox": 62802,
  "hands-holding-circle": 58619,
  "bug": 61832,
  "credit-card": 61597,
  "credit-card-alt": 61597,
  "car": 61881,
  "automobile": 61881,
  "hand-holding-hand": 58615,
  "book-open-reader": 62938,
  "book-reader": 62938,
  "mountain-sun": 58671,
  "arrows-left-right-to-line": 58554,
  "dice-d20": 63183,
  "truck-droplet": 58764,
  "file-circle-xmark": 58785,
  "temperature-arrow-up": 57408,
  "temperature-up": 57408,
  "medal": 62882,
  "bed": 62006,
  "square-h": 61693,
  "h-square": 61693,
  "podcast": 62158,
  "temperature-full": 62151,
  "temperature-4": 62151,
  "thermometer-4": 62151,
  "thermometer-full": 62151,
  "bell": 61683,
  "superscript": 61739,
  "plug-circle-xmark": 58720,
  "star-of-life": 63009,
  "phone-slash": 62429,
  "paint-roller": 62890,
  "handshake-angle": 62660,
  "hands-helping": 62660,
  "location-dot": 62405,
  "map-marker-alt": 62405,
  "file": 61787,
  "greater-than": 62,
  "person-swimming": 62916,
  "swimmer": 62916,
  "arrow-down": 61539,
  "droplet": 61507,
  "tint": 61507,
  "eraser": 61741,
  "earth-americas": 62845,
  "earth": 62845,
  "earth-america": 62845,
  "globe-americas": 62845,
  "person-burst": 58683,
  "dove": 62650,
  "battery-empty": 62020,
  "battery-0": 62020,
  "socks": 63126,
  "inbox": 61468,
  "section": 58439,
  "gauge-high": 63013,
  "tachometer-alt": 63013,
  "tachometer-alt-fast": 63013,
  "envelope-open-text": 63064,
  "hospital": 61688,
  "hospital-alt": 61688,
  "hospital-wide": 61688,
  "wine-bottle": 63279,
  "chess-rook": 62535,
  "bars-staggered": 62800,
  "reorder": 62800,
  "stream": 62800,
  "dharmachakra": 63061,
  "hotdog": 63503,
  "person-walking-with-cane": 62109,
  "blind": 62109,
  "drum": 62825,
  "ice-cream": 63504,
  "heart-circle-bolt": 58620,
  "fax": 61868,
  "paragraph": 61917,
  "check-to-slot": 63346,
  "vote-yea": 63346,
  "star-half": 61577,
  "boxes-stacked": 62568,
  "boxes": 62568,
  "boxes-alt": 62568,
  "link": 61633,
  "chain": 61633,
  "ear-listen": 62114,
  "assistive-listening-systems": 62114,
  "tree-city": 58759,
  "play": 61515,
  "font": 61489,
  "table-cells-row-lock": 59002,
  "rupiah-sign": 57917,
  "magnifying-glass": 61442,
  "search": 61442,
  "table-tennis-paddle-ball": 62557,
  "ping-pong-paddle-ball": 62557,
  "table-tennis": 62557,
  "person-dots-from-line": 62576,
  "diagnoses": 62576,
  "trash-can-arrow-up": 63530,
  "trash-restore-alt": 63530,
  "naira-sign": 57846,
  "cart-arrow-down": 61976,
  "walkie-talkie": 63727,
  "file-pen": 62236,
  "file-edit": 62236,
  "receipt": 62787,
  "square-pen": 61771,
  "pen-square": 61771,
  "pencil-square": 61771,
  "suitcase-rolling": 62913,
  "person-circle-exclamation": 58687,
  "chevron-down": 61560,
  "battery-full": 62016,
  "battery": 62016,
  "battery-5": 62016,
  "skull-crossbones": 63252,
  "code-compare": 57658,
  "list-ul": 61642,
  "list-dots": 61642,
  "school-lock": 58735,
  "tower-cell": 58757,
  "down-long": 62217,
  "long-arrow-alt-down": 62217,
  "ranking-star": 58721,
  "chess-king": 62527,
  "person-harassing": 58697,
  "brazilian-real-sign": 58476,
  "landmark-dome": 63314,
  "landmark-alt": 63314,
  "arrow-up": 61538,
  "tv": 62060,
  "television": 62060,
  "tv-alt": 62060,
  "shrimp": 58440,
  "list-check": 61614,
  "tasks": 61614,
  "jug-detergent": 58649,
  "circle-user": 62141,
  "user-circle": 62141,
  "user-shield": 62725,
  "wind": 63278,
  "car-burst": 62945,
  "car-crash": 62945,
  "y": 89,
  "person-snowboarding": 63438,
  "snowboarding": 63438,
  "truck-fast": 62603,
  "shipping-fast": 62603,
  "fish": 62840,
  "user-graduate": 62721,
  "circle-half-stroke": 61506,
  "adjust": 61506,
  "clapperboard": 57649,
  "circle-radiation": 63418,
  "radiation-alt": 63418,
  "baseball": 62515,
  "baseball-ball": 62515,
  "jet-fighter-up": 58648,
  "diagram-project": 62786,
  "project-diagram": 62786,
  "copy": 61637,
  "volume-xmark": 63145,
  "volume-mute": 63145,
  "volume-times": 63145,
  "hand-sparkles": 57437,
  "grip": 62861,
  "grip-horizontal": 62861,
  "share-from-square": 61773,
  "share-square": 61773,
  "child-combatant": 58592,
  "child-rifle": 58592,
  "gun": 57755,
  "square-phone": 61592,
  "phone-square": 61592,
  "plus": 43,
  "add": 43,
  "expand": 61541,
  "computer": 58597,
  "xmark": 61453,
  "close": 61453,
  "multiply": 61453,
  "remove": 61453,
  "times": 61453,
  "arrows-up-down-left-right": 61511,
  "arrows": 61511,
  "chalkboard-user": 62748,
  "chalkboard-teacher": 62748,
  "peso-sign": 57890,
  "building-shield": 58584,
  "baby": 63356,
  "users-line": 58770,
  "quote-left": 61709,
  "quote-left-alt": 61709,
  "tractor": 63266,
  "trash-arrow-up": 63529,
  "trash-restore": 63529,
  "arrow-down-up-lock": 58544,
  "lines-leaning": 58654,
  "ruler-combined": 62790,
  "copyright": 61945,
  "equals": 61,
  "blender": 62743,
  "teeth": 63022,
  "shekel-sign": 61963,
  "ils": 61963,
  "shekel": 61963,
  "sheqel": 61963,
  "sheqel-sign": 61963,
  "map": 62073,
  "rocket": 61749,
  "photo-film": 63612,
  "photo-video": 63612,
  "folder-minus": 63069,
  "store": 62798,
  "arrow-trend-up": 57496,
  "plug-circle-minus": 58718,
  "sign-hanging": 62681,
  "sign": 62681,
  "bezier-curve": 62811,
  "bell-slash": 61942,
  "tablet": 62459,
  "tablet-android": 62459,
  "school-flag": 58734,
  "fill": 62837,
  "angle-up": 61702,
  "drumstick-bite": 63191,
  "holly-berry": 63402,
  "chevron-left": 61523,
  "bacteria": 57433,
  "hand-lizard": 62040,
  "notdef": 57854,
  "disease": 63482,
  "briefcase-medical": 62569,
  "genderless": 61997,
  "chevron-right": 61524,
  "retweet": 61561,
  "car-rear": 62942,
  "car-alt": 62942,
  "pump-soap": 57451,
  "video-slash": 62690,
  "battery-quarter": 62019,
  "battery-2": 62019,
  "radio": 63703,
  "baby-carriage": 63357,
  "carriage-baby": 63357,
  "traffic-light": 63031,
  "thermometer": 62609,
  "vr-cardboard": 63273,
  "hand-middle-finger": 63494,
  "percent": 37,
  "percentage": 37,
  "truck-moving": 62687,
  "glass-water-droplet": 58613,
  "display": 57699,
  "face-smile": 61720,
  "smile": 61720,
  "thumbtack": 61581,
  "thumb-tack": 61581,
  "trophy": 61585,
  "person-praying": 63107,
  "pray": 63107,
  "hammer": 63203,
  "hand-peace": 62043,
  "rotate": 62193,
  "sync-alt": 62193,
  "spinner": 61712,
  "robot": 62788,
  "peace": 63100,
  "gears": 61573,
  "cogs": 61573,
  "warehouse": 62612,
  "arrow-up-right-dots": 58551,
  "splotch": 62908,
  "face-grin-hearts": 62852,
  "grin-hearts": 62852,
  "dice-four": 62756,
  "sim-card": 63428,
  "transgender": 61989,
  "transgender-alt": 61989,
  "mercury": 61987,
  "arrow-turn-down": 61769,
  "level-down": 61769,
  "person-falling-burst": 58695,
  "award": 62809,
  "ticket-simple": 62463,
  "ticket-alt": 62463,
  "building": 61869,
  "angles-left": 61696,
  "angle-double-left": 61696,
  "qrcode": 61481,
  "clock-rotate-left": 61914,
  "history": 61914,
  "face-grin-beam-sweat": 62851,
  "grin-beam-sweat": 62851,
  "file-export": 62830,
  "arrow-right-from-file": 62830,
  "shield": 61746,
  "shield-blank": 61746,
  "arrow-up-short-wide": 63621,
  "sort-amount-up-alt": 63621,
  "house-medical": 58290,
  "golf-ball-tee": 62544,
  "golf-ball": 62544,
  "circle-chevron-left": 61751,
  "chevron-circle-left": 61751,
  "house-chimney-window": 57357,
  "pen-nib": 62893,
  "tent-arrow-turn-left": 58752,
  "tents": 58754,
  "wand-magic": 61648,
  "magic": 61648,
  "dog": 63187,
  "carrot": 63367,
  "moon": 61830,
  "wine-glass-empty": 62926,
  "wine-glass-alt": 62926,
  "cheese": 63471,
  "yin-yang": 63149,
  "music": 61441,
  "code-commit": 62342,
  "temperature-low": 63339,
  "person-biking": 63562,
  "biking": 63562,
  "broom": 62746,
  "shield-heart": 58740,
  "gopuram": 63076,
  "earth-oceania": 58491,
  "globe-oceania": 58491,
  "square-xmark": 62163,
  "times-square": 62163,
  "xmark-square": 62163,
  "hashtag": 35,
  "up-right-and-down-left-from-center": 62500,
  "expand-alt": 62500,
  "oil-can": 62995,
  "t": 84,
  "hippo": 63213,
  "chart-column": 57571,
  "infinity": 62772,
  "vial-circle-check": 58774,
  "person-arrow-down-to-line": 58680,
  "voicemail": 63639,
  "fan": 63587,
  "person-walking-luggage": 58708,
  "up-down": 62264,
  "arrows-alt-v": 62264,
  "cloud-moon-rain": 63292,
  "calendar": 61747,
  "trailer": 57409,
  "bahai": 63078,
  "haykal": 63078,
  "sd-card": 63426,
  "dragon": 63189,
  "shoe-prints": 62795,
  "circle-plus": 61525,
  "plus-circle": 61525,
  "face-grin-tongue-wink": 62859,
  "grin-tongue-wink": 62859,
  "hand-holding": 62653,
  "plug-circle-exclamation": 58717,
  "link-slash": 61735,
  "chain-broken": 61735,
  "chain-slash": 61735,
  "unlink": 61735,
  "clone": 62029,
  "person-walking-arrow-loop-left": 58705,
  "arrow-up-z-a": 63618,
  "sort-alpha-up-alt": 63618,
  "fire-flame-curved": 63460,
  "fire-alt": 63460,
  "tornado": 63343,
  "file-circle-plus": 58516,
  "book-quran": 63111,
  "quran": 63111,
  "anchor": 61757,
  "border-all": 63564,
  "face-angry": 62806,
  "angry": 62806,
  "cookie-bite": 62820,
  "arrow-trend-down": 57495,
  "rss": 61598,
  "feed": 61598,
  "draw-polygon": 62958,
  "scale-balanced": 62030,
  "balance-scale": 62030,
  "gauge-simple-high": 63018,
  "tachometer": 63018,
  "tachometer-fast": 63018,
  "shower": 62156,
  "desktop": 62352,
  "desktop-alt": 62352,
  "m": 77,
  "table-list": 61451,
  "th-list": 61451,
  "comment-sms": 63437,
  "sms": 63437,
  "book": 61485,
  "user-plus": 62004,
  "check": 61452,
  "battery-three-quarters": 62017,
  "battery-4": 62017,
  "house-circle-check": 58633,
  "angle-left": 61700,
  "diagram-successor": 58490,
  "truck-arrow-right": 58763,
  "arrows-split-up-and-left": 58556,
  "hand-fist": 63198,
  "fist-raised": 63198,
  "cloud-moon": 63171,
  "briefcase": 61617,
  "person-falling": 58694,
  "image-portrait": 62432,
  "portrait": 62432,
  "user-tag": 62727,
  "rug": 58729,
  "earth-europe": 63394,
  "globe-europe": 63394,
  "cart-flatbed-suitcase": 62877,
  "luggage-cart": 62877,
  "rectangle-xmark": 62480,
  "rectangle-times": 62480,
  "times-rectangle": 62480,
  "window-close": 62480,
  "baht-sign": 57516,
  "book-open": 62744,
  "book-journal-whills": 63082,
  "journal-whills": 63082,
  "handcuffs": 58616,
  "triangle-exclamation": 61553,
  "exclamation-triangle": 61553,
  "warning": 61553,
  "database": 61888,
  "share": 61540,
  "mail-forward": 61540,
  "bottle-droplet": 58564,
  "mask-face": 57815,
  "hill-rockslide": 58632,
  "right-left": 62306,
  "exchange-alt": 62306,
  "paper-plane": 61912,
  "road-circle-exclamation": 58725,
  "dungeon": 63193,
  "align-right": 61496,
  "money-bill-1-wave": 62779,
  "money-bill-wave-alt": 62779,
  "life-ring": 61901,
  "hands": 62119,
  "sign-language": 62119,
  "signing": 62119,
  "calendar-day": 63363,
  "water-ladder": 62917,
  "ladder-water": 62917,
  "swimming-pool": 62917,
  "arrows-up-down": 61565,
  "arrows-v": 61565,
  "face-grimace": 62847,
  "grimace": 62847,
  "wheelchair-move": 58062,
  "wheelchair-alt": 58062,
  "turn-down": 62398,
  "level-down-alt": 62398,
  "person-walking-arrow-right": 58706,
  "square-envelope": 61849,
  "envelope-square": 61849,
  "dice": 62754,
  "bowling-ball": 62518,
  "brain": 62940,
  "bandage": 62562,
  "band-aid": 62562,
  "calendar-minus": 62066,
  "circle-xmark": 61527,
  "times-circle": 61527,
  "xmark-circle": 61527,
  "gifts": 63388,
  "hotel": 62868,
  "earth-asia": 62846,
  "globe-asia": 62846,
  "id-card-clip": 62591,
  "id-card-alt": 62591,
  "magnifying-glass-plus": 61454,
  "search-plus": 61454,
  "thumbs-up": 61796,
  "user-clock": 62717,
  "hand-dots": 62561,
  "allergies": 62561,
  "file-invoice": 62832,
  "window-minimize": 62161,
  "mug-saucer": 61684,
  "coffee": 61684,
  "brush": 62813,
  "mask": 63226,
  "magnifying-glass-minus": 61456,
  "search-minus": 61456,
  "ruler-vertical": 62792,
  "user-large": 62470,
  "user-alt": 62470,
  "train-tram": 58804,
  "user-nurse": 63535,
  "syringe": 62606,
  "cloud-sun": 63172,
  "stopwatch-20": 57455,
  "square-full": 62556,
  "magnet": 61558,
  "jar": 58646,
  "note-sticky": 62025,
  "sticky-note": 62025,
  "bug-slash": 58512,
  "arrow-up-from-water-pump": 58550,
  "bone": 62935,
  "table-cells-row-unlock": 59025,
  "user-injured": 63272,
  "face-sad-tear": 62900,
  "sad-tear": 62900,
  "plane": 61554,
  "tent-arrows-down": 58753,
  "exclamation": 33,
  "arrows-spin": 58555,
  "print": 61487,
  "turkish-lira-sign": 58043,
  "try": 58043,
  "turkish-lira": 58043,
  "dollar-sign": 36,
  "dollar": 36,
  "usd": 36,
  "x": 88,
  "magnifying-glass-dollar": 63112,
  "search-dollar": 63112,
  "users-gear": 62729,
  "users-cog": 62729,
  "person-military-pointing": 58698,
  "building-columns": 61852,
  "bank": 61852,
  "institution": 61852,
  "museum": 61852,
  "university": 61852,
  "umbrella": 61673,
  "trowel": 58761,
  "d": 68,
  "stapler": 58799,
  "masks-theater": 63024,
  "theater-masks": 63024,
  "kip-sign": 57796,
  "hand-point-left": 61605,
  "handshake-simple": 62662,
  "handshake-alt": 62662,
  "jet-fighter": 61691,
  "fighter-jet": 61691,
  "square-share-nodes": 61921,
  "share-alt-square": 61921,
  "barcode": 61482,
  "plus-minus": 58428,
  "video": 61501,
  "video-camera": 61501,
  "graduation-cap": 61853,
  "mortar-board": 61853,
  "hand-holding-medical": 57436,
  "person-circle-check": 58686,
  "turn-up": 62399,
  "level-up-alt": 62399,
  "monero": 62416,
  "hooli": 62503,
  "yelp": 61929,
  "cc-visa": 61936,
  "lastfm": 61954,
  "shopware": 62901,
  "creative-commons-nc": 62696,
  "aws": 62325,
  "redhat": 63420,
  "yoast": 62129,
  "cloudflare": 57469,
  "ups": 63456,
  "pixiv": 58944,
  "wpexplorer": 62174,
  "dyalog": 62361,
  "bity": 62330,
  "stackpath": 63554,
  "buysellads": 61965,
  "first-order": 62128,
  "modx": 62085,
  "guilded": 57470,
  "vnv": 62475,
  "square-js": 62393,
  "js-square": 62393,
  "microsoft": 62410,
  "qq": 61910,
  "orcid": 63698,
  "java": 62692,
  "invision": 63408,
  "creative-commons-pd-alt": 62701,
  "centercode": 62336,
  "glide-g": 62118,
  "drupal": 61865,
  "jxl": 59003,
  "dart-lang": 59027,
  "hire-a-helper": 62384,
  "creative-commons-by": 62695,
  "unity": 57417,
  "whmcs": 62477,
  "rocketchat": 62440,
  "vk": 61833,
  "untappd": 62469,
  "mailchimp": 62878,
  "css3-alt": 62347,
  "square-reddit": 61858,
  "reddit-square": 61858,
  "vimeo-v": 62077,
  "contao": 62061,
  "square-font-awesome": 58797,
  "deskpro": 62351,
  "brave": 58940,
  "sistrix": 62446,
  "square-instagram": 57429,
  "instagram-square": 57429,
  "battle-net": 63541,
  "the-red-yeti": 63133,
  "square-hacker-news": 62383,
  "hacker-news-square": 62383,
  "edge": 62082,
  "threads": 58904,
  "napster": 62418,
  "square-snapchat": 62125,
  "snapchat-square": 62125,
  "google-plus-g": 61653,
  "artstation": 63354,
  "markdown": 62991,
  "sourcetree": 63443,
  "google-plus": 62131,
  "diaspora": 63377,
  "foursquare": 61824,
  "stack-overflow": 61804,
  "github-alt": 61715,
  "phoenix-squadron": 62737,
  "pagelines": 61836,
  "algolia": 62316,
  "red-river": 62435,
  "creative-commons-sa": 62703,
  "safari": 62055,
  "google": 61856,
  "square-font-awesome-stroke": 62300,
  "font-awesome-alt": 62300,
  "atlassian": 63355,
  "linkedin-in": 61665,
  "digital-ocean": 62353,
  "nimblr": 62888,
  "chromecast": 63544,
  "evernote": 63545,
  "hacker-news": 61908,
  "creative-commons-sampling": 62704,
  "adversal": 62314,
  "creative-commons": 62046,
  "watchman-monitoring": 57479,
  "fonticons": 62080,
  "weixin": 61911,
  "shirtsinbulk": 61972,
  "codepen": 61899,
  "git-alt": 63553,
  "lyft": 62403,
  "rev": 62898,
  "windows": 61818,
  "wizards-of-the-coast": 63280,
  "square-viadeo": 62122,
  "viadeo-square": 62122,
  "meetup": 62176,
  "centos": 63369,
  "adn": 61808,
  "cloudsmith": 62340,
  "opensuse": 58923,
  "pied-piper-alt": 61864,
  "square-dribbble": 62359,
  "dribbble-square": 62359,
  "codiepie": 62084,
  "node": 62489,
  "mix": 62411,
  "steam": 61878,
  "cc-apple-pay": 62486,
  "scribd": 62090,
  "debian": 58891,
  "openid": 61851,
  "instalod": 57473,
  "expeditedssl": 62014,
  "sellcast": 62170,
  "square-twitter": 61569,
  "twitter-square": 61569,
  "r-project": 62711,
  "delicious": 61861,
  "freebsd": 62372,
  "vuejs": 62495,
  "accusoft": 62313,
  "ioxhost": 61960,
  "fonticons-fi": 62370,
  "app-store": 62319,
  "cc-mastercard": 61937,
  "itunes-note": 62389,
  "golang": 58383,
  "kickstarter": 62395,
  "square-kickstarter": 62395,
  "grav": 62166,
  "weibo": 61834,
  "uncharted": 57476,
  "firstdraft": 62369,
  "square-youtube": 62513,
  "youtube-square": 62513,
  "wikipedia-w": 62054,
  "wpressr": 62436,
  "rendact": 62436,
  "angellist": 61961,
  "galactic-republic": 62732,
  "nfc-directional": 58672,
  "skype": 61822,
  "joget": 62391,
  "fedora": 63384,
  "stripe-s": 62506,
  "meta": 58523,
  "laravel": 62397,
  "hotjar": 62385,
  "bluetooth-b": 62100,
  "square-letterboxd": 58926,
  "sticker-mule": 62455,
  "creative-commons-zero": 62707,
  "hips": 62546,
  "behance": 61876,
  "reddit": 61857,
  "discord": 62354,
  "chrome": 62056,
  "app-store-ios": 62320,
  "cc-discover": 61938,
  "wpbeginner": 62103,
  "confluence": 63373,
  "shoelace": 58892,
  "mdb": 63690,
  "dochub": 62356,
  "accessible-icon": 62312,
  "ebay": 62708,
  "amazon": 62064,
  "unsplash": 57468,
  "yarn": 63459,
  "square-steam": 61879,
  "steam-square": 61879,
  "500px": 62062,
  "square-vimeo": 61844,
  "vimeo-square": 61844,
  "asymmetrik": 62322,
  "font-awesome": 62132,
  "font-awesome-flag": 62132,
  "font-awesome-logo-full": 62132,
  "gratipay": 61828,
  "apple": 61817,
  "hive": 57471,
  "gitkraken": 62374,
  "keybase": 62709,
  "apple-pay": 62485,
  "padlet": 58528,
  "amazon-pay": 62508,
  "square-github": 61586,
  "github-square": 61586,
  "stumbleupon": 61860,
  "fedex": 63383,
  "phoenix-framework": 62428,
  "shopify": 57431,
  "neos": 62994,
  "square-threads": 58905,
  "hackerrank": 62967,
  "researchgate": 62712,
  "swift": 63713,
  "angular": 62496,
  "speakap": 62451,
  "angrycreative": 62318,
  "y-combinator": 62011,
  "empire": 61905,
  "envira": 62105,
  "google-scholar": 58939,
  "square-gitlab": 58798,
  "gitlab-square": 58798,
  "studiovinari": 62456,
  "pied-piper": 62126,
  "wordpress": 61850,
  "product-hunt": 62088,
  "firefox": 62057,
  "linode": 62136,
  "goodreads": 62376,
  "square-odnoklassniki": 62052,
  "odnoklassniki-square": 62052,
  "jsfiddle": 61900,
  "sith": 62738,
  "themeisle": 62130,
  "page4": 62423,
  "hashnode": 58521,
  "react": 62491,
  "cc-paypal": 61940,
  "squarespace": 62910,
  "cc-stripe": 61941,
  "creative-commons-share": 62706,
  "bitcoin": 62329,
  "keycdn": 62394,
  "opera": 62058,
  "itch-io": 63546,
  "umbraco": 63720,
  "galactic-senate": 62733,
  "ubuntu": 63455,
  "draft2digital": 62358,
  "stripe": 62505,
  "houzz": 62076,
  "gg": 62048,
  "dhl": 63376,
  "square-pinterest": 61651,
  "pinterest-square": 61651,
  "xing": 61800,
  "blackberry": 62331,
  "creative-commons-pd": 62700,
  "playstation": 62431,
  "quinscape": 62553,
  "less": 62493,
  "blogger-b": 62333,
  "opencart": 62013,
  "vine": 61898,
  "signal-messenger": 58979,
  "paypal": 61933,
  "gitlab": 62102,
  "typo3": 62507,
  "reddit-alien": 62081,
  "yahoo": 61854,
  "dailymotion": 57426,
  "affiliatetheme": 62315,
  "pied-piper-pp": 61863,
  "bootstrap": 63542,
  "odnoklassniki": 62051,
  "nfc-symbol": 58673,
  "mintbit": 58927,
  "ethereum": 62510,
  "speaker-deck": 63548,
  "creative-commons-nc-eu": 62697,
  "patreon": 62425,
  "avianex": 62324,
  "ello": 62961,
  "gofore": 62375,
  "bimobject": 62328,
  "brave-reverse": 58941,
  "facebook-f": 62366,
  "square-google-plus": 61652,
  "google-plus-square": 61652,
  "web-awesome": 59010,
  "mandalorian": 62735,
  "first-order-alt": 62730,
  "osi": 62490,
  "google-wallet": 61934,
  "d-and-d-beyond": 63178,
  "periscope": 62426,
  "fulcrum": 62731,
  "cloudscale": 62339,
  "forumbee": 61969,
  "mizuni": 62412,
  "schlix": 62442,
  "square-xing": 61801,
  "xing-square": 61801,
  "bandcamp": 62165,
  "wpforms": 62104,
  "cloudversify": 62341,
  "usps": 63457,
  "megaport": 62883,
  "magento": 62404,
  "spotify": 61884,
  "optin-monster": 62012,
  "fly": 62487,
  "aviato": 62497,
  "itunes": 62388,
  "cuttlefish": 62348,
  "blogger": 62332,
  "flickr": 61806,
  "viber": 62473,
  "soundcloud": 61886,
  "digg": 61862,
  "tencent-weibo": 61909,
  "letterboxd": 58925,
  "symfony": 63549,
  "maxcdn": 61750,
  "etsy": 62167,
  "facebook-messenger": 62367,
  "audible": 62323,
  "think-peaks": 63281,
  "bilibili": 58329,
  "erlang": 62365,
  "x-twitter": 58907,
  "cotton-bureau": 63646,
  "dashcube": 61968,
  "42-group": 57472,
  "innosoft": 57472,
  "stack-exchange": 61837,
  "elementor": 62512,
  "square-pied-piper": 57374,
  "pied-piper-square": 57374,
  "creative-commons-nd": 62699,
  "palfed": 62424,
  "superpowers": 62173,
  "resolving": 62439,
  "xbox": 62482,
  "square-web-awesome-stroke": 59012,
  "searchengin": 62443,
  "tiktok": 57467,
  "square-facebook": 61570,
  "facebook-square": 61570,
  "renren": 61835,
  "linux": 61820,
  "glide": 62117,
  "linkedin": 61580,
  "hubspot": 62386,
  "deploydog": 62350,
  "twitch": 61928,
  "flutter": 59028,
  "ravelry": 62169,
  "mixer": 57430,
  "square-lastfm": 61955,
  "lastfm-square": 61955,
  "vimeo": 62474,
  "mendeley": 63411,
  "uniregistry": 62468,
  "figma": 63385,
  "creative-commons-remix": 62702,
  "cc-amazon-pay": 62509,
  "dropbox": 61803,
  "instagram": 61805,
  "cmplid": 58208,
  "upwork": 58945,
  "facebook": 61594,
  "gripfire": 62380,
  "jedi-order": 62734,
  "uikit": 62467,
  "fort-awesome-alt": 62371,
  "phabricator": 62427,
  "ussunnah": 62471,
  "earlybirds": 62362,
  "trade-federation": 62739,
  "autoprefixer": 62492,
  "whatsapp": 62002,
  "square-upwork": 59004,
  "slideshare": 61927,
  "google-play": 62379,
  "viadeo": 62121,
  "line": 62400,
  "google-drive": 62378,
  "servicestack": 62444,
  "simplybuilt": 61973,
  "bitbucket": 61809,
  "imdb": 62168,
  "deezer": 57463,
  "raspberry-pi": 63419,
  "jira": 63409,
  "docker": 62357,
  "screenpal": 58736,
  "bluetooth": 62099,
  "gitter": 62502,
  "d-and-d": 62349,
  "microblog": 57370,
  "cc-diners-club": 62028,
  "gg-circle": 62049,
  "pied-piper-hat": 62693,
  "kickstarter-k": 62396,
  "yandex": 62483,
  "readme": 62677,
  "html5": 61755,
  "sellsy": 61971,
  "square-web-awesome": 59011,
  "sass": 62494,
  "wirsindhandwerk": 58064,
  "wsh": 58064,
  "buromobelexperte": 62335,
  "salesforce": 63547,
  "octopus-deploy": 57474,
  "medapps": 62406,
  "ns8": 62421,
  "pinterest-p": 62001,
  "apper": 62321,
  "fort-awesome": 62086,
  "waze": 63551,
  "bluesky": 58993,
  "cc-jcb": 62027,
  "snapchat": 62123,
  "snapchat-ghost": 62123,
  "fantasy-flight-games": 63196,
  "rust": 57466,
  "wix": 62927,
  "square-behance": 61877,
  "behance-square": 61877,
  "supple": 62457,
  "webflow": 58972,
  "rebel": 61904,
  "css3": 61756,
  "staylinked": 62453,
  "kaggle": 62970,
  "space-awesome": 58796,
  "deviantart": 61885,
  "cpanel": 62344,
  "goodreads-g": 62377,
  "square-git": 61906,
  "git-square": 61906,
  "square-tumblr": 61812,
  "tumblr-square": 61812,
  "trello": 61825,
  "creative-commons-nc-jp": 62698,
  "get-pocket": 62053,
  "perbyte": 57475,
  "grunt": 62381,
  "weebly": 62924,
  "connectdevelop": 61966,
  "leanpub": 61970,
  "black-tie": 62078,
  "themeco": 62918,
  "python": 62434,
  "android": 61819,
  "bots": 58176,
  "free-code-camp": 62149,
  "hornbill": 62866,
  "js": 62392,
  "ideal": 57363,
  "git": 61907,
  "dev": 63180,
  "sketch": 63430,
  "yandex-international": 62484,
  "cc-amex": 61939,
  "uber": 62466,
  "github": 61595,
  "php": 62551,
  "alipay": 63042,
  "youtube": 61799,
  "skyatlas": 61974,
  "firefox-browser": 57351,
  "replyd": 62438,
  "suse": 63446,
  "jenkins": 62390,
  "twitter": 61593,
  "rockrms": 62441,
  "pinterest": 61650,
  "buffer": 63543,
  "npm": 62420,
  "yammer": 63552,
  "btc": 61786,
  "dribbble": 61821,
  "stumbleupon-circle": 61859,
  "internet-explorer": 62059,
  "stubber": 58823,
  "telegram": 62150,
  "telegram-plane": 62150,
  "old-republic": 62736,
  "odysee": 58822,
  "square-whatsapp": 62476,
  "whatsapp-square": 62476,
  "node-js": 62419,
  "edge-legacy": 57464,
  "slack": 61848,
  "slack-hash": 61848,
  "medrt": 62408,
  "usb": 62087,
  "tumblr": 61811,
  "vaadin": 62472,
  "quora": 62148,
  "square-x-twitter": 58906,
  "reacteurope": 63325,
  "medium": 62010,
  "medium-m": 62010,
  "amilia": 62317,
  "mixcloud": 62089,
  "flipboard": 62541,
  "viacoin": 62007,
  "critical-role": 63177,
  "sitrox": 58442,
  "discourse": 62355,
  "joomla": 61866,
  "mastodon": 62710,
  "airbnb": 63540,
  "wolf-pack-battalion": 62740,
  "buy-n-large": 63654,
  "gulp": 62382,
  "creative-commons-sampling-plus": 62705,
  "strava": 62504,
  "ember": 62499,
  "canadian-maple-leaf": 63365,
  "teamspeak": 62713,
  "pushed": 62433,
  "wordpress-simple": 62481,
  "nutritionix": 62422,
  "wodu": 57480,
  "google-pay": 57465,
  "intercom": 63407,
  "zhihu": 63039,
  "korvue": 62511,
  "pix": 58426,
  "steam-symbol": 62454
};
},843,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\glyphmaps\\FontAwesome6Free.json");
__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {
  module.exports = {
  "brands": [
    "42-group",
    "500px",
    "accessible-icon",
    "accusoft",
    "adn",
    "adversal",
    "affiliatetheme",
    "airbnb",
    "algolia",
    "alipay",
    "amazon-pay",
    "amazon",
    "amilia",
    "android",
    "angellist",
    "angrycreative",
    "angular",
    "app-store-ios",
    "app-store",
    "apper",
    "apple-pay",
    "apple",
    "artstation",
    "asymmetrik",
    "atlassian",
    "audible",
    "autoprefixer",
    "avianex",
    "aviato",
    "aws",
    "bandcamp",
    "battle-net",
    "behance",
    "bilibili",
    "bimobject",
    "bitbucket",
    "bitcoin",
    "bity",
    "black-tie",
    "blackberry",
    "blogger-b",
    "blogger",
    "bluesky",
    "bluetooth-b",
    "bluetooth",
    "bootstrap",
    "bots",
    "brave-reverse",
    "brave",
    "btc",
    "buffer",
    "buromobelexperte",
    "buy-n-large",
    "buysellads",
    "canadian-maple-leaf",
    "cc-amazon-pay",
    "cc-amex",
    "cc-apple-pay",
    "cc-diners-club",
    "cc-discover",
    "cc-jcb",
    "cc-mastercard",
    "cc-paypal",
    "cc-stripe",
    "cc-visa",
    "centercode",
    "centos",
    "chrome",
    "chromecast",
    "cloudflare",
    "cloudscale",
    "cloudsmith",
    "cloudversify",
    "cmplid",
    "codepen",
    "codiepie",
    "confluence",
    "connectdevelop",
    "contao",
    "cotton-bureau",
    "cpanel",
    "creative-commons-by",
    "creative-commons-nc-eu",
    "creative-commons-nc-jp",
    "creative-commons-nc",
    "creative-commons-nd",
    "creative-commons-pd-alt",
    "creative-commons-pd",
    "creative-commons-remix",
    "creative-commons-sa",
    "creative-commons-sampling-plus",
    "creative-commons-sampling",
    "creative-commons-share",
    "creative-commons-zero",
    "creative-commons",
    "critical-role",
    "css3-alt",
    "css3",
    "cuttlefish",
    "d-and-d-beyond",
    "d-and-d",
    "dailymotion",
    "dart-lang",
    "dashcube",
    "debian",
    "deezer",
    "delicious",
    "deploydog",
    "deskpro",
    "dev",
    "deviantart",
    "dhl",
    "diaspora",
    "digg",
    "digital-ocean",
    "discord",
    "discourse",
    "dochub",
    "docker",
    "draft2digital",
    "dribbble",
    "dropbox",
    "drupal",
    "dyalog",
    "earlybirds",
    "ebay",
    "edge-legacy",
    "edge",
    "elementor",
    "ello",
    "ember",
    "empire",
    "envira",
    "erlang",
    "ethereum",
    "etsy",
    "evernote",
    "expeditedssl",
    "facebook-f",
    "facebook-messenger",
    "facebook",
    "fantasy-flight-games",
    "fedex",
    "fedora",
    "figma",
    "firefox-browser",
    "firefox",
    "first-order-alt",
    "first-order",
    "firstdraft",
    "flickr",
    "flipboard",
    "flutter",
    "fly",
    "font-awesome",
    "fonticons-fi",
    "fonticons",
    "fort-awesome-alt",
    "fort-awesome",
    "forumbee",
    "foursquare",
    "free-code-camp",
    "freebsd",
    "fulcrum",
    "galactic-republic",
    "galactic-senate",
    "get-pocket",
    "gg-circle",
    "gg",
    "git-alt",
    "git",
    "github-alt",
    "github",
    "gitkraken",
    "gitlab",
    "gitter",
    "glide-g",
    "glide",
    "gofore",
    "golang",
    "goodreads-g",
    "goodreads",
    "google-drive",
    "google-pay",
    "google-play",
    "google-plus-g",
    "google-plus",
    "google-scholar",
    "google-wallet",
    "google",
    "gratipay",
    "grav",
    "gripfire",
    "grunt",
    "guilded",
    "gulp",
    "hacker-news",
    "hackerrank",
    "hashnode",
    "hips",
    "hire-a-helper",
    "hive",
    "hooli",
    "hornbill",
    "hotjar",
    "houzz",
    "html5",
    "hubspot",
    "ideal",
    "imdb",
    "instagram",
    "instalod",
    "intercom",
    "internet-explorer",
    "invision",
    "ioxhost",
    "itch-io",
    "itunes-note",
    "itunes",
    "java",
    "jedi-order",
    "jenkins",
    "jira",
    "joget",
    "joomla",
    "js",
    "jsfiddle",
    "jxl",
    "kaggle",
    "keybase",
    "keycdn",
    "kickstarter-k",
    "kickstarter",
    "korvue",
    "laravel",
    "lastfm",
    "leanpub",
    "less",
    "letterboxd",
    "line",
    "linkedin-in",
    "linkedin",
    "linode",
    "linux",
    "lyft",
    "magento",
    "mailchimp",
    "mandalorian",
    "markdown",
    "mastodon",
    "maxcdn",
    "mdb",
    "medapps",
    "medium",
    "medrt",
    "meetup",
    "megaport",
    "mendeley",
    "meta",
    "microblog",
    "microsoft",
    "mintbit",
    "mix",
    "mixcloud",
    "mixer",
    "mizuni",
    "modx",
    "monero",
    "napster",
    "neos",
    "nfc-directional",
    "nfc-symbol",
    "nimblr",
    "node-js",
    "node",
    "npm",
    "ns8",
    "nutritionix",
    "octopus-deploy",
    "odnoklassniki",
    "odysee",
    "old-republic",
    "opencart",
    "openid",
    "opensuse",
    "opera",
    "optin-monster",
    "orcid",
    "osi",
    "padlet",
    "page4",
    "pagelines",
    "palfed",
    "patreon",
    "paypal",
    "perbyte",
    "periscope",
    "phabricator",
    "phoenix-framework",
    "phoenix-squadron",
    "php",
    "pied-piper-alt",
    "pied-piper-hat",
    "pied-piper-pp",
    "pied-piper",
    "pinterest-p",
    "pinterest",
    "pix",
    "pixiv",
    "playstation",
    "product-hunt",
    "pushed",
    "python",
    "qq",
    "quinscape",
    "quora",
    "r-project",
    "raspberry-pi",
    "ravelry",
    "react",
    "reacteurope",
    "readme",
    "rebel",
    "red-river",
    "reddit-alien",
    "reddit",
    "redhat",
    "renren",
    "replyd",
    "researchgate",
    "resolving",
    "rev",
    "rocketchat",
    "rockrms",
    "rust",
    "safari",
    "salesforce",
    "sass",
    "schlix",
    "screenpal",
    "scribd",
    "searchengin",
    "sellcast",
    "sellsy",
    "servicestack",
    "shirtsinbulk",
    "shoelace",
    "shopify",
    "shopware",
    "signal-messenger",
    "simplybuilt",
    "sistrix",
    "sith",
    "sitrox",
    "sketch",
    "skyatlas",
    "skype",
    "slack",
    "slideshare",
    "snapchat",
    "soundcloud",
    "sourcetree",
    "space-awesome",
    "speakap",
    "speaker-deck",
    "spotify",
    "square-behance",
    "square-dribbble",
    "square-facebook",
    "square-font-awesome-stroke",
    "square-font-awesome",
    "square-git",
    "square-github",
    "square-gitlab",
    "square-google-plus",
    "square-hacker-news",
    "square-instagram",
    "square-js",
    "square-lastfm",
    "square-letterboxd",
    "square-odnoklassniki",
    "square-pied-piper",
    "square-pinterest",
    "square-reddit",
    "square-snapchat",
    "square-steam",
    "square-threads",
    "square-tumblr",
    "square-twitter",
    "square-upwork",
    "square-viadeo",
    "square-vimeo",
    "square-web-awesome-stroke",
    "square-web-awesome",
    "square-whatsapp",
    "square-x-twitter",
    "square-xing",
    "square-youtube",
    "squarespace",
    "stack-exchange",
    "stack-overflow",
    "stackpath",
    "staylinked",
    "steam-symbol",
    "steam",
    "sticker-mule",
    "strava",
    "stripe-s",
    "stripe",
    "stubber",
    "studiovinari",
    "stumbleupon-circle",
    "stumbleupon",
    "superpowers",
    "supple",
    "suse",
    "swift",
    "symfony",
    "teamspeak",
    "telegram",
    "tencent-weibo",
    "the-red-yeti",
    "themeco",
    "themeisle",
    "think-peaks",
    "threads",
    "tiktok",
    "trade-federation",
    "trello",
    "tumblr",
    "twitch",
    "twitter",
    "typo3",
    "uber",
    "ubuntu",
    "uikit",
    "umbraco",
    "uncharted",
    "uniregistry",
    "unity",
    "unsplash",
    "untappd",
    "ups",
    "upwork",
    "usb",
    "usps",
    "ussunnah",
    "vaadin",
    "viacoin",
    "viadeo",
    "viber",
    "vimeo-v",
    "vimeo",
    "vine",
    "vk",
    "vnv",
    "vuejs",
    "watchman-monitoring",
    "waze",
    "web-awesome",
    "webflow",
    "weebly",
    "weibo",
    "weixin",
    "whatsapp",
    "whmcs",
    "wikipedia-w",
    "windows",
    "wirsindhandwerk",
    "wix",
    "wizards-of-the-coast",
    "wodu",
    "wolf-pack-battalion",
    "wordpress-simple",
    "wordpress",
    "wpbeginner",
    "wpexplorer",
    "wpforms",
    "wpressr",
    "x-twitter",
    "xbox",
    "xing",
    "y-combinator",
    "yahoo",
    "yammer",
    "yandex-international",
    "yandex",
    "yarn",
    "yelp",
    "yoast",
    "youtube",
    "zhihu"
  ],
  "regular": [
    "address-book",
    "address-card",
    "bell-slash",
    "bell",
    "bookmark",
    "building",
    "calendar-check",
    "calendar-days",
    "calendar-minus",
    "calendar-plus",
    "calendar-xmark",
    "calendar",
    "chart-bar",
    "chess-bishop",
    "chess-king",
    "chess-knight",
    "chess-pawn",
    "chess-queen",
    "chess-rook",
    "circle-check",
    "circle-dot",
    "circle-down",
    "circle-left",
    "circle-pause",
    "circle-play",
    "circle-question",
    "circle-right",
    "circle-stop",
    "circle-up",
    "circle-user",
    "circle-xmark",
    "circle",
    "clipboard",
    "clock",
    "clone",
    "closed-captioning",
    "comment-dots",
    "comment",
    "comments",
    "compass",
    "copy",
    "copyright",
    "credit-card",
    "envelope-open",
    "envelope",
    "eye-slash",
    "eye",
    "face-angry",
    "face-dizzy",
    "face-flushed",
    "face-frown-open",
    "face-frown",
    "face-grimace",
    "face-grin-beam-sweat",
    "face-grin-beam",
    "face-grin-hearts",
    "face-grin-squint-tears",
    "face-grin-squint",
    "face-grin-stars",
    "face-grin-tears",
    "face-grin-tongue-squint",
    "face-grin-tongue-wink",
    "face-grin-tongue",
    "face-grin-wide",
    "face-grin-wink",
    "face-grin",
    "face-kiss-beam",
    "face-kiss-wink-heart",
    "face-kiss",
    "face-laugh-beam",
    "face-laugh-squint",
    "face-laugh-wink",
    "face-laugh",
    "face-meh-blank",
    "face-meh",
    "face-rolling-eyes",
    "face-sad-cry",
    "face-sad-tear",
    "face-smile-beam",
    "face-smile-wink",
    "face-smile",
    "face-surprise",
    "face-tired",
    "file-audio",
    "file-code",
    "file-excel",
    "file-image",
    "file-lines",
    "file-pdf",
    "file-powerpoint",
    "file-video",
    "file-word",
    "file-zipper",
    "file",
    "flag",
    "floppy-disk",
    "folder-closed",
    "folder-open",
    "folder",
    "font-awesome",
    "futbol",
    "gem",
    "hand-back-fist",
    "hand-lizard",
    "hand-peace",
    "hand-point-down",
    "hand-point-left",
    "hand-point-right",
    "hand-point-up",
    "hand-pointer",
    "hand-scissors",
    "hand-spock",
    "hand",
    "handshake",
    "hard-drive",
    "heart",
    "hospital",
    "hourglass-half",
    "hourglass",
    "id-badge",
    "id-card",
    "image",
    "images",
    "keyboard",
    "lemon",
    "life-ring",
    "lightbulb",
    "map",
    "message",
    "money-bill-1",
    "moon",
    "newspaper",
    "note-sticky",
    "object-group",
    "object-ungroup",
    "paper-plane",
    "paste",
    "pen-to-square",
    "rectangle-list",
    "rectangle-xmark",
    "registered",
    "share-from-square",
    "snowflake",
    "square-caret-down",
    "square-caret-left",
    "square-caret-right",
    "square-caret-up",
    "square-check",
    "square-full",
    "square-minus",
    "square-plus",
    "square",
    "star-half-stroke",
    "star-half",
    "star",
    "sun",
    "thumbs-down",
    "thumbs-up",
    "trash-can",
    "user",
    "window-maximize",
    "window-minimize",
    "window-restore"
  ],
  "solid": [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "address-book",
    "address-card",
    "align-center",
    "align-justify",
    "align-left",
    "align-right",
    "anchor-circle-check",
    "anchor-circle-exclamation",
    "anchor-circle-xmark",
    "anchor-lock",
    "anchor",
    "angle-down",
    "angle-left",
    "angle-right",
    "angle-up",
    "angles-down",
    "angles-left",
    "angles-right",
    "angles-up",
    "ankh",
    "apple-whole",
    "archway",
    "arrow-down-1-9",
    "arrow-down-9-1",
    "arrow-down-a-z",
    "arrow-down-long",
    "arrow-down-short-wide",
    "arrow-down-up-across-line",
    "arrow-down-up-lock",
    "arrow-down-wide-short",
    "arrow-down-z-a",
    "arrow-down",
    "arrow-left-long",
    "arrow-left",
    "arrow-pointer",
    "arrow-right-arrow-left",
    "arrow-right-from-bracket",
    "arrow-right-long",
    "arrow-right-to-bracket",
    "arrow-right-to-city",
    "arrow-right",
    "arrow-rotate-left",
    "arrow-rotate-right",
    "arrow-trend-down",
    "arrow-trend-up",
    "arrow-turn-down",
    "arrow-turn-up",
    "arrow-up-1-9",
    "arrow-up-9-1",
    "arrow-up-a-z",
    "arrow-up-from-bracket",
    "arrow-up-from-ground-water",
    "arrow-up-from-water-pump",
    "arrow-up-long",
    "arrow-up-right-dots",
    "arrow-up-right-from-square",
    "arrow-up-short-wide",
    "arrow-up-wide-short",
    "arrow-up-z-a",
    "arrow-up",
    "arrows-down-to-line",
    "arrows-down-to-people",
    "arrows-left-right-to-line",
    "arrows-left-right",
    "arrows-rotate",
    "arrows-spin",
    "arrows-split-up-and-left",
    "arrows-to-circle",
    "arrows-to-dot",
    "arrows-to-eye",
    "arrows-turn-right",
    "arrows-turn-to-dots",
    "arrows-up-down-left-right",
    "arrows-up-down",
    "arrows-up-to-line",
    "asterisk",
    "at",
    "atom",
    "audio-description",
    "austral-sign",
    "award",
    "b",
    "baby-carriage",
    "baby",
    "backward-fast",
    "backward-step",
    "backward",
    "bacon",
    "bacteria",
    "bacterium",
    "bag-shopping",
    "bahai",
    "baht-sign",
    "ban-smoking",
    "ban",
    "bandage",
    "bangladeshi-taka-sign",
    "barcode",
    "bars-progress",
    "bars-staggered",
    "bars",
    "baseball-bat-ball",
    "baseball",
    "basket-shopping",
    "basketball",
    "bath",
    "battery-empty",
    "battery-full",
    "battery-half",
    "battery-quarter",
    "battery-three-quarters",
    "bed-pulse",
    "bed",
    "beer-mug-empty",
    "bell-concierge",
    "bell-slash",
    "bell",
    "bezier-curve",
    "bicycle",
    "binoculars",
    "biohazard",
    "bitcoin-sign",
    "blender-phone",
    "blender",
    "blog",
    "bold",
    "bolt-lightning",
    "bolt",
    "bomb",
    "bone",
    "bong",
    "book-atlas",
    "book-bible",
    "book-bookmark",
    "book-journal-whills",
    "book-medical",
    "book-open-reader",
    "book-open",
    "book-quran",
    "book-skull",
    "book-tanakh",
    "book",
    "bookmark",
    "border-all",
    "border-none",
    "border-top-left",
    "bore-hole",
    "bottle-droplet",
    "bottle-water",
    "bowl-food",
    "bowl-rice",
    "bowling-ball",
    "box-archive",
    "box-open",
    "box-tissue",
    "box",
    "boxes-packing",
    "boxes-stacked",
    "braille",
    "brain",
    "brazilian-real-sign",
    "bread-slice",
    "bridge-circle-check",
    "bridge-circle-exclamation",
    "bridge-circle-xmark",
    "bridge-lock",
    "bridge-water",
    "bridge",
    "briefcase-medical",
    "briefcase",
    "broom-ball",
    "broom",
    "brush",
    "bucket",
    "bug-slash",
    "bug",
    "bugs",
    "building-circle-arrow-right",
    "building-circle-check",
    "building-circle-exclamation",
    "building-circle-xmark",
    "building-columns",
    "building-flag",
    "building-lock",
    "building-ngo",
    "building-shield",
    "building-un",
    "building-user",
    "building-wheat",
    "building",
    "bullhorn",
    "bullseye",
    "burger",
    "burst",
    "bus-simple",
    "bus",
    "business-time",
    "c",
    "cable-car",
    "cake-candles",
    "calculator",
    "calendar-check",
    "calendar-day",
    "calendar-days",
    "calendar-minus",
    "calendar-plus",
    "calendar-week",
    "calendar-xmark",
    "calendar",
    "camera-retro",
    "camera-rotate",
    "camera",
    "campground",
    "candy-cane",
    "cannabis",
    "capsules",
    "car-battery",
    "car-burst",
    "car-on",
    "car-rear",
    "car-side",
    "car-tunnel",
    "car",
    "caravan",
    "caret-down",
    "caret-left",
    "caret-right",
    "caret-up",
    "carrot",
    "cart-arrow-down",
    "cart-flatbed-suitcase",
    "cart-flatbed",
    "cart-plus",
    "cart-shopping",
    "cash-register",
    "cat",
    "cedi-sign",
    "cent-sign",
    "certificate",
    "chair",
    "chalkboard-user",
    "chalkboard",
    "champagne-glasses",
    "charging-station",
    "chart-area",
    "chart-bar",
    "chart-column",
    "chart-gantt",
    "chart-line",
    "chart-pie",
    "chart-simple",
    "check-double",
    "check-to-slot",
    "check",
    "cheese",
    "chess-bishop",
    "chess-board",
    "chess-king",
    "chess-knight",
    "chess-pawn",
    "chess-queen",
    "chess-rook",
    "chess",
    "chevron-down",
    "chevron-left",
    "chevron-right",
    "chevron-up",
    "child-combatant",
    "child-dress",
    "child-reaching",
    "child",
    "children",
    "church",
    "circle-arrow-down",
    "circle-arrow-left",
    "circle-arrow-right",
    "circle-arrow-up",
    "circle-check",
    "circle-chevron-down",
    "circle-chevron-left",
    "circle-chevron-right",
    "circle-chevron-up",
    "circle-dollar-to-slot",
    "circle-dot",
    "circle-down",
    "circle-exclamation",
    "circle-h",
    "circle-half-stroke",
    "circle-info",
    "circle-left",
    "circle-minus",
    "circle-nodes",
    "circle-notch",
    "circle-pause",
    "circle-play",
    "circle-plus",
    "circle-question",
    "circle-radiation",
    "circle-right",
    "circle-stop",
    "circle-up",
    "circle-user",
    "circle-xmark",
    "circle",
    "city",
    "clapperboard",
    "clipboard-check",
    "clipboard-list",
    "clipboard-question",
    "clipboard-user",
    "clipboard",
    "clock-rotate-left",
    "clock",
    "clone",
    "closed-captioning",
    "cloud-arrow-down",
    "cloud-arrow-up",
    "cloud-bolt",
    "cloud-meatball",
    "cloud-moon-rain",
    "cloud-moon",
    "cloud-rain",
    "cloud-showers-heavy",
    "cloud-showers-water",
    "cloud-sun-rain",
    "cloud-sun",
    "cloud",
    "clover",
    "code-branch",
    "code-commit",
    "code-compare",
    "code-fork",
    "code-merge",
    "code-pull-request",
    "code",
    "coins",
    "colon-sign",
    "comment-dollar",
    "comment-dots",
    "comment-medical",
    "comment-slash",
    "comment-sms",
    "comment",
    "comments-dollar",
    "comments",
    "compact-disc",
    "compass-drafting",
    "compass",
    "compress",
    "computer-mouse",
    "computer",
    "cookie-bite",
    "cookie",
    "copy",
    "copyright",
    "couch",
    "cow",
    "credit-card",
    "crop-simple",
    "crop",
    "cross",
    "crosshairs",
    "crow",
    "crown",
    "crutch",
    "cruzeiro-sign",
    "cube",
    "cubes-stacked",
    "cubes",
    "d",
    "database",
    "delete-left",
    "democrat",
    "desktop",
    "dharmachakra",
    "diagram-next",
    "diagram-predecessor",
    "diagram-project",
    "diagram-successor",
    "diamond-turn-right",
    "diamond",
    "dice-d20",
    "dice-d6",
    "dice-five",
    "dice-four",
    "dice-one",
    "dice-six",
    "dice-three",
    "dice-two",
    "dice",
    "disease",
    "display",
    "divide",
    "dna",
    "dog",
    "dollar-sign",
    "dolly",
    "dong-sign",
    "door-closed",
    "door-open",
    "dove",
    "down-left-and-up-right-to-center",
    "down-long",
    "download",
    "dragon",
    "draw-polygon",
    "droplet-slash",
    "droplet",
    "drum-steelpan",
    "drum",
    "drumstick-bite",
    "dumbbell",
    "dumpster-fire",
    "dumpster",
    "dungeon",
    "e",
    "ear-deaf",
    "ear-listen",
    "earth-africa",
    "earth-americas",
    "earth-asia",
    "earth-europe",
    "earth-oceania",
    "egg",
    "eject",
    "elevator",
    "ellipsis-vertical",
    "ellipsis",
    "envelope-circle-check",
    "envelope-open-text",
    "envelope-open",
    "envelope",
    "envelopes-bulk",
    "equals",
    "eraser",
    "ethernet",
    "euro-sign",
    "exclamation",
    "expand",
    "explosion",
    "eye-dropper",
    "eye-low-vision",
    "eye-slash",
    "eye",
    "f",
    "face-angry",
    "face-dizzy",
    "face-flushed",
    "face-frown-open",
    "face-frown",
    "face-grimace",
    "face-grin-beam-sweat",
    "face-grin-beam",
    "face-grin-hearts",
    "face-grin-squint-tears",
    "face-grin-squint",
    "face-grin-stars",
    "face-grin-tears",
    "face-grin-tongue-squint",
    "face-grin-tongue-wink",
    "face-grin-tongue",
    "face-grin-wide",
    "face-grin-wink",
    "face-grin",
    "face-kiss-beam",
    "face-kiss-wink-heart",
    "face-kiss",
    "face-laugh-beam",
    "face-laugh-squint",
    "face-laugh-wink",
    "face-laugh",
    "face-meh-blank",
    "face-meh",
    "face-rolling-eyes",
    "face-sad-cry",
    "face-sad-tear",
    "face-smile-beam",
    "face-smile-wink",
    "face-smile",
    "face-surprise",
    "face-tired",
    "fan",
    "faucet-drip",
    "faucet",
    "fax",
    "feather-pointed",
    "feather",
    "ferry",
    "file-arrow-down",
    "file-arrow-up",
    "file-audio",
    "file-circle-check",
    "file-circle-exclamation",
    "file-circle-minus",
    "file-circle-plus",
    "file-circle-question",
    "file-circle-xmark",
    "file-code",
    "file-contract",
    "file-csv",
    "file-excel",
    "file-export",
    "file-image",
    "file-import",
    "file-invoice-dollar",
    "file-invoice",
    "file-lines",
    "file-medical",
    "file-pdf",
    "file-pen",
    "file-powerpoint",
    "file-prescription",
    "file-shield",
    "file-signature",
    "file-video",
    "file-waveform",
    "file-word",
    "file-zipper",
    "file",
    "fill-drip",
    "fill",
    "film",
    "filter-circle-dollar",
    "filter-circle-xmark",
    "filter",
    "fingerprint",
    "fire-burner",
    "fire-extinguisher",
    "fire-flame-curved",
    "fire-flame-simple",
    "fire",
    "fish-fins",
    "fish",
    "flag-checkered",
    "flag-usa",
    "flag",
    "flask-vial",
    "flask",
    "floppy-disk",
    "florin-sign",
    "folder-closed",
    "folder-minus",
    "folder-open",
    "folder-plus",
    "folder-tree",
    "folder",
    "font-awesome",
    "font",
    "football",
    "forward-fast",
    "forward-step",
    "forward",
    "franc-sign",
    "frog",
    "futbol",
    "g",
    "gamepad",
    "gas-pump",
    "gauge-high",
    "gauge-simple-high",
    "gauge-simple",
    "gauge",
    "gavel",
    "gear",
    "gears",
    "gem",
    "genderless",
    "ghost",
    "gift",
    "gifts",
    "glass-water-droplet",
    "glass-water",
    "glasses",
    "globe",
    "golf-ball-tee",
    "gopuram",
    "graduation-cap",
    "greater-than-equal",
    "greater-than",
    "grip-lines-vertical",
    "grip-lines",
    "grip-vertical",
    "grip",
    "group-arrows-rotate",
    "guarani-sign",
    "guitar",
    "gun",
    "h",
    "hammer",
    "hamsa",
    "hand-back-fist",
    "hand-dots",
    "hand-fist",
    "hand-holding-dollar",
    "hand-holding-droplet",
    "hand-holding-hand",
    "hand-holding-heart",
    "hand-holding-medical",
    "hand-holding",
    "hand-lizard",
    "hand-middle-finger",
    "hand-peace",
    "hand-point-down",
    "hand-point-left",
    "hand-point-right",
    "hand-point-up",
    "hand-pointer",
    "hand-scissors",
    "hand-sparkles",
    "hand-spock",
    "hand",
    "handcuffs",
    "hands-asl-interpreting",
    "hands-bound",
    "hands-bubbles",
    "hands-clapping",
    "hands-holding-child",
    "hands-holding-circle",
    "hands-holding",
    "hands-praying",
    "hands",
    "handshake-angle",
    "handshake-simple-slash",
    "handshake-simple",
    "handshake-slash",
    "handshake",
    "hanukiah",
    "hard-drive",
    "hashtag",
    "hat-cowboy-side",
    "hat-cowboy",
    "hat-wizard",
    "head-side-cough-slash",
    "head-side-cough",
    "head-side-mask",
    "head-side-virus",
    "heading",
    "headphones-simple",
    "headphones",
    "headset",
    "heart-circle-bolt",
    "heart-circle-check",
    "heart-circle-exclamation",
    "heart-circle-minus",
    "heart-circle-plus",
    "heart-circle-xmark",
    "heart-crack",
    "heart-pulse",
    "heart",
    "helicopter-symbol",
    "helicopter",
    "helmet-safety",
    "helmet-un",
    "highlighter",
    "hill-avalanche",
    "hill-rockslide",
    "hippo",
    "hockey-puck",
    "holly-berry",
    "horse-head",
    "horse",
    "hospital-user",
    "hospital",
    "hot-tub-person",
    "hotdog",
    "hotel",
    "hourglass-end",
    "hourglass-half",
    "hourglass-start",
    "hourglass",
    "house-chimney-crack",
    "house-chimney-medical",
    "house-chimney-user",
    "house-chimney-window",
    "house-chimney",
    "house-circle-check",
    "house-circle-exclamation",
    "house-circle-xmark",
    "house-crack",
    "house-fire",
    "house-flag",
    "house-flood-water-circle-arrow-right",
    "house-flood-water",
    "house-laptop",
    "house-lock",
    "house-medical-circle-check",
    "house-medical-circle-exclamation",
    "house-medical-circle-xmark",
    "house-medical-flag",
    "house-medical",
    "house-signal",
    "house-tsunami",
    "house-user",
    "house",
    "hryvnia-sign",
    "hurricane",
    "i-cursor",
    "i",
    "ice-cream",
    "icicles",
    "icons",
    "id-badge",
    "id-card-clip",
    "id-card",
    "igloo",
    "image-portrait",
    "image",
    "images",
    "inbox",
    "indent",
    "indian-rupee-sign",
    "industry",
    "infinity",
    "info",
    "italic",
    "j",
    "jar-wheat",
    "jar",
    "jedi",
    "jet-fighter-up",
    "jet-fighter",
    "joint",
    "jug-detergent",
    "k",
    "kaaba",
    "key",
    "keyboard",
    "khanda",
    "kip-sign",
    "kit-medical",
    "kitchen-set",
    "kiwi-bird",
    "l",
    "land-mine-on",
    "landmark-dome",
    "landmark-flag",
    "landmark",
    "language",
    "laptop-code",
    "laptop-file",
    "laptop-medical",
    "laptop",
    "lari-sign",
    "layer-group",
    "leaf",
    "left-long",
    "left-right",
    "lemon",
    "less-than-equal",
    "less-than",
    "life-ring",
    "lightbulb",
    "lines-leaning",
    "link-slash",
    "link",
    "lira-sign",
    "list-check",
    "list-ol",
    "list-ul",
    "list",
    "litecoin-sign",
    "location-arrow",
    "location-crosshairs",
    "location-dot",
    "location-pin-lock",
    "location-pin",
    "lock-open",
    "lock",
    "locust",
    "lungs-virus",
    "lungs",
    "m",
    "magnet",
    "magnifying-glass-arrow-right",
    "magnifying-glass-chart",
    "magnifying-glass-dollar",
    "magnifying-glass-location",
    "magnifying-glass-minus",
    "magnifying-glass-plus",
    "magnifying-glass",
    "manat-sign",
    "map-location-dot",
    "map-location",
    "map-pin",
    "map",
    "marker",
    "mars-and-venus-burst",
    "mars-and-venus",
    "mars-double",
    "mars-stroke-right",
    "mars-stroke-up",
    "mars-stroke",
    "mars",
    "martini-glass-citrus",
    "martini-glass-empty",
    "martini-glass",
    "mask-face",
    "mask-ventilator",
    "mask",
    "masks-theater",
    "mattress-pillow",
    "maximize",
    "medal",
    "memory",
    "menorah",
    "mercury",
    "message",
    "meteor",
    "microchip",
    "microphone-lines-slash",
    "microphone-lines",
    "microphone-slash",
    "microphone",
    "microscope",
    "mill-sign",
    "minimize",
    "minus",
    "mitten",
    "mobile-button",
    "mobile-retro",
    "mobile-screen-button",
    "mobile-screen",
    "mobile",
    "money-bill-1-wave",
    "money-bill-1",
    "money-bill-transfer",
    "money-bill-trend-up",
    "money-bill-wave",
    "money-bill-wheat",
    "money-bill",
    "money-bills",
    "money-check-dollar",
    "money-check",
    "monument",
    "moon",
    "mortar-pestle",
    "mosque",
    "mosquito-net",
    "mosquito",
    "motorcycle",
    "mound",
    "mountain-city",
    "mountain-sun",
    "mountain",
    "mug-hot",
    "mug-saucer",
    "music",
    "n",
    "naira-sign",
    "network-wired",
    "neuter",
    "newspaper",
    "not-equal",
    "notdef",
    "note-sticky",
    "notes-medical",
    "o",
    "object-group",
    "object-ungroup",
    "oil-can",
    "oil-well",
    "om",
    "otter",
    "outdent",
    "p",
    "pager",
    "paint-roller",
    "paintbrush",
    "palette",
    "pallet",
    "panorama",
    "paper-plane",
    "paperclip",
    "parachute-box",
    "paragraph",
    "passport",
    "paste",
    "pause",
    "paw",
    "peace",
    "pen-clip",
    "pen-fancy",
    "pen-nib",
    "pen-ruler",
    "pen-to-square",
    "pen",
    "pencil",
    "people-arrows",
    "people-carry-box",
    "people-group",
    "people-line",
    "people-pulling",
    "people-robbery",
    "people-roof",
    "pepper-hot",
    "percent",
    "person-arrow-down-to-line",
    "person-arrow-up-from-line",
    "person-biking",
    "person-booth",
    "person-breastfeeding",
    "person-burst",
    "person-cane",
    "person-chalkboard",
    "person-circle-check",
    "person-circle-exclamation",
    "person-circle-minus",
    "person-circle-plus",
    "person-circle-question",
    "person-circle-xmark",
    "person-digging",
    "person-dots-from-line",
    "person-dress-burst",
    "person-dress",
    "person-drowning",
    "person-falling-burst",
    "person-falling",
    "person-half-dress",
    "person-harassing",
    "person-hiking",
    "person-military-pointing",
    "person-military-rifle",
    "person-military-to-person",
    "person-praying",
    "person-pregnant",
    "person-rays",
    "person-rifle",
    "person-running",
    "person-shelter",
    "person-skating",
    "person-skiing-nordic",
    "person-skiing",
    "person-snowboarding",
    "person-swimming",
    "person-through-window",
    "person-walking-arrow-loop-left",
    "person-walking-arrow-right",
    "person-walking-dashed-line-arrow-right",
    "person-walking-luggage",
    "person-walking-with-cane",
    "person-walking",
    "person",
    "peseta-sign",
    "peso-sign",
    "phone-flip",
    "phone-slash",
    "phone-volume",
    "phone",
    "photo-film",
    "piggy-bank",
    "pills",
    "pizza-slice",
    "place-of-worship",
    "plane-arrival",
    "plane-circle-check",
    "plane-circle-exclamation",
    "plane-circle-xmark",
    "plane-departure",
    "plane-lock",
    "plane-slash",
    "plane-up",
    "plane",
    "plant-wilt",
    "plate-wheat",
    "play",
    "plug-circle-bolt",
    "plug-circle-check",
    "plug-circle-exclamation",
    "plug-circle-minus",
    "plug-circle-plus",
    "plug-circle-xmark",
    "plug",
    "plus-minus",
    "plus",
    "podcast",
    "poo-storm",
    "poo",
    "poop",
    "power-off",
    "prescription-bottle-medical",
    "prescription-bottle",
    "prescription",
    "print",
    "pump-medical",
    "pump-soap",
    "puzzle-piece",
    "q",
    "qrcode",
    "question",
    "quote-left",
    "quote-right",
    "r",
    "radiation",
    "radio",
    "rainbow",
    "ranking-star",
    "receipt",
    "record-vinyl",
    "rectangle-ad",
    "rectangle-list",
    "rectangle-xmark",
    "recycle",
    "registered",
    "repeat",
    "reply-all",
    "reply",
    "republican",
    "restroom",
    "retweet",
    "ribbon",
    "right-from-bracket",
    "right-left",
    "right-long",
    "right-to-bracket",
    "ring",
    "road-barrier",
    "road-bridge",
    "road-circle-check",
    "road-circle-exclamation",
    "road-circle-xmark",
    "road-lock",
    "road-spikes",
    "road",
    "robot",
    "rocket",
    "rotate-left",
    "rotate-right",
    "rotate",
    "route",
    "rss",
    "ruble-sign",
    "rug",
    "ruler-combined",
    "ruler-horizontal",
    "ruler-vertical",
    "ruler",
    "rupee-sign",
    "rupiah-sign",
    "s",
    "sack-dollar",
    "sack-xmark",
    "sailboat",
    "satellite-dish",
    "satellite",
    "scale-balanced",
    "scale-unbalanced-flip",
    "scale-unbalanced",
    "school-circle-check",
    "school-circle-exclamation",
    "school-circle-xmark",
    "school-flag",
    "school-lock",
    "school",
    "scissors",
    "screwdriver-wrench",
    "screwdriver",
    "scroll-torah",
    "scroll",
    "sd-card",
    "section",
    "seedling",
    "server",
    "shapes",
    "share-from-square",
    "share-nodes",
    "share",
    "sheet-plastic",
    "shekel-sign",
    "shield-cat",
    "shield-dog",
    "shield-halved",
    "shield-heart",
    "shield-virus",
    "shield",
    "ship",
    "shirt",
    "shoe-prints",
    "shop-lock",
    "shop-slash",
    "shop",
    "shower",
    "shrimp",
    "shuffle",
    "shuttle-space",
    "sign-hanging",
    "signal",
    "signature",
    "signs-post",
    "sim-card",
    "sink",
    "sitemap",
    "skull-crossbones",
    "skull",
    "slash",
    "sleigh",
    "sliders",
    "smog",
    "smoking",
    "snowflake",
    "snowman",
    "snowplow",
    "soap",
    "socks",
    "solar-panel",
    "sort-down",
    "sort-up",
    "sort",
    "spa",
    "spaghetti-monster-flying",
    "spell-check",
    "spider",
    "spinner",
    "splotch",
    "spoon",
    "spray-can-sparkles",
    "spray-can",
    "square-arrow-up-right",
    "square-caret-down",
    "square-caret-left",
    "square-caret-right",
    "square-caret-up",
    "square-check",
    "square-envelope",
    "square-full",
    "square-h",
    "square-minus",
    "square-nfi",
    "square-parking",
    "square-pen",
    "square-person-confined",
    "square-phone-flip",
    "square-phone",
    "square-plus",
    "square-poll-horizontal",
    "square-poll-vertical",
    "square-root-variable",
    "square-rss",
    "square-share-nodes",
    "square-up-right",
    "square-virus",
    "square-xmark",
    "square",
    "staff-snake",
    "stairs",
    "stamp",
    "stapler",
    "star-and-crescent",
    "star-half-stroke",
    "star-half",
    "star-of-david",
    "star-of-life",
    "star",
    "sterling-sign",
    "stethoscope",
    "stop",
    "stopwatch-20",
    "stopwatch",
    "store-slash",
    "store",
    "street-view",
    "strikethrough",
    "stroopwafel",
    "subscript",
    "suitcase-medical",
    "suitcase-rolling",
    "suitcase",
    "sun-plant-wilt",
    "sun",
    "superscript",
    "swatchbook",
    "synagogue",
    "syringe",
    "t",
    "table-cells-column-lock",
    "table-cells-large",
    "table-cells-row-lock",
    "table-cells-row-unlock",
    "table-cells",
    "table-columns",
    "table-list",
    "table-tennis-paddle-ball",
    "table",
    "tablet-button",
    "tablet-screen-button",
    "tablet",
    "tablets",
    "tachograph-digital",
    "tag",
    "tags",
    "tape",
    "tarp-droplet",
    "tarp",
    "taxi",
    "teeth-open",
    "teeth",
    "temperature-arrow-down",
    "temperature-arrow-up",
    "temperature-empty",
    "temperature-full",
    "temperature-half",
    "temperature-high",
    "temperature-low",
    "temperature-quarter",
    "temperature-three-quarters",
    "tenge-sign",
    "tent-arrow-down-to-line",
    "tent-arrow-left-right",
    "tent-arrow-turn-left",
    "tent-arrows-down",
    "tent",
    "tents",
    "terminal",
    "text-height",
    "text-slash",
    "text-width",
    "thermometer",
    "thumbs-down",
    "thumbs-up",
    "thumbtack-slash",
    "thumbtack",
    "ticket-simple",
    "ticket",
    "timeline",
    "toggle-off",
    "toggle-on",
    "toilet-paper-slash",
    "toilet-paper",
    "toilet-portable",
    "toilet",
    "toilets-portable",
    "toolbox",
    "tooth",
    "torii-gate",
    "tornado",
    "tower-broadcast",
    "tower-cell",
    "tower-observation",
    "tractor",
    "trademark",
    "traffic-light",
    "trailer",
    "train-subway",
    "train-tram",
    "train",
    "transgender",
    "trash-arrow-up",
    "trash-can-arrow-up",
    "trash-can",
    "trash",
    "tree-city",
    "tree",
    "triangle-exclamation",
    "trophy",
    "trowel-bricks",
    "trowel",
    "truck-arrow-right",
    "truck-droplet",
    "truck-fast",
    "truck-field-un",
    "truck-field",
    "truck-front",
    "truck-medical",
    "truck-monster",
    "truck-moving",
    "truck-pickup",
    "truck-plane",
    "truck-ramp-box",
    "truck",
    "tty",
    "turkish-lira-sign",
    "turn-down",
    "turn-up",
    "tv",
    "u",
    "umbrella-beach",
    "umbrella",
    "underline",
    "universal-access",
    "unlock-keyhole",
    "unlock",
    "up-down-left-right",
    "up-down",
    "up-long",
    "up-right-and-down-left-from-center",
    "up-right-from-square",
    "upload",
    "user-astronaut",
    "user-check",
    "user-clock",
    "user-doctor",
    "user-gear",
    "user-graduate",
    "user-group",
    "user-injured",
    "user-large-slash",
    "user-large",
    "user-lock",
    "user-minus",
    "user-ninja",
    "user-nurse",
    "user-pen",
    "user-plus",
    "user-secret",
    "user-shield",
    "user-slash",
    "user-tag",
    "user-tie",
    "user-xmark",
    "user",
    "users-between-lines",
    "users-gear",
    "users-line",
    "users-rays",
    "users-rectangle",
    "users-slash",
    "users-viewfinder",
    "users",
    "utensils",
    "v",
    "van-shuttle",
    "vault",
    "vector-square",
    "venus-double",
    "venus-mars",
    "venus",
    "vest-patches",
    "vest",
    "vial-circle-check",
    "vial-virus",
    "vial",
    "vials",
    "video-slash",
    "video",
    "vihara",
    "virus-covid-slash",
    "virus-covid",
    "virus-slash",
    "virus",
    "viruses",
    "voicemail",
    "volcano",
    "volleyball",
    "volume-high",
    "volume-low",
    "volume-off",
    "volume-xmark",
    "vr-cardboard",
    "w",
    "walkie-talkie",
    "wallet",
    "wand-magic-sparkles",
    "wand-magic",
    "wand-sparkles",
    "warehouse",
    "water-ladder",
    "water",
    "wave-square",
    "web-awesome",
    "weight-hanging",
    "weight-scale",
    "wheat-awn-circle-exclamation",
    "wheat-awn",
    "wheelchair-move",
    "wheelchair",
    "whiskey-glass",
    "wifi",
    "wind",
    "window-maximize",
    "window-minimize",
    "window-restore",
    "wine-bottle",
    "wine-glass-empty",
    "wine-glass",
    "won-sign",
    "worm",
    "wrench",
    "x-ray",
    "x",
    "xmark",
    "xmarks-lines",
    "y",
    "yen-sign",
    "yin-yang",
    "z"
  ]
}
;
},844,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\glyphmaps\\FontAwesome6Free_meta.json");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fvector-icons%2Fbuild%2Fvendor%2Freact-native-vector-icons%2FFonts/FontAwesome6_Regular.ttf";
},845,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Regular.ttf");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fvector-icons%2Fbuild%2Fvendor%2Freact-native-vector-icons%2FFonts/FontAwesome6_Solid.ttf";
},846,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Solid.ttf");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fvector-icons%2Fbuild%2Fvendor%2Freact-native-vector-icons%2FFonts/FontAwesome6_Brands.ttf";
},847,[],"node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Brands.ttf");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(require(_dependencyMap[0], "./ExpoHead"), exports);
},848,[849],"node_modules\\expo-router\\build\\head\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\head\\ExpoHead.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Head = void 0;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const lib_1 = require(_dependencyMap[2], "../../vendor/react-helmet-async/lib");
  const Head = ({
    children
  }) => {
    return _reactNativeCssInteropJsxRuntime.jsx(lib_1.Helmet, {
      children: children
    });
  };
  exports.Head = Head;
  exports.Head.Provider = lib_1.HelmetProvider;
},849,[2,3,850],"node_modules\\expo-router\\build\\head\\ExpoHead.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"],
    _excluded2 = ["children"];
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // src/index.tsx
  var src_exports = {};
  __export(src_exports, {
    Helmet: () => Helmet,
    HelmetData: () => HelmetData,
    HelmetProvider: () => HelmetProvider
  });
  module.exports = __toCommonJS(src_exports);
  var import_react4 = __toESM(require(_dependencyMap[1], "react"));
  var import_react_fast_compare = __toESM(require(_dependencyMap[2], "react-fast-compare"));
  var import_invariant = __toESM(require(_dependencyMap[3], "invariant"));

  // src/Provider.tsx
  var import_react2 = __toESM(require(_dependencyMap[1], "react"));

  // src/server.ts
  var import_react = __toESM(require(_dependencyMap[1], "react"));

  // src/constants.ts
  var TAG_NAMES = /* @__PURE__ */(TAG_NAMES2 => {
    TAG_NAMES2["BASE"] = "base";
    TAG_NAMES2["BODY"] = "body";
    TAG_NAMES2["HEAD"] = "head";
    TAG_NAMES2["HTML"] = "html";
    TAG_NAMES2["LINK"] = "link";
    TAG_NAMES2["META"] = "meta";
    TAG_NAMES2["NOSCRIPT"] = "noscript";
    TAG_NAMES2["SCRIPT"] = "script";
    TAG_NAMES2["STYLE"] = "style";
    TAG_NAMES2["TITLE"] = "title";
    TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
    return TAG_NAMES2;
  })(TAG_NAMES || {});
  var SEO_PRIORITY_TAGS = {
    link: {
      rel: ["amphtml", "canonical", "alternate"]
    },
    script: {
      type: ["application/ld+json"]
    },
    meta: {
      charset: "",
      name: ["generator", "robots", "description"],
      property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
    }
  };
  var VALID_TAG_NAMES = Object.values(TAG_NAMES);
  var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  };
  var HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce((carry, [key, value]) => {
    carry[value] = key;
    return carry;
  }, {});
  var HELMET_ATTRIBUTE = "data-rh";

  // src/utils.ts
  var HELMET_PROPS = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate",
    PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
  };
  var getInnermostProperty = (propsList, property) => {
    for (let i = propsList.length - 1; i >= 0; i -= 1) {
      const props = propsList[i];
      if (Object.prototype.hasOwnProperty.call(props, property)) {
        return props[property];
      }
    }
    return null;
  };
  var getTitleFromPropsList = propsList => {
    let innermostTitle = getInnermostProperty(propsList, "title" /* TITLE */);
    const innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
    if (Array.isArray(innermostTitle)) {
      innermostTitle = innermostTitle.join("");
    }
    if (innermostTemplate && innermostTitle) {
      return innermostTemplate.replace(/%s/g, () => innermostTitle);
    }
    const innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
    return innermostTitle || innermostDefaultTitle || void 0;
  };
  var getOnChangeClientState = propsList => getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {});
  var getAttributesFromPropsList = (tagType, propsList) => propsList.filter(props => typeof props[tagType] !== "undefined").map(props => props[tagType]).reduce((tagAttrs, current) => Object.assign({}, tagAttrs, current), {});
  var getBaseTagFromPropsList = (primaryAttributes, propsList) => propsList.filter(props => typeof props["base" /* BASE */] !== "undefined").map(props => props["base" /* BASE */]).reverse().reduce((innermostBaseTag, tag) => {
    if (!innermostBaseTag.length) {
      const keys = Object.keys(tag);
      for (let i = 0; i < keys.length; i += 1) {
        const attributeKey = keys[i];
        const lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
          return innermostBaseTag.concat(tag);
        }
      }
    }
    return innermostBaseTag;
  }, []);
  var warn = msg => console && typeof console.warn === "function" && console.warn(msg);
  var getTagsFromPropsList = (tagName, primaryAttributes, propsList) => {
    const approvedSeenTags = {};
    return propsList.filter(props => {
      if (Array.isArray(props[tagName])) {
        return true;
      }
      if (typeof props[tagName] !== "undefined") {
        warn(`Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`);
      }
      return false;
    }).map(props => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
      const instanceSeenTags = {};
      instanceTags.filter(tag => {
        let primaryAttributeKey;
        const keys2 = Object.keys(tag);
        for (let i = 0; i < keys2.length; i += 1) {
          const attributeKey = keys2[i];
          const lowerCaseAttributeKey = attributeKey.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === "rel" /* REL */ && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === "rel" /* REL */ && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
            primaryAttributeKey = lowerCaseAttributeKey;
          }
          if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === "innerHTML" /* INNER_HTML */ || attributeKey === "cssText" /* CSS_TEXT */ || attributeKey === "itemprop" /* ITEM_PROP */)) {
            primaryAttributeKey = attributeKey;
          }
        }
        if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
          return false;
        }
        const value = tag[primaryAttributeKey].toLowerCase();
        if (!approvedSeenTags[primaryAttributeKey]) {
          approvedSeenTags[primaryAttributeKey] = {};
        }
        if (!instanceSeenTags[primaryAttributeKey]) {
          instanceSeenTags[primaryAttributeKey] = {};
        }
        if (!approvedSeenTags[primaryAttributeKey][value]) {
          instanceSeenTags[primaryAttributeKey][value] = true;
          return true;
        }
        return false;
      }).reverse().forEach(tag => approvedTags.push(tag));
      const keys = Object.keys(instanceSeenTags);
      for (let i = 0; i < keys.length; i += 1) {
        const attributeKey = keys[i];
        const tagUnion = Object.assign({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
        approvedSeenTags[attributeKey] = tagUnion;
      }
      return approvedTags;
    }, []).reverse();
  };
  var getAnyTrueFromPropsList = (propsList, checkedTag) => {
    if (Array.isArray(propsList) && propsList.length) {
      for (let index = 0; index < propsList.length; index += 1) {
        const prop = propsList[index];
        if (prop[checkedTag]) {
          return true;
        }
      }
    }
    return false;
  };
  var reducePropsToState = propsList => ({
    baseTag: getBaseTagFromPropsList(["href" /* HREF */], propsList),
    bodyAttributes: getAttributesFromPropsList("bodyAttributes" /* BODY */, propsList),
    defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
    encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: getAttributesFromPropsList("htmlAttributes" /* HTML */, propsList),
    linkTags: getTagsFromPropsList("link" /* LINK */, ["rel" /* REL */, "href" /* HREF */], propsList),
    metaTags: getTagsFromPropsList("meta" /* META */, ["name" /* NAME */, "charset" /* CHARSET */, "http-equiv" /* HTTPEQUIV */, "property" /* PROPERTY */, "itemprop" /* ITEM_PROP */], propsList),
    noscriptTags: getTagsFromPropsList("noscript" /* NOSCRIPT */, ["innerHTML" /* INNER_HTML */], propsList),
    onChangeClientState: getOnChangeClientState(propsList),
    scriptTags: getTagsFromPropsList("script" /* SCRIPT */, ["src" /* SRC */, "innerHTML" /* INNER_HTML */], propsList),
    styleTags: getTagsFromPropsList("style" /* STYLE */, ["cssText" /* CSS_TEXT */], propsList),
    title: getTitleFromPropsList(propsList),
    titleAttributes: getAttributesFromPropsList("titleAttributes" /* TITLE */, propsList),
    prioritizeSeoTags: getAnyTrueFromPropsList(propsList, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
  });
  var flattenArray = possibleArray => Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
  var checkIfPropsMatch = (props, toMatch) => {
    const keys = Object.keys(props);
    for (let i = 0; i < keys.length; i += 1) {
      if (toMatch[keys[i]] && toMatch[keys[i]].includes(props[keys[i]])) {
        return true;
      }
    }
    return false;
  };
  var prioritizer = (elementsList, propsToMatch) => {
    if (Array.isArray(elementsList)) {
      return elementsList.reduce((acc, elementAttrs) => {
        if (checkIfPropsMatch(elementAttrs, propsToMatch)) {
          acc.priority.push(elementAttrs);
        } else {
          acc.default.push(elementAttrs);
        }
        return acc;
      }, {
        priority: [],
        default: []
      });
    }
    return {
      default: elementsList,
      priority: []
    };
  };
  var without = (obj, key) => {
    return Object.assign({}, obj, {
      [key]: void 0
    });
  };

  // src/server.ts
  var SELF_CLOSING_TAGS = ["noscript" /* NOSCRIPT */, "script" /* SCRIPT */, "style" /* STYLE */];
  var encodeSpecialCharacters = (str, encode = true) => {
    if (encode === false) {
      return String(str);
    }
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  };
  var generateElementAttributesAsString = attributes => Object.keys(attributes).reduce((str, key) => {
    const attr = typeof attributes[key] !== "undefined" ? `${key}="${attributes[key]}"` : `${key}`;
    return str ? `${str} ${attr}` : attr;
  }, "");
  var generateTitleAsString = (type, title, attributes, encode) => {
    const attributeString = generateElementAttributesAsString(attributes);
    const flattenedTitle = flattenArray(title);
    return attributeString ? `<${type} ${HELMET_ATTRIBUTE}="true" ${attributeString}>${encodeSpecialCharacters(flattenedTitle, encode)}</${type}>` : `<${type} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(flattenedTitle, encode)}</${type}>`;
  };
  var generateTagsAsString = (type, tags, encode = true) => tags.reduce((str, t) => {
    const tag = t;
    const attributeHtml = Object.keys(tag).filter(attribute => !(attribute === "innerHTML" /* INNER_HTML */ || attribute === "cssText" /* CSS_TEXT */)).reduce((string, attribute) => {
      const attr = typeof tag[attribute] === "undefined" ? attribute : `${attribute}="${encodeSpecialCharacters(tag[attribute], encode)}"`;
      return string ? `${string} ${attr}` : attr;
    }, "");
    const tagContent = tag.innerHTML || tag.cssText || "";
    const isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
    return `${str}<${type} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? `/>` : `>${tagContent}</${type}>`}`;
  }, "");
  var convertElementAttributesToReactProps = (attributes, initProps = {}) => Object.keys(attributes).reduce((obj, key) => {
    const mapped = REACT_TAG_MAP[key];
    obj[mapped || key] = attributes[key];
    return obj;
  }, initProps);
  var generateTitleAsReactComponent = (_type, title, attributes) => {
    const initProps = {
      key: title,
      [HELMET_ATTRIBUTE]: true
    };
    const props = convertElementAttributesToReactProps(attributes, initProps);
    return [import_react.default.createElement("title" /* TITLE */, props, title)];
  };
  var generateTagsAsReactComponent = (type, tags) => tags.map((tag, i) => {
    const mappedTag = {
      key: i,
      [HELMET_ATTRIBUTE]: true
    };
    Object.keys(tag).forEach(attribute => {
      const mapped = REACT_TAG_MAP[attribute];
      const mappedAttribute = mapped || attribute;
      if (mappedAttribute === "innerHTML" /* INNER_HTML */ || mappedAttribute === "cssText" /* CSS_TEXT */) {
        const content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = {
          __html: content
        };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });
    return import_react.default.createElement(type, mappedTag);
  });
  var getMethodsForTag = (type, tags, encode = true) => {
    switch (type) {
      case "title" /* TITLE */:
        return {
          toComponent: () => generateTitleAsReactComponent(type, tags.title, tags.titleAttributes),
          toString: () => generateTitleAsString(type, tags.title, tags.titleAttributes, encode)
        };
      case "bodyAttributes" /* BODY */:
      case "htmlAttributes" /* HTML */:
        return {
          toComponent: () => convertElementAttributesToReactProps(tags),
          toString: () => generateElementAttributesAsString(tags)
        };
      default:
        return {
          toComponent: () => generateTagsAsReactComponent(type, tags),
          toString: () => generateTagsAsString(type, tags, encode)
        };
    }
  };
  var getPriorityMethods = ({
    metaTags,
    linkTags,
    scriptTags,
    encode
  }) => {
    const meta = prioritizer(metaTags, SEO_PRIORITY_TAGS.meta);
    const link = prioritizer(linkTags, SEO_PRIORITY_TAGS.link);
    const script = prioritizer(scriptTags, SEO_PRIORITY_TAGS.script);
    const priorityMethods = {
      toComponent: () => [...generateTagsAsReactComponent("meta" /* META */, meta.priority), ...generateTagsAsReactComponent("link" /* LINK */, link.priority), ...generateTagsAsReactComponent("script" /* SCRIPT */, script.priority)],
      toString: () =>
      // generate all the tags as strings and concatenate them
      `${getMethodsForTag("meta" /* META */, meta.priority, encode)} ${getMethodsForTag("link" /* LINK */, link.priority, encode)} ${getMethodsForTag("script" /* SCRIPT */, script.priority, encode)}`
    };
    return {
      priorityMethods,
      metaTags: meta.default,
      linkTags: link.default,
      scriptTags: script.default
    };
  };
  var mapStateOnServer = props => {
    const {
      baseTag,
      bodyAttributes,
      encode = true,
      htmlAttributes,
      noscriptTags,
      styleTags,
      title = "",
      titleAttributes,
      prioritizeSeoTags
    } = props;
    let {
      linkTags,
      metaTags,
      scriptTags
    } = props;
    let priorityMethods = {
      toComponent: () => {},
      toString: () => ""
    };
    if (prioritizeSeoTags) {
      ({
        priorityMethods,
        linkTags,
        metaTags,
        scriptTags
      } = getPriorityMethods(props));
    }
    return {
      priority: priorityMethods,
      base: getMethodsForTag("base" /* BASE */, baseTag, encode),
      bodyAttributes: getMethodsForTag("bodyAttributes" /* BODY */, bodyAttributes, encode),
      htmlAttributes: getMethodsForTag("htmlAttributes" /* HTML */, htmlAttributes, encode),
      link: getMethodsForTag("link" /* LINK */, linkTags, encode),
      meta: getMethodsForTag("meta" /* META */, metaTags, encode),
      noscript: getMethodsForTag("noscript" /* NOSCRIPT */, noscriptTags, encode),
      script: getMethodsForTag("script" /* SCRIPT */, scriptTags, encode),
      style: getMethodsForTag("style" /* STYLE */, styleTags, encode),
      title: getMethodsForTag("title" /* TITLE */, {
        title,
        titleAttributes
      }, encode)
    };
  };
  var server_default = mapStateOnServer;

  // src/HelmetData.ts
  var instances = [];
  var isDocument = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  var HelmetData = class {
    instances = [];
    canUseDOM = isDocument;
    value = {
      setHelmet: serverState => {
        this.context.helmet = serverState;
      },
      helmetInstances: {
        get: () => this.canUseDOM ? instances : this.instances,
        add: instance => {
          (this.canUseDOM ? instances : this.instances).push(instance);
        },
        remove: instance => {
          const index = (this.canUseDOM ? instances : this.instances).indexOf(instance);
          (this.canUseDOM ? instances : this.instances).splice(index, 1);
        }
      }
    };
    constructor(context, canUseDOM) {
      this.context = context;
      this.canUseDOM = canUseDOM || false;
      if (!canUseDOM) {
        context.helmet = server_default({
          baseTag: [],
          bodyAttributes: {},
          encodeSpecialCharacters: true,
          htmlAttributes: {},
          linkTags: [],
          metaTags: [],
          noscriptTags: [],
          scriptTags: [],
          styleTags: [],
          title: "",
          titleAttributes: {}
        });
      }
    }
  };

  // src/Provider.tsx
  var defaultValue = {};
  var Context = import_react2.default.createContext(defaultValue);
  var HelmetProvider = class _HelmetProvider extends import_react2.Component {
    static canUseDOM = isDocument;
    constructor(props) {
      super(props);
      this.helmetData = new HelmetData(this.props.context || {}, _HelmetProvider.canUseDOM);
    }
    render() {
      return /* @__PURE__ */import_react2.default.createElement(Context.Provider, {
        value: this.helmetData.value
      }, this.props.children);
    }
  };

  // src/Dispatcher.tsx
  var import_react3 = require(_dependencyMap[1], "react");
  var import_shallowequal = __toESM(require(_dependencyMap[4], "shallowequal"));

  // src/client.ts
  var updateTags = (type, tags) => {
    const headElement = document.head || document.querySelector("head" /* HEAD */);
    const tagNodes = headElement.querySelectorAll(`${type}[${HELMET_ATTRIBUTE}]`);
    const oldTags = [].slice.call(tagNodes);
    const newTags = [];
    let indexToDelete;
    if (tags && tags.length) {
      tags.forEach(tag => {
        const newElement = document.createElement(type);
        for (const attribute in tag) {
          if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
            if (attribute === "innerHTML" /* INNER_HTML */) {
              newElement.innerHTML = tag.innerHTML;
            } else if (attribute === "cssText" /* CSS_TEXT */) {
              if (newElement.styleSheet) {
                newElement.styleSheet.cssText = tag.cssText;
              } else {
                newElement.appendChild(document.createTextNode(tag.cssText));
              }
            } else {
              const attr = attribute;
              const value = typeof tag[attr] === "undefined" ? "" : tag[attr];
              newElement.setAttribute(attribute, value);
            }
          }
        }
        newElement.setAttribute(HELMET_ATTRIBUTE, "true");
        if (oldTags.some((existingTag, index) => {
          indexToDelete = index;
          return newElement.isEqualNode(existingTag);
        })) {
          oldTags.splice(indexToDelete, 1);
        } else {
          newTags.push(newElement);
        }
      });
    }
    oldTags.forEach(tag => tag.parentNode?.removeChild(tag));
    newTags.forEach(tag => headElement.appendChild(tag));
    return {
      oldTags,
      newTags
    };
  };
  var updateAttributes = (tagName, attributes) => {
    const elementTag = document.getElementsByTagName(tagName)[0];
    if (!elementTag) {
      return;
    }
    const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
    const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
    const attributesToRemove = [...helmetAttributes];
    const attributeKeys = Object.keys(attributes);
    for (const attribute of attributeKeys) {
      const value = attributes[attribute] || "";
      if (elementTag.getAttribute(attribute) !== value) {
        elementTag.setAttribute(attribute, value);
      }
      if (helmetAttributes.indexOf(attribute) === -1) {
        helmetAttributes.push(attribute);
      }
      const indexToSave = attributesToRemove.indexOf(attribute);
      if (indexToSave !== -1) {
        attributesToRemove.splice(indexToSave, 1);
      }
    }
    for (let i = attributesToRemove.length - 1; i >= 0; i -= 1) {
      elementTag.removeAttribute(attributesToRemove[i]);
    }
    if (helmetAttributes.length === attributesToRemove.length) {
      elementTag.removeAttribute(HELMET_ATTRIBUTE);
    } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
      elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
    }
  };
  var updateTitle = (title, attributes) => {
    if (typeof title !== "undefined" && document.title !== title) {
      document.title = flattenArray(title);
    }
    updateAttributes("title" /* TITLE */, attributes);
  };
  var commitTagChanges = (newState, cb) => {
    const {
      baseTag,
      bodyAttributes,
      htmlAttributes,
      linkTags,
      metaTags,
      noscriptTags,
      onChangeClientState,
      scriptTags,
      styleTags,
      title,
      titleAttributes
    } = newState;
    updateAttributes("body" /* BODY */, bodyAttributes);
    updateAttributes("html" /* HTML */, htmlAttributes);
    updateTitle(title, titleAttributes);
    const tagUpdates = {
      baseTag: updateTags("base" /* BASE */, baseTag),
      linkTags: updateTags("link" /* LINK */, linkTags),
      metaTags: updateTags("meta" /* META */, metaTags),
      noscriptTags: updateTags("noscript" /* NOSCRIPT */, noscriptTags),
      scriptTags: updateTags("script" /* SCRIPT */, scriptTags),
      styleTags: updateTags("style" /* STYLE */, styleTags)
    };
    const addedTags = {};
    const removedTags = {};
    Object.keys(tagUpdates).forEach(tagType => {
      const {
        newTags,
        oldTags
      } = tagUpdates[tagType];
      if (newTags.length) {
        addedTags[tagType] = newTags;
      }
      if (oldTags.length) {
        removedTags[tagType] = tagUpdates[tagType].oldTags;
      }
    });
    if (cb) {
      cb();
    }
    onChangeClientState(newState, addedTags, removedTags);
  };
  var _helmetCallback = null;
  var handleStateChangeOnClient = newState => {
    if (_helmetCallback) {
      cancelAnimationFrame(_helmetCallback);
    }
    if (newState.defer) {
      _helmetCallback = requestAnimationFrame(() => {
        commitTagChanges(newState, () => {
          _helmetCallback = null;
        });
      });
    } else {
      commitTagChanges(newState);
      _helmetCallback = null;
    }
  };
  var client_default = handleStateChangeOnClient;

  // src/Dispatcher.tsx
  var HelmetDispatcher = class extends import_react3.Component {
    rendered = false;
    shouldComponentUpdate(nextProps) {
      return !(0, import_shallowequal.default)(nextProps, this.props);
    }
    componentDidUpdate() {
      this.emitChange();
    }
    componentWillUnmount() {
      const {
        helmetInstances
      } = this.props.context;
      helmetInstances.remove(this);
      this.emitChange();
    }
    emitChange() {
      const {
        helmetInstances,
        setHelmet
      } = this.props.context;
      let serverState = null;
      const state = reducePropsToState(helmetInstances.get().map(instance => {
        const props = Object.assign({}, instance.props);
        delete props.context;
        return props;
      }));
      if (HelmetProvider.canUseDOM) {
        client_default(state);
      } else if (server_default) {
        serverState = server_default(state);
      }
      setHelmet(serverState);
    }
    // componentWillMount will be deprecated
    // for SSR, initialize on first render
    // constructor is also unsafe in StrictMode
    init() {
      if (this.rendered) {
        return;
      }
      this.rendered = true;
      const {
        helmetInstances
      } = this.props.context;
      helmetInstances.add(this);
      this.emitChange();
    }
    render() {
      this.init();
      return null;
    }
  };

  // src/index.tsx
  var Helmet = class extends import_react4.Component {
    static defaultProps = {
      defer: true,
      encodeSpecialCharacters: true,
      prioritizeSeoTags: false
    };
    shouldComponentUpdate(nextProps) {
      return !(0, import_react_fast_compare.default)(without(this.props, "helmetData"), without(nextProps, "helmetData"));
    }
    mapNestedChildrenToProps(child, nestedChildren) {
      if (!nestedChildren) {
        return null;
      }
      switch (child.type) {
        case "script" /* SCRIPT */:
        case "noscript" /* NOSCRIPT */:
          return {
            innerHTML: nestedChildren
          };
        case "style" /* STYLE */:
          return {
            cssText: nestedChildren
          };
        default:
          throw new Error(`<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`);
      }
    }
    flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren) {
      return Object.assign({}, arrayTypeChildren, {
        [child.type]: [...(arrayTypeChildren[child.type] || []), Object.assign({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]
      });
    }
    mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren) {
      switch (child.type) {
        case "title" /* TITLE */:
          return Object.assign({}, newProps, {
            [child.type]: nestedChildren,
            titleAttributes: Object.assign({}, newChildProps)
          });
        case "body" /* BODY */:
          return Object.assign({}, newProps, {
            bodyAttributes: Object.assign({}, newChildProps)
          });
        case "html" /* HTML */:
          return Object.assign({}, newProps, {
            htmlAttributes: Object.assign({}, newChildProps)
          });
        default:
          return Object.assign({}, newProps, {
            [child.type]: Object.assign({}, newChildProps)
          });
      }
    }
    mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
      let newFlattenedProps = Object.assign({}, newProps);
      Object.keys(arrayTypeChildren).forEach(arrayChildName => {
        newFlattenedProps = Object.assign({}, newFlattenedProps, {
          [arrayChildName]: arrayTypeChildren[arrayChildName]
        });
      });
      return newFlattenedProps;
    }
    warnOnInvalidChildren(child, nestedChildren) {
      (0, import_invariant.default)(VALID_TAG_NAMES.some(name => child.type === name), typeof child.type === "function" ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.` : `Only elements types ${VALID_TAG_NAMES.join(", ")} are allowed. Helmet does not support rendering <${child.type}> elements. Refer to our API for more information.`);
      (0, import_invariant.default)(!nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren) && !nestedChildren.some(nestedChild => typeof nestedChild !== "string"), `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\`\`}</${child.type}> ) Refer to our API for more information.`);
      return true;
    }
    mapChildrenToProps(children, newProps) {
      let arrayTypeChildren = {};
      import_react4.default.Children.forEach(children, child => {
        if (!child || !child.props) {
          return;
        }
        const _child$props = child.props,
          {
            children: nestedChildren
          } = _child$props,
          childProps = _objectWithoutPropertiesLoose(_child$props, _excluded);
        const newChildProps = Object.keys(childProps).reduce((obj, key) => {
          obj[HTML_TAG_MAP[key] || key] = childProps[key];
          return obj;
        }, {});
        let {
          type
        } = child;
        if (typeof type === "symbol") {
          type = type.toString();
        } else {
          this.warnOnInvalidChildren(child, nestedChildren);
        }
        switch (type) {
          case "Symbol(react.fragment)" /* FRAGMENT */:
            newProps = this.mapChildrenToProps(nestedChildren, newProps);
            break;
          case "link" /* LINK */:
          case "meta" /* META */:
          case "noscript" /* NOSCRIPT */:
          case "script" /* SCRIPT */:
          case "style" /* STYLE */:
            arrayTypeChildren = this.flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren);
            break;
          default:
            newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);
            break;
        }
      });
      return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
    }
    render() {
      const _this$props = this.props,
        {
          children
        } = _this$props,
        props = _objectWithoutPropertiesLoose(_this$props, _excluded2);
      let newProps = Object.assign({}, props);
      let {
        helmetData
      } = props;
      if (children) {
        newProps = this.mapChildrenToProps(children, newProps);
      }
      if (helmetData && !(helmetData instanceof HelmetData)) {
        const data = helmetData;
        helmetData = new HelmetData(data.context, true);
        delete newProps.helmetData;
      }
      return helmetData ? /* @__PURE__ */import_react4.default.createElement(HelmetDispatcher, Object.assign({}, newProps, {
        context: helmetData.value
      })) : /* @__PURE__ */import_react4.default.createElement(Context.Consumer, null, context => /* @__PURE__ */import_react4.default.createElement(HelmetDispatcher, Object.assign({}, newProps, {
        context
      })));
    }
  };
},850,[29,3,851,919,852],"node_modules\\expo-router\\vendor\\react-helmet-async\\lib\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

  var hasElementType = typeof Element !== 'undefined';
  var hasMap = typeof Map === 'function';
  var hasSet = typeof Set === 'function';
  var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

  // Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

  function equal(a, b) {
    // START: fast-deep-equal es6/index.js 3.1.3
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }

      // START: Modifications:
      // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
      //    to co-exist with es5.
      // 2. Replace `for of` with es5 compliant iteration using `for`.
      //    Basically, take:
      //
      //    ```js
      //    for (i of a.entries())
      //      if (!b.has(i[0])) return false;
      //    ```
      //
      //    ... and convert to:
      //
      //    ```js
      //    it = a.entries();
      //    while (!(i = it.next()).done)
      //      if (!b.has(i.value[0])) return false;
      //    ```
      //
      //    **Note**: `i` access switches to `i.value`.
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false;
        return true;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
        return true;
      }
      // END: Modifications

      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      // START: Modifications:
      // Apply guards for `Object.create(null)` handling. See:
      // - https://github.com/FormidableLabs/react-fast-compare/issues/64
      // - https://github.com/epoberezkin/fast-deep-equal/issues/49
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
      // END: Modifications

      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      // END: fast-deep-equal

      // START: react-fast-compare
      // custom handling for DOM elements
      if (hasElementType && a instanceof Element) return false;

      // custom handling for React/Preact
      for (i = length; i-- !== 0;) {
        if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
          // React-specific: avoid traversing React elements' _owner
          // Preact-specific: avoid traversing Preact elements' __v and __o
          //    __v = $_original / $_vnode
          //    __o = $_owner
          // These properties contain circular references and are not needed when
          // comparing the actual elements (and not their owners)
          // .$$typeof and ._store on just reasonable markers of elements

          continue;
        }

        // all other properties should be traversed as usual
        if (!equal(a[keys[i]], b[keys[i]])) return false;
      }
      // END: react-fast-compare

      // START: fast-deep-equal
      return true;
    }
    return a !== a && b !== b;
  }
  // end fast-deep-equal

  module.exports = function isEqual(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || '').match(/stack|recursion/i)) {
        // warn on circular references, don't crash
        // browsers give this different errors name and messages:
        // chrome/safari: "RangeError", "Maximum call stack size exceeded"
        // firefox: "InternalError", too much recursion"
        // edge: "Error", "Out of stack space"
        console.warn('react-fast-compare cannot handle circular refs');
        return false;
      }
      // some other error. we should definitely know about these
      throw error;
    }
  };
},851,[],"node_modules\\react-fast-compare\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  //

  module.exports = function shallowEqual(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (ret !== void 0) {
      return !!ret;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

    // Test for A's keys different from B.
    for (var idx = 0; idx < keysA.length; idx++) {
      var key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      var valueA = objA[key];
      var valueB = objB[key];
      ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
      if (ret === false || ret === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  };
},852,[],"node_modules\\shallowequal\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  require(_dependencyMap[0], "expo-router/entry-classic");
},865,[866],"node_modules\\expo-router\\entry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  require(_dependencyMap[0], "@expo/metro-runtime");
  var _qualifiedEntry = require(_dependencyMap[1], "expo-router/build/qualified-entry");
  var _renderRootComponent = require(_dependencyMap[2], "expo-router/build/renderRootComponent");
  // `@expo/metro-runtime` MUST be the first import to ensure Fast Refresh works
  // on web.

  // This file should only import and register the root. No components or exports
  // should be added here.
  (0, _renderRootComponent.renderRootComponent)(_qualifiedEntry.App);
},866,[282,899,946],"node_modules\\expo-router\\entry-classic.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parse = parse;
  var UNKNOWN_FUNCTION = '<unknown>';
  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function (stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
      if (parseResult) {
        stack.push(parseResult);
      }
      return stack;
    }, []);
  }
  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
      return null;
    }
    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url

      parts[3] = submatch[2]; // line

      parts[4] = submatch[3]; // column
    }
    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }
  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
      return null;
    }
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }
  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }
  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
},867,[],"node_modules\\stacktrace-parser\\dist\\stack-trace-parser.esm.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _objectSpread2;
  var _defineProperty = _interopRequireDefault(require(_dependencyMap[1], "./defineProperty.js"));
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        (0, _defineProperty.default)(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
},868,[17,869],"node_modules\\@babel\\runtime\\helpers\\esm\\objectSpread2.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _defineProperty;
  var _toPropertyKey = _interopRequireDefault(require(_dependencyMap[1], "./toPropertyKey.js"));
  function _defineProperty(e, r, t) {
    return (r = (0, _toPropertyKey.default)(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
},869,[17,870],"node_modules\\@babel\\runtime\\helpers\\esm\\defineProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toPropertyKey;
  var _typeof2 = _interopRequireDefault(require(_dependencyMap[1], "./typeof.js"));
  var _toPrimitive = _interopRequireDefault(require(_dependencyMap[2], "./toPrimitive.js"));
  function toPropertyKey(t) {
    var i = (0, _toPrimitive.default)(t, "string");
    return "symbol" == (0, _typeof2.default)(i) ? i : i + "";
  }
},870,[17,871,872],"node_modules\\@babel\\runtime\\helpers\\esm\\toPropertyKey.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _typeof;
  function _typeof(o) {
    "@babel/helpers - typeof";

    return exports.default = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
},871,[],"node_modules\\@babel\\runtime\\helpers\\esm\\typeof.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toPrimitive;
  var _typeof2 = _interopRequireDefault(require(_dependencyMap[1], "./typeof.js"));
  function toPrimitive(t, r) {
    if ("object" != (0, _typeof2.default)(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != (0, _typeof2.default)(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
},872,[17,871],"node_modules\\@babel\\runtime\\helpers\\esm\\toPrimitive.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _objectWithoutPropertiesLoose;
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
},873,[],"node_modules\\@babel\\runtime\\helpers\\esm\\objectWithoutPropertiesLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "assignStyle", {
    enumerable: true,
    get: function () {
      return _assignStyle.default;
    }
  });
  Object.defineProperty(exports, "camelCaseProperty", {
    enumerable: true,
    get: function () {
      return _camelCaseProperty.default;
    }
  });
  Object.defineProperty(exports, "cssifyDeclaration", {
    enumerable: true,
    get: function () {
      return _cssifyDeclaration.default;
    }
  });
  Object.defineProperty(exports, "cssifyObject", {
    enumerable: true,
    get: function () {
      return _cssifyObject.default;
    }
  });
  Object.defineProperty(exports, "hyphenateProperty", {
    enumerable: true,
    get: function () {
      return _hyphenateProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedProperty", {
    enumerable: true,
    get: function () {
      return _isPrefixedProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedValue", {
    enumerable: true,
    get: function () {
      return _isPrefixedValue.default;
    }
  });
  Object.defineProperty(exports, "isUnitlessProperty", {
    enumerable: true,
    get: function () {
      return _isUnitlessProperty.default;
    }
  });
  Object.defineProperty(exports, "normalizeProperty", {
    enumerable: true,
    get: function () {
      return _normalizeProperty.default;
    }
  });
  Object.defineProperty(exports, "resolveArrayValue", {
    enumerable: true,
    get: function () {
      return _resolveArrayValue.default;
    }
  });
  Object.defineProperty(exports, "unprefixProperty", {
    enumerable: true,
    get: function () {
      return _unprefixProperty.default;
    }
  });
  Object.defineProperty(exports, "unprefixValue", {
    enumerable: true,
    get: function () {
      return _unprefixValue.default;
    }
  });
  var _assignStyle = _interopRequireDefault(require(_dependencyMap[1], "./assignStyle"));
  var _camelCaseProperty = _interopRequireDefault(require(_dependencyMap[2], "./camelCaseProperty"));
  var _cssifyDeclaration = _interopRequireDefault(require(_dependencyMap[3], "./cssifyDeclaration"));
  var _cssifyObject = _interopRequireDefault(require(_dependencyMap[4], "./cssifyObject"));
  var _hyphenateProperty = _interopRequireDefault(require(_dependencyMap[5], "./hyphenateProperty"));
  var _isPrefixedProperty = _interopRequireDefault(require(_dependencyMap[6], "./isPrefixedProperty"));
  var _isPrefixedValue = _interopRequireDefault(require(_dependencyMap[7], "./isPrefixedValue"));
  var _isUnitlessProperty = _interopRequireDefault(require(_dependencyMap[8], "./isUnitlessProperty"));
  var _normalizeProperty = _interopRequireDefault(require(_dependencyMap[9], "./normalizeProperty"));
  var _resolveArrayValue = _interopRequireDefault(require(_dependencyMap[10], "./resolveArrayValue"));
  var _unprefixProperty = _interopRequireDefault(require(_dependencyMap[11], "./unprefixProperty"));
  var _unprefixValue = _interopRequireDefault(require(_dependencyMap[12], "./unprefixValue"));
},874,[17,875,876,877,880,878,881,882,883,884,886,885,887],"node_modules\\css-in-js-utils\\es\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assignStyle;
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }
    return _typeof(obj);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function filterUniqueArray(arr) {
    return arr.filter(function (val, index) {
      return arr.lastIndexOf(val) === index;
    });
  }
  function assignStyle(base) {
    for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; ++i) {
      var style = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
      for (var property in style) {
        var value = style[property];
        var baseValue = base[property];
        if (baseValue && value) {
          if (Array.isArray(baseValue)) {
            base[property] = filterUniqueArray(baseValue.concat(value));
            continue;
          }
          if (Array.isArray(value)) {
            base[property] = filterUniqueArray([baseValue].concat(_toConsumableArray(value)));
            continue;
          }
          if (_typeof(value) === 'object') {
            base[property] = assignStyle({}, baseValue, value);
            continue;
          }
        }
        base[property] = value;
      }
    }
    return base;
  }
},875,[],"node_modules\\css-in-js-utils\\es\\assignStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = camelCaseProperty;
  var DASH = /-([a-z])/g;
  var MS = /^Ms/g;
  var cache = {};
  function toUpper(match) {
    return match[1].toUpperCase();
  }
  function camelCaseProperty(property) {
    if (cache.hasOwnProperty(property)) {
      return cache[property];
    }
    var camelProp = property.replace(DASH, toUpper).replace(MS, 'ms');
    cache[property] = camelProp;
    return camelProp;
  }
},876,[],"node_modules\\css-in-js-utils\\es\\camelCaseProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cssifyDeclaration;
  var _hyphenateProperty = _interopRequireDefault(require(_dependencyMap[1], "./hyphenateProperty"));
  function cssifyDeclaration(property, value) {
    return (0, _hyphenateProperty.default)(property) + ':' + value;
  }
},877,[17,878],"node_modules\\css-in-js-utils\\es\\cssifyDeclaration.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hyphenateProperty;
  var _hyphenateStyleName = _interopRequireDefault(require(_dependencyMap[1], "hyphenate-style-name"));
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName.default)(property);
  }
},878,[17,879],"node_modules\\css-in-js-utils\\es\\hyphenateProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (cache.hasOwnProperty(name)) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = exports.default = hyphenateStyleName;
},879,[],"node_modules\\hyphenate-style-name\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cssifyObject;
  var _cssifyDeclaration = _interopRequireDefault(require(_dependencyMap[1], "./cssifyDeclaration"));
  function cssifyObject(style) {
    var css = '';
    for (var property in style) {
      var value = style[property];
      if (typeof value !== 'string' && typeof value !== 'number') {
        continue;
      } // prevents the semicolon after
      // the last rule declaration

      if (css) {
        css += ';';
      }
      css += (0, _cssifyDeclaration.default)(property, value);
    }
    return css;
  }
},880,[17,877],"node_modules\\css-in-js-utils\\es\\cssifyObject.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedProperty;
  var RE = /^(Webkit|Moz|O|ms)/;
  function isPrefixedProperty(property) {
    return RE.test(property);
  }
},881,[],"node_modules\\css-in-js-utils\\es\\isPrefixedProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedValue;
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},882,[],"node_modules\\css-in-js-utils\\es\\isPrefixedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUnitlessProperty;
  var _hyphenateProperty = _interopRequireDefault(require(_dependencyMap[1], "./hyphenateProperty"));
  var unitlessProperties = {
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    fontWeight: true,
    lineHeight: true,
    opacity: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixedUnitlessProperties = ['animationIterationCount', 'boxFlex', 'boxFlexGroup', 'boxOrdinalGroup', 'columnCount', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexNegative', 'flexOrder', 'gridColumn', 'gridColumnEnd', 'gridColumnStart', 'gridRow', 'gridRowEnd', 'gridRowStart', 'lineClamp', 'order'];
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  function getPrefixedProperty(prefix, property) {
    return prefix + property.charAt(0).toUpperCase() + property.slice(1);
  } // add all prefixed properties to the unitless properties

  for (var i = 0, len = prefixedUnitlessProperties.length; i < len; ++i) {
    var property = prefixedUnitlessProperties[i];
    unitlessProperties[property] = true;
    for (var j = 0, jLen = prefixes.length; j < jLen; ++j) {
      unitlessProperties[getPrefixedProperty(prefixes[j], property)] = true;
    }
  } // add all hypenated properties as well

  for (var _property in unitlessProperties) {
    unitlessProperties[(0, _hyphenateProperty.default)(_property)] = true;
  }
  function isUnitlessProperty(property) {
    return unitlessProperties.hasOwnProperty(property);
  }
},883,[17,878],"node_modules\\css-in-js-utils\\es\\isUnitlessProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeProperty;
  var _camelCaseProperty = _interopRequireDefault(require(_dependencyMap[1], "./camelCaseProperty"));
  var _unprefixProperty = _interopRequireDefault(require(_dependencyMap[2], "./unprefixProperty"));
  function normalizeProperty(property) {
    return (0, _unprefixProperty.default)((0, _camelCaseProperty.default)(property));
  }
},884,[17,876,885],"node_modules\\css-in-js-utils\\es\\normalizeProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unprefixProperty;
  var RE = /^(ms|Webkit|Moz|O)/;
  function unprefixProperty(property) {
    var propertyWithoutPrefix = property.replace(RE, '');
    return propertyWithoutPrefix.charAt(0).toLowerCase() + propertyWithoutPrefix.slice(1);
  }
},885,[],"node_modules\\css-in-js-utils\\es\\unprefixProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = resolveArrayValue;
  var _hyphenateProperty = _interopRequireDefault(require(_dependencyMap[1], "./hyphenateProperty"));
  function resolveArrayValue(property, value) {
    return value.join(';' + (0, _hyphenateProperty.default)(property) + ':');
  }
},886,[17,878],"node_modules\\css-in-js-utils\\es\\resolveArrayValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unprefixValue;
  var RE = /(-ms-|-webkit-|-moz-|-o-)/g;
  function unprefixValue(value) {
    if (typeof value === 'string') {
      return value.replace(RE, '');
    }
    return value;
  }
},887,[],"node_modules\\css-in-js-utils\\es\\unprefixValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _extends;
  function _extends() {
    return exports.default = _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
},888,[],"node_modules\\@babel\\runtime\\helpers\\esm\\extends.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _createForOfIteratorHelperLoose;
  var _unsupportedIterableToArray = _interopRequireDefault(require(_dependencyMap[1], "./unsupportedIterableToArray.js"));
  function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = (0, _unsupportedIterableToArray.default)(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var o = 0;
      return function () {
        return o >= r.length ? {
          done: !0
        } : {
          done: !1,
          value: r[o++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
},889,[17,890],"node_modules\\@babel\\runtime\\helpers\\esm\\createForOfIteratorHelperLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _unsupportedIterableToArray;
  var _arrayLikeToArray = _interopRequireDefault(require(_dependencyMap[1], "./arrayLikeToArray.js"));
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return (0, _arrayLikeToArray.default)(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0, _arrayLikeToArray.default)(r, a) : void 0;
    }
  }
},890,[17,891],"node_modules\\@babel\\runtime\\helpers\\esm\\unsupportedIterableToArray.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _arrayLikeToArray;
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
},891,[],"node_modules\\@babel\\runtime\\helpers\\esm\\arrayLikeToArray.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = memoizeOne;
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === 'number' && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) {
      isEqual = areInputsEqual;
    }
    var cache = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
        return cache.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache = {
        lastResult: lastResult,
        lastArgs: newArgs,
        lastThis: this
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache = null;
    };
    return memoized;
  }
},892,[],"node_modules\\react-native-web\\node_modules\\memoize-one\\dist\\memoize-one.esm.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _SafeAreaContext = require(_dependencyMap[0], "./SafeAreaContext");
  Object.keys(_SafeAreaContext).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeAreaContext[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _SafeAreaContext[key];
      }
    });
  });
  var _SafeAreaView = require(_dependencyMap[1], "./SafeAreaView");
  Object.keys(_SafeAreaView).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeAreaView[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _SafeAreaView[key];
      }
    });
  });
  var _InitialWindow = require(_dependencyMap[2], "./InitialWindow");
  Object.keys(_InitialWindow).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _InitialWindow[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _InitialWindow[key];
      }
    });
  });
  var _SafeArea = require(_dependencyMap[3], "./SafeArea.types");
  Object.keys(_SafeArea).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeArea[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _SafeArea[key];
      }
    });
  });
},893,[894,896,897,898],"node_modules\\react-native-safe-area-context\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SafeAreaInsetsContext = exports.SafeAreaFrameContext = exports.SafeAreaContext = exports.SafeAreaConsumer = void 0;
  exports.SafeAreaProvider = SafeAreaProvider;
  exports.useSafeArea = useSafeArea;
  exports.useSafeAreaFrame = useSafeAreaFrame;
  exports.useSafeAreaInsets = useSafeAreaInsets;
  exports.withSafeAreaInsets = withSafeAreaInsets;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Dimensions = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Dimensions"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _NativeSafeAreaProvider = require(_dependencyMap[6], "./NativeSafeAreaProvider");
  const _excluded = ["children", "initialMetrics", "initialSafeAreaInsets", "style"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const isDev = process.env.NODE_ENV !== 'production';
  const SafeAreaInsetsContext = exports.SafeAreaInsetsContext = /*#__PURE__*/React.createContext(null);
  if (isDev) {
    SafeAreaInsetsContext.displayName = 'SafeAreaInsetsContext';
  }
  const SafeAreaFrameContext = exports.SafeAreaFrameContext = /*#__PURE__*/React.createContext(null);
  if (isDev) {
    SafeAreaFrameContext.displayName = 'SafeAreaFrameContext';
  }
  function SafeAreaProvider(_ref) {
    let {
        children,
        initialMetrics,
        initialSafeAreaInsets,
        style
      } = _ref,
      others = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const parentInsets = useParentSafeAreaInsets();
    const parentFrame = useParentSafeAreaFrame();
    const [insets, setInsets] = React.useState(initialMetrics?.insets ?? initialSafeAreaInsets ?? parentInsets ?? null);
    const [frame, setFrame] = React.useState(initialMetrics?.frame ?? parentFrame ?? {
      // Backwards compat so we render anyway if we don't have frame.
      x: 0,
      y: 0,
      width: _Dimensions.default.get('window').width,
      height: _Dimensions.default.get('window').height
    });
    const onInsetsChange = React.useCallback(event => {
      const {
        nativeEvent: {
          frame: nextFrame,
          insets: nextInsets
        }
      } = event;
      setFrame(curFrame => {
        if (
        // Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== curFrame.height || nextFrame.width !== curFrame.width || nextFrame.x !== curFrame.x || nextFrame.y !== curFrame.y)) {
          return nextFrame;
        } else {
          return curFrame;
        }
      });
      setInsets(curInsets => {
        if (!curInsets || nextInsets.bottom !== curInsets.bottom || nextInsets.left !== curInsets.left || nextInsets.right !== curInsets.right || nextInsets.top !== curInsets.top) {
          return nextInsets;
        } else {
          return curInsets;
        }
      });
    }, []);
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_NativeSafeAreaProvider.NativeSafeAreaProvider, _extends({
      style: [styles.fill, style],
      onInsetsChange: onInsetsChange
    }, others), insets != null ? /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SafeAreaFrameContext.Provider, {
      value: frame
    }, /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SafeAreaInsetsContext.Provider, {
      value: insets
    }, children)) : null);
  }
  const styles = _StyleSheet.default.create({
    fill: {
      flex: 1
    }
  });
  function useParentSafeAreaInsets() {
    return React.useContext(SafeAreaInsetsContext);
  }
  function useParentSafeAreaFrame() {
    return React.useContext(SafeAreaFrameContext);
  }
  const NO_INSETS_ERROR = 'No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.';
  function useSafeAreaInsets() {
    const insets = React.useContext(SafeAreaInsetsContext);
    if (insets == null) {
      throw new Error(NO_INSETS_ERROR);
    }
    return insets;
  }
  function useSafeAreaFrame() {
    const frame = React.useContext(SafeAreaFrameContext);
    if (frame == null) {
      throw new Error(NO_INSETS_ERROR);
    }
    return frame;
  }
  function withSafeAreaInsets(WrappedComponent) {
    return /*#__PURE__*/React.forwardRef((props, ref) => {
      const insets = useSafeAreaInsets();
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(WrappedComponent, _extends({}, props, {
        insets: insets,
        ref: ref
      }));
    });
  }

  /**
   * @deprecated
   */
  function useSafeArea() {
    return useSafeAreaInsets();
  }

  /**
   * @deprecated
   */
  const SafeAreaConsumer = exports.SafeAreaConsumer = SafeAreaInsetsContext.Consumer;

  /**
   * @deprecated
   */
  const SafeAreaContext = exports.SafeAreaContext = SafeAreaInsetsContext;
},894,[17,29,412,3,136,30,895],"node_modules\\react-native-safe-area-context\\lib\\module\\SafeAreaContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeSafeAreaProvider = NativeSafeAreaProvider;
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[1], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  /* eslint-env browser */

  /**
   * TODO:
   * Currently insets and frame are based on the window and are not
   * relative to the provider view. This is inconsistent with iOS and Android.
   * However in most cases if the provider view covers the screen this is not
   * an issue.
   */

  const CSSTransitions = {
    WebkitTransition: 'webkitTransitionEnd',
    Transition: 'transitionEnd',
    MozTransition: 'transitionend',
    MSTransition: 'msTransitionEnd',
    OTransition: 'oTransitionEnd'
  };
  function NativeSafeAreaProvider({
    children,
    style,
    onInsetsChange
  }) {
    React.useEffect(() => {
      // Skip for SSR.
      if (typeof document === 'undefined') {
        return;
      }
      const element = createContextElement();
      document.body.appendChild(element);
      const onEnd = () => {
        const {
          paddingTop,
          paddingBottom,
          paddingLeft,
          paddingRight
        } = window.getComputedStyle(element);
        const insets = {
          top: paddingTop ? parseInt(paddingTop, 10) : 0,
          bottom: paddingBottom ? parseInt(paddingBottom, 10) : 0,
          left: paddingLeft ? parseInt(paddingLeft, 10) : 0,
          right: paddingRight ? parseInt(paddingRight, 10) : 0
        };
        const frame = {
          x: 0,
          y: 0,
          width: document.documentElement.offsetWidth,
          height: document.documentElement.offsetHeight
        };
        // @ts-ignore: missing properties
        onInsetsChange({
          nativeEvent: {
            insets,
            frame
          }
        });
      };
      element.addEventListener(getSupportedTransitionEvent(), onEnd);
      onEnd();
      return () => {
        document.body.removeChild(element);
        element.removeEventListener(getSupportedTransitionEvent(), onEnd);
      };
    }, [onInsetsChange]);
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, {
      style: style
    }, children);
  }
  let _supportedTransitionEvent = null;
  function getSupportedTransitionEvent() {
    if (_supportedTransitionEvent != null) {
      return _supportedTransitionEvent;
    }
    const element = document.createElement('invalidtype');
    _supportedTransitionEvent = CSSTransitions.Transition;
    for (const key in CSSTransitions) {
      if (element.style[key] !== undefined) {
        _supportedTransitionEvent = CSSTransitions[key];
        break;
      }
    }
    return _supportedTransitionEvent;
  }
  let _supportedEnv = null;
  function getSupportedEnv() {
    if (_supportedEnv !== null) {
      return _supportedEnv;
    }
    const {
      CSS
    } = window;
    if (CSS && CSS.supports && CSS.supports('top: constant(safe-area-inset-top)')) {
      _supportedEnv = 'constant';
    } else {
      _supportedEnv = 'env';
    }
    return _supportedEnv;
  }
  function getInset(side) {
    return `${getSupportedEnv()}(safe-area-inset-${side})`;
  }
  function createContextElement() {
    const element = document.createElement('div');
    const {
      style
    } = element;
    style.position = 'fixed';
    style.left = '0';
    style.top = '0';
    style.width = '0';
    style.height = '0';
    style.zIndex = '-1';
    style.overflow = 'hidden';
    style.visibility = 'hidden';
    // Bacon: Anything faster than this and the callback will be invoked too early with the wrong insets
    style.transitionDuration = '0.05s';
    style.transitionProperty = 'padding';
    style.transitionDelay = '0s';
    style.paddingTop = getInset('top');
    style.paddingBottom = getInset('bottom');
    style.paddingLeft = getInset('left');
    style.paddingRight = getInset('right');
    return element;
  }
},895,[17,412,3,111],"node_modules\\react-native-safe-area-context\\lib\\module\\NativeSafeAreaProvider.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SafeAreaView = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/View"));
  var _SafeAreaContext = require(_dependencyMap[6], "./SafeAreaContext");
  const _excluded = ["style", "mode", "edges"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const defaultEdges = {
    top: 'additive',
    left: 'additive',
    bottom: 'additive',
    right: 'additive'
  };
  function getEdgeValue(inset, current, mode) {
    switch (mode) {
      case 'off':
        return current;
      case 'maximum':
        return Math.max(current, inset);
      case 'additive':
      default:
        return current + inset;
    }
  }
  const SafeAreaView = exports.SafeAreaView = /*#__PURE__*/React.forwardRef((_ref, ref) => {
    let {
        style = {},
        mode,
        edges
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const insets = (0, _SafeAreaContext.useSafeAreaInsets)();
    const edgesRecord = React.useMemo(() => {
      if (edges == null) {
        return defaultEdges;
      }
      return Array.isArray(edges) ? edges.reduce((acc, edge) => {
        acc[edge] = 'additive';
        return acc;
      }, {}) :
      // ts has trouble with refining readonly arrays.
      edges;
    }, [edges]);
    const appliedStyle = React.useMemo(() => {
      const flatStyle = _StyleSheet.default.flatten(style);
      if (mode === 'margin') {
        const {
          margin = 0,
          marginVertical = margin,
          marginHorizontal = margin,
          marginTop = marginVertical,
          marginRight = marginHorizontal,
          marginBottom = marginVertical,
          marginLeft = marginHorizontal
        } = flatStyle;
        const marginStyle = {
          marginTop: getEdgeValue(insets.top, marginTop, edgesRecord.top),
          marginRight: getEdgeValue(insets.right, marginRight, edgesRecord.right),
          marginBottom: getEdgeValue(insets.bottom, marginBottom, edgesRecord.bottom),
          marginLeft: getEdgeValue(insets.left, marginLeft, edgesRecord.left)
        };
        return [style, marginStyle];
      } else {
        const {
          padding = 0,
          paddingVertical = padding,
          paddingHorizontal = padding,
          paddingTop = paddingVertical,
          paddingRight = paddingHorizontal,
          paddingBottom = paddingVertical,
          paddingLeft = paddingHorizontal
        } = flatStyle;
        const paddingStyle = {
          paddingTop: getEdgeValue(insets.top, paddingTop, edgesRecord.top),
          paddingRight: getEdgeValue(insets.right, paddingRight, edgesRecord.right),
          paddingBottom: getEdgeValue(insets.bottom, paddingBottom, edgesRecord.bottom),
          paddingLeft: getEdgeValue(insets.left, paddingLeft, edgesRecord.left)
        };
        return [style, paddingStyle];
      }
    }, [edgesRecord.bottom, edgesRecord.left, edgesRecord.right, edgesRecord.top, insets.bottom, insets.left, insets.right, insets.top, mode, style]);
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, _extends({
      style: appliedStyle
    }, rest, {
      ref: ref
    }));
  });
},896,[17,29,412,3,30,111,894],"node_modules\\react-native-safe-area-context\\lib\\module\\SafeAreaView.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initialWindowSafeAreaInsets = exports.initialWindowMetrics = void 0;
  const initialWindowMetrics = exports.initialWindowMetrics = null;

  /**
   * @deprecated
   */
  const initialWindowSafeAreaInsets = exports.initialWindowSafeAreaInsets = null;
},897,[],"node_modules\\react-native-safe-area-context\\lib\\module\\InitialWindow.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},898,[],"node_modules\\react-native-safe-area-context\\lib\\module\\SafeArea.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // The entry component (one that uses context modules) cannot be in the same file as the
  // entry side-effects, otherwise they'll be updated when files are added/removed from the
  // app directory. This will cause a lot of unfortunate errors regarding HMR and Fast Refresh.
  // This is because Fast Refresh is sending the entire file containing an updated component.
  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\qualified-entry.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.App = App;
  // This has to be the string "expo-router/_ctx" as we resolve the exact string to
  // a different file in a custom resolver for bundle splitting in Node.js.
  const _ctx_1 = require(_dependencyMap[1], "expo-router/_ctx");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const ExpoRoot_1 = require(_dependencyMap[3], "./ExpoRoot");
  const head_1 = require(_dependencyMap[4], "./head");
  require(_dependencyMap[5], "./fast-refresh");
  // Must be exported or Fast Refresh won't update the context
  function App() {
    return _reactNativeCssInteropJsxRuntime.jsx(head_1.Head.Provider, {
      children: _reactNativeCssInteropJsxRuntime.jsx(ExpoRoot_1.ExpoRoot, {
        context: _ctx_1.ctx
      })
    });
  }
},899,[2,532,3,715,848,945],"node_modules\\expo-router\\build\\qualified-entry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.nanoid = exports.customAlphabet = void 0;
  let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
  let customAlphabet = (alphabet, defaultSize = 21) => {
    return (size = defaultSize) => {
      let id = '';
      let i = size | 0;
      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }
      return id;
    };
  };
  exports.customAlphabet = customAlphabet;
  let nanoid = (size = 21) => {
    let id = '';
    let i = size | 0;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
  exports.nanoid = nanoid;
},900,[],"node_modules\\nanoid\\non-secure\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    enableScreens: true,
    enableFreeze: true,
    screensEnabled: true,
    freezeEnabled: true,
    Screen: true,
    InnerScreen: true,
    ScreenContext: true,
    ScreenStackHeaderConfig: true,
    ScreenStackHeaderSubview: true,
    ScreenStackHeaderLeftView: true,
    ScreenStackHeaderCenterView: true,
    ScreenStackHeaderRightView: true,
    ScreenStackHeaderBackButtonImage: true,
    ScreenStackHeaderSearchBarView: true,
    SearchBar: true,
    ScreenContainer: true,
    ScreenStack: true,
    ScreenStackItem: true,
    FullWindowOverlay: true,
    ScreenFooter: true,
    ScreenContentWrapper: true,
    isSearchBarAvailableForCurrentPlatform: true,
    compatibilityFlags: true,
    executeNativeBackPress: true,
    useTransitionProgress: true
  };
  Object.defineProperty(exports, "FullWindowOverlay", {
    enumerable: true,
    get: function () {
      return _FullWindowOverlay.default;
    }
  });
  Object.defineProperty(exports, "InnerScreen", {
    enumerable: true,
    get: function () {
      return _Screen.InnerScreen;
    }
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function () {
      return _Screen.default;
    }
  });
  Object.defineProperty(exports, "ScreenContainer", {
    enumerable: true,
    get: function () {
      return _ScreenContainer.default;
    }
  });
  Object.defineProperty(exports, "ScreenContentWrapper", {
    enumerable: true,
    get: function () {
      return _ScreenContentWrapper.default;
    }
  });
  Object.defineProperty(exports, "ScreenContext", {
    enumerable: true,
    get: function () {
      return _Screen.ScreenContext;
    }
  });
  Object.defineProperty(exports, "ScreenFooter", {
    enumerable: true,
    get: function () {
      return _ScreenFooter.default;
    }
  });
  Object.defineProperty(exports, "ScreenStack", {
    enumerable: true,
    get: function () {
      return _ScreenStack.default;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderBackButtonImage", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderBackButtonImage;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderCenterView", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderCenterView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderConfig", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderConfig;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderLeftView", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderLeftView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderRightView", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderRightView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSearchBarView", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderSearchBarView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSubview", {
    enumerable: true,
    get: function () {
      return _ScreenStackHeaderConfig.ScreenStackHeaderSubview;
    }
  });
  Object.defineProperty(exports, "ScreenStackItem", {
    enumerable: true,
    get: function () {
      return _ScreenStackItem.default;
    }
  });
  Object.defineProperty(exports, "SearchBar", {
    enumerable: true,
    get: function () {
      return _SearchBar.default;
    }
  });
  Object.defineProperty(exports, "compatibilityFlags", {
    enumerable: true,
    get: function () {
      return _utils.compatibilityFlags;
    }
  });
  Object.defineProperty(exports, "enableFreeze", {
    enumerable: true,
    get: function () {
      return _core.enableFreeze;
    }
  });
  Object.defineProperty(exports, "enableScreens", {
    enumerable: true,
    get: function () {
      return _core.enableScreens;
    }
  });
  Object.defineProperty(exports, "executeNativeBackPress", {
    enumerable: true,
    get: function () {
      return _utils.executeNativeBackPress;
    }
  });
  Object.defineProperty(exports, "freezeEnabled", {
    enumerable: true,
    get: function () {
      return _core.freezeEnabled;
    }
  });
  Object.defineProperty(exports, "isSearchBarAvailableForCurrentPlatform", {
    enumerable: true,
    get: function () {
      return _utils.isSearchBarAvailableForCurrentPlatform;
    }
  });
  Object.defineProperty(exports, "screensEnabled", {
    enumerable: true,
    get: function () {
      return _core.screensEnabled;
    }
  });
  Object.defineProperty(exports, "useTransitionProgress", {
    enumerable: true,
    get: function () {
      return _useTransitionProgress.default;
    }
  });
  require(_dependencyMap[1], "./fabric/NativeScreensModule");
  var _types = require(_dependencyMap[2], "./types");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  var _core = require(_dependencyMap[3], "./core");
  var _Screen = _interopRequireWildcard(require(_dependencyMap[4], "./components/Screen"));
  var _ScreenStackHeaderConfig = require(_dependencyMap[5], "./components/ScreenStackHeaderConfig");
  var _SearchBar = _interopRequireDefault(require(_dependencyMap[6], "./components/SearchBar"));
  var _ScreenContainer = _interopRequireDefault(require(_dependencyMap[7], "./components/ScreenContainer"));
  var _ScreenStack = _interopRequireDefault(require(_dependencyMap[8], "./components/ScreenStack"));
  var _ScreenStackItem = _interopRequireDefault(require(_dependencyMap[9], "./components/ScreenStackItem"));
  var _FullWindowOverlay = _interopRequireDefault(require(_dependencyMap[10], "./components/FullWindowOverlay"));
  var _ScreenFooter = _interopRequireDefault(require(_dependencyMap[11], "./components/ScreenFooter"));
  var _ScreenContentWrapper = _interopRequireDefault(require(_dependencyMap[12], "./components/ScreenContentWrapper"));
  var _utils = require(_dependencyMap[13], "./utils");
  var _useTransitionProgress = _interopRequireDefault(require(_dependencyMap[14], "./useTransitionProgress"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
},901,[17,902,903,904,905,906,907,908,909,910,915,914,912,916,917],"node_modules\\react-native-screens\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _default = exports.default = {};
},902,[],"node_modules\\react-native-screens\\lib\\module\\fabric\\NativeScreensModule.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},903,[],"node_modules\\react-native-screens\\lib\\module\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.enableFreeze = enableFreeze;
  exports.enableScreens = enableScreens;
  exports.freezeEnabled = freezeEnabled;
  exports.isNativePlatformSupported = void 0;
  exports.screensEnabled = screensEnabled;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Platform"));
  var _UIManager = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/UIManager"));
  const isNativePlatformSupported = exports.isNativePlatformSupported = _Platform.default.OS === 'ios' || _Platform.default.OS === 'android' || _Platform.default.OS === 'windows';
  let ENABLE_SCREENS = isNativePlatformSupported;
  function enableScreens(shouldEnableScreens = true) {
    ENABLE_SCREENS = shouldEnableScreens;
    if (!isNativePlatformSupported) {
      return;
    }
    if (ENABLE_SCREENS && !_UIManager.default.getViewManagerConfig('RNSScreen')) {
      console.error(`Screen native module hasn't been linked. Please check the react-native-screens README for more details`);
    }
  }
  let ENABLE_FREEZE = false;
  function enableFreeze(shouldEnableReactFreeze = true) {
    if (!isNativePlatformSupported) {
      return;
    }
    ENABLE_FREEZE = shouldEnableReactFreeze;
  }
  function screensEnabled() {
    return ENABLE_SCREENS;
  }
  function freezeEnabled() {
    return ENABLE_FREEZE;
  }
},904,[17,106,97],"node_modules\\react-native-screens\\lib\\module\\core.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.ScreenContext = exports.NativeScreen = exports.InnerScreen = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var _Animated = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Animated"));
  var _View = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/View"));
  var _react = _interopRequireDefault(require(_dependencyMap[5], "react"));
  var _core = require(_dependencyMap[6], "../core");
  const _excluded = ["active", "activityState", "style", "enabled"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const InnerScreen = exports.InnerScreen = _View.default;

  // We're using class component here because of the error from reanimated:
  // createAnimatedComponent` does not support stateless functional components; use a class component instead.
  // NOTE: React Server Components do not support class components.
  class NativeScreen extends _react.default.Component {
    render() {
      let _this$props = this.props,
        {
          active,
          activityState,
          style,
          enabled = (0, _core.screensEnabled)()
        } = _this$props,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
      if (enabled) {
        if (active !== undefined && activityState === undefined) {
          activityState = active !== 0 ? 2 : 0; // change taken from index.native.tsx
        }
        return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default
        // @ts-expect-error: hidden exists on web, but not in React Native
        , _extends({
          hidden: activityState === 0,
          style: [style, {
            display: activityState !== 0 ? 'flex' : 'none'
          }]
        }, rest));
      }
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, rest);
    }
  }
  exports.NativeScreen = NativeScreen;
  const Screen = _Animated.default.createAnimatedComponent(NativeScreen);
  const ScreenContext = exports.ScreenContext = /*#__PURE__*/_react.default.createContext(Screen);
  var _default = exports.default = Screen;
},905,[17,29,412,104,111,3,904],"node_modules\\react-native-screens\\lib\\module\\components\\Screen.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScreenStackHeaderSubview = exports.ScreenStackHeaderSearchBarView = exports.ScreenStackHeaderRightView = exports.ScreenStackHeaderLeftView = exports.ScreenStackHeaderConfig = exports.ScreenStackHeaderCenterView = exports.ScreenStackHeaderBackButtonImage = void 0;
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[1], "react-native-css-interop"));
  var _Image = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Image"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _react = _interopRequireDefault(require(_dependencyMap[4], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const ScreenStackHeaderBackButtonImage = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, null, /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_Image.default, _extends({
    resizeMode: "center",
    fadeDuration: 0
  }, props)));
  exports.ScreenStackHeaderBackButtonImage = ScreenStackHeaderBackButtonImage;
  const ScreenStackHeaderRightView = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, props);
  exports.ScreenStackHeaderRightView = ScreenStackHeaderRightView;
  const ScreenStackHeaderLeftView = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, props);
  exports.ScreenStackHeaderLeftView = ScreenStackHeaderLeftView;
  const ScreenStackHeaderCenterView = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, props);
  exports.ScreenStackHeaderCenterView = ScreenStackHeaderCenterView;
  const ScreenStackHeaderSearchBarView = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, props);
  exports.ScreenStackHeaderSearchBarView = ScreenStackHeaderSearchBarView;
  const ScreenStackHeaderConfig = props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_View.default, props);
  exports.ScreenStackHeaderConfig = ScreenStackHeaderConfig;
  const ScreenStackHeaderSubview = exports.ScreenStackHeaderSubview = _View.default;
},906,[17,412,180,111,3],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenStackHeaderConfig.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  const SearchBar = _View.default;
  var _default = exports.default = SearchBar;
},907,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\SearchBar.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  const ScreenContainer = _View.default;
  var _default = exports.default = ScreenContainer;
},908,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenContainer.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  const ScreenStack = _View.default;
  var _default = exports.default = ScreenStack;
},909,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenStack.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[2], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[3], "react"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Platform"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _warnOnce = _interopRequireDefault(require(_dependencyMap[6], "warn-once"));
  var _DebugContainer = _interopRequireDefault(require(_dependencyMap[7], "./DebugContainer"));
  var _ScreenStackHeaderConfig = require(_dependencyMap[8], "./ScreenStackHeaderConfig");
  var _Screen = _interopRequireDefault(require(_dependencyMap[9], "./Screen"));
  var _ScreenStack = _interopRequireDefault(require(_dependencyMap[10], "./ScreenStack"));
  var _contexts = require(_dependencyMap[11], "../contexts");
  var _ScreenFooter = require(_dependencyMap[12], "./ScreenFooter");
  const _excluded = ["children", "headerConfig", "activityState", "shouldFreeze", "stackPresentation", "sheetAllowedDetents", "contentStyle", "style", "screenId", "unstable_sheetFooter"];
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function ScreenStackItem(_ref, ref) {
    let {
        children,
        headerConfig,
        activityState,
        shouldFreeze,
        stackPresentation,
        sheetAllowedDetents,
        contentStyle,
        style,
        screenId,
        // eslint-disable-next-line camelcase
        unstable_sheetFooter
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    const currentScreenRef = React.useRef(null);
    const screenRefs = React.useContext(_contexts.RNSScreensRefContext);
    React.useImperativeHandle(ref, () => currentScreenRef.current);
    const isHeaderInModal = _Platform.default.OS === 'android' ? false : stackPresentation !== 'push' && headerConfig?.hidden === false;
    const headerHiddenPreviousRef = React.useRef(headerConfig?.hidden);
    React.useEffect(() => {
      (0, _warnOnce.default)(_Platform.default.OS !== 'android' && stackPresentation !== 'push' && headerHiddenPreviousRef.current !== headerConfig?.hidden, `Dynamically changing header's visibility in modals will result in remounting the screen and losing all local state.`);
      headerHiddenPreviousRef.current = headerConfig?.hidden;
    }, [headerConfig?.hidden, stackPresentation]);
    const content = /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(React.Fragment, null, /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_DebugContainer.default, {
      style: [stackPresentation === 'formSheet' ? _Platform.default.OS === 'ios' ? styles.absolute : sheetAllowedDetents === 'fitToContents' ? null : styles.container : styles.container, contentStyle],
      stackPresentation: stackPresentation ?? 'push'
    }, children), /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_ScreenStackHeaderConfig.ScreenStackHeaderConfig, headerConfig), stackPresentation === 'formSheet' && unstable_sheetFooter && /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_ScreenFooter.FooterComponent, null, unstable_sheetFooter()));

    // We take backgroundColor from contentStyle and apply it on Screen.
    // This allows to workaround one issue with truncated
    // content with formSheet presentation.
    let internalScreenStyle;
    if (stackPresentation === 'formSheet' && contentStyle) {
      const flattenContentStyles = _StyleSheet.default.flatten(contentStyle);
      internalScreenStyle = {
        backgroundColor: flattenContentStyles?.backgroundColor
      };
    }
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_Screen.default, _extends({
      ref: node => {
        currentScreenRef.current = node;
        if (screenRefs === null) {
          console.warn('Looks like RNSScreensRefContext is missing. Make sure the ScreenStack component is wrapped in it');
          return;
        }
        const currentRefs = screenRefs.current;
        if (node === null) {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete currentRefs[screenId];
        } else {
          currentRefs[screenId] = {
            current: node
          };
        }
      },
      enabled: true,
      isNativeStack: true,
      activityState: activityState,
      shouldFreeze: shouldFreeze,
      stackPresentation: stackPresentation,
      hasLargeHeader: headerConfig?.largeTitle ?? false,
      sheetAllowedDetents: sheetAllowedDetents,
      style: [style, internalScreenStyle]
    }, rest), isHeaderInModal ? /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_ScreenStack.default, {
      style: styles.container
    }, /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_Screen.default, {
      enabled: true,
      isNativeStack: true,
      activityState: activityState,
      shouldFreeze: shouldFreeze,
      hasLargeHeader: headerConfig?.largeTitle ?? false,
      style: _StyleSheet.default.absoluteFill
    }, content)) : content);
  }
  var _default = exports.default = /*#__PURE__*/React.forwardRef(ScreenStackItem);
  const styles = _StyleSheet.default.create({
    container: {
      flex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      start: 0,
      end: 0
    }
  });
},910,[17,29,412,3,106,30,618,911,906,905,909,913,914],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenStackItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = DebugContainer;
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[1], "react-native-css-interop"));
  var React = _interopRequireWildcard(require(_dependencyMap[2], "react"));
  var _ScreenContentWrapper = _interopRequireDefault(require(_dependencyMap[3], "./ScreenContentWrapper"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function DebugContainer(props) {
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_ScreenContentWrapper.default, props);
  }
},911,[17,412,3,912],"node_modules\\react-native-screens\\lib\\module\\components\\DebugContainer.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  const ScreenContentWrapper = _View.default;
  var _default = exports.default = ScreenContentWrapper;
},912,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenContentWrapper.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RNSScreensRefContext = exports.GHContext = void 0;
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[1], "react-native-css-interop"));
  var _react = _interopRequireDefault(require(_dependencyMap[2], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  const GHContext = exports.GHContext = /*#__PURE__*/_react.default.createContext(props => /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(_react.default.Fragment, null, props.children));
  const RNSScreensRefContext = exports.RNSScreensRefContext = /*#__PURE__*/_react.default.createContext(null);
},913,[17,412,3],"node_modules\\react-native-screens\\lib\\module\\contexts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.FooterComponent = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  const ScreenFooter = _View.default;
  const FooterComponent = exports.FooterComponent = _View.default;
  var _default = exports.default = ScreenFooter;
},914,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\ScreenFooter.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _View = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/View"));
  var _default = exports.default = _View.default;
},915,[17,111],"node_modules\\react-native-screens\\lib\\module\\components\\FullWindowOverlay.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.compatibilityFlags = void 0;
  exports.executeNativeBackPress = executeNativeBackPress;
  exports.isSearchBarAvailableForCurrentPlatform = void 0;
  var _BackHandler = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/BackHandler"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Platform"));
  const isSearchBarAvailableForCurrentPlatform = exports.isSearchBarAvailableForCurrentPlatform = ['ios', 'android'].includes(_Platform.default.OS);
  function executeNativeBackPress() {
    // This function invokes the native back press event
    _BackHandler.default.exitApp();
    return true;
  }

  /**
   * Exposes information useful for downstream navigation library implementers,
   * so they can keep reasonable backward compatibility, if desired.
   *
   * We don't mean for this object to only grow in number of fields, however at the same time
   * we won't be very hasty to reduce it. Expect gradual changes.
   */
  const compatibilityFlags = exports.compatibilityFlags = {
    /**
     * Because of a bug introduced in https://github.com/software-mansion/react-native-screens/pull/1646
     * react-native-screens v3.21 changed how header's backTitle handles whitespace strings in https://github.com/software-mansion/react-native-screens/pull/1726
     * To allow for backwards compatibility in @react-navigation/native-stack we need a way to check if this version or newer is used.
     * See https://github.com/react-navigation/react-navigation/pull/11423 for more context.
     */
    isNewBackTitleImplementation: true,
    /**
     * With version 4.0.0 the header implementation has been changed. To allow for backward compat
     * with native-stack@v6 we want to expose a way to check whether the new implementation
     * is in use or not.
     *
     * See:
     * * https://github.com/software-mansion/react-native-screens/pull/2325
     * * https://github.com/react-navigation/react-navigation/pull/12125
     */
    usesHeaderFlexboxImplementation: true
  };
},916,[17,216,106],"node_modules\\react-native-screens\\lib\\module\\utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useTransitionProgress;
  var React = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _TransitionProgressContext = _interopRequireDefault(require(_dependencyMap[2], "./TransitionProgressContext"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useTransitionProgress() {
    const progress = React.useContext(_TransitionProgressContext.default);
    if (progress === undefined) {
      throw new Error("Couldn't find values for transition progress. Are you inside a screen in Native Stack?");
    }
    return progress;
  }
},917,[17,3,918],"node_modules\\react-native-screens\\lib\\module\\useTransitionProgress.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var React = _interopRequireWildcard(require(_dependencyMap[0], "react"));
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  var _default = exports.default = /*#__PURE__*/React.createContext(undefined);
},918,[3],"node_modules\\react-native-screens\\lib\\module\\TransitionProgressContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var invariant = function (condition, format, a, b, c, d, e, f) {
    if (process.env.NODE_ENV !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  module.exports = invariant;
},919,[],"node_modules\\invariant\\browser.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEdgeToEdge = exports.controlEdgeToEdgeValues = void 0;
  // src/index.ts
  var isEdgeToEdge = () => true;
  exports.isEdgeToEdge = isEdgeToEdge;
  var controlEdgeToEdgeValues = values => {};
  exports.controlEdgeToEdgeValues = controlEdgeToEdgeValues;
},920,[],"node_modules\\react-native-is-edge-to-edge\\dist\\index.mjs");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {};
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _ReactNativeSVG.default;
    }
  });
  var _ReactNativeSVG = _interopRequireWildcard(require(_dependencyMap[0], "./ReactNativeSVG"));
  Object.keys(_ReactNativeSVG).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _ReactNativeSVG[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _ReactNativeSVG[key];
      }
    });
  });
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
},921,[922],"node_modules\\react-native-svg\\lib\\module\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    camelCase: true,
    parse: true,
    SvgAst: true,
    SvgFromUri: true,
    SvgFromXml: true,
    SvgUri: true,
    SvgXml: true,
    fetchText: true,
    inlineStyles: true,
    loadLocalRawResource: true,
    LocalSvg: true,
    SvgCss: true,
    SvgCssUri: true,
    SvgWithCss: true,
    SvgWithCssUri: true,
    WithLocalSvg: true
  };
  Object.defineProperty(exports, "LocalSvg", {
    enumerable: true,
    get: function () {
      return _deprecated.LocalSvg;
    }
  });
  Object.defineProperty(exports, "SvgAst", {
    enumerable: true,
    get: function () {
      return _xml.SvgAst;
    }
  });
  Object.defineProperty(exports, "SvgCss", {
    enumerable: true,
    get: function () {
      return _deprecated.SvgCss;
    }
  });
  Object.defineProperty(exports, "SvgCssUri", {
    enumerable: true,
    get: function () {
      return _deprecated.SvgCssUri;
    }
  });
  Object.defineProperty(exports, "SvgFromUri", {
    enumerable: true,
    get: function () {
      return _xml.SvgFromUri;
    }
  });
  Object.defineProperty(exports, "SvgFromXml", {
    enumerable: true,
    get: function () {
      return _xml.SvgFromXml;
    }
  });
  Object.defineProperty(exports, "SvgUri", {
    enumerable: true,
    get: function () {
      return _xml.SvgUri;
    }
  });
  Object.defineProperty(exports, "SvgWithCss", {
    enumerable: true,
    get: function () {
      return _deprecated.SvgWithCss;
    }
  });
  Object.defineProperty(exports, "SvgWithCssUri", {
    enumerable: true,
    get: function () {
      return _deprecated.SvgWithCssUri;
    }
  });
  Object.defineProperty(exports, "SvgXml", {
    enumerable: true,
    get: function () {
      return _xml.SvgXml;
    }
  });
  Object.defineProperty(exports, "WithLocalSvg", {
    enumerable: true,
    get: function () {
      return _deprecated.WithLocalSvg;
    }
  });
  Object.defineProperty(exports, "camelCase", {
    enumerable: true,
    get: function () {
      return _xml.camelCase;
    }
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _elements.default;
    }
  });
  Object.defineProperty(exports, "fetchText", {
    enumerable: true,
    get: function () {
      return _fetchData.fetchText;
    }
  });
  Object.defineProperty(exports, "inlineStyles", {
    enumerable: true,
    get: function () {
      return _deprecated.inlineStyles;
    }
  });
  Object.defineProperty(exports, "loadLocalRawResource", {
    enumerable: true,
    get: function () {
      return _deprecated.loadLocalRawResource;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return _xml.parse;
    }
  });
  var _xml = require(_dependencyMap[0], "./xml");
  var _fetchData = require(_dependencyMap[1], "./utils/fetchData");
  var _deprecated = require(_dependencyMap[2], "./deprecated");
  var _types = require(_dependencyMap[3], "./lib/extract/types");
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });
  var _elements = _interopRequireWildcard(require(_dependencyMap[4], "./elements"));
  Object.keys(_elements).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _elements[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _elements[key];
      }
    });
  });
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
},922,[923,924,943,944,929],"node_modules\\react-native-svg\\lib\\module\\ReactNativeSVG.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SvgAst = SvgAst;
  exports.SvgFromXml = exports.SvgFromUri = void 0;
  exports.SvgUri = SvgUri;
  exports.SvgXml = SvgXml;
  exports.astToReact = astToReact;
  exports.camelCase = void 0;
  exports.getStyle = getStyle;
  exports.parse = parse;
  Object.defineProperty(exports, "tags", {
    enumerable: true,
    get: function () {
      return _xmlTags.tags;
    }
  });
  var _ReactNativeCSSInterop = _interopRequireWildcard(require(_dependencyMap[0], "react-native-css-interop"));
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var React = _react;
  var _fetchData = require(_dependencyMap[2], "./utils/fetchData");
  var _xmlTags = require(_dependencyMap[3], "./xmlTags");
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function missingTag() {
    return null;
  }
  function SvgAst({
    ast,
    override
  }) {
    if (!ast) {
      return null;
    }
    const {
      props,
      children
    } = ast;
    const Svg = _xmlTags.tags.svg;
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(Svg, _extends({}, props, override), children);
  }
  const err = console.error.bind(console);
  function SvgXml(props) {
    const {
      onError = err,
      xml,
      override,
      fallback
    } = props;
    try {
      const ast = (0, _react.useMemo)(() => xml !== null ? parse(xml) : null, [xml]);
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SvgAst, {
        ast: ast,
        override: override || props
      });
    } catch (error) {
      onError(error);
      return fallback ?? null;
    }
  }
  function SvgUri(props) {
    const {
      onError = err,
      uri,
      onLoad,
      fallback
    } = props;
    const [xml, setXml] = (0, _react.useState)(null);
    const [isError, setIsError] = (0, _react.useState)(false);
    (0, _react.useEffect)(() => {
      uri ? (0, _fetchData.fetchText)(uri).then(data => {
        setXml(data);
        isError && setIsError(false);
        onLoad === null || onLoad === void 0 || onLoad();
      }).catch(e => {
        onError(e);
        setIsError(true);
      }) : setXml(null);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [onError, uri, onLoad]);
    if (isError) {
      return fallback ?? null;
    }
    return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SvgXml, {
      xml: xml,
      override: props,
      fallback: fallback
    });
  }

  // Extending Component is required for Animated support.

  class SvgFromXml extends _react.Component {
    state = {
      ast: null
    };
    componentDidMount() {
      this.parse(this.props.xml);
    }
    componentDidUpdate(prevProps) {
      const {
        xml
      } = this.props;
      if (xml !== prevProps.xml) {
        this.parse(xml);
      }
    }
    parse(xml) {
      const {
        onError = err
      } = this.props;
      try {
        this.setState({
          ast: xml ? parse(xml) : null
        });
      } catch (e) {
        const error = e;
        onError(Object.assign({}, error, {
          message: `[RNSVG] Couldn't parse SVG, reason: ${error.message}`
        }));
      }
    }
    render() {
      const {
        props,
        state: {
          ast
        }
      } = this;
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SvgAst, {
        ast: ast,
        override: props.override || props
      });
    }
  }
  exports.SvgFromXml = SvgFromXml;
  class SvgFromUri extends _react.Component {
    state = {
      xml: null
    };
    componentDidMount() {
      this.fetch(this.props.uri);
    }
    componentDidUpdate(prevProps) {
      const {
        uri
      } = this.props;
      if (uri !== prevProps.uri) {
        this.fetch(uri);
      }
    }
    async fetch(uri) {
      try {
        this.setState({
          xml: uri ? await (0, _fetchData.fetchText)(uri) : null
        });
      } catch (e) {
        console.error(e);
      }
    }
    render() {
      const {
        props,
        state: {
          xml
        }
      } = this;
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(SvgFromXml, {
        xml: xml,
        override: props,
        onError: props.onError
      });
    }
  }
  exports.SvgFromUri = SvgFromUri;
  const upperCase = (_match, letter) => letter.toUpperCase();
  const camelCase = phrase => phrase.replace(/[:-]([a-z])/g, upperCase);
  exports.camelCase = camelCase;
  function getStyle(string) {
    const style = {};
    const declarations = string.split(';').filter(v => v.trim());
    const {
      length
    } = declarations;
    for (let i = 0; i < length; i++) {
      const declaration = declarations[i];
      if (declaration.length !== 0) {
        const split = declaration.split(':');
        const property = split[0];
        const value = split[1];
        style[camelCase(property.trim())] = value.trim();
      }
    }
    return style;
  }
  function astToReact(value, index) {
    if (typeof value === 'object') {
      const {
        Tag,
        props,
        children
      } = value;
      if (props !== null && props !== void 0 && props.class) {
        props.className = props.class;
        delete props.class;
      }
      return /*#__PURE__*/_ReactNativeCSSInterop.createInteropElement(Tag, _extends({
        key: index
      }, props), children.map(astToReact));
    }
    return value;
  }

  // slimmed down parser based on https://github.com/Rich-Harris/svg-parser

  function repeat(str, i) {
    let result = '';
    while (i--) {
      result += str;
    }
    return result;
  }
  const toSpaces = tabs => repeat('  ', tabs.length);
  function locate(source, i) {
    const lines = source.split('\n');
    const nLines = lines.length;
    let column = i;
    let line = 0;
    for (; line < nLines; line++) {
      const {
        length
      } = lines[line];
      if (column >= length) {
        column -= length;
      } else {
        break;
      }
    }
    const before = source.slice(0, i).replace(/^\t+/, toSpaces);
    const beforeExec = /(^|\n).*$/.exec(before);
    const beforeLine = beforeExec && beforeExec[0] || '';
    const after = source.slice(i);
    const afterExec = /.*(\n|$)/.exec(after);
    const afterLine = afterExec && afterExec[0];
    const pad = repeat(' ', beforeLine.length);
    const snippet = `${beforeLine}${afterLine}\n${pad}^`;
    return {
      line,
      column,
      snippet
    };
  }
  const validNameCharacters = /[a-zA-Z0-9:_-]/;
  const commentStart = /<!--/;
  const whitespace = /[\s\t\r\n]/;
  const quotemarks = /['"]/;
  function parse(source, middleware) {
    const length = source.length;
    let currentElement = null;
    let state = metadata;
    let children = null;
    let root;
    const stack = [];
    function error(message) {
      const {
        line,
        column,
        snippet
      } = locate(source, i);
      throw new Error(`${message} (${line}:${column}). If this is valid SVG, it's probably a bug. Please raise an issue\n\n${snippet}`);
    }
    function metadata() {
      while (i + 1 < length && (source[i] !== '<' || !(validNameCharacters.test(source[i + 1]) || commentStart.test(source.slice(i, i + 4))))) {
        i++;
      }
      return neutral();
    }
    function neutral() {
      let text = '';
      let char;
      while (i < length && (char = source[i]) !== '<') {
        text += char;
        i += 1;
      }
      if (/\S/.test(text)) {
        children.push(text);
      }
      if (source[i] === '<') {
        return openingTag;
      }
      return neutral;
    }
    function openingTag() {
      const char = source[i];
      if (char === '?') {
        return neutral;
      } // <?xml...

      if (char === '!') {
        const start = i + 1;
        if (source.slice(start, i + 3) === '--') {
          return comment;
        }
        const end = i + 8;
        if (source.slice(start, end) === '[CDATA[') {
          return cdata;
        }
        if (/doctype/i.test(source.slice(start, end))) {
          return neutral;
        }
      }
      if (char === '/') {
        return closingTag;
      }
      const tag = getName();
      const props = {};
      const element = {
        tag,
        props,
        children: [],
        parent: currentElement,
        Tag: _xmlTags.tags[tag] || missingTag
      };
      if (currentElement) {
        children.push(element);
      } else {
        root = element;
      }
      getAttributes(props);
      const {
        style
      } = props;
      if (typeof style === 'string') {
        element.styles = style;
        props.style = getStyle(style);
      }
      let selfClosing = false;
      if (source[i] === '/') {
        i += 1;
        selfClosing = true;
      }
      if (source[i] !== '>') {
        error('Expected >');
      }
      if (!selfClosing) {
        currentElement = element;
        ({
          children
        } = element);
        stack.push(element);
      }
      return neutral;
    }
    function comment() {
      const index = source.indexOf('-->', i);
      if (!~index) {
        error('expected -->');
      }
      i = index + 2;
      return neutral;
    }
    function cdata() {
      const index = source.indexOf(']]>', i);
      if (!~index) {
        error('expected ]]>');
      }
      children.push(source.slice(i + 7, index));
      i = index + 2;
      return neutral;
    }
    function closingTag() {
      const tag = getName();
      if (!tag) {
        error('Expected tag name');
      }
      if (currentElement && tag !== currentElement.tag) {
        error(`Expected closing tag </${tag}> to match opening tag <${currentElement.tag}>`);
      }
      allowSpaces();
      if (source[i] !== '>') {
        error('Expected >');
      }
      stack.pop();
      currentElement = stack[stack.length - 1];
      if (currentElement) {
        ({
          children
        } = currentElement);
      }
      return neutral;
    }
    function getName() {
      let name = '';
      let char;
      while (i < length && validNameCharacters.test(char = source[i])) {
        name += char;
        i += 1;
      }
      return name;
    }
    function getAttributes(props) {
      while (i < length) {
        if (!whitespace.test(source[i])) {
          return;
        }
        allowSpaces();
        const name = getName();
        if (!name) {
          return;
        }
        let value = true;
        allowSpaces();
        if (source[i] === '=') {
          i += 1;
          allowSpaces();
          value = getAttributeValue();
          if (name !== 'id' && !isNaN(+value) && value.trim() !== '') {
            value = +value;
          }
        }
        props[camelCase(name)] = value;
      }
    }
    function getAttributeValue() {
      return quotemarks.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();
    }
    function getUnquotedAttributeValue() {
      let value = '';
      do {
        const char = source[i];
        if (char === ' ' || char === '>' || char === '/') {
          return value;
        }
        value += char;
        i += 1;
      } while (i < length);
      return value;
    }
    function getQuotedAttributeValue() {
      const quotemark = source[i++];
      let value = '';
      let escaped = false;
      while (i < length) {
        const char = source[i++];
        if (char === quotemark && !escaped) {
          return value;
        }
        if (char === '\\' && !escaped) {
          escaped = true;
        }
        value += escaped ? `\\${char}` : char;
        escaped = false;
      }
      return value;
    }
    function allowSpaces() {
      while (i < length && whitespace.test(source[i])) {
        i += 1;
      }
    }
    let i = 0;
    while (i < length) {
      if (!state) {
        error('Unexpected character');
      }
      state = state();
      i += 1;
    }
    if (state !== neutral) {
      error('Unexpected end of input');
    }
    if (root) {
      const xml = (middleware ? middleware(root) : root) || root;
      const ast = xml.children.map(astToReact);
      const jsx = xml;
      jsx.children = ast;
      return jsx;
    }
    return null;
  }
},923,[412,3,924,928],"node_modules\\react-native-svg\\lib\\module\\xml.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fetchText = fetchText;
  var _Platform = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Platform"));
  var _buffer = require(_dependencyMap[2], "buffer");
  async function fetchText(uri) {
    if (!uri) {
      return null;
    }
    if (uri.startsWith('data:image/svg+xml;utf8') && _Platform.default.OS === 'android') {
      return dataUriToXml(uri);
    } else if (uri.startsWith('data:image/svg+xml;base64')) {
      return decodeBase64Image(uri);
    } else {
      return fetchUriData(uri);
    }
  }
  const decodeBase64Image = uri => {
    const decoded = decodeURIComponent(uri);
    const splitContent = decoded.split(';')[1].split(',');
    const dataType = splitContent[0];
    const content = splitContent.slice(1).join(',');
    return _buffer.Buffer.from(content, dataType).toString('utf-8');
  };
  function dataUriToXml(uri) {
    try {
      // decode and remove data:image/svg+xml;utf8, prefix
      return decodeURIComponent(uri).split(',').slice(1).join(',');
    } catch (error) {
      throw new Error(`Decoding ${uri} failed with error: ${error}`);
    }
  }
  async function fetchUriData(uri) {
    const response = await fetch(uri);
    if (response.ok || response.status === 0 && uri.startsWith('file://')) {
      return await response.text();
    }
    throw new Error(`Fetching ${uri} failed with status ${response.status}`);
  }
},924,[17,106,925],"node_modules\\react-native-svg\\lib\\module\\utils\\fetchData.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var base64 = require(_dependencyMap[0], "base64-js");
  var ieee754 = require(_dependencyMap[1], "ieee754");
  var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
  ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
  }
  function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function () {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192; // not used by this implementation

  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpreted as a start offset.
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
  };
  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          Buffer.from(buf).copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== 'string') {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
          }
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return '';
    }
    if (end === undefined || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return '';
    }

    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return '';
    }
    if (!encoding) encoding = 'utf8';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }
    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length);
        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;
          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }

  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj; // eslint-disable-line no-self-compare
  }

  // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219
  var hexSliceLookupTable = function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
},925,[926,927],"node_modules\\buffer\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }
    return output.join('');
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
  }
},926,[],"node_modules\\base64-js\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
},927,[],"node_modules\\ieee754\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.tags = void 0;
  var _elements = require(_dependencyMap[0], "./elements");
  const tags = exports.tags = {
    circle: _elements.Circle,
    clipPath: _elements.ClipPath,
    defs: _elements.Defs,
    ellipse: _elements.Ellipse,
    filter: _elements.Filter,
    feBlend: _elements.FeBlend,
    feColorMatrix: _elements.FeColorMatrix,
    feComponentTransfer: _elements.FeComponentTransfer,
    feComposite: _elements.FeComposite,
    feConvolveMatrix: _elements.FeConvolveMatrix,
    feDiffuseLighting: _elements.FeDiffuseLighting,
    feDisplacementMap: _elements.FeDisplacementMap,
    feDistantLight: _elements.FeDistantLight,
    feDropShadow: _elements.FeDropShadow,
    feFlood: _elements.FeFlood,
    feGaussianBlur: _elements.FeGaussianBlur,
    feImage: _elements.FeImage,
    feMerge: _elements.FeMerge,
    feMergeNode: _elements.FeMergeNode,
    feMorphology: _elements.FeMorphology,
    feOffset: _elements.FeOffset,
    fePointLight: _elements.FePointLight,
    feSpecularLighting: _elements.FeSpecularLighting,
    feSpotLight: _elements.FeSpotLight,
    feTile: _elements.FeTile,
    feTurbulence: _elements.FeTurbulence,
    foreignObject: _elements.ForeignObject,
    g: _elements.G,
    image: _elements.Image,
    line: _elements.Line,
    linearGradient: _elements.LinearGradient,
    marker: _elements.Marker,
    mask: _elements.Mask,
    path: _elements.Path,
    pattern: _elements.Pattern,
    polygon: _elements.Polygon,
    polyline: _elements.Polyline,
    radialGradient: _elements.RadialGradient,
    rect: _elements.Rect,
    stop: _elements.Stop,
    svg: _elements.Svg,
    symbol: _elements.Symbol,
    text: _elements.Text,
    textPath: _elements.TextPath,
    tspan: _elements.TSpan,
    use: _elements.Use
  };
},928,[929],"node_modules\\react-native-svg\\lib\\module\\xmlTags.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Use = exports.TextPath = exports.Text = exports.TSpan = exports.Symbol = exports.Svg = exports.Stop = exports.Rect = exports.RadialGradient = exports.Polyline = exports.Polygon = exports.Pattern = exports.Path = exports.Mask = exports.Marker = exports.LinearGradient = exports.Line = exports.Image = exports.G = exports.ForeignObject = exports.Filter = exports.FeTurbulence = exports.FeTile = exports.FeSpotLight = exports.FeSpecularLighting = exports.FePointLight = exports.FeOffset = exports.FeMorphology = exports.FeMergeNode = exports.FeMerge = exports.FeImage = exports.FeGaussianBlur = exports.FeFuncR = exports.FeFuncG = exports.FeFuncB = exports.FeFuncA = exports.FeFlood = exports.FeDropShadow = exports.FeDistantLight = exports.FeDisplacementMap = exports.FeDiffuseLighting = exports.FeConvolveMatrix = exports.FeComposite = exports.FeComponentTransfer = exports.FeColorMatrix = exports.FeBlend = exports.Ellipse = exports.Defs = exports.ClipPath = exports.Circle = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _utils = require(_dependencyMap[2], "./web/utils");
  var _WebShape = require(_dependencyMap[3], "./web/WebShape");
  const _excluded = ["x", "y"];
  class Circle extends _WebShape.WebShape {
    tag = 'circle';
  }
  exports.Circle = Circle;
  class ClipPath extends _WebShape.WebShape {
    tag = 'clipPath';
  }
  exports.ClipPath = ClipPath;
  class Defs extends _WebShape.WebShape {
    tag = 'defs';
  }
  exports.Defs = Defs;
  class Ellipse extends _WebShape.WebShape {
    tag = 'ellipse';
  }
  exports.Ellipse = Ellipse;
  class FeBlend extends _WebShape.WebShape {
    tag = 'feBlend';
  }
  exports.FeBlend = FeBlend;
  class FeColorMatrix extends _WebShape.WebShape {
    tag = 'feColorMatrix';
  }
  exports.FeColorMatrix = FeColorMatrix;
  class FeComponentTransfer extends _WebShape.WebShape {
    tag = 'feComponentTransfer';
  }
  exports.FeComponentTransfer = FeComponentTransfer;
  class FeComposite extends _WebShape.WebShape {
    tag = 'feComposite';
  }
  exports.FeComposite = FeComposite;
  class FeConvolveMatrix extends _WebShape.WebShape {
    tag = 'feConvolveMatrix';
  }
  exports.FeConvolveMatrix = FeConvolveMatrix;
  class FeDiffuseLighting extends _WebShape.WebShape {
    tag = 'feDiffuseLighting';
  }
  exports.FeDiffuseLighting = FeDiffuseLighting;
  class FeDisplacementMap extends _WebShape.WebShape {
    tag = 'feDisplacementMap';
  }
  exports.FeDisplacementMap = FeDisplacementMap;
  class FeDistantLight extends _WebShape.WebShape {
    tag = 'feDistantLight';
  }
  exports.FeDistantLight = FeDistantLight;
  class FeDropShadow extends _WebShape.WebShape {
    tag = 'feDropShadow';
  }
  exports.FeDropShadow = FeDropShadow;
  class FeFlood extends _WebShape.WebShape {
    tag = 'feFlood';
  }
  exports.FeFlood = FeFlood;
  class FeFuncA extends _WebShape.WebShape {
    tag = 'feFuncA';
  }
  exports.FeFuncA = FeFuncA;
  class FeFuncB extends _WebShape.WebShape {
    tag = 'feFuncB';
  }
  exports.FeFuncB = FeFuncB;
  class FeFuncG extends _WebShape.WebShape {
    tag = 'feFuncG';
  }
  exports.FeFuncG = FeFuncG;
  class FeFuncR extends _WebShape.WebShape {
    tag = 'feFuncR';
  }
  exports.FeFuncR = FeFuncR;
  class FeGaussianBlur extends _WebShape.WebShape {
    tag = 'feGaussianBlur';
  }
  exports.FeGaussianBlur = FeGaussianBlur;
  class FeImage extends _WebShape.WebShape {
    tag = 'feImage';
  }
  exports.FeImage = FeImage;
  class FeMerge extends _WebShape.WebShape {
    tag = 'feMerge';
  }
  exports.FeMerge = FeMerge;
  class FeMergeNode extends _WebShape.WebShape {
    tag = 'feMergeNode';
  }
  exports.FeMergeNode = FeMergeNode;
  class FeMorphology extends _WebShape.WebShape {
    tag = 'feMorphology';
  }
  exports.FeMorphology = FeMorphology;
  class FeOffset extends _WebShape.WebShape {
    tag = 'feOffset';
  }
  exports.FeOffset = FeOffset;
  class FePointLight extends _WebShape.WebShape {
    tag = 'fePointLight';
  }
  exports.FePointLight = FePointLight;
  class FeSpecularLighting extends _WebShape.WebShape {
    tag = 'feSpecularLighting';
  }
  exports.FeSpecularLighting = FeSpecularLighting;
  class FeSpotLight extends _WebShape.WebShape {
    tag = 'feSpotLight';
  }
  exports.FeSpotLight = FeSpotLight;
  class FeTile extends _WebShape.WebShape {
    tag = 'feTile';
  }
  exports.FeTile = FeTile;
  class FeTurbulence extends _WebShape.WebShape {
    tag = 'feTurbulence';
  }
  exports.FeTurbulence = FeTurbulence;
  class Filter extends _WebShape.WebShape {
    tag = 'filter';
  }
  exports.Filter = Filter;
  class ForeignObject extends _WebShape.WebShape {
    tag = 'foreignObject';
  }
  exports.ForeignObject = ForeignObject;
  class G extends _WebShape.WebShape {
    tag = 'g';
    prepareProps(props) {
      const {
          x,
          y
        } = props,
        rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
      if ((x || y) && !rest.translate) {
        rest.translate = `${x || 0}, ${y || 0}`;
      }
      return rest;
    }
  }
  exports.G = G;
  class Image extends _WebShape.WebShape {
    tag = 'image';
  }
  exports.Image = Image;
  class Line extends _WebShape.WebShape {
    tag = 'line';
  }
  exports.Line = Line;
  class LinearGradient extends _WebShape.WebShape {
    tag = 'linearGradient';
  }
  exports.LinearGradient = LinearGradient;
  class Marker extends _WebShape.WebShape {
    tag = 'marker';
  }
  exports.Marker = Marker;
  class Mask extends _WebShape.WebShape {
    tag = 'mask';
  }
  exports.Mask = Mask;
  class Path extends _WebShape.WebShape {
    tag = 'path';
  }
  exports.Path = Path;
  class Pattern extends _WebShape.WebShape {
    tag = 'pattern';
  }
  exports.Pattern = Pattern;
  class Polygon extends _WebShape.WebShape {
    tag = 'polygon';
  }
  exports.Polygon = Polygon;
  class Polyline extends _WebShape.WebShape {
    tag = 'polyline';
  }
  exports.Polyline = Polyline;
  class RadialGradient extends _WebShape.WebShape {
    tag = 'radialGradient';
  }
  exports.RadialGradient = RadialGradient;
  class Rect extends _WebShape.WebShape {
    tag = 'rect';
  }
  exports.Rect = Rect;
  class Stop extends _WebShape.WebShape {
    tag = 'stop';
  }
  exports.Stop = Stop;
  class Svg extends _WebShape.WebShape {
    tag = 'svg';
    toDataURL(callback, options = {}) {
      const ref = this.elementRef.current;
      if (ref === null) {
        return;
      }
      const rect = (0, _utils.getBoundingClientRect)(ref);
      const width = Number(options.width) || rect.width;
      const height = Number(options.height) || rect.height;
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
      svg.setAttribute('width', String(width));
      svg.setAttribute('height', String(height));
      svg.appendChild(ref.cloneNode(true));
      const img = new window.Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context === null || context === void 0 || context.drawImage(img, 0, 0);
        callback(canvas.toDataURL().replace('data:image/png;base64,', ''));
      };
      img.src = `data:image/svg+xml;utf8,${(0, _utils.encodeSvg)(new window.XMLSerializer().serializeToString(svg))}`;
    }
  }
  exports.Svg = Svg;
  class Symbol extends _WebShape.WebShape {
    tag = 'symbol';
  }
  exports.Symbol = Symbol;
  class TSpan extends _WebShape.WebShape {
    tag = 'tspan';
  }
  exports.TSpan = TSpan;
  class Text extends _WebShape.WebShape {
    tag = 'text';
  }
  exports.Text = Text;
  class TextPath extends _WebShape.WebShape {
    tag = 'textPath';
  }
  exports.TextPath = TextPath;
  class Use extends _WebShape.WebShape {
    tag = 'use';
  }
  exports.Use = Use;
  var _default = exports.default = Svg;
},929,[17,29,930,931],"node_modules\\react-native-svg\\lib\\module\\elements.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.camelCaseToDashed = void 0;
  exports.encodeSvg = encodeSvg;
  exports.getBoundingClientRect = void 0;
  exports.remeasure = remeasure;
  const camelCaseToDashed = camelCase => {
    return camelCase.replace(/[A-Z]/g, m => '-' + m.toLowerCase());
  };
  exports.camelCaseToDashed = camelCaseToDashed;
  const getBoundingClientRect = node => {
    if (node) {
      const isElement = node.nodeType === 1; /* Node.ELEMENT_NODE */
      if (isElement && typeof node.getBoundingClientRect === 'function') {
        return node.getBoundingClientRect();
      }
    }
    throw new Error('Can not get boundingClientRect of ' + node || 'undefined');
  };
  exports.getBoundingClientRect = getBoundingClientRect;
  const measureLayout = (node, callback) => {
    const relativeNode = node === null || node === void 0 ? void 0 : node.parentNode;
    if (relativeNode) {
      setTimeout(() => {
        // @ts-expect-error TODO: handle it better
        const relativeRect = getBoundingClientRect(relativeNode);
        const {
          height,
          left,
          top,
          width
        } = getBoundingClientRect(node);
        const x = left - relativeRect.left;
        const y = top - relativeRect.top;
        callback(x, y, width, height, left, top);
      }, 0);
    }
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function remeasure() {
    const tag = this.state.touchable.responderID;
    if (tag === null) {
      return;
    }
    measureLayout(tag, this._handleQueryLayout);
  }

  /* Taken from here: https://gist.github.com/jennyknuth/222825e315d45a738ed9d6e04c7a88d0 */
  function encodeSvg(svgString) {
    return svgString.replace('<svg', ~svgString.indexOf('xmlns') ? '<svg' : '<svg xmlns="http://www.w3.org/2000/svg"').replace(/"/g, "'").replace(/%/g, '%25').replace(/#/g, '%23').replace(/{/g, '%7B').replace(/}/g, '%7D').replace(/</g, '%3C').replace(/>/g, '%3E').replace(/\s+/g, ' ');
  }
},930,[],"node_modules\\react-native-svg\\lib\\module\\web\\utils\\index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.WebShape = void 0;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _createElement = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/createElement"));
  var _prepare = require(_dependencyMap[3], "./utils/prepare");
  var _convertInt32Color = require(_dependencyMap[4], "./utils/convertInt32Color");
  var _utils = require(_dependencyMap[5], "./utils");
  var _hasProperty = require(_dependencyMap[6], "./utils/hasProperty");
  var _SvgTouchableMixin = _interopRequireDefault(require(_dependencyMap[7], "../lib/SvgTouchableMixin"));
  class WebShape extends _react.default.Component {
    prepareProps(props) {
      return props;
    }
    elementRef = /*#__PURE__*/_react.default.createRef();
    lastMergedProps = {};

    /**
     * disclaimer: I am not sure why the props are wrapped in a `style` attribute here, but that's how reanimated calls it
     */
    setNativeProps(props) {
      const merged = Object.assign({}, this.props, this.lastMergedProps, props.style);
      this.lastMergedProps = merged;
      const clean = (0, _prepare.prepare)(this, this.prepareProps(merged));
      const current = this.elementRef.current;
      if (current) {
        for (const cleanAttribute of Object.keys(clean)) {
          const cleanValue = clean[cleanAttribute];
          switch (cleanAttribute) {
            case 'ref':
            case 'children':
              break;
            case 'style':
              // style can be an object here or an array, so we convert it to an array and assign each element
              for (const partialStyle of [].concat(clean.style ?? [])) {
                Object.assign(current.style, partialStyle);
              }
              break;
            case 'fill':
              if (cleanValue && typeof cleanValue === 'object') {
                const value = cleanValue;
                current.setAttribute('fill', (0, _convertInt32Color.convertInt32ColorToRGBA)(value.payload));
              }
              break;
            case 'stroke':
              if (cleanValue && typeof cleanValue === 'object') {
                const value = cleanValue;
                current.setAttribute('stroke', (0, _convertInt32Color.convertInt32ColorToRGBA)(value.payload));
              }
              break;
            default:
              // apply all other incoming prop updates as attributes on the node
              // same logic as in https://github.com/software-mansion/react-native-reanimated/blob/d04720c82f5941532991b235787285d36d717247/src/reanimated2/js-reanimated/index.ts#L38-L39
              // @ts-expect-error TODO: fix this
              current.setAttribute((0, _utils.camelCaseToDashed)(cleanAttribute), cleanValue);
              break;
          }
        }
      }
    }
    constructor(props) {
      super(props);

      // Do not attach touchable mixin handlers if SVG element doesn't have a touchable prop
      if ((0, _hasProperty.hasTouchableProperty)(props)) {
        (0, _SvgTouchableMixin.default)(this);
      }
      this._remeasureMetricsOnActivation = _utils.remeasure.bind(this);
    }
    render() {
      if (!this.tag) {
        throw new Error('When extending `WebShape` you need to overwrite either `tag` or `render`!');
      }
      this.lastMergedProps = {};
      return (0, _createElement.default)(this.tag, (0, _prepare.prepare)(this, this.prepareProps(this.props)));
    }
  }
  exports.WebShape = WebShape;
},931,[17,3,18,932,941,930,933,942],"node_modules\\react-native-svg\\lib\\module\\web\\WebShape.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.prepare = void 0;
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose"));
  var _hasProperty = require(_dependencyMap[2], "./hasProperty");
  var _parseTransform = require(_dependencyMap[3], "./parseTransform");
  var _resolve = require(_dependencyMap[4], "../../lib/resolve");
  var _resolveAssetUri2 = require(_dependencyMap[5], "../../lib/resolveAssetUri");
  const _excluded = ["transform", "origin", "originX", "originY", "fontFamily", "fontSize", "fontWeight", "fontStyle", "style", "forwardedRef", "gradientTransform", "patternTransform", "onPress"];
  /**
   * `react-native-svg` supports additional props that aren't defined in the spec.
   * This function replaces them in a spec conforming manner.
   *
   * @param {WebShape} self Instance given to us.
   * @param {Object?} props Optional overridden props given to us.
   * @returns {Object} Cleaned props object.
   * @private
   */
  const prepare = (self, props = self.props) => {
    const {
        transform,
        origin,
        originX,
        originY,
        fontFamily,
        fontSize,
        fontWeight,
        fontStyle,
        style,
        forwardedRef,
        gradientTransform,
        patternTransform,
        onPress
      } = props,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
    const clean = Object.assign({}, (0, _hasProperty.hasTouchableProperty)(props) ? {
      onStartShouldSetResponder: self.touchableHandleStartShouldSetResponder,
      onResponderTerminationRequest: self.touchableHandleResponderTerminationRequest,
      onResponderGrant: self.touchableHandleResponderGrant,
      onResponderMove: self.touchableHandleResponderMove,
      onResponderRelease: self.touchableHandleResponderRelease,
      onResponderTerminate: self.touchableHandleResponderTerminate
    } : null, rest);
    if (origin != null) {
      clean['transform-origin'] = origin.toString().replace(',', ' ');
    } else if (originX != null || originY != null) {
      clean['transform-origin'] = `${originX || 0} ${originY || 0}`;
    }

    // we do it like this because setting transform as undefined causes error in web
    const parsedTransform = (0, _parseTransform.parseTransformProp)(transform, props);
    if (parsedTransform) {
      clean.transform = parsedTransform;
    }
    const parsedGradientTransform = (0, _parseTransform.parseTransformProp)(gradientTransform);
    if (parsedGradientTransform) {
      clean.gradientTransform = parsedGradientTransform;
    }
    const parsedPatternTransform = (0, _parseTransform.parseTransformProp)(patternTransform);
    if (parsedPatternTransform) {
      clean.patternTransform = parsedPatternTransform;
    }
    clean.ref = el => {
      self.elementRef.current = el;
      if (typeof forwardedRef === 'function') {
        forwardedRef(el);
      } else if (forwardedRef) {
        forwardedRef.current = el;
      }
    };
    const styles = {};
    if (fontFamily != null) {
      styles.fontFamily = fontFamily;
    }
    if (fontSize != null) {
      styles.fontSize = fontSize;
    }
    if (fontWeight != null) {
      styles.fontWeight = fontWeight;
    }
    if (fontStyle != null) {
      styles.fontStyle = fontStyle;
    }
    clean.style = (0, _resolve.resolve)(style, styles);
    if (onPress !== null) {
      clean.onClick = props.onPress;
    }
    if (props.href !== null && props.href !== undefined) {
      var _resolveAssetUri;
      clean.href = (_resolveAssetUri = (0, _resolveAssetUri2.resolveAssetUri)(props.href)) === null || _resolveAssetUri === void 0 ? void 0 : _resolveAssetUri.uri;
    }
    return clean;
  };
  exports.prepare = prepare;
},932,[17,29,933,934,939,940],"node_modules\\react-native-svg\\lib\\module\\web\\utils\\prepare.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hasTouchableProperty = hasTouchableProperty;
  function hasTouchableProperty(props) {
    return !!(props.onPress || props.onPressIn || props.onPressOut || props.onLongPress);
  }
},933,[],"node_modules\\react-native-svg\\lib\\module\\web\\utils\\hasProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseTransformProp = parseTransformProp;
  exports.stringifyTransformProps = stringifyTransformProps;
  var _extractTransform = require(_dependencyMap[0], "../../lib/extract/extractTransform");
  function parseTransformProp(transform, props) {
    const transformArray = [];
    props && transformArray.push(...stringifyTransformProps(props));
    if (Array.isArray(transform)) {
      if (typeof transform[0] === 'number') {
        transformArray.push(`matrix(${transform.join(' ')})`);
      } else {
        const stringifiedProps = (0, _extractTransform.transformsArrayToProps)(
        // @ts-expect-error FIXME
        transform);
        transformArray.push(...stringifyTransformProps(stringifiedProps));
      }
    } else if (typeof transform === 'string') {
      transformArray.push(transform);
    }
    return transformArray.length ? transformArray.join(' ') : undefined;
  }
  function stringifyTransformProps(transformProps) {
    const transformArray = [];
    if (transformProps.translate != null) {
      transformArray.push(`translate(${transformProps.translate})`);
    }
    if (transformProps.translateX != null || transformProps.translateY != null) {
      transformArray.push(`translate(${transformProps.translateX || 0}, ${transformProps.translateY || 0})`);
    }
    if (transformProps.scale != null) {
      transformArray.push(`scale(${transformProps.scale})`);
    }
    if (transformProps.scaleX != null || transformProps.scaleY != null) {
      transformArray.push(`scale(${transformProps.scaleX || 1}, ${transformProps.scaleY || 1})`);
    }
    // rotation maps to rotate, not to collide with the text rotate attribute (which acts per glyph rather than block)
    if (transformProps.rotation != null) {
      transformArray.push(`rotate(${transformProps.rotation})`);
    }
    if (transformProps.skewX != null) {
      transformArray.push(`skewX(${transformProps.skewX})`);
    }
    if (transformProps.skewY != null) {
      transformArray.push(`skewY(${transformProps.skewY})`);
    }
    return transformArray;
  }
},934,[935],"node_modules\\react-native-svg\\lib\\module\\web\\utils\\parseTransform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = extractTransform;
  exports.extractTransformSvgView = extractTransformSvgView;
  exports.props2transform = props2transform;
  exports.transformToMatrix = transformToMatrix;
  exports.transformsArrayToProps = transformsArrayToProps;
  var _Matrix2D = require(_dependencyMap[0], "../Matrix2D");
  var _transform = require(_dependencyMap[1], "./transform");
  var _transformToRn = require(_dependencyMap[2], "./transformToRn");
  function appendTransformProps(props) {
    const {
      x,
      y,
      originX,
      originY,
      scaleX,
      scaleY,
      rotation,
      skewX,
      skewY
    } = props;
    (0, _Matrix2D.appendTransform)(x + originX, y + originY, scaleX, scaleY, rotation, skewX, skewY, originX, originY);
  }
  function universal2axis(universal, axisX, axisY, defaultValue) {
    let x;
    let y;
    if (typeof universal === 'number') {
      x = y = universal;
    } else if (typeof universal === 'string') {
      const coords = universal.split(/\s*,\s*/);
      if (coords.length === 2) {
        x = +coords[0];
        y = +coords[1];
      } else if (coords.length === 1) {
        x = y = +coords[0];
      }
    } else if (Array.isArray(universal)) {
      if (universal.length === 2) {
        x = +universal[0];
        y = +universal[1];
      } else if (universal.length === 1) {
        x = y = +universal[0];
      }
    }
    axisX = +axisX;
    if (!isNaN(axisX)) {
      x = axisX;
    }
    axisY = +axisY;
    if (!isNaN(axisY)) {
      y = axisY;
    }
    return [x || defaultValue || 0, y || defaultValue || 0];
  }
  function transformsArrayToProps(transformObjectsArray) {
    const props = {};
    transformObjectsArray === null || transformObjectsArray === void 0 || transformObjectsArray.forEach(transformObject => {
      const keys = Object.keys(transformObject);
      if (keys.length !== 1) {
        console.error('You must specify exactly one property per transform object.');
      }
      const key = keys[0];
      const value = transformObject[key];
      // @ts-expect-error FIXME
      props[key] = value;
    });
    return props;
  }
  function props2transform(props) {
    if (!props) {
      return null;
    }
    const {
      rotation,
      translate,
      translateX,
      translateY,
      origin,
      originX,
      originY,
      scale,
      scaleX,
      scaleY,
      skew,
      skewX,
      skewY,
      x,
      y
    } = props;
    if (rotation == null && translate == null && translateX == null && translateY == null && origin == null && originX == null && originY == null && scale == null && scaleX == null && scaleY == null && skew == null && skewX == null && skewY == null && x == null && y == null) {
      return null;
    }
    if (Array.isArray(x) || Array.isArray(y)) {
      console.warn('Passing SvgLengthList to x or y attribute where SvgLength expected');
    }
    const tr = universal2axis(translate, translateX || (Array.isArray(x) ? x[0] : x), translateY || (Array.isArray(y) ? y[0] : y));
    const or = universal2axis(origin, originX, originY);
    const sc = universal2axis(scale, scaleX, scaleY, 1);
    const sk = universal2axis(skew, skewX, skewY);
    return {
      rotation: rotation == null ? 0 : +rotation || 0,
      originX: or[0],
      originY: or[1],
      scaleX: sc[0],
      scaleY: sc[1],
      skewX: sk[0],
      skewY: sk[1],
      x: tr[0],
      y: tr[1]
    };
  }
  function transformToMatrix(props, transform) {
    if (!props && !transform) {
      return null;
    }
    (0, _Matrix2D.reset)();
    props && appendTransformProps(props);
    if (transform) {
      if (Array.isArray(transform)) {
        if (typeof transform[0] === 'number') {
          const columnMatrix = transform;
          (0, _Matrix2D.append)(columnMatrix[0], columnMatrix[1], columnMatrix[2], columnMatrix[3], columnMatrix[4], columnMatrix[5]);
        } else {
          const transformProps = props2transform(
          // @ts-expect-error FIXME
          transformsArrayToProps(transform));
          transformProps && appendTransformProps(transformProps);
        }
      } else if (typeof transform === 'string') {
        try {
          const t = (0, _transform.parse)(transform);
          (0, _Matrix2D.append)(t[0], t[3], t[1], t[4], t[2], t[5]);
        } catch (e) {
          console.error(e);
        }
      } else {
        // @ts-expect-error FIXME
        const transformProps = props2transform(transform);
        transformProps && appendTransformProps(transformProps);
      }
    }
    return (0, _Matrix2D.toArray)();
  }
  function extractTransform(props) {
    if (Array.isArray(props) && typeof props[0] === 'number') {
      return props;
    }
    if (typeof props === 'string') {
      try {
        const t = (0, _transform.parse)(props);
        return [t[0], t[3], t[1], t[4], t[2], t[5]];
      } catch (e) {
        console.error(e);
        return _Matrix2D.identity;
      }
    }
    // this type is not correct since props can be of type TransformsStyle['transform'] too
    // but it satisfies TS and should not produce any type errors
    const transformProps = props;
    return transformToMatrix(props2transform(transformProps), transformProps === null || transformProps === void 0 ? void 0 : transformProps.transform);
  }
  function extractTransformSvgView(props) {
    if (typeof props.transform === 'string') {
      return (0, _transformToRn.parse)(props.transform);
    }
    return props.transform;
  }
},935,[936,937,938],"node_modules\\react-native-svg\\lib\\module\\lib\\extract\\extractTransform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.append = append;
  exports.appendTransform = appendTransform;
  exports.identity = void 0;
  exports.reset = reset;
  exports.toArray = toArray;
  /**
   * based on
   * https://github.com/CreateJS/EaselJS/blob/631cdffb85eff9413dab43b4676f059b4232d291/src/easeljs/geom/Matrix2D.js
   */
  const DEG_TO_RAD = Math.PI / 180;
  const identity = exports.identity = [1, 0, 0, 1, 0, 0];
  let a = 1;
  let b = 0;
  let c = 0;
  let d = 1;
  let tx = 0;
  let ty = 0;
  let hasInitialState = true;

  /**
   * Represents an affine transformation matrix, and provides tools for concatenating transforms.
   *
   * This matrix can be visualized as:
   *
   * 	[ a  c  tx
   * 	  b  d  ty
   * 	  0  0  1  ]
   *
   * Note the locations of b and c.
   **/

  /**
   * Reset current matrix to an identity matrix.
   * @method reset
   **/
  function reset() {
    if (hasInitialState) {
      return;
    }
    a = d = 1;
    b = c = tx = ty = 0;
    hasInitialState = true;
  }

  /**
   * Returns an array with current matrix values.
   * @method toArray
   * @return {Array} an array with current matrix values.
   **/
  function toArray() {
    if (hasInitialState) {
      return identity;
    }
    return [a, b, c, d, tx, ty];
  }

  /**
   * Appends the specified matrix properties to this matrix. All parameters are required.
   * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
   * @method append
   * @param {Number} a2
   * @param {Number} b2
   * @param {Number} c2
   * @param {Number} d2
   * @param {Number} tx2
   * @param {Number} ty2
   **/
  function append(a2, b2, c2, d2, tx2, ty2) {
    const change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;
    const translate = tx2 !== 0 || ty2 !== 0;
    if (!change && !translate) {
      return;
    }
    if (hasInitialState) {
      hasInitialState = false;
      a = a2;
      b = b2;
      c = c2;
      d = d2;
      tx = tx2;
      ty = ty2;
      return;
    }
    const a1 = a;
    const b1 = b;
    const c1 = c;
    const d1 = d;
    if (change) {
      a = a1 * a2 + c1 * b2;
      b = b1 * a2 + d1 * b2;
      c = a1 * c2 + c1 * d2;
      d = b1 * c2 + d1 * d2;
    }
    if (translate) {
      tx = a1 * tx2 + c1 * ty2 + tx;
      ty = b1 * tx2 + d1 * ty2 + ty;
    }
  }

  /**
   * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
   * For example, you can use this to generate a matrix representing the transformations of a display object:
   *
   * 	reset();
   * 	appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
   * 	var matrix = toArray()
   *
   * @method appendTransform
   * @param {Number} x
   * @param {Number} y
   * @param {Number} scaleX
   * @param {Number} scaleY
   * @param {Number} rotation
   * @param {Number} skewX
   * @param {Number} skewY
   * @param {Number} regX Optional.
   * @param {Number} regY Optional.
   **/
  function appendTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
    if (x === 0 && y === 0 && scaleX === 1 && scaleY === 1 && rotation === 0 && skewX === 0 && skewY === 0 && regX === 0 && regY === 0) {
      return;
    }
    let cos, sin;
    if (rotation % 360) {
      const r = rotation * DEG_TO_RAD;
      cos = Math.cos(r);
      sin = Math.sin(r);
    } else {
      cos = 1;
      sin = 0;
    }
    const a2 = cos * scaleX;
    const b2 = sin * scaleX;
    const c2 = -sin * scaleY;
    const d2 = cos * scaleY;
    if (skewX || skewY) {
      const b1 = Math.tan(skewY * DEG_TO_RAD);
      const c1 = Math.tan(skewX * DEG_TO_RAD);
      append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);
    } else {
      append(a2, b2, c2, d2, x, y);
    }
    if (regX || regY) {
      // append the registration offset:
      tx -= regX * a + regY * c;
      ty -= regX * b + regY * d;
      hasInitialState = false;
    }
  }
},936,[],"node_modules\\react-native-svg\\lib\\module\\lib\\Matrix2D.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */

  "use strict";

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }
  peg$subclass(peg$SyntaxError, Error);
  peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function (expectation) {
        return "\"" + literalEscape(expectation.text) + "\"";
      },
      "class": function (expectation) {
        var escapedParts = "",
          i;
        for (i = 0; i < expectation.parts.length; i++) {
          escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
        }
        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
      },
      any: function (expectation) {
        return "any character";
      },
      end: function (expectation) {
        return "end of input";
      },
      other: function (expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }
    function classEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
        i,
        j;
      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};
    var peg$FAILED = {},
      peg$startRuleFunctions = {
        transformList: peg$parsetransformList
      },
      peg$startRuleFunction = peg$parsetransformList,
      peg$c0 = function (ts) {
        return ts;
      },
      peg$c1 = function (t, ts) {
        return multiply_matrices(t, ts);
      },
      peg$c2 = "matrix",
      peg$c3 = peg$literalExpectation("matrix", false),
      peg$c4 = "(",
      peg$c5 = peg$literalExpectation("(", false),
      peg$c6 = ")",
      peg$c7 = peg$literalExpectation(")", false),
      peg$c8 = function (a, b, c, d, e, f) {
        return [a, c, e, b, d, f];
      },
      peg$c9 = "translate",
      peg$c10 = peg$literalExpectation("translate", false),
      peg$c11 = function (tx, ty) {
        return [1, 0, tx, 0, 1, ty || 0];
      },
      peg$c12 = "scale",
      peg$c13 = peg$literalExpectation("scale", false),
      peg$c14 = function (sx, sy) {
        return [sx, 0, 0, 0, sy === null ? sx : sy, 0];
      },
      peg$c15 = "rotate",
      peg$c16 = peg$literalExpectation("rotate", false),
      peg$c17 = function (angle, c) {
        var cos = Math.cos(deg2rad * angle);
        var sin = Math.sin(deg2rad * angle);
        if (c !== null) {
          var x = c[0];
          var y = c[1];
          return [cos, -sin, cos * -x + -sin * -y + x, sin, cos, sin * -x + cos * -y + y];
        }
        return [cos, -sin, 0, sin, cos, 0];
      },
      peg$c18 = "skewX",
      peg$c19 = peg$literalExpectation("skewX", false),
      peg$c20 = function (angle) {
        return [1, Math.tan(deg2rad * angle), 0, 0, 1, 0];
      },
      peg$c21 = "skewY",
      peg$c22 = peg$literalExpectation("skewY", false),
      peg$c23 = function (angle) {
        return [1, 0, 0, Math.tan(deg2rad * angle), 1, 0];
      },
      peg$c24 = function (f) {
        return parseFloat(f.join(""));
      },
      peg$c25 = function (i) {
        return parseInt(i.join(""));
      },
      peg$c26 = function (n) {
        return n;
      },
      peg$c27 = function (n1, n2) {
        return [n1, n2];
      },
      peg$c28 = ",",
      peg$c29 = peg$literalExpectation(",", false),
      peg$c30 = function (ds) {
        return ds.join("");
      },
      peg$c31 = function (f) {
        return f.join("");
      },
      peg$c32 = function (d) {
        return d.join("");
      },
      peg$c33 = peg$otherExpectation("fractionalConstant"),
      peg$c34 = ".",
      peg$c35 = peg$literalExpectation(".", false),
      peg$c36 = function (d1, d2) {
        return [d1 ? d1.join("") : null, ".", d2.join("")].join("");
      },
      peg$c37 = /^[eE]/,
      peg$c38 = peg$classExpectation(["e", "E"], false, false),
      peg$c39 = function (e) {
        return [e[0], e[1], e[2].join("")].join("");
      },
      peg$c40 = /^[+\-]/,
      peg$c41 = peg$classExpectation(["+", "-"], false, false),
      peg$c42 = /^[0-9]/,
      peg$c43 = peg$classExpectation([["0", "9"]], false, false),
      peg$c44 = /^[ \t\r\n]/,
      peg$c45 = peg$classExpectation([" ", "\t", "\r", "\n"], false, false),
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;
    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }
      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
      return {
        type: "literal",
        text: text,
        ignoreCase: ignoreCase
      };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: "class",
        parts: parts,
        inverted: inverted,
        ignoreCase: ignoreCase
      };
    }
    function peg$anyExpectation() {
      return {
        type: "any"
      };
    }
    function peg$endExpectation() {
      return {
        type: "end"
      };
    }
    function peg$otherExpectation(description) {
      return {
        type: "other",
        description: description
      };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
        p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);
      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }
    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parsetransformList() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewsp();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewsp();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetransforms();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsewsp();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsewsp();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetransforms() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsetransform();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsecommaWsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsecommaWsp();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetransforms();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsetransform();
      }
      return s0;
    }
    function peg$parsetransform() {
      var s0;
      s0 = peg$parsematrix();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetranslate();
        if (s0 === peg$FAILED) {
          s0 = peg$parsescale();
          if (s0 === peg$FAILED) {
            s0 = peg$parserotate();
            if (s0 === peg$FAILED) {
              s0 = peg$parseskewX();
              if (s0 === peg$FAILED) {
                s0 = peg$parseskewY();
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parsematrix() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c2) {
        s1 = peg$c2;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecommaWsp();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsenumber();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsecommaWsp();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsenumber();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsecommaWsp();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsenumber();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parsecommaWsp();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parsenumber();
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parsecommaWsp();
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parsenumber();
                                  if (s15 !== peg$FAILED) {
                                    s16 = [];
                                    s17 = peg$parsewsp();
                                    while (s17 !== peg$FAILED) {
                                      s16.push(s17);
                                      s17 = peg$parsewsp();
                                    }
                                    if (s16 !== peg$FAILED) {
                                      if (input.charCodeAt(peg$currPos) === 41) {
                                        s17 = peg$c6;
                                        peg$currPos++;
                                      } else {
                                        s17 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c7);
                                        }
                                      }
                                      if (s17 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c8(s5, s7, s9, s11, s13, s15);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetranslate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c9) {
        s1 = peg$c9;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c10);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecommaWspNumber();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsewsp();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsewsp();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c6;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c7);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c11(s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsescale() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c12) {
        s1 = peg$c12;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c13);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecommaWspNumber();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsewsp();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsewsp();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c6;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c7);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserotate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c15) {
        s1 = peg$c15;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c16);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecommaWspTwoNumbers();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsewsp();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsewsp();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c6;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c7);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c17(s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseskewX() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c18) {
        s1 = peg$c18;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c19);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsewsp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsewsp();
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c6;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c7);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c20(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseskewY() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c21) {
        s1 = peg$c21;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c22);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsewsp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsewsp();
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c6;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c7);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c23(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsesign();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsefloatingPointConstant();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c24(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseintegerConstant();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c25(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsecommaWspNumber() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsecommaWsp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecommaWspTwoNumbers() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parsecommaWsp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecommaWsp();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsenumber();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecommaWsp() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewsp();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsewsp();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomma();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsewsp();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsewsp();
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecomma();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parsecomma() {
      var s0;
      if (input.charCodeAt(peg$currPos) === 44) {
        s0 = peg$c28;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c29);
        }
      }
      return s0;
    }
    function peg$parseintegerConstant() {
      var s0, s1;
      s0 = peg$currPos;
      s1 = peg$parsedigitSequence();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c30(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsefloatingPointConstant() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsefractionalConstant();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexponent();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c31(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsedigitSequence();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexponent();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsefractionalConstant() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsedigitSequence();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c34;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedigitSequence();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c36(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c32(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c33);
        }
      }
      return s0;
    }
    function peg$parseexponent() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c38);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsesign();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsedigitSequence();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsesign() {
      var s0;
      if (peg$c40.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c41);
        }
      }
      return s0;
    }
    function peg$parsedigitSequence() {
      var s0, s1;
      s0 = [];
      s1 = peg$parsedigit();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsedigit();
        }
      } else {
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedigit() {
      var s0;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c43);
        }
      }
      return s0;
    }
    function peg$parsewsp() {
      var s0;
      if (peg$c44.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c45);
        }
      }
      return s0;
    }
    var deg2rad = Math.PI / 180;

    /*
                                
      al cl el     ar cr er     a c e 
      bl dl fl  *  br dr fr  =  b d f 
      0  0  1      0  0  1      0 0 1 
                                
    */
    function multiply_matrices(l, r) {
      var al = l[0];
      var cl = l[1];
      var el = l[2];
      var bl = l[3];
      var dl = l[4];
      var fl = l[5];
      var ar = r[0];
      var cr = r[1];
      var er = r[2];
      var br = r[3];
      var dr = r[4];
      var fr = r[5];
      var a = al * ar + cl * br;
      var c = al * cr + cl * dr;
      var e = al * er + cl * fr + el;
      var b = bl * ar + dl * br;
      var d = bl * cr + dl * dr;
      var f = bl * er + dl * fr + fl;
      return [a, c, e, b, d, f];
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  module.exports = {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
},937,[],"node_modules\\react-native-svg\\lib\\module\\lib\\extract\\transform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // @generated by Peggy 4.0.3.
  //
  // https://peggyjs.org/

  'use strict';

  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self, peg$SyntaxError.prototype);
    }
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = 'SyntaxError';
    return self;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || ' ';
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function (sources) {
    var str = 'Error: ' + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0; k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === 'function' ? this.location.source.offset(s) : s;
      var loc = this.location.source + ':' + offset_s.line + ':' + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd('', offset_s.line.toString().length, ' ');
        var line = src[s.line - 1];
        var last = s.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s.column || 1;
        str += '\n --> ' + loc + '\n' + filler + ' |\n' + offset_s.line + ' | ' + line + '\n' + filler + ' | ' + peg$padEnd('', s.column - 1, ' ') + peg$padEnd('', hatLen, '^');
      } else {
        str += '\n at ' + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function (expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function (expectation) {
        var escapedParts = expectation.parts.map(function (part) {
          return Array.isArray(part) ? classEscape(part[0]) + '-' + classEscape(part[1]) : classEscape(part);
        });
        return '[' + (expectation.inverted ? '^' : '') + escapedParts.join('') + ']';
      },
      any: function () {
        return 'any character';
      },
      end: function () {
        return 'end of input';
      },
      other: function (expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }
    function classEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
      var descriptions = expected.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + ' or ' + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found) {
      return found ? '"' + literalEscape(found) + '"' : 'end of input';
    }
    return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
  };
  function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = {
      start: peg$parsestart
    };
    var peg$startRuleFunction = peg$parsestart;
    var peg$c0 = 'matrix(';
    var peg$c1 = ')';
    var peg$c2 = 'translate(';
    var peg$c3 = 'scale(';
    var peg$c4 = 'rotate(';
    var peg$c5 = 'skewX(';
    var peg$c6 = 'skewY(';
    var peg$c7 = '.';
    var peg$c8 = 'e';
    var peg$r0 = /^[ \t\n\r,]/;
    var peg$r1 = /^[ \t\n\r]/;
    var peg$r2 = /^[+\-]/;
    var peg$r3 = /^[0-9]/;
    var peg$e0 = peg$otherExpectation('transform functions');
    var peg$e1 = peg$otherExpectation('transformFunctions');
    var peg$e2 = peg$otherExpectation('transform function');
    var peg$e3 = peg$otherExpectation('matrix');
    var peg$e4 = peg$literalExpectation('matrix(', false);
    var peg$e5 = peg$literalExpectation(')', false);
    var peg$e6 = peg$otherExpectation('translate');
    var peg$e7 = peg$literalExpectation('translate(', false);
    var peg$e8 = peg$otherExpectation('scale');
    var peg$e9 = peg$literalExpectation('scale(', false);
    var peg$e10 = peg$otherExpectation('rotate');
    var peg$e11 = peg$literalExpectation('rotate(', false);
    var peg$e12 = peg$otherExpectation('x, y');
    var peg$e13 = peg$otherExpectation('skewX');
    var peg$e14 = peg$literalExpectation('skewX(', false);
    var peg$e15 = peg$otherExpectation('skewY');
    var peg$e16 = peg$literalExpectation('skewY(', false);
    var peg$e17 = peg$otherExpectation('space or comma');
    var peg$e18 = peg$classExpectation([' ', '\t', '\n', '\r', ','], false, false);
    var peg$e19 = peg$otherExpectation('whitespace');
    var peg$e20 = peg$classExpectation([' ', '\t', '\n', '\r'], false, false);
    var peg$e21 = peg$classExpectation(['+', '-'], false, false);
    var peg$e22 = peg$classExpectation([['0', '9']], false, false);
    var peg$e23 = peg$literalExpectation('.', false);
    var peg$e24 = peg$literalExpectation('e', false);
    var peg$f0 = function (head, tail) {
      const results = Array.isArray(head) ? head : [head];
      tail.forEach(element => {
        if (Array.isArray(element[1])) {
          results.push(...element[1]);
        } else {
          results.push(element[1]);
        }
      });
      return results;
    };
    var peg$f1 = function (a, b, c, d, e, f, g, h, i) {
      return {
        matrix: [a, b, c, d, e, f, g, h, i]
      };
    };
    var peg$f2 = function (x, y) {
      if (y == undefined) {
        return {
          translate: x
        };
      }
      return {
        translate: [x, y]
      };
    };
    var peg$f3 = function (x, y) {
      if (y == undefined) {
        return {
          scale: x
        };
      }
      return [{
        scaleX: x
      }, {
        scaleY: y
      }];
    };
    var peg$f4 = function (x, yz) {
      if (yz !== null) {
        return {
          rotate: `${x}deg`
        };
      }
      return [{
        rotate: `${x}deg`
      }];
    };
    var peg$f5 = function (y, z) {
      return [y, z];
    };
    var peg$f6 = function (x) {
      return [{
        skewX: `${x}deg`
      }];
    };
    var peg$f7 = function (y) {
      return [{
        skewY: `${y}deg`
      }];
    };
    var peg$f8 = function () {
      return parseFloat(text());
    };
    var peg$currPos = options.peg$currPos | 0;
    var peg$savedPos = peg$currPos;
    var peg$posDetailsCache = [{
      line: 1,
      column: 1
    }];
    var peg$maxFailPos = peg$currPos;
    var peg$maxFailExpected = options.peg$maxFailExpected || [];
    var peg$silentFails = options.peg$silentFails | 0;
    var peg$result;
    if (options.startRule) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
      return peg$savedPos;
    }
    function range() {
      return {
        source: peg$source,
        start: peg$savedPos,
        end: peg$currPos
      };
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
      location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
      location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
      return {
        type: 'literal',
        text: text,
        ignoreCase: ignoreCase
      };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: 'class',
        parts: parts,
        inverted: inverted,
        ignoreCase: ignoreCase
      };
    }
    function peg$anyExpectation() {
      return {
        type: 'any'
      };
    }
    function peg$endExpectation() {
      return {
        type: 'end'
      };
    }
    function peg$otherExpectation(description) {
      return {
        type: 'other',
        description: description
      };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        if (pos >= peg$posDetailsCache.length) {
          p = peg$posDetailsCache.length - 1;
        } else {
          p = pos;
          while (!peg$posDetailsCache[--p]) {}
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      if (offset && peg$source && typeof peg$source.offset === 'function') {
        res.start = peg$source.offset(res.start);
        res.end = peg$source.offset(res.end);
      }
      return res;
    }
    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parsestart() {
      var s0, s1;
      peg$silentFails++;
      s0 = peg$parsetransformFunctions();
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      return s0;
    }
    function peg$parsetransformFunctions() {
      var s0, s1, s2, s3, s4, s5;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsefunction();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        s5 = peg$parsefunction();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          s5 = peg$parsefunction();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        peg$savedPos = s0;
        s0 = peg$f0(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      return s0;
    }
    function peg$parsefunction() {
      var s0, s1;
      peg$silentFails++;
      s0 = peg$parsematrix();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetranslate();
        if (s0 === peg$FAILED) {
          s0 = peg$parsescale();
          if (s0 === peg$FAILED) {
            s0 = peg$parserotate();
            if (s0 === peg$FAILED) {
              s0 = peg$parseskewX();
              if (s0 === peg$FAILED) {
                s0 = peg$parseskewY();
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      return s0;
    }
    function peg$parsematrix() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 7) === peg$c0) {
        s2 = peg$c0;
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsespaceOrComma();
          s6 = peg$parseNUM();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsespaceOrComma();
            s8 = peg$parseNUM();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsespaceOrComma();
              s10 = peg$parseNUM();
              if (s10 !== peg$FAILED) {
                s11 = peg$parsespaceOrComma();
                s12 = peg$parseNUM();
                if (s12 !== peg$FAILED) {
                  s13 = peg$parsespaceOrComma();
                  s14 = peg$parseNUM();
                  if (s14 !== peg$FAILED) {
                    s15 = peg$parsespaceOrComma();
                    s16 = peg$parseNUM();
                    if (s16 !== peg$FAILED) {
                      s17 = peg$parsespaceOrComma();
                      s18 = peg$parseNUM();
                      if (s18 !== peg$FAILED) {
                        s19 = peg$parsespaceOrComma();
                        s20 = peg$parseNUM();
                        if (s20 !== peg$FAILED) {
                          s21 = peg$parse_();
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s22 = peg$c1;
                            peg$currPos++;
                          } else {
                            s22 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e5);
                            }
                          }
                          if (s22 !== peg$FAILED) {
                            s23 = peg$parse_();
                            peg$savedPos = s0;
                            s0 = peg$f1(s4, s6, s8, s10, s12, s14, s16, s18, s20);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      return s0;
    }
    function peg$parsetranslate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 10) === peg$c2) {
        s2 = peg$c2;
        peg$currPos += 10;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsespaceOrComma();
          s6 = peg$parseNUM();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s8 = peg$c1;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f2(s4, s6);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      return s0;
    }
    function peg$parsescale() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 6) === peg$c3) {
        s2 = peg$c3;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsespaceOrComma();
          s6 = peg$parseNUM();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s8 = peg$c1;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f3(s4, s6);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      return s0;
    }
    function peg$parserotate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 7) === peg$c4) {
        s2 = peg$c4;
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e11);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetwoNumbers();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s6 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s7 = peg$c1;
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f4(s4, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      return s0;
    }
    function peg$parsetwoNumbers() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsespaceOrComma();
      s2 = peg$parseNUM();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsespaceOrComma();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }
      return s0;
    }
    function peg$parseskewX() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 6) === peg$c5) {
        s2 = peg$c5;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e14);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s6 = peg$c1;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      return s0;
    }
    function peg$parseskewY() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (input.substr(peg$currPos, 6) === peg$c6) {
        s2 = peg$c6;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = peg$parseNUM();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s6 = peg$c1;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f7(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      return s0;
    }
    function peg$parsespaceOrComma() {
      var s0, s1;
      peg$silentFails++;
      s0 = [];
      s1 = input.charAt(peg$currPos);
      if (peg$r0.test(s1)) {
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e18);
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = input.charAt(peg$currPos);
        if (peg$r0.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
      }
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e17);
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1;
      peg$silentFails++;
      s0 = [];
      s1 = input.charAt(peg$currPos);
      if (peg$r1.test(s1)) {
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e20);
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = input.charAt(peg$currPos);
        if (peg$r1.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
      }
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e19);
      }
      return s0;
    }
    function peg$parseNUM() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = input.charAt(peg$currPos);
      if (peg$r2.test(s1)) {
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e21);
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = peg$currPos;
      s3 = [];
      s4 = input.charAt(peg$currPos);
      if (peg$r3.test(s4)) {
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e22);
        }
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = input.charAt(peg$currPos);
        if (peg$r3.test(s4)) {
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 46) {
        s4 = peg$c7;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e23);
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = input.charAt(peg$currPos);
        if (peg$r3.test(s6)) {
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s6 !== peg$FAILED) {
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = input.charAt(peg$currPos);
            if (peg$r3.test(s6)) {
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        } else {
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = [];
        s3 = input.charAt(peg$currPos);
        if (peg$r3.test(s3)) {
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = input.charAt(peg$currPos);
            if (peg$r3.test(s3)) {
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s4 = peg$c8;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = input.charAt(peg$currPos);
          if (peg$r2.test(s5)) {
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s6 = [];
          s7 = input.charAt(peg$currPos);
          if (peg$r3.test(s7)) {
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s7 !== peg$FAILED) {
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = input.charAt(peg$currPos);
              if (peg$r3.test(s7)) {
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
            }
          } else {
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f8();
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (options.peg$library) {
      return /** @type {any} */{
        peg$result,
        peg$currPos,
        peg$FAILED,
        peg$maxFailExpected,
        peg$maxFailPos
      };
    }
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  module.exports = {
    StartRules: ['start'],
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
},938,[],"node_modules\\react-native-svg\\lib\\module\\lib\\extract\\transformToRn.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolve = resolve;
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet"));
  // Kept in separate file, to avoid name collision with Symbol element
  function resolve(styleProp, cleanedProps) {
    if (styleProp) {
      return _StyleSheet.default ? [styleProp, cleanedProps] :
      // Compatibility for arrays of styles in plain react web
      styleProp[Symbol.iterator] ? Object.assign({}, ...styleProp, cleanedProps) : Object.assign({}, styleProp, cleanedProps);
    } else {
      return cleanedProps;
    }
  }
},939,[17,30],"node_modules\\react-native-svg\\lib\\module\\lib\\resolve.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveAssetUri = resolveAssetUri;
  var _PixelRatio = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/PixelRatio"));
  var _registry = require(_dependencyMap[2], "@react-native/assets-registry/registry");
  // @ts-expect-error react-native/assets-registry doesn't export types.

  const svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;

  // Based on that function: https://github.com/necolas/react-native-web/blob/54c14d64dabd175e8055e1dc92e9196c821f9b7d/packages/react-native-web/src/exports/Image/index.js#L118-L156
  function resolveAssetUri(source) {
    let src = {};
    if (typeof source === 'number') {
      // get the URI from the packager
      const asset = (0, _registry.getAssetByID)(source);
      if (asset == null) {
        throw new Error(`Image: asset with ID "${source}" could not be found. Please check the image source or packager.`);
      }
      src = {
        width: asset.width,
        height: asset.height,
        scale: asset.scales[0]
      };
      if (asset.scales.length > 1) {
        const preferredScale = _PixelRatio.default.get();
        // Get the scale which is closest to the preferred scale
        src.scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
      }
      const scaleSuffix = src.scale !== 1 ? `@${src.scale}x` : '';
      src.uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : '';
    } else if (typeof source === 'string') {
      src.uri = source;
    } else if (source && !Array.isArray(source) && typeof source.uri === 'string') {
      src.uri = source.uri;
    }
    if (src.uri) {
      var _src;
      const match = (_src = src) === null || _src === void 0 || (_src = _src.uri) === null || _src === void 0 ? void 0 : _src.match(svgDataUriPattern);
      // inline SVG markup may contain characters (e.g., #, ") that need to be escaped
      if (match) {
        const [, prefix, svg] = match;
        const encodedSvg = encodeURIComponent(svg);
        src.uri = `${prefix}${encodedSvg}`;
        return src;
      }
    }
    return src;
  }
},940,[17,183,181],"node_modules\\react-native-svg\\lib\\module\\lib\\resolveAssetUri.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.convertInt32ColorToRGBA = convertInt32ColorToRGBA;
  function convertInt32ColorToRGBA(color) {
    const r = color >> 16 & 255;
    const g = color >> 8 & 255;
    const b = color & 255;
    const a = (color >> 24 & 255) / 255;
    const alpha = a.toFixed(2);
    return `rgba(${r},${g},${b},${alpha})`;
  }
},941,[],"node_modules\\react-native-svg\\lib\\module\\web\\utils\\convertInt32Color.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _Touchable = _interopRequireDefault(require(_dependencyMap[1], "react-native-web/dist/exports/Touchable"));
  const PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  // @ts-expect-error: Mixin is not typed
  const {
    Mixin
  } = _Touchable.default;
  const {
    touchableHandleStartShouldSetResponder,
    touchableHandleResponderTerminationRequest,
    touchableHandleResponderGrant,
    touchableHandleResponderMove,
    touchableHandleResponderRelease,
    touchableHandleResponderTerminate,
    touchableGetInitialState
  } = Mixin;
  const SvgTouchableMixin = Object.assign({}, Mixin, {
    touchableHandleStartShouldSetResponder(e) {
      const {
        onStartShouldSetResponder
      } = this.props;
      if (onStartShouldSetResponder) {
        return onStartShouldSetResponder(e);
      } else {
        return touchableHandleStartShouldSetResponder.call(this, e);
      }
    },
    touchableHandleResponderTerminationRequest(e) {
      const {
        onResponderTerminationRequest
      } = this.props;
      if (onResponderTerminationRequest) {
        return onResponderTerminationRequest(e);
      } else {
        return touchableHandleResponderTerminationRequest.call(this, e);
      }
    },
    touchableHandleResponderGrant(e) {
      const {
        onResponderGrant
      } = this.props;
      if (onResponderGrant) {
        return onResponderGrant(e);
      } else {
        return touchableHandleResponderGrant.call(this, e);
      }
    },
    touchableHandleResponderMove(e) {
      const {
        onResponderMove
      } = this.props;
      if (onResponderMove) {
        return onResponderMove(e);
      } else {
        return touchableHandleResponderMove.call(this, e);
      }
    },
    touchableHandleResponderRelease(e) {
      const {
        onResponderRelease
      } = this.props;
      if (onResponderRelease) {
        return onResponderRelease(e);
      } else {
        return touchableHandleResponderRelease.call(this, e);
      }
    },
    touchableHandleResponderTerminate(e) {
      const {
        onResponderTerminate
      } = this.props;
      if (onResponderTerminate) {
        return onResponderTerminate(e);
      } else {
        return touchableHandleResponderTerminate.call(this, e);
      }
    },
    touchableHandlePress(e) {
      const {
        onPress
      } = this.props;
      onPress && onPress(e);
    },
    touchableHandleActivePressIn(e) {
      const {
        onPressIn
      } = this.props;
      onPressIn && onPressIn(e);
    },
    touchableHandleActivePressOut(e) {
      const {
        onPressOut
      } = this.props;
      onPressOut && onPressOut(e);
    },
    touchableHandleLongPress(e) {
      const {
        onLongPress
      } = this.props;
      onLongPress && onLongPress(e);
    },
    touchableGetPressRectOffset() {
      const {
        pressRetentionOffset
      } = this.props;
      return pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop() {
      const {
        hitSlop
      } = this.props;
      return hitSlop;
    },
    touchableGetHighlightDelayMS() {
      const {
        delayPressIn
      } = this.props;
      return delayPressIn || 0;
    },
    touchableGetLongPressDelayMS() {
      const {
        delayLongPress
      } = this.props;
      return delayLongPress === 0 ? 0 : delayLongPress || 500;
    },
    touchableGetPressOutDelayMS() {
      const {
        delayPressOut
      } = this.props;
      return delayPressOut || 0;
    }
  });
  const touchKeys = Object.keys(SvgTouchableMixin);
  const touchVals = touchKeys.map(key => SvgTouchableMixin[key]);
  const numTouchKeys = touchKeys.length;
  var _default = target => {
    for (let i = 0; i < numTouchKeys; i++) {
      const key = touchKeys[i];
      const val = touchVals[i];
      if (typeof val === 'function') {
        target[key] = val.bind(target);
      } else {
        target[key] = val;
      }
    }
    target.state = touchableGetInitialState();
  };
  exports.default = _default;
},942,[17,255],"node_modules\\react-native-svg\\lib\\module\\lib\\SvgTouchableMixin.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocalSvg = LocalSvg;
  exports.SvgCss = SvgCss;
  exports.SvgCssUri = SvgCssUri;
  exports.SvgWithCss = SvgWithCss;
  exports.SvgWithCssUri = SvgWithCssUri;
  exports.WithLocalSvg = WithLocalSvg;
  exports.inlineStyles = inlineStyles;
  exports.loadLocalRawResource = loadLocalRawResource;
  exports.showErrorCSS = showErrorCSS;
  function showErrorCSS(name, type) {
    throw Error(`[react-native-svg] You are trying to import a ${type} \`${name}\` that has been moved to a sub-package. Change your import from \`react-native-svg\` to \`react-native-svg/css\`.`);
  }
  function SvgCss() {
    showErrorCSS('SvgCss', 'component');
  }
  function SvgCssUri() {
    showErrorCSS('SvgCssUri', 'component');
  }
  function SvgWithCss() {
    showErrorCSS('SvgWithCss', 'component');
  }
  function SvgWithCssUri() {
    showErrorCSS('SvgWithCssUri', 'component');
  }
  function inlineStyles() {
    showErrorCSS('inlineStyles', 'function');
  }
  function LocalSvg() {
    showErrorCSS('LocalSvg', 'component');
  }
  function WithLocalSvg() {
    showErrorCSS('WithLocalSvg', 'component');
  }
  function loadLocalRawResource() {
    showErrorCSS('loadLocalRawResource', 'function');
  }
},943,[],"node_modules\\react-native-svg\\lib\\module\\deprecated.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},944,[],"node_modules\\react-native-svg\\lib\\module\\lib\\extract\\types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This is a hack for Expo Router to support Fast Refresh on _layout files
   *
   * Fast Refresh only works when:
   *  - Files only export React Components
   *  - All inverse dependencies only export React Components
   *
   * Expo Router's _layout files support exporting both 'unstable_settings' and 'ErrorBoundary'
   *
   * 'unstable_settings':
   *  - This is a plain object, so it will break Fast Refresh
   *
   * 'ErrorBoundary'
   *  - While this is a React component, it is imported from 'expo-router'
   *  - 'expo-router' has an inverse dependency on _ctx, which is a require.context object
   *
   * 'generateStaticParams'
   *  - This is a function that is not a React Component, so it will break Fast Refresh
   *
   *
   * To resolve this issue, we extend ReactRefresh to flag these exports as React components
   *
   * @see https://reactnative.dev/docs/fast-refresh
   */
  if (process.env.NODE_ENV === 'development') {
    if (
    // Should be a string at runtime
    typeof __METRO_GLOBAL_PREFIX__ !== 'undefined' &&
    // Should be set by Metro's require polyfill
    global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh']) {
      // source: https://github.com/facebook/metro/blob/main/packages/metro-runtime/src/polyfills/require.js
      // TODO(@kitten): Add type for this and use `globalThis` over `global`
      const Refresh = global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'];
      // Keep a reference to the original
      const isLikelyComponentType = Refresh.isLikelyComponentType;
      // Modules can be dereferenced at any time
      const expoRouterExports = new WeakSet();
      Object.assign(Refresh, {
        /*
         * isLikelyComponentType is called twice.
         *   1. Initially with a modules export object
         *   2. With each individual export of a module
         */
        isLikelyComponentType(value) {
          try {
            if (typeof value === 'object') {
              if ('unstable_settings' in value) {
                expoRouterExports.add(value.unstable_settings);
              }
              if ('ErrorBoundary' in value) {
                expoRouterExports.add(value.ErrorBoundary);
              }
              if ('generateStaticParams' in value) {
                expoRouterExports.add(value.generateStaticParams);
              }
            }
          } catch {
            // Ignore - we're just trying to avoid breaking Fast Refresh by using exports
            // that aren't JS objects valid as keys for the WeakSet - like we've seen with
            // some JSI::HostObject instances that are exported in a module - see #33670
            // https://github.com/expo/expo/issues/33670
          }
          return expoRouterExports.has(value) || isLikelyComponentType(value);
        }
      });
    }
  }
},945,[],"node_modules\\expo-router\\build\\fast-refresh.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactNativeCssInteropJsxRuntime = require(_dependencyMap[0], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\expo-router\\build\\renderRootComponent.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.renderRootComponent = renderRootComponent;
  const expo_1 = require(_dependencyMap[1], "expo");
  const React = __importStar(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const SplashScreen = __importStar(require(_dependencyMap[4], "./utils/splash"));
  function isBaseObject(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      return false;
    }
    const proto = Object.getPrototypeOf(obj);
    if (proto === null) {
      return true;
    }
    return proto === Object.prototype;
  }
  function isErrorShaped(error) {
    return error && typeof error === 'object' && typeof error.name === 'string' && typeof error.message === 'string';
  }
  /**
   * After we throw this error, any number of tools could handle it.
   * This check ensures the error is always in a reason state before surfacing it to the runtime.
   */
  function convertError(error) {
    if (isErrorShaped(error)) {
      return error;
    }
    if (process.env.NODE_ENV === 'development') {
      if (error == null) {
        return new Error('A null/undefined error was thrown.');
      }
    }
    if (isBaseObject(error)) {
      return new Error(JSON.stringify(error));
    }
    return new Error(String(error));
  }
  /**
   * Register and mount the root component using the predefined rendering
   * method. This function ensures the Splash Screen and errors are handled correctly.
   */
  function renderRootComponent(Component) {
    try {
      // This must be delayed so the user has a chance to call it first.
      setTimeout(() => {
        SplashScreen._internal_preventAutoHideAsync?.();
      });
      React.startTransition(() => {
        if (process.env.NODE_ENV !== 'production') {
          const {
            withErrorOverlay
          } = require(_dependencyMap[5], "@expo/metro-runtime/error-overlay");
          (0, expo_1.registerRootComponent)(withErrorOverlay(Component));
        } else {
          (0, expo_1.registerRootComponent)(Component);
        }
      });
    } catch (e) {
      // Hide the splash screen if there was an error so the user can see it.
      SplashScreen.hideAsync();
      const error = convertError(e);
      // Prevent the app from throwing confusing:
      //  ERROR  Invariant Violation: "main" has not been registered. This can happen if:
      // * Metro (the local dev server) is run from the wrong folder. Check if Metro is running, stop it and restart it in the current project.
      // * A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.
      (0, expo_1.registerRootComponent)(() => _reactNativeCssInteropJsxRuntime.jsx(react_native_1.View, {}));
      // Console is pretty useless on native, on web you get interactive stack traces.
      if (true) {
        console.error(error);
        console.error(`A runtime error has occurred while rendering the root component.`);
      }
      // Give React a tick to render before throwing.
      setTimeout(() => {
        throw error;
      });
      // TODO: Render a production-only error screen.
    }
  }
},946,[2,633,3,16,632,947],"node_modules\\expo-router\\build\\renderRootComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _errorOverlay = require(_dependencyMap[0], "./src/error-overlay");
  Object.keys(_errorOverlay).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _errorOverlay[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _errorOverlay[key];
      }
    });
  });
},947,[948],"node_modules\\@expo\\metro-runtime\\error-overlay.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.withErrorOverlay = withErrorOverlay;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _jsxRuntime = require(_dependencyMap[2], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\index.tsx";
  if (process.env.NODE_ENV === 'development' && true) {
    // Stack traces are big with React Navigation
    require(_dependencyMap[3], "./LogBox").default.install();
  }
  function withErrorOverlay(Comp) {
    if (process.env.NODE_ENV === 'production') {
      return Comp;
    }
    const {
      default: ErrorToastContainer
    } = require(_dependencyMap[4], "./toast/ErrorToastContainer");
    return function ErrorOverlay(props) {
      return (0, _jsxRuntime.jsx)(ErrorToastContainer, {
        children: (0, _jsxRuntime.jsx)(Comp, Object.assign({}, props))
      });
    };
  }
},948,[17,3,2,306,949],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorToastContainer = ErrorToastContainer;
  exports.default = void 0;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _View = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/View"));
  var _ErrorToast = require(_dependencyMap[4], "./ErrorToast");
  var LogBoxData = _interopRequireWildcard(require(_dependencyMap[5], "../Data/LogBoxData"));
  var _LogContext = require(_dependencyMap[6], "../Data/LogContext");
  var _useRejectionHandler = require(_dependencyMap[7], "../useRejectionHandler");
  var _jsxRuntime = require(_dependencyMap[8], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastContainer.web.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function ErrorToastContainer() {
    (0, _useRejectionHandler.useRejectionHandler)();
    const {
      logs,
      isDisabled
    } = (0, _LogContext.useLogs)();
    if (!logs.length || isDisabled) {
      return null;
    }
    return (0, _jsxRuntime.jsx)(ErrorToastStack, {
      logs: logs
    });
  }
  function ErrorToastStack({
    logs
  }) {
    const onDismissWarns = (0, _react.useCallback)(() => {
      LogBoxData.clearWarnings();
    }, []);
    const onDismissErrors = (0, _react.useCallback)(() => {
      LogBoxData.clearErrors();
    }, []);
    const setSelectedLog = (0, _react.useCallback)(index => {
      LogBoxData.setSelectedLog(index);
    }, []);
    function openLog(log) {
      let index = logs.length - 1;

      // Stop at zero because if we don't find any log, we'll open the first log.
      while (index > 0 && logs[index] !== log) {
        index -= 1;
      }
      setSelectedLog(index);
    }
    const warnings = (0, _react.useMemo)(() => logs.filter(log => log.level === 'warn'), [logs]);
    const errors = (0, _react.useMemo)(() => logs.filter(log => log.level === 'error' || log.level === 'fatal'), [logs]);
    return (0, _jsxRuntime.jsxs)(_View.default, {
      style: styles.list,
      children: [warnings.length > 0 && (0, _jsxRuntime.jsx)(_ErrorToast.ErrorToast, {
        log: warnings[warnings.length - 1],
        level: "warn",
        totalLogCount: warnings.length,
        onPressOpen: () => openLog(warnings[warnings.length - 1]),
        onPressDismiss: onDismissWarns
      }), errors.length > 0 && (0, _jsxRuntime.jsx)(_ErrorToast.ErrorToast, {
        log: errors[errors.length - 1],
        level: "error",
        totalLogCount: errors.length,
        onPressOpen: () => openLog(errors[errors.length - 1]),
        onPressDismiss: onDismissErrors
      })]
    });
  }
  const styles = _StyleSheet.default.create({
    list: {
      bottom: 6,
      left: 10,
      right: 10,
      maxWidth: 320,
      // @ts-expect-error
      position: 'fixed'
    }
  });
  var _default = exports.default = LogBoxData.withSubscription(ErrorToastContainer);
},949,[17,3,30,111,950,307,311,953,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastContainer.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorToast = ErrorToast;
  var _react = _interopRequireWildcard(require(_dependencyMap[1], "react"));
  var _Image = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/Image"));
  var _Platform = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Platform"));
  var _Pressable = _interopRequireDefault(require(_dependencyMap[4], "react-native-web/dist/exports/Pressable"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[6], "react-native-web/dist/exports/Text"));
  var _View = _interopRequireDefault(require(_dependencyMap[7], "react-native-web/dist/exports/View"));
  var _ErrorToastMessage = require(_dependencyMap[8], "./ErrorToastMessage");
  var LogBoxData = _interopRequireWildcard(require(_dependencyMap[9], "../Data/LogBoxData"));
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[10], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[11], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToast.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function useSymbolicatedLog(log) {
    // Eagerly symbolicate so the stack is available when pressing to inspect.
    (0, _react.useEffect)(() => {
      LogBoxData.symbolicateLogLazy('stack', log);
      LogBoxData.symbolicateLogLazy('component', log);
    }, [log]);
  }
  function ErrorToast(props) {
    const {
      totalLogCount,
      level,
      log
    } = props;
    useSymbolicatedLog(log);
    return (0, _jsxRuntime.jsx)(_View.default, {
      style: toastStyles.container,
      children: (0, _jsxRuntime.jsx)(_Pressable.default, {
        style: {
          flex: 1
        },
        onPress: props.onPressOpen,
        children: ({
          /** @ts-expect-error: react-native types are broken. */
          hovered,
          pressed
        }) => (0, _jsxRuntime.jsxs)(_View.default, {
          style: [toastStyles.press, {
            // @ts-expect-error: web-only type
            transitionDuration: '150ms',
            backgroundColor: pressed ? '#323232' : hovered ? '#111111' : LogBoxStyle.getBackgroundColor()
          }],
          children: [(0, _jsxRuntime.jsx)(Count, {
            count: totalLogCount,
            level: level
          }), (0, _jsxRuntime.jsx)(_ErrorToastMessage.ErrorToastMessage, {
            message: log.message
          }), (0, _jsxRuntime.jsx)(Dismiss, {
            onPress: props.onPressDismiss
          })]
        })
      })
    });
  }
  function Count({
    count,
    level
  }) {
    return (0, _jsxRuntime.jsx)(_View.default, {
      style: [countStyles.inside, countStyles[level]],
      children: (0, _jsxRuntime.jsx)(_Text.default, {
        style: countStyles.text,
        children: count <= 1 ? '!' : count
      })
    });
  }
  function Dismiss({
    onPress
  }) {
    return (0, _jsxRuntime.jsx)(_Pressable.default, {
      style: {
        marginLeft: 5
      },
      hitSlop: {
        top: 12,
        right: 10,
        bottom: 12,
        left: 10
      },
      onPress: onPress,
      children: ({
        /** @ts-expect-error: react-native types are broken. */
        hovered,
        pressed
      }) => (0, _jsxRuntime.jsx)(_View.default, {
        style: [dismissStyles.press, hovered && {
          opacity: 0.8
        }, pressed && {
          opacity: 0.5
        }],
        children: (0, _jsxRuntime.jsx)(_Image.default, {
          source: require(_dependencyMap[12], "@expo/metro-runtime/assets/close.png"),
          style: dismissStyles.image
        })
      })
    });
  }
  const countStyles = _StyleSheet.default.create({
    warn: {
      backgroundColor: LogBoxStyle.getWarningColor(1)
    },
    error: {
      backgroundColor: LogBoxStyle.getErrorColor(1)
    },
    log: {
      backgroundColor: LogBoxStyle.getLogColor(1)
    },
    inside: {
      marginRight: 8,
      minWidth: 22,
      aspectRatio: 1,
      paddingHorizontal: 4,
      borderRadius: 11,
      justifyContent: 'center',
      alignItems: 'center'
    },
    text: Object.assign({
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      lineHeight: 18,
      textAlign: 'center',
      fontWeight: '600'
    }, _Platform.default.select({
      web: {
        textShadow: `0px 0px 3px ${LogBoxStyle.getBackgroundColor(0.8)}`
      }
    }))
  });
  const dismissStyles = _StyleSheet.default.create({
    press: {
      backgroundColor: '#323232',
      height: 20,
      width: 20,
      borderRadius: 25,
      alignItems: 'center',
      justifyContent: 'center'
    },
    image: {
      height: 8,
      width: 8
    }
  });
  const toastStyles = _StyleSheet.default.create({
    container: {
      height: 48,
      justifyContent: 'center',
      marginBottom: 4
    },
    press: {
      borderWidth: 1,
      borderRadius: 8,
      overflow: 'hidden',
      flexDirection: 'row',
      alignItems: 'center',
      borderColor: '#323232',
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      flex: 1,
      paddingHorizontal: 12
    }
  });
},950,[17,3,180,106,244,30,190,111,951,307,318,2,952],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToast.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorToastMessage = ErrorToastMessage;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _StyleSheet = _interopRequireDefault(require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet"));
  var _Text = _interopRequireDefault(require(_dependencyMap[3], "react-native-web/dist/exports/Text"));
  var _LogBoxMessage = require(_dependencyMap[4], "../UI/LogBoxMessage");
  var LogBoxStyle = _interopRequireWildcard(require(_dependencyMap[5], "../UI/LogBoxStyle"));
  var _jsxRuntime = require(_dependencyMap[6], "react-native-css-interop/jsx-runtime");
  var _jsxFileName = "C:\\Users\\kiero\\OneDrive\\Desktop\\LandRock\\FYP-G19-Rockland\\frontend\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastMessage.tsx";
  function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
  function ErrorToastMessage({
    message
  }) {
    return (0, _jsxRuntime.jsx)(_Text.default, {
      numberOfLines: 1,
      style: styles.text,
      children: message && (0, _jsxRuntime.jsx)(_LogBoxMessage.LogBoxMessage, {
        plaintext: true,
        message: message,
        style: styles.substitutionText
      })
    });
  }
  const styles = _StyleSheet.default.create({
    text: {
      userSelect: 'none',
      paddingLeft: 8,
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 14,
      lineHeight: 22
    },
    substitutionText: {
      color: LogBoxStyle.getTextColor(0.6)
    }
  });
},951,[17,3,30,190,332,318,2],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastMessage.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/close.png",
    width: 28,
    height: 28
  };
},952,[],"node_modules\\@expo\\metro-runtime\\assets\\close.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = require(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useRejectionHandler = useRejectionHandler;
  var _react = _interopRequireDefault(require(_dependencyMap[1], "react"));
  var _ExceptionsManager = _interopRequireDefault(require(_dependencyMap[2], "./modules/ExceptionsManager"));
  function useStackTraceLimit(limit) {
    const current = _react.default.useRef(0);
    _react.default.useEffect(() => {
      try {
        // @ts-expect-error: StackTraceLimit is not defined in the Error type
        const currentLimit = Error.stackTraceLimit;
        // @ts-expect-error: StackTraceLimit is not defined in the Error type
        Error.stackTraceLimit = limit;
        current.current = currentLimit;
      } catch {}
      return () => {
        try {
          // @ts-expect-error: StackTraceLimit is not defined in the Error type
          Error.stackTraceLimit = current.current;
        } catch {}
      };
    }, [limit]);
  }
  function useRejectionHandler() {
    const hasError = _react.default.useRef(false);
    useStackTraceLimit(35);
    _react.default.useEffect(() => {
      function onUnhandledError(ev) {
        hasError.current = true;
        const error = ev?.error;
        if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
          return;
        }
        _ExceptionsManager.default.handleException(error);
      }
      function onUnhandledRejection(ev) {
        hasError.current = true;
        const reason = ev?.reason;
        if (!reason || !(reason instanceof Error) || typeof reason.stack !== 'string') {
          return;
        }
        _ExceptionsManager.default.handleException(reason);
      }
      window.addEventListener('unhandledrejection', onUnhandledRejection);
      window.addEventListener('error', onUnhandledError);
      return () => {
        window.removeEventListener('error', onUnhandledError);
        window.removeEventListener('unhandledrejection', onUnhandledRejection);
      };
    }, []);
    return hasError;
  }
},953,[17,3,338],"node_modules\\@expo\\metro-runtime\\src\\error-overlay\\useRejectionHandler.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectDestructuringEmpty(t) {
    if (null == t) throw new TypeError("Cannot destructure " + t);
  }
  module.exports = _objectDestructuringEmpty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},954,[],"node_modules\\@babel\\runtime\\helpers\\objectDestructuringEmpty.js");
__r(635);
__r(282);
__r(865);
//# sourceMappingURL=//localhost:8081/node_modules/expo-router/entry.map?platform=web&dev=true&hot=false&lazy=true&transform.routerRoot=app